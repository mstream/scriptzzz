(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod4) => function __require() {
    return mod4 || (0, cb[__getOwnPropNames(cb)[0]])((mod4 = { exports: {} }).exports, mod4), mod4.exports;
  };
  var __export = (target5, all4) => {
    for (var name16 in all4)
      __defProp(target5, name16, { get: all4[name16], enumerable: true });
  };
  var __copyProps = (to3, from3, except3, desc) => {
    if (from3 && typeof from3 === "object" || typeof from3 === "function") {
      for (let key of __getOwnPropNames(from3))
        if (!__hasOwnProp.call(to3, key) && key !== except3)
          __defProp(to3, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
    }
    return to3;
  };
  var __toESM = (mod4, isNodeMode, target5) => (target5 = mod4 != null ? __create(__getProtoOf(mod4)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod4 || !mod4.__esModule ? __defProp(target5, "default", { value: mod4, enumerable: true }) : target5,
    mod4
  ));

  // node_modules/heap/lib/heap.js
  var require_heap = __commonJS({
    "node_modules/heap/lib/heap.js"(exports, module) {
      (function() {
        var Heap, defaultCmp, floor3, heapify, heappop, heappush, heappushpop, heapreplace, insort, min6, nlargest, nsmallest, updateItem, _siftdown, _siftup;
        floor3 = Math.floor, min6 = Math.min;
        defaultCmp = function(x2, y2) {
          if (x2 < y2) {
            return -1;
          }
          if (x2 > y2) {
            return 1;
          }
          return 0;
        };
        insort = function(a2, x2, lo, hi, cmp) {
          var mid;
          if (lo == null) {
            lo = 0;
          }
          if (cmp == null) {
            cmp = defaultCmp;
          }
          if (lo < 0) {
            throw new Error("lo must be non-negative");
          }
          if (hi == null) {
            hi = a2.length;
          }
          while (lo < hi) {
            mid = floor3((lo + hi) / 2);
            if (cmp(x2, a2[mid]) < 0) {
              hi = mid;
            } else {
              lo = mid + 1;
            }
          }
          return [].splice.apply(a2, [lo, lo - lo].concat(x2)), x2;
        };
        heappush = function(array, item, cmp) {
          if (cmp == null) {
            cmp = defaultCmp;
          }
          array.push(item);
          return _siftdown(array, 0, array.length - 1, cmp);
        };
        heappop = function(array, cmp) {
          var lastelt, returnitem;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          lastelt = array.pop();
          if (array.length) {
            returnitem = array[0];
            array[0] = lastelt;
            _siftup(array, 0, cmp);
          } else {
            returnitem = lastelt;
          }
          return returnitem;
        };
        heapreplace = function(array, item, cmp) {
          var returnitem;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          returnitem = array[0];
          array[0] = item;
          _siftup(array, 0, cmp);
          return returnitem;
        };
        heappushpop = function(array, item, cmp) {
          var _ref;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          if (array.length && cmp(array[0], item) < 0) {
            _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
            _siftup(array, 0, cmp);
          }
          return item;
        };
        heapify = function(array, cmp) {
          var i2, _i, _j, _len, _ref, _ref1, _results, _results1;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          _ref1 = function() {
            _results1 = [];
            for (var _j2 = 0, _ref2 = floor3(array.length / 2); 0 <= _ref2 ? _j2 < _ref2 : _j2 > _ref2; 0 <= _ref2 ? _j2++ : _j2--) {
              _results1.push(_j2);
            }
            return _results1;
          }.apply(this).reverse();
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            i2 = _ref1[_i];
            _results.push(_siftup(array, i2, cmp));
          }
          return _results;
        };
        updateItem = function(array, item, cmp) {
          var pos;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          pos = array.indexOf(item);
          if (pos === -1) {
            return;
          }
          _siftdown(array, 0, pos, cmp);
          return _siftup(array, pos, cmp);
        };
        nlargest = function(array, n2, cmp) {
          var elem3, result, _i, _len, _ref;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          result = array.slice(0, n2);
          if (!result.length) {
            return result;
          }
          heapify(result, cmp);
          _ref = array.slice(n2);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            elem3 = _ref[_i];
            heappushpop(result, elem3, cmp);
          }
          return result.sort(cmp).reverse();
        };
        nsmallest = function(array, n2, cmp) {
          var elem3, i2, los, result, _i, _j, _len, _ref, _ref1, _results;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          if (n2 * 10 <= array.length) {
            result = array.slice(0, n2).sort(cmp);
            if (!result.length) {
              return result;
            }
            los = result[result.length - 1];
            _ref = array.slice(n2);
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              elem3 = _ref[_i];
              if (cmp(elem3, los) < 0) {
                insort(result, elem3, 0, null, cmp);
                result.pop();
                los = result[result.length - 1];
              }
            }
            return result;
          }
          heapify(array, cmp);
          _results = [];
          for (i2 = _j = 0, _ref1 = min6(n2, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i2 = 0 <= _ref1 ? ++_j : --_j) {
            _results.push(heappop(array, cmp));
          }
          return _results;
        };
        _siftdown = function(array, startpos, pos, cmp) {
          var newitem, parent2, parentpos;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          newitem = array[pos];
          while (pos > startpos) {
            parentpos = pos - 1 >> 1;
            parent2 = array[parentpos];
            if (cmp(newitem, parent2) < 0) {
              array[pos] = parent2;
              pos = parentpos;
              continue;
            }
            break;
          }
          return array[pos] = newitem;
        };
        _siftup = function(array, pos, cmp) {
          var childpos, endpos, newitem, rightpos, startpos;
          if (cmp == null) {
            cmp = defaultCmp;
          }
          endpos = array.length;
          startpos = pos;
          newitem = array[pos];
          childpos = 2 * pos + 1;
          while (childpos < endpos) {
            rightpos = childpos + 1;
            if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
              childpos = rightpos;
            }
            array[pos] = array[childpos];
            pos = childpos;
            childpos = 2 * pos + 1;
          }
          array[pos] = newitem;
          return _siftdown(array, startpos, pos, cmp);
        };
        Heap = function() {
          Heap2.push = heappush;
          Heap2.pop = heappop;
          Heap2.replace = heapreplace;
          Heap2.pushpop = heappushpop;
          Heap2.heapify = heapify;
          Heap2.updateItem = updateItem;
          Heap2.nlargest = nlargest;
          Heap2.nsmallest = nsmallest;
          function Heap2(cmp) {
            this.cmp = cmp != null ? cmp : defaultCmp;
            this.nodes = [];
          }
          Heap2.prototype.push = function(x2) {
            return heappush(this.nodes, x2, this.cmp);
          };
          Heap2.prototype.pop = function() {
            return heappop(this.nodes, this.cmp);
          };
          Heap2.prototype.peek = function() {
            return this.nodes[0];
          };
          Heap2.prototype.contains = function(x2) {
            return this.nodes.indexOf(x2) !== -1;
          };
          Heap2.prototype.replace = function(x2) {
            return heapreplace(this.nodes, x2, this.cmp);
          };
          Heap2.prototype.pushpop = function(x2) {
            return heappushpop(this.nodes, x2, this.cmp);
          };
          Heap2.prototype.heapify = function() {
            return heapify(this.nodes, this.cmp);
          };
          Heap2.prototype.updateItem = function(x2) {
            return updateItem(this.nodes, x2, this.cmp);
          };
          Heap2.prototype.clear = function() {
            return this.nodes = [];
          };
          Heap2.prototype.empty = function() {
            return this.nodes.length === 0;
          };
          Heap2.prototype.size = function() {
            return this.nodes.length;
          };
          Heap2.prototype.clone = function() {
            var heap;
            heap = new Heap2();
            heap.nodes = this.nodes.slice(0);
            return heap;
          };
          Heap2.prototype.toArray = function() {
            return this.nodes.slice(0);
          };
          Heap2.prototype.insert = Heap2.prototype.push;
          Heap2.prototype.top = Heap2.prototype.peek;
          Heap2.prototype.front = Heap2.prototype.peek;
          Heap2.prototype.has = Heap2.prototype.contains;
          Heap2.prototype.copy = Heap2.prototype.clone;
          return Heap2;
        }();
        if (typeof module !== "undefined" && module !== null ? module.exports : void 0) {
          module.exports = Heap;
        } else {
          window.Heap = Heap;
        }
      }).call(exports);
    }
  });

  // node_modules/heap/index.js
  var require_heap2 = __commonJS({
    "node_modules/heap/index.js"(exports, module) {
      module.exports = require_heap();
    }
  });

  // node_modules/pathfinding/src/core/Node.js
  var require_Node = __commonJS({
    "node_modules/pathfinding/src/core/Node.js"(exports, module) {
      function Node2(x2, y2, walkable) {
        this.x = x2;
        this.y = y2;
        this.walkable = walkable === void 0 ? true : walkable;
      }
      module.exports = Node2;
    }
  });

  // node_modules/pathfinding/src/core/DiagonalMovement.js
  var require_DiagonalMovement = __commonJS({
    "node_modules/pathfinding/src/core/DiagonalMovement.js"(exports, module) {
      var DiagonalMovement = {
        Always: 1,
        Never: 2,
        IfAtMostOneObstacle: 3,
        OnlyWhenNoObstacles: 4
      };
      module.exports = DiagonalMovement;
    }
  });

  // node_modules/pathfinding/src/core/Grid.js
  var require_Grid = __commonJS({
    "node_modules/pathfinding/src/core/Grid.js"(exports, module) {
      var Node2 = require_Node();
      var DiagonalMovement = require_DiagonalMovement();
      function Grid(width_or_matrix, height8, matrix) {
        var width8;
        if (typeof width_or_matrix !== "object") {
          width8 = width_or_matrix;
        } else {
          height8 = width_or_matrix.length;
          width8 = width_or_matrix[0].length;
          matrix = width_or_matrix;
        }
        this.width = width8;
        this.height = height8;
        this.nodes = this._buildNodes(width8, height8, matrix);
      }
      Grid.prototype._buildNodes = function(width8, height8, matrix) {
        var i2, j2, nodes = new Array(height8);
        for (i2 = 0; i2 < height8; ++i2) {
          nodes[i2] = new Array(width8);
          for (j2 = 0; j2 < width8; ++j2) {
            nodes[i2][j2] = new Node2(j2, i2);
          }
        }
        if (matrix === void 0) {
          return nodes;
        }
        if (matrix.length !== height8 || matrix[0].length !== width8) {
          throw new Error("Matrix size does not fit");
        }
        for (i2 = 0; i2 < height8; ++i2) {
          for (j2 = 0; j2 < width8; ++j2) {
            if (matrix[i2][j2]) {
              nodes[i2][j2].walkable = false;
            }
          }
        }
        return nodes;
      };
      Grid.prototype.getNodeAt = function(x2, y2) {
        return this.nodes[y2][x2];
      };
      Grid.prototype.isWalkableAt = function(x2, y2) {
        return this.isInside(x2, y2) && this.nodes[y2][x2].walkable;
      };
      Grid.prototype.isInside = function(x2, y2) {
        return x2 >= 0 && x2 < this.width && (y2 >= 0 && y2 < this.height);
      };
      Grid.prototype.setWalkableAt = function(x2, y2, walkable) {
        this.nodes[y2][x2].walkable = walkable;
      };
      Grid.prototype.getNeighbors = function(node, diagonalMovement) {
        var x2 = node.x, y2 = node.y, neighbors = [], s0 = false, d0 = false, s1 = false, d1 = false, s2 = false, d2 = false, s3 = false, d3 = false, nodes = this.nodes;
        if (this.isWalkableAt(x2, y2 - 1)) {
          neighbors.push(nodes[y2 - 1][x2]);
          s0 = true;
        }
        if (this.isWalkableAt(x2 + 1, y2)) {
          neighbors.push(nodes[y2][x2 + 1]);
          s1 = true;
        }
        if (this.isWalkableAt(x2, y2 + 1)) {
          neighbors.push(nodes[y2 + 1][x2]);
          s2 = true;
        }
        if (this.isWalkableAt(x2 - 1, y2)) {
          neighbors.push(nodes[y2][x2 - 1]);
          s3 = true;
        }
        if (diagonalMovement === DiagonalMovement.Never) {
          return neighbors;
        }
        if (diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {
          d0 = s3 && s0;
          d1 = s0 && s1;
          d2 = s1 && s2;
          d3 = s2 && s3;
        } else if (diagonalMovement === DiagonalMovement.IfAtMostOneObstacle) {
          d0 = s3 || s0;
          d1 = s0 || s1;
          d2 = s1 || s2;
          d3 = s2 || s3;
        } else if (diagonalMovement === DiagonalMovement.Always) {
          d0 = true;
          d1 = true;
          d2 = true;
          d3 = true;
        } else {
          throw new Error("Incorrect value of diagonalMovement");
        }
        if (d0 && this.isWalkableAt(x2 - 1, y2 - 1)) {
          neighbors.push(nodes[y2 - 1][x2 - 1]);
        }
        if (d1 && this.isWalkableAt(x2 + 1, y2 - 1)) {
          neighbors.push(nodes[y2 - 1][x2 + 1]);
        }
        if (d2 && this.isWalkableAt(x2 + 1, y2 + 1)) {
          neighbors.push(nodes[y2 + 1][x2 + 1]);
        }
        if (d3 && this.isWalkableAt(x2 - 1, y2 + 1)) {
          neighbors.push(nodes[y2 + 1][x2 - 1]);
        }
        return neighbors;
      };
      Grid.prototype.clone = function() {
        var i2, j2, width8 = this.width, height8 = this.height, thisNodes = this.nodes, newGrid = new Grid(width8, height8), newNodes = new Array(height8);
        for (i2 = 0; i2 < height8; ++i2) {
          newNodes[i2] = new Array(width8);
          for (j2 = 0; j2 < width8; ++j2) {
            newNodes[i2][j2] = new Node2(j2, i2, thisNodes[i2][j2].walkable);
          }
        }
        newGrid.nodes = newNodes;
        return newGrid;
      };
      module.exports = Grid;
    }
  });

  // node_modules/pathfinding/src/core/Util.js
  var require_Util = __commonJS({
    "node_modules/pathfinding/src/core/Util.js"(exports) {
      function backtrace(node) {
        var path2 = [[node.x, node.y]];
        while (node.parent) {
          node = node.parent;
          path2.push([node.x, node.y]);
        }
        return path2.reverse();
      }
      exports.backtrace = backtrace;
      function biBacktrace(nodeA, nodeB) {
        var pathA = backtrace(nodeA), pathB = backtrace(nodeB);
        return pathA.concat(pathB.reverse());
      }
      exports.biBacktrace = biBacktrace;
      function pathLength(path2) {
        var i2, sum2 = 0, a2, b2, dx, dy;
        for (i2 = 1; i2 < path2.length; ++i2) {
          a2 = path2[i2 - 1];
          b2 = path2[i2];
          dx = a2[0] - b2[0];
          dy = a2[1] - b2[1];
          sum2 += Math.sqrt(dx * dx + dy * dy);
        }
        return sum2;
      }
      exports.pathLength = pathLength;
      function interpolate(x0, y0, x1, y1) {
        var abs3 = Math.abs, line = [], sx, sy, dx, dy, err, e2;
        dx = abs3(x1 - x0);
        dy = abs3(y1 - y0);
        sx = x0 < x1 ? 1 : -1;
        sy = y0 < y1 ? 1 : -1;
        err = dx - dy;
        while (true) {
          line.push([x0, y0]);
          if (x0 === x1 && y0 === y1) {
            break;
          }
          e2 = 2 * err;
          if (e2 > -dy) {
            err = err - dy;
            x0 = x0 + sx;
          }
          if (e2 < dx) {
            err = err + dx;
            y0 = y0 + sy;
          }
        }
        return line;
      }
      exports.interpolate = interpolate;
      function expandPath(path2) {
        var expanded = [], len = path2.length, coord0, coord1, interpolated, interpolatedLen, i2, j2;
        if (len < 2) {
          return expanded;
        }
        for (i2 = 0; i2 < len - 1; ++i2) {
          coord0 = path2[i2];
          coord1 = path2[i2 + 1];
          interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);
          interpolatedLen = interpolated.length;
          for (j2 = 0; j2 < interpolatedLen - 1; ++j2) {
            expanded.push(interpolated[j2]);
          }
        }
        expanded.push(path2[len - 1]);
        return expanded;
      }
      exports.expandPath = expandPath;
      function smoothenPath(grid, path2) {
        var len = path2.length, x0 = path2[0][0], y0 = path2[0][1], x1 = path2[len - 1][0], y1 = path2[len - 1][1], sx, sy, ex, ey, newPath, i2, j2, coord, line, testCoord, blocked;
        sx = x0;
        sy = y0;
        newPath = [[sx, sy]];
        for (i2 = 2; i2 < len; ++i2) {
          coord = path2[i2];
          ex = coord[0];
          ey = coord[1];
          line = interpolate(sx, sy, ex, ey);
          blocked = false;
          for (j2 = 1; j2 < line.length; ++j2) {
            testCoord = line[j2];
            if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {
              blocked = true;
              break;
            }
          }
          if (blocked) {
            lastValidCoord = path2[i2 - 1];
            newPath.push(lastValidCoord);
            sx = lastValidCoord[0];
            sy = lastValidCoord[1];
          }
        }
        newPath.push([x1, y1]);
        return newPath;
      }
      exports.smoothenPath = smoothenPath;
      function compressPath(path2) {
        if (path2.length < 3) {
          return path2;
        }
        var compressed = [], sx = path2[0][0], sy = path2[0][1], px = path2[1][0], py = path2[1][1], dx = px - sx, dy = py - sy, lx, ly, ldx, ldy, sq, i2;
        sq = Math.sqrt(dx * dx + dy * dy);
        dx /= sq;
        dy /= sq;
        compressed.push([sx, sy]);
        for (i2 = 2; i2 < path2.length; i2++) {
          lx = px;
          ly = py;
          ldx = dx;
          ldy = dy;
          px = path2[i2][0];
          py = path2[i2][1];
          dx = px - lx;
          dy = py - ly;
          sq = Math.sqrt(dx * dx + dy * dy);
          dx /= sq;
          dy /= sq;
          if (dx !== ldx || dy !== ldy) {
            compressed.push([lx, ly]);
          }
        }
        compressed.push([px, py]);
        return compressed;
      }
      exports.compressPath = compressPath;
    }
  });

  // node_modules/pathfinding/src/core/Heuristic.js
  var require_Heuristic = __commonJS({
    "node_modules/pathfinding/src/core/Heuristic.js"(exports, module) {
      module.exports = {
        /**
         * Manhattan distance.
         * @param {number} dx - Difference in x.
         * @param {number} dy - Difference in y.
         * @return {number} dx + dy
         */
        manhattan: function(dx, dy) {
          return dx + dy;
        },
        /**
         * Euclidean distance.
         * @param {number} dx - Difference in x.
         * @param {number} dy - Difference in y.
         * @return {number} sqrt(dx * dx + dy * dy)
         */
        euclidean: function(dx, dy) {
          return Math.sqrt(dx * dx + dy * dy);
        },
        /**
         * Octile distance.
         * @param {number} dx - Difference in x.
         * @param {number} dy - Difference in y.
         * @return {number} sqrt(dx * dx + dy * dy) for grids
         */
        octile: function(dx, dy) {
          var F2 = Math.SQRT2 - 1;
          return dx < dy ? F2 * dx + dy : F2 * dy + dx;
        },
        /**
         * Chebyshev distance.
         * @param {number} dx - Difference in x.
         * @param {number} dy - Difference in y.
         * @return {number} max(dx, dy)
         */
        chebyshev: function(dx, dy) {
          return Math.max(dx, dy);
        }
      };
    }
  });

  // node_modules/pathfinding/src/finders/AStarFinder.js
  var require_AStarFinder = __commonJS({
    "node_modules/pathfinding/src/finders/AStarFinder.js"(exports, module) {
      var Heap = require_heap2();
      var Util = require_Util();
      var Heuristic = require_Heuristic();
      var DiagonalMovement = require_DiagonalMovement();
      function AStarFinder(opt) {
        opt = opt || {};
        this.allowDiagonal = opt.allowDiagonal;
        this.dontCrossCorners = opt.dontCrossCorners;
        this.heuristic = opt.heuristic || Heuristic.manhattan;
        this.weight = opt.weight || 1;
        this.diagonalMovement = opt.diagonalMovement;
        if (!this.diagonalMovement) {
          if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
          } else {
            if (this.dontCrossCorners) {
              this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
              this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
          }
        }
        if (this.diagonalMovement === DiagonalMovement.Never) {
          this.heuristic = opt.heuristic || Heuristic.manhattan;
        } else {
          this.heuristic = opt.heuristic || Heuristic.octile;
        }
      }
      AStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
        var openList = new Heap(function(nodeA, nodeB) {
          return nodeA.f - nodeB.f;
        }), startNode = grid.getNodeAt(startX, startY), endNode = grid.getNodeAt(endX, endY), heuristic = this.heuristic, diagonalMovement = this.diagonalMovement, weight = this.weight, abs3 = Math.abs, SQRT2 = Math.SQRT2, node, neighbors, neighbor, i2, l2, x2, y2, ng;
        startNode.g = 0;
        startNode.f = 0;
        openList.push(startNode);
        startNode.opened = true;
        while (!openList.empty()) {
          node = openList.pop();
          node.closed = true;
          if (node === endNode) {
            return Util.backtrace(endNode);
          }
          neighbors = grid.getNeighbors(node, diagonalMovement);
          for (i2 = 0, l2 = neighbors.length; i2 < l2; ++i2) {
            neighbor = neighbors[i2];
            if (neighbor.closed) {
              continue;
            }
            x2 = neighbor.x;
            y2 = neighbor.y;
            ng = node.g + (x2 - node.x === 0 || y2 - node.y === 0 ? 1 : SQRT2);
            if (!neighbor.opened || ng < neighbor.g) {
              neighbor.g = ng;
              neighbor.h = neighbor.h || weight * heuristic(abs3(x2 - endX), abs3(y2 - endY));
              neighbor.f = neighbor.g + neighbor.h;
              neighbor.parent = node;
              if (!neighbor.opened) {
                openList.push(neighbor);
                neighbor.opened = true;
              } else {
                openList.updateItem(neighbor);
              }
            }
          }
        }
        return [];
      };
      module.exports = AStarFinder;
    }
  });

  // node_modules/pathfinding/src/finders/BestFirstFinder.js
  var require_BestFirstFinder = __commonJS({
    "node_modules/pathfinding/src/finders/BestFirstFinder.js"(exports, module) {
      var AStarFinder = require_AStarFinder();
      function BestFirstFinder(opt) {
        AStarFinder.call(this, opt);
        var orig = this.heuristic;
        this.heuristic = function(dx, dy) {
          return orig(dx, dy) * 1e6;
        };
      }
      BestFirstFinder.prototype = new AStarFinder();
      BestFirstFinder.prototype.constructor = BestFirstFinder;
      module.exports = BestFirstFinder;
    }
  });

  // node_modules/pathfinding/src/finders/BreadthFirstFinder.js
  var require_BreadthFirstFinder = __commonJS({
    "node_modules/pathfinding/src/finders/BreadthFirstFinder.js"(exports, module) {
      var Util = require_Util();
      var DiagonalMovement = require_DiagonalMovement();
      function BreadthFirstFinder(opt) {
        opt = opt || {};
        this.allowDiagonal = opt.allowDiagonal;
        this.dontCrossCorners = opt.dontCrossCorners;
        this.diagonalMovement = opt.diagonalMovement;
        if (!this.diagonalMovement) {
          if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
          } else {
            if (this.dontCrossCorners) {
              this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
              this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
          }
        }
      }
      BreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
        var openList = [], diagonalMovement = this.diagonalMovement, startNode = grid.getNodeAt(startX, startY), endNode = grid.getNodeAt(endX, endY), neighbors, neighbor, node, i2, l2;
        openList.push(startNode);
        startNode.opened = true;
        while (openList.length) {
          node = openList.shift();
          node.closed = true;
          if (node === endNode) {
            return Util.backtrace(endNode);
          }
          neighbors = grid.getNeighbors(node, diagonalMovement);
          for (i2 = 0, l2 = neighbors.length; i2 < l2; ++i2) {
            neighbor = neighbors[i2];
            if (neighbor.closed || neighbor.opened) {
              continue;
            }
            openList.push(neighbor);
            neighbor.opened = true;
            neighbor.parent = node;
          }
        }
        return [];
      };
      module.exports = BreadthFirstFinder;
    }
  });

  // node_modules/pathfinding/src/finders/DijkstraFinder.js
  var require_DijkstraFinder = __commonJS({
    "node_modules/pathfinding/src/finders/DijkstraFinder.js"(exports, module) {
      var AStarFinder = require_AStarFinder();
      function DijkstraFinder(opt) {
        AStarFinder.call(this, opt);
        this.heuristic = function(dx, dy) {
          return 0;
        };
      }
      DijkstraFinder.prototype = new AStarFinder();
      DijkstraFinder.prototype.constructor = DijkstraFinder;
      module.exports = DijkstraFinder;
    }
  });

  // node_modules/pathfinding/src/finders/BiAStarFinder.js
  var require_BiAStarFinder = __commonJS({
    "node_modules/pathfinding/src/finders/BiAStarFinder.js"(exports, module) {
      var Heap = require_heap2();
      var Util = require_Util();
      var Heuristic = require_Heuristic();
      var DiagonalMovement = require_DiagonalMovement();
      function BiAStarFinder(opt) {
        opt = opt || {};
        this.allowDiagonal = opt.allowDiagonal;
        this.dontCrossCorners = opt.dontCrossCorners;
        this.diagonalMovement = opt.diagonalMovement;
        this.heuristic = opt.heuristic || Heuristic.manhattan;
        this.weight = opt.weight || 1;
        if (!this.diagonalMovement) {
          if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
          } else {
            if (this.dontCrossCorners) {
              this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
              this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
          }
        }
        if (this.diagonalMovement === DiagonalMovement.Never) {
          this.heuristic = opt.heuristic || Heuristic.manhattan;
        } else {
          this.heuristic = opt.heuristic || Heuristic.octile;
        }
      }
      BiAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
        var cmp = function(nodeA, nodeB) {
          return nodeA.f - nodeB.f;
        }, startOpenList = new Heap(cmp), endOpenList = new Heap(cmp), startNode = grid.getNodeAt(startX, startY), endNode = grid.getNodeAt(endX, endY), heuristic = this.heuristic, diagonalMovement = this.diagonalMovement, weight = this.weight, abs3 = Math.abs, SQRT2 = Math.SQRT2, node, neighbors, neighbor, i2, l2, x2, y2, ng, BY_START = 1, BY_END = 2;
        startNode.g = 0;
        startNode.f = 0;
        startOpenList.push(startNode);
        startNode.opened = BY_START;
        endNode.g = 0;
        endNode.f = 0;
        endOpenList.push(endNode);
        endNode.opened = BY_END;
        while (!startOpenList.empty() && !endOpenList.empty()) {
          node = startOpenList.pop();
          node.closed = true;
          neighbors = grid.getNeighbors(node, diagonalMovement);
          for (i2 = 0, l2 = neighbors.length; i2 < l2; ++i2) {
            neighbor = neighbors[i2];
            if (neighbor.closed) {
              continue;
            }
            if (neighbor.opened === BY_END) {
              return Util.biBacktrace(node, neighbor);
            }
            x2 = neighbor.x;
            y2 = neighbor.y;
            ng = node.g + (x2 - node.x === 0 || y2 - node.y === 0 ? 1 : SQRT2);
            if (!neighbor.opened || ng < neighbor.g) {
              neighbor.g = ng;
              neighbor.h = neighbor.h || weight * heuristic(abs3(x2 - endX), abs3(y2 - endY));
              neighbor.f = neighbor.g + neighbor.h;
              neighbor.parent = node;
              if (!neighbor.opened) {
                startOpenList.push(neighbor);
                neighbor.opened = BY_START;
              } else {
                startOpenList.updateItem(neighbor);
              }
            }
          }
          node = endOpenList.pop();
          node.closed = true;
          neighbors = grid.getNeighbors(node, diagonalMovement);
          for (i2 = 0, l2 = neighbors.length; i2 < l2; ++i2) {
            neighbor = neighbors[i2];
            if (neighbor.closed) {
              continue;
            }
            if (neighbor.opened === BY_START) {
              return Util.biBacktrace(neighbor, node);
            }
            x2 = neighbor.x;
            y2 = neighbor.y;
            ng = node.g + (x2 - node.x === 0 || y2 - node.y === 0 ? 1 : SQRT2);
            if (!neighbor.opened || ng < neighbor.g) {
              neighbor.g = ng;
              neighbor.h = neighbor.h || weight * heuristic(abs3(x2 - startX), abs3(y2 - startY));
              neighbor.f = neighbor.g + neighbor.h;
              neighbor.parent = node;
              if (!neighbor.opened) {
                endOpenList.push(neighbor);
                neighbor.opened = BY_END;
              } else {
                endOpenList.updateItem(neighbor);
              }
            }
          }
        }
        return [];
      };
      module.exports = BiAStarFinder;
    }
  });

  // node_modules/pathfinding/src/finders/BiBestFirstFinder.js
  var require_BiBestFirstFinder = __commonJS({
    "node_modules/pathfinding/src/finders/BiBestFirstFinder.js"(exports, module) {
      var BiAStarFinder = require_BiAStarFinder();
      function BiBestFirstFinder(opt) {
        BiAStarFinder.call(this, opt);
        var orig = this.heuristic;
        this.heuristic = function(dx, dy) {
          return orig(dx, dy) * 1e6;
        };
      }
      BiBestFirstFinder.prototype = new BiAStarFinder();
      BiBestFirstFinder.prototype.constructor = BiBestFirstFinder;
      module.exports = BiBestFirstFinder;
    }
  });

  // node_modules/pathfinding/src/finders/BiBreadthFirstFinder.js
  var require_BiBreadthFirstFinder = __commonJS({
    "node_modules/pathfinding/src/finders/BiBreadthFirstFinder.js"(exports, module) {
      var Util = require_Util();
      var DiagonalMovement = require_DiagonalMovement();
      function BiBreadthFirstFinder(opt) {
        opt = opt || {};
        this.allowDiagonal = opt.allowDiagonal;
        this.dontCrossCorners = opt.dontCrossCorners;
        this.diagonalMovement = opt.diagonalMovement;
        if (!this.diagonalMovement) {
          if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
          } else {
            if (this.dontCrossCorners) {
              this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
              this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
          }
        }
      }
      BiBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
        var startNode = grid.getNodeAt(startX, startY), endNode = grid.getNodeAt(endX, endY), startOpenList = [], endOpenList = [], neighbors, neighbor, node, diagonalMovement = this.diagonalMovement, BY_START = 0, BY_END = 1, i2, l2;
        startOpenList.push(startNode);
        startNode.opened = true;
        startNode.by = BY_START;
        endOpenList.push(endNode);
        endNode.opened = true;
        endNode.by = BY_END;
        while (startOpenList.length && endOpenList.length) {
          node = startOpenList.shift();
          node.closed = true;
          neighbors = grid.getNeighbors(node, diagonalMovement);
          for (i2 = 0, l2 = neighbors.length; i2 < l2; ++i2) {
            neighbor = neighbors[i2];
            if (neighbor.closed) {
              continue;
            }
            if (neighbor.opened) {
              if (neighbor.by === BY_END) {
                return Util.biBacktrace(node, neighbor);
              }
              continue;
            }
            startOpenList.push(neighbor);
            neighbor.parent = node;
            neighbor.opened = true;
            neighbor.by = BY_START;
          }
          node = endOpenList.shift();
          node.closed = true;
          neighbors = grid.getNeighbors(node, diagonalMovement);
          for (i2 = 0, l2 = neighbors.length; i2 < l2; ++i2) {
            neighbor = neighbors[i2];
            if (neighbor.closed) {
              continue;
            }
            if (neighbor.opened) {
              if (neighbor.by === BY_START) {
                return Util.biBacktrace(neighbor, node);
              }
              continue;
            }
            endOpenList.push(neighbor);
            neighbor.parent = node;
            neighbor.opened = true;
            neighbor.by = BY_END;
          }
        }
        return [];
      };
      module.exports = BiBreadthFirstFinder;
    }
  });

  // node_modules/pathfinding/src/finders/BiDijkstraFinder.js
  var require_BiDijkstraFinder = __commonJS({
    "node_modules/pathfinding/src/finders/BiDijkstraFinder.js"(exports, module) {
      var BiAStarFinder = require_BiAStarFinder();
      function BiDijkstraFinder(opt) {
        BiAStarFinder.call(this, opt);
        this.heuristic = function(dx, dy) {
          return 0;
        };
      }
      BiDijkstraFinder.prototype = new BiAStarFinder();
      BiDijkstraFinder.prototype.constructor = BiDijkstraFinder;
      module.exports = BiDijkstraFinder;
    }
  });

  // node_modules/pathfinding/src/finders/IDAStarFinder.js
  var require_IDAStarFinder = __commonJS({
    "node_modules/pathfinding/src/finders/IDAStarFinder.js"(exports, module) {
      var Util = require_Util();
      var Heuristic = require_Heuristic();
      var Node2 = require_Node();
      var DiagonalMovement = require_DiagonalMovement();
      function IDAStarFinder(opt) {
        opt = opt || {};
        this.allowDiagonal = opt.allowDiagonal;
        this.dontCrossCorners = opt.dontCrossCorners;
        this.diagonalMovement = opt.diagonalMovement;
        this.heuristic = opt.heuristic || Heuristic.manhattan;
        this.weight = opt.weight || 1;
        this.trackRecursion = opt.trackRecursion || false;
        this.timeLimit = opt.timeLimit || Infinity;
        if (!this.diagonalMovement) {
          if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
          } else {
            if (this.dontCrossCorners) {
              this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
              this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
          }
        }
        if (this.diagonalMovement === DiagonalMovement.Never) {
          this.heuristic = opt.heuristic || Heuristic.manhattan;
        } else {
          this.heuristic = opt.heuristic || Heuristic.octile;
        }
      }
      IDAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
        var nodesVisited = 0;
        var startTime = (/* @__PURE__ */ new Date()).getTime();
        var h2 = function(a2, b2) {
          return this.heuristic(Math.abs(b2.x - a2.x), Math.abs(b2.y - a2.y));
        }.bind(this);
        var cost = function(a2, b2) {
          return a2.x === b2.x || a2.y === b2.y ? 1 : Math.SQRT2;
        };
        var search2 = function(node, g2, cutoff, route2, depth) {
          nodesVisited++;
          if (this.timeLimit > 0 && (/* @__PURE__ */ new Date()).getTime() - startTime > this.timeLimit * 1e3) {
            return Infinity;
          }
          var f2 = g2 + h2(node, end) * this.weight;
          if (f2 > cutoff) {
            return f2;
          }
          if (node == end) {
            route2[depth] = [node.x, node.y];
            return node;
          }
          var min6, t4, k2, neighbour;
          var neighbours = grid.getNeighbors(node, this.diagonalMovement);
          for (k2 = 0, min6 = Infinity; neighbour = neighbours[k2]; ++k2) {
            if (this.trackRecursion) {
              neighbour.retainCount = neighbour.retainCount + 1 || 1;
              if (neighbour.tested !== true) {
                neighbour.tested = true;
              }
            }
            t4 = search2(neighbour, g2 + cost(node, neighbour), cutoff, route2, depth + 1);
            if (t4 instanceof Node2) {
              route2[depth] = [node.x, node.y];
              return t4;
            }
            if (this.trackRecursion && --neighbour.retainCount === 0) {
              neighbour.tested = false;
            }
            if (t4 < min6) {
              min6 = t4;
            }
          }
          return min6;
        }.bind(this);
        var start3 = grid.getNodeAt(startX, startY);
        var end = grid.getNodeAt(endX, endY);
        var cutOff = h2(start3, end);
        var j2, route, t3;
        for (j2 = 0; true; ++j2) {
          route = [];
          t3 = search2(start3, 0, cutOff, route, 0);
          if (t3 === Infinity) {
            return [];
          }
          if (t3 instanceof Node2) {
            return route;
          }
          cutOff = t3;
        }
        return [];
      };
      module.exports = IDAStarFinder;
    }
  });

  // node_modules/pathfinding/src/finders/JumpPointFinderBase.js
  var require_JumpPointFinderBase = __commonJS({
    "node_modules/pathfinding/src/finders/JumpPointFinderBase.js"(exports, module) {
      var Heap = require_heap2();
      var Util = require_Util();
      var Heuristic = require_Heuristic();
      var DiagonalMovement = require_DiagonalMovement();
      function JumpPointFinderBase(opt) {
        opt = opt || {};
        this.heuristic = opt.heuristic || Heuristic.manhattan;
        this.trackJumpRecursion = opt.trackJumpRecursion || false;
      }
      JumpPointFinderBase.prototype.findPath = function(startX, startY, endX, endY, grid) {
        var openList = this.openList = new Heap(function(nodeA, nodeB) {
          return nodeA.f - nodeB.f;
        }), startNode = this.startNode = grid.getNodeAt(startX, startY), endNode = this.endNode = grid.getNodeAt(endX, endY), node;
        this.grid = grid;
        startNode.g = 0;
        startNode.f = 0;
        openList.push(startNode);
        startNode.opened = true;
        while (!openList.empty()) {
          node = openList.pop();
          node.closed = true;
          if (node === endNode) {
            return Util.expandPath(Util.backtrace(endNode));
          }
          this._identifySuccessors(node);
        }
        return [];
      };
      JumpPointFinderBase.prototype._identifySuccessors = function(node) {
        var grid = this.grid, heuristic = this.heuristic, openList = this.openList, endX = this.endNode.x, endY = this.endNode.y, neighbors, neighbor, jumpPoint, i2, l2, x2 = node.x, y2 = node.y, jx, jy, dx, dy, d2, ng, jumpNode, abs3 = Math.abs, max7 = Math.max;
        neighbors = this._findNeighbors(node);
        for (i2 = 0, l2 = neighbors.length; i2 < l2; ++i2) {
          neighbor = neighbors[i2];
          jumpPoint = this._jump(neighbor[0], neighbor[1], x2, y2);
          if (jumpPoint) {
            jx = jumpPoint[0];
            jy = jumpPoint[1];
            jumpNode = grid.getNodeAt(jx, jy);
            if (jumpNode.closed) {
              continue;
            }
            d2 = Heuristic.octile(abs3(jx - x2), abs3(jy - y2));
            ng = node.g + d2;
            if (!jumpNode.opened || ng < jumpNode.g) {
              jumpNode.g = ng;
              jumpNode.h = jumpNode.h || heuristic(abs3(jx - endX), abs3(jy - endY));
              jumpNode.f = jumpNode.g + jumpNode.h;
              jumpNode.parent = node;
              if (!jumpNode.opened) {
                openList.push(jumpNode);
                jumpNode.opened = true;
              } else {
                openList.updateItem(jumpNode);
              }
            }
          }
        }
      };
      module.exports = JumpPointFinderBase;
    }
  });

  // node_modules/pathfinding/src/finders/JPFNeverMoveDiagonally.js
  var require_JPFNeverMoveDiagonally = __commonJS({
    "node_modules/pathfinding/src/finders/JPFNeverMoveDiagonally.js"(exports, module) {
      var JumpPointFinderBase = require_JumpPointFinderBase();
      var DiagonalMovement = require_DiagonalMovement();
      function JPFNeverMoveDiagonally(opt) {
        JumpPointFinderBase.call(this, opt);
      }
      JPFNeverMoveDiagonally.prototype = new JumpPointFinderBase();
      JPFNeverMoveDiagonally.prototype.constructor = JPFNeverMoveDiagonally;
      JPFNeverMoveDiagonally.prototype._jump = function(x2, y2, px, py) {
        var grid = this.grid, dx = x2 - px, dy = y2 - py;
        if (!grid.isWalkableAt(x2, y2)) {
          return null;
        }
        if (this.trackJumpRecursion === true) {
          grid.getNodeAt(x2, y2).tested = true;
        }
        if (grid.getNodeAt(x2, y2) === this.endNode) {
          return [x2, y2];
        }
        if (dx !== 0) {
          if (grid.isWalkableAt(x2, y2 - 1) && !grid.isWalkableAt(x2 - dx, y2 - 1) || grid.isWalkableAt(x2, y2 + 1) && !grid.isWalkableAt(x2 - dx, y2 + 1)) {
            return [x2, y2];
          }
        } else if (dy !== 0) {
          if (grid.isWalkableAt(x2 - 1, y2) && !grid.isWalkableAt(x2 - 1, y2 - dy) || grid.isWalkableAt(x2 + 1, y2) && !grid.isWalkableAt(x2 + 1, y2 - dy)) {
            return [x2, y2];
          }
          if (this._jump(x2 + 1, y2, x2, y2) || this._jump(x2 - 1, y2, x2, y2)) {
            return [x2, y2];
          }
        } else {
          throw new Error("Only horizontal and vertical movements are allowed");
        }
        return this._jump(x2 + dx, y2 + dy, x2, y2);
      };
      JPFNeverMoveDiagonally.prototype._findNeighbors = function(node) {
        var parent2 = node.parent, x2 = node.x, y2 = node.y, grid = this.grid, px, py, nx, ny, dx, dy, neighbors = [], neighborNodes, neighborNode, i2, l2;
        if (parent2) {
          px = parent2.x;
          py = parent2.y;
          dx = (x2 - px) / Math.max(Math.abs(x2 - px), 1);
          dy = (y2 - py) / Math.max(Math.abs(y2 - py), 1);
          if (dx !== 0) {
            if (grid.isWalkableAt(x2, y2 - 1)) {
              neighbors.push([x2, y2 - 1]);
            }
            if (grid.isWalkableAt(x2, y2 + 1)) {
              neighbors.push([x2, y2 + 1]);
            }
            if (grid.isWalkableAt(x2 + dx, y2)) {
              neighbors.push([x2 + dx, y2]);
            }
          } else if (dy !== 0) {
            if (grid.isWalkableAt(x2 - 1, y2)) {
              neighbors.push([x2 - 1, y2]);
            }
            if (grid.isWalkableAt(x2 + 1, y2)) {
              neighbors.push([x2 + 1, y2]);
            }
            if (grid.isWalkableAt(x2, y2 + dy)) {
              neighbors.push([x2, y2 + dy]);
            }
          }
        } else {
          neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);
          for (i2 = 0, l2 = neighborNodes.length; i2 < l2; ++i2) {
            neighborNode = neighborNodes[i2];
            neighbors.push([neighborNode.x, neighborNode.y]);
          }
        }
        return neighbors;
      };
      module.exports = JPFNeverMoveDiagonally;
    }
  });

  // node_modules/pathfinding/src/finders/JPFAlwaysMoveDiagonally.js
  var require_JPFAlwaysMoveDiagonally = __commonJS({
    "node_modules/pathfinding/src/finders/JPFAlwaysMoveDiagonally.js"(exports, module) {
      var JumpPointFinderBase = require_JumpPointFinderBase();
      var DiagonalMovement = require_DiagonalMovement();
      function JPFAlwaysMoveDiagonally(opt) {
        JumpPointFinderBase.call(this, opt);
      }
      JPFAlwaysMoveDiagonally.prototype = new JumpPointFinderBase();
      JPFAlwaysMoveDiagonally.prototype.constructor = JPFAlwaysMoveDiagonally;
      JPFAlwaysMoveDiagonally.prototype._jump = function(x2, y2, px, py) {
        var grid = this.grid, dx = x2 - px, dy = y2 - py;
        if (!grid.isWalkableAt(x2, y2)) {
          return null;
        }
        if (this.trackJumpRecursion === true) {
          grid.getNodeAt(x2, y2).tested = true;
        }
        if (grid.getNodeAt(x2, y2) === this.endNode) {
          return [x2, y2];
        }
        if (dx !== 0 && dy !== 0) {
          if (grid.isWalkableAt(x2 - dx, y2 + dy) && !grid.isWalkableAt(x2 - dx, y2) || grid.isWalkableAt(x2 + dx, y2 - dy) && !grid.isWalkableAt(x2, y2 - dy)) {
            return [x2, y2];
          }
          if (this._jump(x2 + dx, y2, x2, y2) || this._jump(x2, y2 + dy, x2, y2)) {
            return [x2, y2];
          }
        } else {
          if (dx !== 0) {
            if (grid.isWalkableAt(x2 + dx, y2 + 1) && !grid.isWalkableAt(x2, y2 + 1) || grid.isWalkableAt(x2 + dx, y2 - 1) && !grid.isWalkableAt(x2, y2 - 1)) {
              return [x2, y2];
            }
          } else {
            if (grid.isWalkableAt(x2 + 1, y2 + dy) && !grid.isWalkableAt(x2 + 1, y2) || grid.isWalkableAt(x2 - 1, y2 + dy) && !grid.isWalkableAt(x2 - 1, y2)) {
              return [x2, y2];
            }
          }
        }
        return this._jump(x2 + dx, y2 + dy, x2, y2);
      };
      JPFAlwaysMoveDiagonally.prototype._findNeighbors = function(node) {
        var parent2 = node.parent, x2 = node.x, y2 = node.y, grid = this.grid, px, py, nx, ny, dx, dy, neighbors = [], neighborNodes, neighborNode, i2, l2;
        if (parent2) {
          px = parent2.x;
          py = parent2.y;
          dx = (x2 - px) / Math.max(Math.abs(x2 - px), 1);
          dy = (y2 - py) / Math.max(Math.abs(y2 - py), 1);
          if (dx !== 0 && dy !== 0) {
            if (grid.isWalkableAt(x2, y2 + dy)) {
              neighbors.push([x2, y2 + dy]);
            }
            if (grid.isWalkableAt(x2 + dx, y2)) {
              neighbors.push([x2 + dx, y2]);
            }
            if (grid.isWalkableAt(x2 + dx, y2 + dy)) {
              neighbors.push([x2 + dx, y2 + dy]);
            }
            if (!grid.isWalkableAt(x2 - dx, y2)) {
              neighbors.push([x2 - dx, y2 + dy]);
            }
            if (!grid.isWalkableAt(x2, y2 - dy)) {
              neighbors.push([x2 + dx, y2 - dy]);
            }
          } else {
            if (dx === 0) {
              if (grid.isWalkableAt(x2, y2 + dy)) {
                neighbors.push([x2, y2 + dy]);
              }
              if (!grid.isWalkableAt(x2 + 1, y2)) {
                neighbors.push([x2 + 1, y2 + dy]);
              }
              if (!grid.isWalkableAt(x2 - 1, y2)) {
                neighbors.push([x2 - 1, y2 + dy]);
              }
            } else {
              if (grid.isWalkableAt(x2 + dx, y2)) {
                neighbors.push([x2 + dx, y2]);
              }
              if (!grid.isWalkableAt(x2, y2 + 1)) {
                neighbors.push([x2 + dx, y2 + 1]);
              }
              if (!grid.isWalkableAt(x2, y2 - 1)) {
                neighbors.push([x2 + dx, y2 - 1]);
              }
            }
          }
        } else {
          neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);
          for (i2 = 0, l2 = neighborNodes.length; i2 < l2; ++i2) {
            neighborNode = neighborNodes[i2];
            neighbors.push([neighborNode.x, neighborNode.y]);
          }
        }
        return neighbors;
      };
      module.exports = JPFAlwaysMoveDiagonally;
    }
  });

  // node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfNoObstacles.js
  var require_JPFMoveDiagonallyIfNoObstacles = __commonJS({
    "node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfNoObstacles.js"(exports, module) {
      var JumpPointFinderBase = require_JumpPointFinderBase();
      var DiagonalMovement = require_DiagonalMovement();
      function JPFMoveDiagonallyIfNoObstacles(opt) {
        JumpPointFinderBase.call(this, opt);
      }
      JPFMoveDiagonallyIfNoObstacles.prototype = new JumpPointFinderBase();
      JPFMoveDiagonallyIfNoObstacles.prototype.constructor = JPFMoveDiagonallyIfNoObstacles;
      JPFMoveDiagonallyIfNoObstacles.prototype._jump = function(x2, y2, px, py) {
        var grid = this.grid, dx = x2 - px, dy = y2 - py;
        if (!grid.isWalkableAt(x2, y2)) {
          return null;
        }
        if (this.trackJumpRecursion === true) {
          grid.getNodeAt(x2, y2).tested = true;
        }
        if (grid.getNodeAt(x2, y2) === this.endNode) {
          return [x2, y2];
        }
        if (dx !== 0 && dy !== 0) {
          if (this._jump(x2 + dx, y2, x2, y2) || this._jump(x2, y2 + dy, x2, y2)) {
            return [x2, y2];
          }
        } else {
          if (dx !== 0) {
            if (grid.isWalkableAt(x2, y2 - 1) && !grid.isWalkableAt(x2 - dx, y2 - 1) || grid.isWalkableAt(x2, y2 + 1) && !grid.isWalkableAt(x2 - dx, y2 + 1)) {
              return [x2, y2];
            }
          } else if (dy !== 0) {
            if (grid.isWalkableAt(x2 - 1, y2) && !grid.isWalkableAt(x2 - 1, y2 - dy) || grid.isWalkableAt(x2 + 1, y2) && !grid.isWalkableAt(x2 + 1, y2 - dy)) {
              return [x2, y2];
            }
          }
        }
        if (grid.isWalkableAt(x2 + dx, y2) && grid.isWalkableAt(x2, y2 + dy)) {
          return this._jump(x2 + dx, y2 + dy, x2, y2);
        } else {
          return null;
        }
      };
      JPFMoveDiagonallyIfNoObstacles.prototype._findNeighbors = function(node) {
        var parent2 = node.parent, x2 = node.x, y2 = node.y, grid = this.grid, px, py, nx, ny, dx, dy, neighbors = [], neighborNodes, neighborNode, i2, l2;
        if (parent2) {
          px = parent2.x;
          py = parent2.y;
          dx = (x2 - px) / Math.max(Math.abs(x2 - px), 1);
          dy = (y2 - py) / Math.max(Math.abs(y2 - py), 1);
          if (dx !== 0 && dy !== 0) {
            if (grid.isWalkableAt(x2, y2 + dy)) {
              neighbors.push([x2, y2 + dy]);
            }
            if (grid.isWalkableAt(x2 + dx, y2)) {
              neighbors.push([x2 + dx, y2]);
            }
            if (grid.isWalkableAt(x2, y2 + dy) && grid.isWalkableAt(x2 + dx, y2)) {
              neighbors.push([x2 + dx, y2 + dy]);
            }
          } else {
            var isNextWalkable;
            if (dx !== 0) {
              isNextWalkable = grid.isWalkableAt(x2 + dx, y2);
              var isTopWalkable = grid.isWalkableAt(x2, y2 + 1);
              var isBottomWalkable = grid.isWalkableAt(x2, y2 - 1);
              if (isNextWalkable) {
                neighbors.push([x2 + dx, y2]);
                if (isTopWalkable) {
                  neighbors.push([x2 + dx, y2 + 1]);
                }
                if (isBottomWalkable) {
                  neighbors.push([x2 + dx, y2 - 1]);
                }
              }
              if (isTopWalkable) {
                neighbors.push([x2, y2 + 1]);
              }
              if (isBottomWalkable) {
                neighbors.push([x2, y2 - 1]);
              }
            } else if (dy !== 0) {
              isNextWalkable = grid.isWalkableAt(x2, y2 + dy);
              var isRightWalkable = grid.isWalkableAt(x2 + 1, y2);
              var isLeftWalkable = grid.isWalkableAt(x2 - 1, y2);
              if (isNextWalkable) {
                neighbors.push([x2, y2 + dy]);
                if (isRightWalkable) {
                  neighbors.push([x2 + 1, y2 + dy]);
                }
                if (isLeftWalkable) {
                  neighbors.push([x2 - 1, y2 + dy]);
                }
              }
              if (isRightWalkable) {
                neighbors.push([x2 + 1, y2]);
              }
              if (isLeftWalkable) {
                neighbors.push([x2 - 1, y2]);
              }
            }
          }
        } else {
          neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);
          for (i2 = 0, l2 = neighborNodes.length; i2 < l2; ++i2) {
            neighborNode = neighborNodes[i2];
            neighbors.push([neighborNode.x, neighborNode.y]);
          }
        }
        return neighbors;
      };
      module.exports = JPFMoveDiagonallyIfNoObstacles;
    }
  });

  // node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfAtMostOneObstacle.js
  var require_JPFMoveDiagonallyIfAtMostOneObstacle = __commonJS({
    "node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfAtMostOneObstacle.js"(exports, module) {
      var JumpPointFinderBase = require_JumpPointFinderBase();
      var DiagonalMovement = require_DiagonalMovement();
      function JPFMoveDiagonallyIfAtMostOneObstacle(opt) {
        JumpPointFinderBase.call(this, opt);
      }
      JPFMoveDiagonallyIfAtMostOneObstacle.prototype = new JumpPointFinderBase();
      JPFMoveDiagonallyIfAtMostOneObstacle.prototype.constructor = JPFMoveDiagonallyIfAtMostOneObstacle;
      JPFMoveDiagonallyIfAtMostOneObstacle.prototype._jump = function(x2, y2, px, py) {
        var grid = this.grid, dx = x2 - px, dy = y2 - py;
        if (!grid.isWalkableAt(x2, y2)) {
          return null;
        }
        if (this.trackJumpRecursion === true) {
          grid.getNodeAt(x2, y2).tested = true;
        }
        if (grid.getNodeAt(x2, y2) === this.endNode) {
          return [x2, y2];
        }
        if (dx !== 0 && dy !== 0) {
          if (grid.isWalkableAt(x2 - dx, y2 + dy) && !grid.isWalkableAt(x2 - dx, y2) || grid.isWalkableAt(x2 + dx, y2 - dy) && !grid.isWalkableAt(x2, y2 - dy)) {
            return [x2, y2];
          }
          if (this._jump(x2 + dx, y2, x2, y2) || this._jump(x2, y2 + dy, x2, y2)) {
            return [x2, y2];
          }
        } else {
          if (dx !== 0) {
            if (grid.isWalkableAt(x2 + dx, y2 + 1) && !grid.isWalkableAt(x2, y2 + 1) || grid.isWalkableAt(x2 + dx, y2 - 1) && !grid.isWalkableAt(x2, y2 - 1)) {
              return [x2, y2];
            }
          } else {
            if (grid.isWalkableAt(x2 + 1, y2 + dy) && !grid.isWalkableAt(x2 + 1, y2) || grid.isWalkableAt(x2 - 1, y2 + dy) && !grid.isWalkableAt(x2 - 1, y2)) {
              return [x2, y2];
            }
          }
        }
        if (grid.isWalkableAt(x2 + dx, y2) || grid.isWalkableAt(x2, y2 + dy)) {
          return this._jump(x2 + dx, y2 + dy, x2, y2);
        } else {
          return null;
        }
      };
      JPFMoveDiagonallyIfAtMostOneObstacle.prototype._findNeighbors = function(node) {
        var parent2 = node.parent, x2 = node.x, y2 = node.y, grid = this.grid, px, py, nx, ny, dx, dy, neighbors = [], neighborNodes, neighborNode, i2, l2;
        if (parent2) {
          px = parent2.x;
          py = parent2.y;
          dx = (x2 - px) / Math.max(Math.abs(x2 - px), 1);
          dy = (y2 - py) / Math.max(Math.abs(y2 - py), 1);
          if (dx !== 0 && dy !== 0) {
            if (grid.isWalkableAt(x2, y2 + dy)) {
              neighbors.push([x2, y2 + dy]);
            }
            if (grid.isWalkableAt(x2 + dx, y2)) {
              neighbors.push([x2 + dx, y2]);
            }
            if (grid.isWalkableAt(x2, y2 + dy) || grid.isWalkableAt(x2 + dx, y2)) {
              neighbors.push([x2 + dx, y2 + dy]);
            }
            if (!grid.isWalkableAt(x2 - dx, y2) && grid.isWalkableAt(x2, y2 + dy)) {
              neighbors.push([x2 - dx, y2 + dy]);
            }
            if (!grid.isWalkableAt(x2, y2 - dy) && grid.isWalkableAt(x2 + dx, y2)) {
              neighbors.push([x2 + dx, y2 - dy]);
            }
          } else {
            if (dx === 0) {
              if (grid.isWalkableAt(x2, y2 + dy)) {
                neighbors.push([x2, y2 + dy]);
                if (!grid.isWalkableAt(x2 + 1, y2)) {
                  neighbors.push([x2 + 1, y2 + dy]);
                }
                if (!grid.isWalkableAt(x2 - 1, y2)) {
                  neighbors.push([x2 - 1, y2 + dy]);
                }
              }
            } else {
              if (grid.isWalkableAt(x2 + dx, y2)) {
                neighbors.push([x2 + dx, y2]);
                if (!grid.isWalkableAt(x2, y2 + 1)) {
                  neighbors.push([x2 + dx, y2 + 1]);
                }
                if (!grid.isWalkableAt(x2, y2 - 1)) {
                  neighbors.push([x2 + dx, y2 - 1]);
                }
              }
            }
          }
        } else {
          neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);
          for (i2 = 0, l2 = neighborNodes.length; i2 < l2; ++i2) {
            neighborNode = neighborNodes[i2];
            neighbors.push([neighborNode.x, neighborNode.y]);
          }
        }
        return neighbors;
      };
      module.exports = JPFMoveDiagonallyIfAtMostOneObstacle;
    }
  });

  // node_modules/pathfinding/src/finders/JumpPointFinder.js
  var require_JumpPointFinder = __commonJS({
    "node_modules/pathfinding/src/finders/JumpPointFinder.js"(exports, module) {
      var DiagonalMovement = require_DiagonalMovement();
      var JPFNeverMoveDiagonally = require_JPFNeverMoveDiagonally();
      var JPFAlwaysMoveDiagonally = require_JPFAlwaysMoveDiagonally();
      var JPFMoveDiagonallyIfNoObstacles = require_JPFMoveDiagonallyIfNoObstacles();
      var JPFMoveDiagonallyIfAtMostOneObstacle = require_JPFMoveDiagonallyIfAtMostOneObstacle();
      function JumpPointFinder(opt) {
        opt = opt || {};
        if (opt.diagonalMovement === DiagonalMovement.Never) {
          return new JPFNeverMoveDiagonally(opt);
        } else if (opt.diagonalMovement === DiagonalMovement.Always) {
          return new JPFAlwaysMoveDiagonally(opt);
        } else if (opt.diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {
          return new JPFMoveDiagonallyIfNoObstacles(opt);
        } else {
          return new JPFMoveDiagonallyIfAtMostOneObstacle(opt);
        }
      }
      module.exports = JumpPointFinder;
    }
  });

  // node_modules/pathfinding/src/PathFinding.js
  var require_PathFinding = __commonJS({
    "node_modules/pathfinding/src/PathFinding.js"(exports, module) {
      module.exports = {
        "Heap": require_heap2(),
        "Node": require_Node(),
        "Grid": require_Grid(),
        "Util": require_Util(),
        "DiagonalMovement": require_DiagonalMovement(),
        "Heuristic": require_Heuristic(),
        "AStarFinder": require_AStarFinder(),
        "BestFirstFinder": require_BestFirstFinder(),
        "BreadthFirstFinder": require_BreadthFirstFinder(),
        "DijkstraFinder": require_DijkstraFinder(),
        "BiAStarFinder": require_BiAStarFinder(),
        "BiBestFirstFinder": require_BiBestFirstFinder(),
        "BiBreadthFirstFinder": require_BiBreadthFirstFinder(),
        "BiDijkstraFinder": require_BiDijkstraFinder(),
        "IDAStarFinder": require_IDAStarFinder(),
        "JumpPointFinder": require_JumpPointFinder()
      };
    }
  });

  // node_modules/pathfinding/index.js
  var require_pathfinding = __commonJS({
    "node_modules/pathfinding/index.js"(exports, module) {
      module.exports = require_PathFinding();
    }
  });

  // node_modules/pixi.js/lib/extensions/Extensions.mjs
  var ExtensionType, normalizeExtension, normalizeExtensionPriority, extensions;
  var init_Extensions = __esm({
    "node_modules/pixi.js/lib/extensions/Extensions.mjs"() {
      "use strict";
      ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {
        ExtensionType2["Application"] = "application";
        ExtensionType2["WebGLPipes"] = "webgl-pipes";
        ExtensionType2["WebGLPipesAdaptor"] = "webgl-pipes-adaptor";
        ExtensionType2["WebGLSystem"] = "webgl-system";
        ExtensionType2["WebGPUPipes"] = "webgpu-pipes";
        ExtensionType2["WebGPUPipesAdaptor"] = "webgpu-pipes-adaptor";
        ExtensionType2["WebGPUSystem"] = "webgpu-system";
        ExtensionType2["CanvasSystem"] = "canvas-system";
        ExtensionType2["CanvasPipesAdaptor"] = "canvas-pipes-adaptor";
        ExtensionType2["CanvasPipes"] = "canvas-pipes";
        ExtensionType2["Asset"] = "asset";
        ExtensionType2["LoadParser"] = "load-parser";
        ExtensionType2["ResolveParser"] = "resolve-parser";
        ExtensionType2["CacheParser"] = "cache-parser";
        ExtensionType2["DetectionParser"] = "detection-parser";
        ExtensionType2["MaskEffect"] = "mask-effect";
        ExtensionType2["BlendMode"] = "blend-mode";
        ExtensionType2["TextureSource"] = "texture-source";
        ExtensionType2["Environment"] = "environment";
        ExtensionType2["ShapeBuilder"] = "shape-builder";
        ExtensionType2["Batcher"] = "batcher";
        return ExtensionType2;
      })(ExtensionType || {});
      normalizeExtension = (ext) => {
        if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
          if (!ext.extension) {
            throw new Error("Extension class must have an extension object");
          }
          const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
          ext = { ...metadata, ref: ext };
        }
        if (typeof ext === "object") {
          ext = { ...ext };
        } else {
          throw new Error("Invalid extension type");
        }
        if (typeof ext.type === "string") {
          ext.type = [ext.type];
        }
        return ext;
      };
      normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;
      extensions = {
        /** @ignore */
        _addHandlers: {},
        /** @ignore */
        _removeHandlers: {},
        /** @ignore */
        _queue: {},
        /**
         * Remove extensions from PixiJS.
         * @param extensions - Extensions to be removed.
         * @returns {extensions} For chaining.
         */
        remove(...extensions2) {
          extensions2.map(normalizeExtension).forEach((ext) => {
            ext.type.forEach((type) => this._removeHandlers[type]?.(ext));
          });
          return this;
        },
        /**
         * Register new extensions with PixiJS.
         * @param extensions - The spread of extensions to add to PixiJS.
         * @returns {extensions} For chaining.
         */
        add(...extensions2) {
          extensions2.map(normalizeExtension).forEach((ext) => {
            ext.type.forEach((type) => {
              const handlers2 = this._addHandlers;
              const queue = this._queue;
              if (!handlers2[type]) {
                queue[type] = queue[type] || [];
                queue[type]?.push(ext);
              } else {
                handlers2[type]?.(ext);
              }
            });
          });
          return this;
        },
        /**
         * Internal method to handle extensions by name.
         * @param type - The extension type.
         * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.
         * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.
         * @returns {extensions} For chaining.
         */
        handle(type, onAdd, onRemove) {
          const addHandlers = this._addHandlers;
          const removeHandlers = this._removeHandlers;
          if (addHandlers[type] || removeHandlers[type]) {
            throw new Error(`Extension type ${type} already has a handler`);
          }
          addHandlers[type] = onAdd;
          removeHandlers[type] = onRemove;
          const queue = this._queue;
          if (queue[type]) {
            queue[type]?.forEach((ext) => onAdd(ext));
            delete queue[type];
          }
          return this;
        },
        /**
         * Handle a type, but using a map by `name` property.
         * @param type - Type of extension to handle.
         * @param map - The object map of named extensions.
         * @returns {extensions} For chaining.
         */
        handleByMap(type, map27) {
          return this.handle(
            type,
            (extension) => {
              if (extension.name) {
                map27[extension.name] = extension.ref;
              }
            },
            (extension) => {
              if (extension.name) {
                delete map27[extension.name];
              }
            }
          );
        },
        /**
         * Handle a type, but using a list of extensions with a `name` property.
         * @param type - Type of extension to handle.
         * @param map - The array of named extensions.
         * @param defaultPriority - Fallback priority if none is defined.
         * @returns {extensions} For chaining.
         */
        handleByNamedList(type, map27, defaultPriority = -1) {
          return this.handle(
            type,
            (extension) => {
              const index6 = map27.findIndex((item) => item.name === extension.name);
              if (index6 >= 0)
                return;
              map27.push({ name: extension.name, value: extension.ref });
              map27.sort((a2, b2) => normalizeExtensionPriority(b2.value, defaultPriority) - normalizeExtensionPriority(a2.value, defaultPriority));
            },
            (extension) => {
              const index6 = map27.findIndex((item) => item.name === extension.name);
              if (index6 !== -1) {
                map27.splice(index6, 1);
              }
            }
          );
        },
        /**
         * Handle a type, but using a list of extensions.
         * @param type - Type of extension to handle.
         * @param list - The list of extensions.
         * @param defaultPriority - The default priority to use if none is specified.
         * @returns {extensions} For chaining.
         */
        handleByList(type, list, defaultPriority = -1) {
          return this.handle(
            type,
            (extension) => {
              if (list.includes(extension.ref)) {
                return;
              }
              list.push(extension.ref);
              list.sort((a2, b2) => normalizeExtensionPriority(b2, defaultPriority) - normalizeExtensionPriority(a2, defaultPriority));
            },
            (extension) => {
              const index6 = list.indexOf(extension.ref);
              if (index6 !== -1) {
                list.splice(index6, 1);
              }
            }
          );
        }
      };
    }
  });

  // node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "node_modules/eventemitter3/index.js"(exports, module) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__) prefix = false;
      }
      function EE(fn, context3, once) {
        this.fn = fn;
        this.context = context3;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context3, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context3 || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
        else emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0) emitter._events = new Events();
        else delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events, name16;
        if (this._eventsCount === 0) return names;
        for (name16 in events = this._events) {
          if (has.call(events, name16)) names.push(prefix ? name16.slice(1) : name16);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers2 = this._events[evt];
        if (!handlers2) return [];
        if (handlers2.fn) return [handlers2.fn];
        for (var i2 = 0, l2 = handlers2.length, ee = new Array(l2); i2 < l2; i2++) {
          ee[i2] = handlers2[i2].fn;
        }
        return ee;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners) return 0;
        if (listeners.fn) return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return false;
        var listeners = this._events[evt], len = arguments.length, args, i2;
        if (listeners.fn) {
          if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
            args[i2 - 1] = arguments[i2];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length9 = listeners.length, j2;
          for (i2 = 0; i2 < length9; i2++) {
            if (listeners[i2].once) this.removeListener(event, listeners[i2].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i2].fn.call(listeners[i2].context);
                break;
              case 2:
                listeners[i2].fn.call(listeners[i2].context, a1);
                break;
              case 3:
                listeners[i2].fn.call(listeners[i2].context, a1, a2);
                break;
              case 4:
                listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
                break;
              default:
                if (!args) for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                  args[j2 - 1] = arguments[j2];
                }
                listeners[i2].fn.apply(listeners[i2].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on3(event, fn, context3) {
        return addListener(this, event, fn, context3, false);
      };
      EventEmitter2.prototype.once = function once(event, fn, context3) {
        return addListener(this, event, fn, context3, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context3, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context3 || listeners.context === context3)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i2 = 0, events = [], length9 = listeners.length; i2 < length9; i2++) {
            if (listeners[i2].fn !== fn || once && !listeners[i2].once || context3 && listeners[i2].context !== context3) {
              events.push(listeners[i2]);
            }
          }
          if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
          else clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt]) clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      if ("undefined" !== typeof module) {
        module.exports = EventEmitter2;
      }
    }
  });

  // node_modules/eventemitter3/index.mjs
  var import_index, eventemitter3_default;
  var init_eventemitter3 = __esm({
    "node_modules/eventemitter3/index.mjs"() {
      import_index = __toESM(require_eventemitter3(), 1);
      eventemitter3_default = import_index.default;
    }
  });

  // node_modules/@pixi/colord/index.mjs
  var r, t, n, e, u, a, o, i, s, h, b, g, d, f, c, l, p, v, m, y, N, x, M, H, $, j, w, S, k;
  var init_colord = __esm({
    "node_modules/@pixi/colord/index.mjs"() {
      r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
      t = function(r2) {
        return "string" == typeof r2 ? r2.length > 0 : "number" == typeof r2;
      };
      n = function(r2, t3, n2) {
        return void 0 === t3 && (t3 = 0), void 0 === n2 && (n2 = Math.pow(10, t3)), Math.round(n2 * r2) / n2 + 0;
      };
      e = function(r2, t3, n2) {
        return void 0 === t3 && (t3 = 0), void 0 === n2 && (n2 = 1), r2 > n2 ? n2 : r2 > t3 ? r2 : t3;
      };
      u = function(r2) {
        return (r2 = isFinite(r2) ? r2 % 360 : 0) > 0 ? r2 : r2 + 360;
      };
      a = function(r2) {
        return { r: e(r2.r, 0, 255), g: e(r2.g, 0, 255), b: e(r2.b, 0, 255), a: e(r2.a) };
      };
      o = function(r2) {
        return { r: n(r2.r), g: n(r2.g), b: n(r2.b), a: n(r2.a, 3) };
      };
      i = /^#([0-9a-f]{3,8})$/i;
      s = function(r2) {
        var t3 = r2.toString(16);
        return t3.length < 2 ? "0" + t3 : t3;
      };
      h = function(r2) {
        var t3 = r2.r, n2 = r2.g, e2 = r2.b, u2 = r2.a, a2 = Math.max(t3, n2, e2), o2 = a2 - Math.min(t3, n2, e2), i2 = o2 ? a2 === t3 ? (n2 - e2) / o2 : a2 === n2 ? 2 + (e2 - t3) / o2 : 4 + (t3 - n2) / o2 : 0;
        return { h: 60 * (i2 < 0 ? i2 + 6 : i2), s: a2 ? o2 / a2 * 100 : 0, v: a2 / 255 * 100, a: u2 };
      };
      b = function(r2) {
        var t3 = r2.h, n2 = r2.s, e2 = r2.v, u2 = r2.a;
        t3 = t3 / 360 * 6, n2 /= 100, e2 /= 100;
        var a2 = Math.floor(t3), o2 = e2 * (1 - n2), i2 = e2 * (1 - (t3 - a2) * n2), s2 = e2 * (1 - (1 - t3 + a2) * n2), h2 = a2 % 6;
        return { r: 255 * [e2, i2, o2, o2, s2, e2][h2], g: 255 * [s2, e2, e2, i2, o2, o2][h2], b: 255 * [o2, o2, s2, e2, e2, i2][h2], a: u2 };
      };
      g = function(r2) {
        return { h: u(r2.h), s: e(r2.s, 0, 100), l: e(r2.l, 0, 100), a: e(r2.a) };
      };
      d = function(r2) {
        return { h: n(r2.h), s: n(r2.s), l: n(r2.l), a: n(r2.a, 3) };
      };
      f = function(r2) {
        return b((n2 = (t3 = r2).s, { h: t3.h, s: (n2 *= ((e2 = t3.l) < 50 ? e2 : 100 - e2) / 100) > 0 ? 2 * n2 / (e2 + n2) * 100 : 0, v: e2 + n2, a: t3.a }));
        var t3, n2, e2;
      };
      c = function(r2) {
        return { h: (t3 = h(r2)).h, s: (u2 = (200 - (n2 = t3.s)) * (e2 = t3.v) / 100) > 0 && u2 < 200 ? n2 * e2 / 100 / (u2 <= 100 ? u2 : 200 - u2) * 100 : 0, l: u2 / 2, a: t3.a };
        var t3, n2, e2, u2;
      };
      l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      p = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      y = { string: [[function(r2) {
        var t3 = i.exec(r2);
        return t3 ? (r2 = t3[1]).length <= 4 ? { r: parseInt(r2[0] + r2[0], 16), g: parseInt(r2[1] + r2[1], 16), b: parseInt(r2[2] + r2[2], 16), a: 4 === r2.length ? n(parseInt(r2[3] + r2[3], 16) / 255, 2) : 1 } : 6 === r2.length || 8 === r2.length ? { r: parseInt(r2.substr(0, 2), 16), g: parseInt(r2.substr(2, 2), 16), b: parseInt(r2.substr(4, 2), 16), a: 8 === r2.length ? n(parseInt(r2.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
      }, "hex"], [function(r2) {
        var t3 = v.exec(r2) || m.exec(r2);
        return t3 ? t3[2] !== t3[4] || t3[4] !== t3[6] ? null : a({ r: Number(t3[1]) / (t3[2] ? 100 / 255 : 1), g: Number(t3[3]) / (t3[4] ? 100 / 255 : 1), b: Number(t3[5]) / (t3[6] ? 100 / 255 : 1), a: void 0 === t3[7] ? 1 : Number(t3[7]) / (t3[8] ? 100 : 1) }) : null;
      }, "rgb"], [function(t3) {
        var n2 = l.exec(t3) || p.exec(t3);
        if (!n2) return null;
        var e2, u2, a2 = g({ h: (e2 = n2[1], u2 = n2[2], void 0 === u2 && (u2 = "deg"), Number(e2) * (r[u2] || 1)), s: Number(n2[3]), l: Number(n2[4]), a: void 0 === n2[5] ? 1 : Number(n2[5]) / (n2[6] ? 100 : 1) });
        return f(a2);
      }, "hsl"]], object: [[function(r2) {
        var n2 = r2.r, e2 = r2.g, u2 = r2.b, o2 = r2.a, i2 = void 0 === o2 ? 1 : o2;
        return t(n2) && t(e2) && t(u2) ? a({ r: Number(n2), g: Number(e2), b: Number(u2), a: Number(i2) }) : null;
      }, "rgb"], [function(r2) {
        var n2 = r2.h, e2 = r2.s, u2 = r2.l, a2 = r2.a, o2 = void 0 === a2 ? 1 : a2;
        if (!t(n2) || !t(e2) || !t(u2)) return null;
        var i2 = g({ h: Number(n2), s: Number(e2), l: Number(u2), a: Number(o2) });
        return f(i2);
      }, "hsl"], [function(r2) {
        var n2 = r2.h, a2 = r2.s, o2 = r2.v, i2 = r2.a, s2 = void 0 === i2 ? 1 : i2;
        if (!t(n2) || !t(a2) || !t(o2)) return null;
        var h2 = function(r3) {
          return { h: u(r3.h), s: e(r3.s, 0, 100), v: e(r3.v, 0, 100), a: e(r3.a) };
        }({ h: Number(n2), s: Number(a2), v: Number(o2), a: Number(s2) });
        return b(h2);
      }, "hsv"]] };
      N = function(r2, t3) {
        for (var n2 = 0; n2 < t3.length; n2++) {
          var e2 = t3[n2][0](r2);
          if (e2) return [e2, t3[n2][1]];
        }
        return [null, void 0];
      };
      x = function(r2) {
        return "string" == typeof r2 ? N(r2.trim(), y.string) : "object" == typeof r2 && null !== r2 ? N(r2, y.object) : [null, void 0];
      };
      M = function(r2, t3) {
        var n2 = c(r2);
        return { h: n2.h, s: e(n2.s + 100 * t3, 0, 100), l: n2.l, a: n2.a };
      };
      H = function(r2) {
        return (299 * r2.r + 587 * r2.g + 114 * r2.b) / 1e3 / 255;
      };
      $ = function(r2, t3) {
        var n2 = c(r2);
        return { h: n2.h, s: n2.s, l: e(n2.l + 100 * t3, 0, 100), a: n2.a };
      };
      j = function() {
        function r2(r3) {
          this.parsed = x(r3)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
        }
        return r2.prototype.isValid = function() {
          return null !== this.parsed;
        }, r2.prototype.brightness = function() {
          return n(H(this.rgba), 2);
        }, r2.prototype.isDark = function() {
          return H(this.rgba) < 0.5;
        }, r2.prototype.isLight = function() {
          return H(this.rgba) >= 0.5;
        }, r2.prototype.toHex = function() {
          return r3 = o(this.rgba), t3 = r3.r, e2 = r3.g, u2 = r3.b, i2 = (a2 = r3.a) < 1 ? s(n(255 * a2)) : "", "#" + s(t3) + s(e2) + s(u2) + i2;
          var r3, t3, e2, u2, a2, i2;
        }, r2.prototype.toRgb = function() {
          return o(this.rgba);
        }, r2.prototype.toRgbString = function() {
          return r3 = o(this.rgba), t3 = r3.r, n2 = r3.g, e2 = r3.b, (u2 = r3.a) < 1 ? "rgba(" + t3 + ", " + n2 + ", " + e2 + ", " + u2 + ")" : "rgb(" + t3 + ", " + n2 + ", " + e2 + ")";
          var r3, t3, n2, e2, u2;
        }, r2.prototype.toHsl = function() {
          return d(c(this.rgba));
        }, r2.prototype.toHslString = function() {
          return r3 = d(c(this.rgba)), t3 = r3.h, n2 = r3.s, e2 = r3.l, (u2 = r3.a) < 1 ? "hsla(" + t3 + ", " + n2 + "%, " + e2 + "%, " + u2 + ")" : "hsl(" + t3 + ", " + n2 + "%, " + e2 + "%)";
          var r3, t3, n2, e2, u2;
        }, r2.prototype.toHsv = function() {
          return r3 = h(this.rgba), { h: n(r3.h), s: n(r3.s), v: n(r3.v), a: n(r3.a, 3) };
          var r3;
        }, r2.prototype.invert = function() {
          return w({ r: 255 - (r3 = this.rgba).r, g: 255 - r3.g, b: 255 - r3.b, a: r3.a });
          var r3;
        }, r2.prototype.saturate = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, r3));
        }, r2.prototype.desaturate = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, -r3));
        }, r2.prototype.grayscale = function() {
          return w(M(this.rgba, -1));
        }, r2.prototype.lighten = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w($(this.rgba, r3));
        }, r2.prototype.darken = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w($(this.rgba, -r3));
        }, r2.prototype.rotate = function(r3) {
          return void 0 === r3 && (r3 = 15), this.hue(this.hue() + r3);
        }, r2.prototype.alpha = function(r3) {
          return "number" == typeof r3 ? w({ r: (t3 = this.rgba).r, g: t3.g, b: t3.b, a: r3 }) : n(this.rgba.a, 3);
          var t3;
        }, r2.prototype.hue = function(r3) {
          var t3 = c(this.rgba);
          return "number" == typeof r3 ? w({ h: r3, s: t3.s, l: t3.l, a: t3.a }) : n(t3.h);
        }, r2.prototype.isEqual = function(r3) {
          return this.toHex() === w(r3).toHex();
        }, r2;
      }();
      w = function(r2) {
        return r2 instanceof j ? r2 : new j(r2);
      };
      S = [];
      k = function(r2) {
        r2.forEach(function(r3) {
          S.indexOf(r3) < 0 && (r3(j, y), S.push(r3));
        });
      };
    }
  });

  // node_modules/@pixi/colord/plugins/names.mjs
  function names_default(e2, f2) {
    var a2 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r2 = {};
    for (var d2 in a2) r2[a2[d2]] = d2;
    var l2 = {};
    e2.prototype.toName = function(f3) {
      if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
      var d3, i2, n2 = r2[this.toHex()];
      if (n2) return n2;
      if (null == f3 ? void 0 : f3.closest) {
        var o2 = this.toRgb(), t3 = 1 / 0, b2 = "black";
        if (!l2.length) for (var c2 in a2) l2[c2] = new e2(a2[c2]).toRgb();
        for (var g2 in a2) {
          var u2 = (d3 = o2, i2 = l2[g2], Math.pow(d3.r - i2.r, 2) + Math.pow(d3.g - i2.g, 2) + Math.pow(d3.b - i2.b, 2));
          u2 < t3 && (t3 = u2, b2 = g2);
        }
        return b2;
      }
    };
    f2.string.push([function(f3) {
      var r3 = f3.toLowerCase(), d3 = "transparent" === r3 ? "#0000" : a2[r3];
      return d3 ? new e2(d3).toRgb() : null;
    }, "name"]);
  }
  var init_names = __esm({
    "node_modules/@pixi/colord/plugins/names.mjs"() {
    }
  });

  // node_modules/pixi.js/lib/color/Color.mjs
  var _Color, Color;
  var init_Color = __esm({
    "node_modules/pixi.js/lib/color/Color.mjs"() {
      init_colord();
      init_names();
      k([names_default]);
      _Color = class _Color2 {
        /**
         * @param {ColorSource} value - Optional value to use, if not provided, white is used.
         */
        constructor(value12 = 16777215) {
          this._value = null;
          this._components = new Float32Array(4);
          this._components.fill(1);
          this._int = 16777215;
          this.value = value12;
        }
        /** Get red component (0 - 1) */
        get red() {
          return this._components[0];
        }
        /** Get green component (0 - 1) */
        get green() {
          return this._components[1];
        }
        /** Get blue component (0 - 1) */
        get blue() {
          return this._components[2];
        }
        /** Get alpha component (0 - 1) */
        get alpha() {
          return this._components[3];
        }
        /**
         * Set the value, suitable for chaining
         * @param value
         * @see Color.value
         */
        setValue(value12) {
          this.value = value12;
          return this;
        }
        /**
         * The current color source.
         *
         * When setting:
         * - Setting to an instance of `Color` will copy its color source and components.
         * - Otherwise, `Color` will try to normalize the color source and set the components.
         *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.
         *
         * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter
         * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.
         *
         * When getting:
         * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},
         *   {@link Color.premultiply premultiply} or {@link Color.round round}).
         * - Otherwise, the color source used when setting is returned.
         */
        set value(value12) {
          if (value12 instanceof _Color2) {
            this._value = this._cloneSource(value12._value);
            this._int = value12._int;
            this._components.set(value12._components);
          } else if (value12 === null) {
            throw new Error("Cannot set Color#value to null");
          } else if (this._value === null || !this._isSourceEqual(this._value, value12)) {
            this._value = this._cloneSource(value12);
            this._normalize(this._value);
          }
        }
        get value() {
          return this._value;
        }
        /**
         * Copy a color source internally.
         * @param value - Color source
         */
        _cloneSource(value12) {
          if (typeof value12 === "string" || typeof value12 === "number" || value12 instanceof Number || value12 === null) {
            return value12;
          } else if (Array.isArray(value12) || ArrayBuffer.isView(value12)) {
            return value12.slice(0);
          } else if (typeof value12 === "object" && value12 !== null) {
            return { ...value12 };
          }
          return value12;
        }
        /**
         * Equality check for color sources.
         * @param value1 - First color source
         * @param value2 - Second color source
         * @returns `true` if the color sources are equal, `false` otherwise.
         */
        _isSourceEqual(value1, value22) {
          const type1 = typeof value1;
          const type2 = typeof value22;
          if (type1 !== type2) {
            return false;
          } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {
            return value1 === value22;
          } else if (Array.isArray(value1) && Array.isArray(value22) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value22)) {
            if (value1.length !== value22.length) {
              return false;
            }
            return value1.every((v2, i2) => v2 === value22[i2]);
          } else if (value1 !== null && value22 !== null) {
            const keys1 = Object.keys(value1);
            const keys22 = Object.keys(value22);
            if (keys1.length !== keys22.length) {
              return false;
            }
            return keys1.every((key) => value1[key] === value22[key]);
          }
          return value1 === value22;
        }
        /**
         * Convert to a RGBA color object.
         * @example
         * import { Color } from 'pixi.js';
         * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }
         */
        toRgba() {
          const [r2, g2, b2, a2] = this._components;
          return { r: r2, g: g2, b: b2, a: a2 };
        }
        /**
         * Convert to a RGB color object.
         * @example
         * import { Color } from 'pixi.js';
         * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }
         */
        toRgb() {
          const [r2, g2, b2] = this._components;
          return { r: r2, g: g2, b: b2 };
        }
        /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */
        toRgbaString() {
          const [r2, g2, b2] = this.toUint8RgbArray();
          return `rgba(${r2},${g2},${b2},${this.alpha})`;
        }
        toUint8RgbArray(out2) {
          const [r2, g2, b2] = this._components;
          if (!this._arrayRgb) {
            this._arrayRgb = [];
          }
          out2 = out2 || this._arrayRgb;
          out2[0] = Math.round(r2 * 255);
          out2[1] = Math.round(g2 * 255);
          out2[2] = Math.round(b2 * 255);
          return out2;
        }
        toArray(out2) {
          if (!this._arrayRgba) {
            this._arrayRgba = [];
          }
          out2 = out2 || this._arrayRgba;
          const [r2, g2, b2, a2] = this._components;
          out2[0] = r2;
          out2[1] = g2;
          out2[2] = b2;
          out2[3] = a2;
          return out2;
        }
        toRgbArray(out2) {
          if (!this._arrayRgb) {
            this._arrayRgb = [];
          }
          out2 = out2 || this._arrayRgb;
          const [r2, g2, b2] = this._components;
          out2[0] = r2;
          out2[1] = g2;
          out2[2] = b2;
          return out2;
        }
        /**
         * Convert to a hexadecimal number.
         * @example
         * import { Color } from 'pixi.js';
         * new Color('white').toNumber(); // returns 16777215
         */
        toNumber() {
          return this._int;
        }
        /**
         * Convert to a BGR number
         * @example
         * import { Color } from 'pixi.js';
         * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff
         */
        toBgrNumber() {
          const [r2, g2, b2] = this.toUint8RgbArray();
          return (b2 << 16) + (g2 << 8) + r2;
        }
        /**
         * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).
         * @example
         * import { Color } from 'pixi.js';
         * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff
         * @returns {number} - The color as a number in little endian format.
         */
        toLittleEndianNumber() {
          const value12 = this._int;
          return (value12 >> 16) + (value12 & 65280) + ((value12 & 255) << 16);
        }
        /**
         * Multiply with another color. This action is destructive, and will
         * override the previous `value` property to be `null`.
         * @param {ColorSource} value - The color to multiply by.
         */
        multiply(value12) {
          const [r2, g2, b2, a2] = _Color2._temp.setValue(value12)._components;
          this._components[0] *= r2;
          this._components[1] *= g2;
          this._components[2] *= b2;
          this._components[3] *= a2;
          this._refreshInt();
          this._value = null;
          return this;
        }
        /**
         * Converts color to a premultiplied alpha format. This action is destructive, and will
         * override the previous `value` property to be `null`.
         * @param alpha - The alpha to multiply by.
         * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
         * @returns {Color} - Itself.
         */
        premultiply(alpha, applyToRGB = true) {
          if (applyToRGB) {
            this._components[0] *= alpha;
            this._components[1] *= alpha;
            this._components[2] *= alpha;
          }
          this._components[3] = alpha;
          this._refreshInt();
          this._value = null;
          return this;
        }
        /**
         * Premultiplies alpha with current color.
         * @param {number} alpha - The alpha to multiply by.
         * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
         * @returns {number} tint multiplied by alpha
         */
        toPremultiplied(alpha, applyToRGB = true) {
          if (alpha === 1) {
            return (255 << 24) + this._int;
          }
          if (alpha === 0) {
            return applyToRGB ? 0 : this._int;
          }
          let r2 = this._int >> 16 & 255;
          let g2 = this._int >> 8 & 255;
          let b2 = this._int & 255;
          if (applyToRGB) {
            r2 = r2 * alpha + 0.5 | 0;
            g2 = g2 * alpha + 0.5 | 0;
            b2 = b2 * alpha + 0.5 | 0;
          }
          return (alpha * 255 << 24) + (r2 << 16) + (g2 << 8) + b2;
        }
        /**
         * Convert to a hexadecimal string.
         * @example
         * import { Color } from 'pixi.js';
         * new Color('white').toHex(); // returns "#ffffff"
         */
        toHex() {
          const hexString = this._int.toString(16);
          return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
        }
        /**
         * Convert to a hexadecimal string with alpha.
         * @example
         * import { Color } from 'pixi.js';
         * new Color('white').toHexa(); // returns "#ffffffff"
         */
        toHexa() {
          const alphaValue = Math.round(this._components[3] * 255);
          const alphaString = alphaValue.toString(16);
          return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
        }
        /**
         * Set alpha, suitable for chaining.
         * @param alpha
         */
        setAlpha(alpha) {
          this._components[3] = this._clamp(alpha);
          return this;
        }
        /**
         * Normalize the input value into rgba
         * @param value - Input value
         */
        _normalize(value12) {
          let r2;
          let g2;
          let b2;
          let a2;
          if ((typeof value12 === "number" || value12 instanceof Number) && value12 >= 0 && value12 <= 16777215) {
            const int = value12;
            r2 = (int >> 16 & 255) / 255;
            g2 = (int >> 8 & 255) / 255;
            b2 = (int & 255) / 255;
            a2 = 1;
          } else if ((Array.isArray(value12) || value12 instanceof Float32Array) && value12.length >= 3 && value12.length <= 4) {
            value12 = this._clamp(value12);
            [r2, g2, b2, a2 = 1] = value12;
          } else if ((value12 instanceof Uint8Array || value12 instanceof Uint8ClampedArray) && value12.length >= 3 && value12.length <= 4) {
            value12 = this._clamp(value12, 0, 255);
            [r2, g2, b2, a2 = 255] = value12;
            r2 /= 255;
            g2 /= 255;
            b2 /= 255;
            a2 /= 255;
          } else if (typeof value12 === "string" || typeof value12 === "object") {
            if (typeof value12 === "string") {
              const match2 = _Color2.HEX_PATTERN.exec(value12);
              if (match2) {
                value12 = `#${match2[2]}`;
              }
            }
            const color = w(value12);
            if (color.isValid()) {
              ({ r: r2, g: g2, b: b2, a: a2 } = color.rgba);
              r2 /= 255;
              g2 /= 255;
              b2 /= 255;
            }
          }
          if (r2 !== void 0) {
            this._components[0] = r2;
            this._components[1] = g2;
            this._components[2] = b2;
            this._components[3] = a2;
            this._refreshInt();
          } else {
            throw new Error(`Unable to convert color ${value12}`);
          }
        }
        /** Refresh the internal color rgb number */
        _refreshInt() {
          this._clamp(this._components);
          const [r2, g2, b2] = this._components;
          this._int = (r2 * 255 << 16) + (g2 * 255 << 8) + (b2 * 255 | 0);
        }
        /**
         * Clamps values to a range. Will override original values
         * @param value - Value(s) to clamp
         * @param min - Minimum value
         * @param max - Maximum value
         */
        _clamp(value12, min6 = 0, max7 = 1) {
          if (typeof value12 === "number") {
            return Math.min(Math.max(value12, min6), max7);
          }
          value12.forEach((v2, i2) => {
            value12[i2] = Math.min(Math.max(v2, min6), max7);
          });
          return value12;
        }
        /**
         * Check if the value is a color-like object
         * @param value - Value to check
         * @returns True if the value is a color-like object
         * @static
         * @example
         * import { Color } from 'pixi.js';
         * Color.isColorLike('white'); // returns true
         * Color.isColorLike(0xffffff); // returns true
         * Color.isColorLike([1, 1, 1]); // returns true
         */
        static isColorLike(value12) {
          return typeof value12 === "number" || typeof value12 === "string" || value12 instanceof Number || value12 instanceof _Color2 || Array.isArray(value12) || value12 instanceof Uint8Array || value12 instanceof Uint8ClampedArray || value12 instanceof Float32Array || value12.r !== void 0 && value12.g !== void 0 && value12.b !== void 0 || value12.r !== void 0 && value12.g !== void 0 && value12.b !== void 0 && value12.a !== void 0 || value12.h !== void 0 && value12.s !== void 0 && value12.l !== void 0 || value12.h !== void 0 && value12.s !== void 0 && value12.l !== void 0 && value12.a !== void 0 || value12.h !== void 0 && value12.s !== void 0 && value12.v !== void 0 || value12.h !== void 0 && value12.s !== void 0 && value12.v !== void 0 && value12.a !== void 0;
        }
      };
      _Color.shared = new _Color();
      _Color._temp = new _Color();
      _Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
      Color = _Color;
    }
  });

  // node_modules/pixi.js/lib/culling/cullingMixin.mjs
  var cullingMixin;
  var init_cullingMixin = __esm({
    "node_modules/pixi.js/lib/culling/cullingMixin.mjs"() {
      "use strict";
      cullingMixin = {
        cullArea: null,
        cullable: false,
        cullableChildren: true
      };
    }
  });

  // node_modules/pixi.js/lib/maths/misc/const.mjs
  var PI_2, RAD_TO_DEG, DEG_TO_RAD;
  var init_const = __esm({
    "node_modules/pixi.js/lib/maths/misc/const.mjs"() {
      "use strict";
      PI_2 = Math.PI * 2;
      RAD_TO_DEG = 180 / Math.PI;
      DEG_TO_RAD = Math.PI / 180;
    }
  });

  // node_modules/pixi.js/lib/maths/point/Point.mjs
  var Point, tempPoint;
  var init_Point = __esm({
    "node_modules/pixi.js/lib/maths/point/Point.mjs"() {
      "use strict";
      Point = class _Point {
        /**
         * Creates a new `Point`
         * @param {number} [x=0] - position of the point on the x axis
         * @param {number} [y=0] - position of the point on the y axis
         */
        constructor(x2 = 0, y2 = 0) {
          this.x = 0;
          this.y = 0;
          this.x = x2;
          this.y = y2;
        }
        /**
         * Creates a clone of this point
         * @returns A clone of this point
         */
        clone() {
          return new _Point(this.x, this.y);
        }
        /**
         * Copies `x` and `y` from the given point into this point
         * @param p - The point to copy from
         * @returns The point instance itself
         */
        copyFrom(p2) {
          this.set(p2.x, p2.y);
          return this;
        }
        /**
         * Copies this point's x and y into the given point (`p`).
         * @param p - The point to copy to. Can be any of type that is or extends `PointData`
         * @returns The point (`p`) with values updated
         */
        copyTo(p2) {
          p2.set(this.x, this.y);
          return p2;
        }
        /**
         * Accepts another point (`p`) and returns `true` if the given point is equal to this point
         * @param p - The point to check
         * @returns Returns `true` if both `x` and `y` are equal
         */
        equals(p2) {
          return p2.x === this.x && p2.y === this.y;
        }
        /**
         * Sets the point to a new `x` and `y` position.
         * If `y` is omitted, both `x` and `y` will be set to `x`.
         * @param {number} [x=0] - position of the point on the `x` axis
         * @param {number} [y=x] - position of the point on the `y` axis
         * @returns The point instance itself
         */
        set(x2 = 0, y2 = x2) {
          this.x = x2;
          this.y = y2;
          return this;
        }
        toString() {
          return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
        }
        /**
         * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.
         * @readonly
         */
        static get shared() {
          tempPoint.x = 0;
          tempPoint.y = 0;
          return tempPoint;
        }
      };
      tempPoint = new Point();
    }
  });

  // node_modules/pixi.js/lib/maths/matrix/Matrix.mjs
  var Matrix, tempMatrix, identityMatrix;
  var init_Matrix = __esm({
    "node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"() {
      init_const();
      init_Point();
      Matrix = class _Matrix {
        /**
         * @param a - x scale
         * @param b - y skew
         * @param c - x skew
         * @param d - y scale
         * @param tx - x translation
         * @param ty - y translation
         */
        constructor(a2 = 1, b2 = 0, c2 = 0, d2 = 1, tx = 0, ty = 0) {
          this.array = null;
          this.a = a2;
          this.b = b2;
          this.c = c2;
          this.d = d2;
          this.tx = tx;
          this.ty = ty;
        }
        /**
         * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
         *
         * a = array[0]
         * b = array[1]
         * c = array[3]
         * d = array[4]
         * tx = array[2]
         * ty = array[5]
         * @param array - The array that the matrix will be populated from.
         */
        fromArray(array) {
          this.a = array[0];
          this.b = array[1];
          this.c = array[3];
          this.d = array[4];
          this.tx = array[2];
          this.ty = array[5];
        }
        /**
         * Sets the matrix properties.
         * @param a - Matrix component
         * @param b - Matrix component
         * @param c - Matrix component
         * @param d - Matrix component
         * @param tx - Matrix component
         * @param ty - Matrix component
         * @returns This matrix. Good for chaining method calls.
         */
        set(a2, b2, c2, d2, tx, ty) {
          this.a = a2;
          this.b = b2;
          this.c = c2;
          this.d = d2;
          this.tx = tx;
          this.ty = ty;
          return this;
        }
        /**
         * Creates an array from the current Matrix object.
         * @param transpose - Whether we need to transpose the matrix or not
         * @param [out=new Float32Array(9)] - If provided the array will be assigned to out
         * @returns The newly created array which contains the matrix
         */
        toArray(transpose2, out2) {
          if (!this.array) {
            this.array = new Float32Array(9);
          }
          const array = out2 || this.array;
          if (transpose2) {
            array[0] = this.a;
            array[1] = this.b;
            array[2] = 0;
            array[3] = this.c;
            array[4] = this.d;
            array[5] = 0;
            array[6] = this.tx;
            array[7] = this.ty;
            array[8] = 1;
          } else {
            array[0] = this.a;
            array[1] = this.c;
            array[2] = this.tx;
            array[3] = this.b;
            array[4] = this.d;
            array[5] = this.ty;
            array[6] = 0;
            array[7] = 0;
            array[8] = 1;
          }
          return array;
        }
        /**
         * Get a new position with the current transformation applied.
         * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
         * @param pos - The origin
         * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
         * @returns {Point} The new point, transformed through this matrix
         */
        apply(pos, newPos) {
          newPos = newPos || new Point();
          const x2 = pos.x;
          const y2 = pos.y;
          newPos.x = this.a * x2 + this.c * y2 + this.tx;
          newPos.y = this.b * x2 + this.d * y2 + this.ty;
          return newPos;
        }
        /**
         * Get a new position with the inverse of the current transformation applied.
         * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
         * @param pos - The origin
         * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
         * @returns {Point} The new point, inverse-transformed through this matrix
         */
        applyInverse(pos, newPos) {
          newPos = newPos || new Point();
          const a2 = this.a;
          const b2 = this.b;
          const c2 = this.c;
          const d2 = this.d;
          const tx = this.tx;
          const ty = this.ty;
          const id5 = 1 / (a2 * d2 + c2 * -b2);
          const x2 = pos.x;
          const y2 = pos.y;
          newPos.x = d2 * id5 * x2 + -c2 * id5 * y2 + (ty * c2 - tx * d2) * id5;
          newPos.y = a2 * id5 * y2 + -b2 * id5 * x2 + (-ty * a2 + tx * b2) * id5;
          return newPos;
        }
        /**
         * Translates the matrix on the x and y.
         * @param x - How much to translate x by
         * @param y - How much to translate y by
         * @returns This matrix. Good for chaining method calls.
         */
        translate(x2, y2) {
          this.tx += x2;
          this.ty += y2;
          return this;
        }
        /**
         * Applies a scale transformation to the matrix.
         * @param x - The amount to scale horizontally
         * @param y - The amount to scale vertically
         * @returns This matrix. Good for chaining method calls.
         */
        scale(x2, y2) {
          this.a *= x2;
          this.d *= y2;
          this.c *= x2;
          this.b *= y2;
          this.tx *= x2;
          this.ty *= y2;
          return this;
        }
        /**
         * Applies a rotation transformation to the matrix.
         * @param angle - The angle in radians.
         * @returns This matrix. Good for chaining method calls.
         */
        rotate(angle) {
          const cos2 = Math.cos(angle);
          const sin2 = Math.sin(angle);
          const a1 = this.a;
          const c1 = this.c;
          const tx1 = this.tx;
          this.a = a1 * cos2 - this.b * sin2;
          this.b = a1 * sin2 + this.b * cos2;
          this.c = c1 * cos2 - this.d * sin2;
          this.d = c1 * sin2 + this.d * cos2;
          this.tx = tx1 * cos2 - this.ty * sin2;
          this.ty = tx1 * sin2 + this.ty * cos2;
          return this;
        }
        /**
         * Appends the given Matrix to this Matrix.
         * @param matrix - The matrix to append.
         * @returns This matrix. Good for chaining method calls.
         */
        append(matrix) {
          const a1 = this.a;
          const b1 = this.b;
          const c1 = this.c;
          const d1 = this.d;
          this.a = matrix.a * a1 + matrix.b * c1;
          this.b = matrix.a * b1 + matrix.b * d1;
          this.c = matrix.c * a1 + matrix.d * c1;
          this.d = matrix.c * b1 + matrix.d * d1;
          this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
          this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
          return this;
        }
        /**
         * Appends two matrix's and sets the result to this matrix. AB = A * B
         * @param a - The matrix to append.
         * @param b - The matrix to append.
         * @returns This matrix. Good for chaining method calls.
         */
        appendFrom(a2, b2) {
          const a1 = a2.a;
          const b1 = a2.b;
          const c1 = a2.c;
          const d1 = a2.d;
          const tx = a2.tx;
          const ty = a2.ty;
          const a22 = b2.a;
          const b22 = b2.b;
          const c2 = b2.c;
          const d2 = b2.d;
          this.a = a1 * a22 + b1 * c2;
          this.b = a1 * b22 + b1 * d2;
          this.c = c1 * a22 + d1 * c2;
          this.d = c1 * b22 + d1 * d2;
          this.tx = tx * a22 + ty * c2 + b2.tx;
          this.ty = tx * b22 + ty * d2 + b2.ty;
          return this;
        }
        /**
         * Sets the matrix based on all the available properties
         * @param x - Position on the x axis
         * @param y - Position on the y axis
         * @param pivotX - Pivot on the x axis
         * @param pivotY - Pivot on the y axis
         * @param scaleX - Scale on the x axis
         * @param scaleY - Scale on the y axis
         * @param rotation - Rotation in radians
         * @param skewX - Skew on the x axis
         * @param skewY - Skew on the y axis
         * @returns This matrix. Good for chaining method calls.
         */
        setTransform(x2, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
          this.a = Math.cos(rotation + skewY) * scaleX;
          this.b = Math.sin(rotation + skewY) * scaleX;
          this.c = -Math.sin(rotation - skewX) * scaleY;
          this.d = Math.cos(rotation - skewX) * scaleY;
          this.tx = x2 - (pivotX * this.a + pivotY * this.c);
          this.ty = y2 - (pivotX * this.b + pivotY * this.d);
          return this;
        }
        /**
         * Prepends the given Matrix to this Matrix.
         * @param matrix - The matrix to prepend
         * @returns This matrix. Good for chaining method calls.
         */
        prepend(matrix) {
          const tx1 = this.tx;
          if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
            const a1 = this.a;
            const c1 = this.c;
            this.a = a1 * matrix.a + this.b * matrix.c;
            this.b = a1 * matrix.b + this.b * matrix.d;
            this.c = c1 * matrix.a + this.d * matrix.c;
            this.d = c1 * matrix.b + this.d * matrix.d;
          }
          this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
          this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
          return this;
        }
        /**
         * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
         * @param transform - The transform to apply the properties to.
         * @returns The transform with the newly applied properties
         */
        decompose(transform2) {
          const a2 = this.a;
          const b2 = this.b;
          const c2 = this.c;
          const d2 = this.d;
          const pivot = transform2.pivot;
          const skewX = -Math.atan2(-c2, d2);
          const skewY = Math.atan2(b2, a2);
          const delta = Math.abs(skewX + skewY);
          if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
            transform2.rotation = skewY;
            transform2.skew.x = transform2.skew.y = 0;
          } else {
            transform2.rotation = 0;
            transform2.skew.x = skewX;
            transform2.skew.y = skewY;
          }
          transform2.scale.x = Math.sqrt(a2 * a2 + b2 * b2);
          transform2.scale.y = Math.sqrt(c2 * c2 + d2 * d2);
          transform2.position.x = this.tx + (pivot.x * a2 + pivot.y * c2);
          transform2.position.y = this.ty + (pivot.x * b2 + pivot.y * d2);
          return transform2;
        }
        /**
         * Inverts this matrix
         * @returns This matrix. Good for chaining method calls.
         */
        invert() {
          const a1 = this.a;
          const b1 = this.b;
          const c1 = this.c;
          const d1 = this.d;
          const tx1 = this.tx;
          const n2 = a1 * d1 - b1 * c1;
          this.a = d1 / n2;
          this.b = -b1 / n2;
          this.c = -c1 / n2;
          this.d = a1 / n2;
          this.tx = (c1 * this.ty - d1 * tx1) / n2;
          this.ty = -(a1 * this.ty - b1 * tx1) / n2;
          return this;
        }
        /** Checks if this matrix is an identity matrix */
        isIdentity() {
          return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
        }
        /**
         * Resets this Matrix to an identity (default) matrix.
         * @returns This matrix. Good for chaining method calls.
         */
        identity() {
          this.a = 1;
          this.b = 0;
          this.c = 0;
          this.d = 1;
          this.tx = 0;
          this.ty = 0;
          return this;
        }
        /**
         * Creates a new Matrix object with the same values as this one.
         * @returns A copy of this matrix. Good for chaining method calls.
         */
        clone() {
          const matrix = new _Matrix();
          matrix.a = this.a;
          matrix.b = this.b;
          matrix.c = this.c;
          matrix.d = this.d;
          matrix.tx = this.tx;
          matrix.ty = this.ty;
          return matrix;
        }
        /**
         * Changes the values of the given matrix to be the same as the ones in this matrix
         * @param matrix - The matrix to copy to.
         * @returns The matrix given in parameter with its values updated.
         */
        copyTo(matrix) {
          matrix.a = this.a;
          matrix.b = this.b;
          matrix.c = this.c;
          matrix.d = this.d;
          matrix.tx = this.tx;
          matrix.ty = this.ty;
          return matrix;
        }
        /**
         * Changes the values of the matrix to be the same as the ones in given matrix
         * @param matrix - The matrix to copy from.
         * @returns this
         */
        copyFrom(matrix) {
          this.a = matrix.a;
          this.b = matrix.b;
          this.c = matrix.c;
          this.d = matrix.d;
          this.tx = matrix.tx;
          this.ty = matrix.ty;
          return this;
        }
        /**
         * check to see if two matrices are the same
         * @param matrix - The matrix to compare to.
         */
        equals(matrix) {
          return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;
        }
        toString() {
          return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
        }
        /**
         * A default (identity) matrix.
         *
         * This is a shared object, if you want to modify it consider creating a new `Matrix`
         * @readonly
         */
        static get IDENTITY() {
          return identityMatrix.identity();
        }
        /**
         * A static Matrix that can be used to avoid creating new objects.
         * Will always ensure the matrix is reset to identity when requested.
         * Use this object for fast but temporary calculations, as it may be mutated later on.
         * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.
         * @readonly
         */
        static get shared() {
          return tempMatrix.identity();
        }
      };
      tempMatrix = new Matrix();
      identityMatrix = new Matrix();
    }
  });

  // node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs
  var ObservablePoint;
  var init_ObservablePoint = __esm({
    "node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs"() {
      "use strict";
      ObservablePoint = class _ObservablePoint {
        /**
         * Creates a new `ObservablePoint`
         * @param observer - Observer to pass to listen for change events.
         * @param {number} [x=0] - position of the point on the x axis
         * @param {number} [y=0] - position of the point on the y axis
         */
        constructor(observer, x2, y2) {
          this._x = x2 || 0;
          this._y = y2 || 0;
          this._observer = observer;
        }
        /**
         * Creates a clone of this point.
         * @param observer - Optional observer to pass to the new observable point.
         * @returns a copy of this observable point
         */
        clone(observer) {
          return new _ObservablePoint(observer ?? this._observer, this._x, this._y);
        }
        /**
         * Sets the point to a new `x` and `y` position.
         * If `y` is omitted, both `x` and `y` will be set to `x`.
         * @param {number} [x=0] - position of the point on the x axis
         * @param {number} [y=x] - position of the point on the y axis
         * @returns The observable point instance itself
         */
        set(x2 = 0, y2 = x2) {
          if (this._x !== x2 || this._y !== y2) {
            this._x = x2;
            this._y = y2;
            this._observer._onUpdate(this);
          }
          return this;
        }
        /**
         * Copies x and y from the given point (`p`)
         * @param p - The point to copy from. Can be any of type that is or extends `PointData`
         * @returns The observable point instance itself
         */
        copyFrom(p2) {
          if (this._x !== p2.x || this._y !== p2.y) {
            this._x = p2.x;
            this._y = p2.y;
            this._observer._onUpdate(this);
          }
          return this;
        }
        /**
         * Copies this point's x and y into that of the given point (`p`)
         * @param p - The point to copy to. Can be any of type that is or extends `PointData`
         * @returns The point (`p`) with values updated
         */
        copyTo(p2) {
          p2.set(this._x, this._y);
          return p2;
        }
        /**
         * Accepts another point (`p`) and returns `true` if the given point is equal to this point
         * @param p - The point to check
         * @returns Returns `true` if both `x` and `y` are equal
         */
        equals(p2) {
          return p2.x === this._x && p2.y === this._y;
        }
        toString() {
          return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;
        }
        /** Position of the observable point on the x axis. */
        get x() {
          return this._x;
        }
        set x(value12) {
          if (this._x !== value12) {
            this._x = value12;
            this._observer._onUpdate(this);
          }
        }
        /** Position of the observable point on the y axis. */
        get y() {
          return this._y;
        }
        set y(value12) {
          if (this._y !== value12) {
            this._y = value12;
            this._observer._onUpdate(this);
          }
        }
      };
    }
  });

  // node_modules/pixi.js/lib/utils/data/uid.mjs
  function uid(name16 = "default") {
    if (uidCache[name16] === void 0) {
      uidCache[name16] = -1;
    }
    return ++uidCache[name16];
  }
  var uidCache;
  var init_uid = __esm({
    "node_modules/pixi.js/lib/utils/data/uid.mjs"() {
      "use strict";
      uidCache = {
        default: -1
      };
    }
  });

  // node_modules/pixi.js/lib/utils/logging/deprecation.mjs
  function deprecation(version, message2, ignoreDepth = 3) {
    if (warnings[message2]) {
      return;
    }
    let stack = new Error().stack;
    if (typeof stack === "undefined") {
      console.warn("PixiJS Deprecation Warning: ", `${message2}
Deprecated since v${version}`);
    } else {
      stack = stack.split("\n").splice(ignoreDepth).join("\n");
      if (console.groupCollapsed) {
        console.groupCollapsed(
          "%cPixiJS Deprecation Warning: %c%s",
          "color:#614108;background:#fffbe6",
          "font-weight:normal;color:#614108;background:#fffbe6",
          `${message2}
Deprecated since v${version}`
        );
        console.warn(stack);
        console.groupEnd();
      } else {
        console.warn("PixiJS Deprecation Warning: ", `${message2}
Deprecated since v${version}`);
        console.warn(stack);
      }
    }
    warnings[message2] = true;
  }
  var warnings, v8_0_0, v8_3_4;
  var init_deprecation = __esm({
    "node_modules/pixi.js/lib/utils/logging/deprecation.mjs"() {
      "use strict";
      warnings = {};
      v8_0_0 = "8.0.0";
      v8_3_4 = "8.3.4";
    }
  });

  // node_modules/pixi.js/lib/utils/pool/Pool.mjs
  var Pool;
  var init_Pool = __esm({
    "node_modules/pixi.js/lib/utils/pool/Pool.mjs"() {
      "use strict";
      Pool = class {
        /**
         * Constructs a new Pool.
         * @param ClassType - The constructor of the items in the pool.
         * @param {number} [initialSize] - The initial size of the pool.
         */
        constructor(ClassType, initialSize) {
          this._pool = [];
          this._count = 0;
          this._index = 0;
          this._classType = ClassType;
          if (initialSize) {
            this.prepopulate(initialSize);
          }
        }
        /**
         * Prepopulates the pool with a given number of items.
         * @param total - The number of items to add to the pool.
         */
        prepopulate(total) {
          for (let i2 = 0; i2 < total; i2++) {
            this._pool[this._index++] = new this._classType();
          }
          this._count += total;
        }
        /**
         * Gets an item from the pool. Calls the item's `init` method if it exists.
         * If there are no items left in the pool, a new one will be created.
         * @param {unknown} [data] - Optional data to pass to the item's constructor.
         * @returns {T} The item from the pool.
         */
        get(data) {
          let item;
          if (this._index > 0) {
            item = this._pool[--this._index];
          } else {
            item = new this._classType();
          }
          item.init?.(data);
          return item;
        }
        /**
         * Returns an item to the pool. Calls the item's `reset` method if it exists.
         * @param {T} item - The item to return to the pool.
         */
        return(item) {
          item.reset?.();
          this._pool[this._index++] = item;
        }
        /**
         * Gets the number of items in the pool.
         * @readonly
         * @member {number}
         */
        get totalSize() {
          return this._count;
        }
        /**
         * Gets the number of items in the pool that are free to use without needing to create more.
         * @readonly
         * @member {number}
         */
        get totalFree() {
          return this._index;
        }
        /**
         * Gets the number of items in the pool that are currently in use.
         * @readonly
         * @member {number}
         */
        get totalUsed() {
          return this._count - this._index;
        }
        /** clears the pool - mainly used for debugging! */
        clear() {
          this._pool.length = 0;
          this._index = 0;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs
  var PoolGroupClass, BigPool;
  var init_PoolGroup = __esm({
    "node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs"() {
      init_Pool();
      PoolGroupClass = class {
        constructor() {
          this._poolsByClass = /* @__PURE__ */ new Map();
        }
        /**
         * Prepopulates a specific pool with a given number of items.
         * @template T The type of items in the pool. Must extend PoolItem.
         * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
         * @param {number} total - The number of items to add to the pool.
         */
        prepopulate(Class, total) {
          const classPool = this.getPool(Class);
          classPool.prepopulate(total);
        }
        /**
         * Gets an item from a specific pool.
         * @template T The type of items in the pool. Must extend PoolItem.
         * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
         * @param {unknown} [data] - Optional data to pass to the item's constructor.
         * @returns {T} The item from the pool.
         */
        get(Class, data) {
          const pool = this.getPool(Class);
          return pool.get(data);
        }
        /**
         * Returns an item to its respective pool.
         * @param {PoolItem} item - The item to return to the pool.
         */
        return(item) {
          const pool = this.getPool(item.constructor);
          pool.return(item);
        }
        /**
         * Gets a specific pool based on the class type.
         * @template T The type of items in the pool. Must extend PoolItem.
         * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.
         * @returns {Pool<T>} The pool of the given class type.
         */
        getPool(ClassType) {
          if (!this._poolsByClass.has(ClassType)) {
            this._poolsByClass.set(ClassType, new Pool(ClassType));
          }
          return this._poolsByClass.get(ClassType);
        }
        /** gets the usage stats of each pool in the system */
        stats() {
          const stats = {};
          this._poolsByClass.forEach((pool) => {
            const name16 = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;
            stats[name16] = {
              free: pool.totalFree,
              used: pool.totalUsed,
              size: pool.totalSize
            };
          });
          return stats;
        }
      };
      BigPool = new PoolGroupClass();
    }
  });

  // node_modules/pixi.js/lib/utils/data/removeItems.mjs
  function removeItems(arr, startIdx, removeCount) {
    const length9 = arr.length;
    let i2;
    if (startIdx >= length9 || removeCount === 0) {
      return;
    }
    removeCount = startIdx + removeCount > length9 ? length9 - startIdx : removeCount;
    const len = length9 - removeCount;
    for (i2 = startIdx; i2 < len; ++i2) {
      arr[i2] = arr[i2 + removeCount];
    }
    arr.length = len;
  }
  var init_removeItems = __esm({
    "node_modules/pixi.js/lib/utils/data/removeItems.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs
  var childrenHelperMixin;
  var init_childrenHelperMixin = __esm({
    "node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs"() {
      init_removeItems();
      init_deprecation();
      childrenHelperMixin = {
        allowChildren: true,
        /**
         * Removes all children from this container that are within the begin and end indexes.
         * @param beginIndex - The beginning position.
         * @param endIndex - The ending position. Default value is size of the container.
         * @returns - List of removed children
         * @memberof scene.Container#
         */
        removeChildren(beginIndex = 0, endIndex) {
          const end = endIndex ?? this.children.length;
          const range3 = end - beginIndex;
          const removed = [];
          if (range3 > 0 && range3 <= end) {
            for (let i2 = end - 1; i2 >= beginIndex; i2--) {
              const child = this.children[i2];
              if (!child)
                continue;
              removed.push(child);
              child.parent = null;
            }
            removeItems(this.children, beginIndex, end);
            const renderGroup = this.renderGroup || this.parentRenderGroup;
            if (renderGroup) {
              renderGroup.removeChildren(removed);
            }
            for (let i2 = 0; i2 < removed.length; ++i2) {
              this.emit("childRemoved", removed[i2], this, i2);
              removed[i2].emit("removed", this);
            }
            return removed;
          } else if (range3 === 0 && this.children.length === 0) {
            return removed;
          }
          throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
        },
        /**
         * Removes a child from the specified index position.
         * @param index - The index to get the child from
         * @returns The child that was removed.
         * @memberof scene.Container#
         */
        removeChildAt(index6) {
          const child = this.getChildAt(index6);
          return this.removeChild(child);
        },
        /**
         * Returns the child at the specified index
         * @param index - The index to get the child at
         * @returns - The child at the given index, if any.
         * @memberof scene.Container#
         */
        getChildAt(index6) {
          if (index6 < 0 || index6 >= this.children.length) {
            throw new Error(`getChildAt: Index (${index6}) does not exist.`);
          }
          return this.children[index6];
        },
        /**
         * Changes the position of an existing child in the container container
         * @param child - The child Container instance for which you want to change the index number
         * @param index - The resulting index number for the child container
         * @memberof scene.Container#
         */
        setChildIndex(child, index6) {
          if (index6 < 0 || index6 >= this.children.length) {
            throw new Error(`The index ${index6} supplied is out of bounds ${this.children.length}`);
          }
          this.getChildIndex(child);
          this.addChildAt(child, index6);
        },
        /**
         * Returns the index position of a child Container instance
         * @param child - The Container instance to identify
         * @returns - The index position of the child container to identify
         * @memberof scene.Container#
         */
        getChildIndex(child) {
          const index6 = this.children.indexOf(child);
          if (index6 === -1) {
            throw new Error("The supplied Container must be a child of the caller");
          }
          return index6;
        },
        /**
         * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.
         * If the child is already in this container, it will be moved to the specified index.
         * @param {Container} child - The child to add.
         * @param {number} index - The absolute index where the child will be positioned at the end of the operation.
         * @returns {Container} The child that was added.
         * @memberof scene.Container#
         */
        addChildAt(child, index6) {
          if (!this.allowChildren) {
            deprecation(v8_0_0, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
          }
          const { children: children2 } = this;
          if (index6 < 0 || index6 > children2.length) {
            throw new Error(`${child}addChildAt: The index ${index6} supplied is out of bounds ${children2.length}`);
          }
          if (child.parent) {
            const currentIndex = child.parent.children.indexOf(child);
            if (child.parent === this && currentIndex === index6) {
              return child;
            }
            if (currentIndex !== -1) {
              child.parent.children.splice(currentIndex, 1);
            }
          }
          if (index6 === children2.length) {
            children2.push(child);
          } else {
            children2.splice(index6, 0, child);
          }
          child.parent = this;
          child.didChange = true;
          child._updateFlags = 15;
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.addChild(child);
          }
          if (this.sortableChildren)
            this.sortDirty = true;
          this.emit("childAdded", child, this, index6);
          child.emit("added", this);
          return child;
        },
        /**
         * Swaps the position of 2 Containers within this container.
         * @param child - First container to swap
         * @param child2 - Second container to swap
         * @memberof scene.Container#
         */
        swapChildren(child, child2) {
          if (child === child2) {
            return;
          }
          const index1 = this.getChildIndex(child);
          const index22 = this.getChildIndex(child2);
          this.children[index1] = child2;
          this.children[index22] = child;
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.structureDidChange = true;
          }
          this._didContainerChangeTick++;
        },
        /**
         * Remove the Container from its parent Container. If the Container has no parent, do nothing.
         * @memberof scene.Container#
         */
        removeFromParent() {
          this.parent?.removeChild(this);
        },
        /**
         * Reparent the child to this container, keeping the same worldTransform.
         * @param child - The child to reparent
         * @returns The first child that was reparented.
         * @memberof scene.Container#
         */
        reparentChild(...child) {
          if (child.length === 1) {
            return this.reparentChildAt(child[0], this.children.length);
          }
          child.forEach((c2) => this.reparentChildAt(c2, this.children.length));
          return child[0];
        },
        /**
         * Reparent the child to this container at the specified index, keeping the same worldTransform.
         * @param child - The child to reparent
         * @param index - The index to reparent the child to
         * @memberof scene.Container#
         */
        reparentChildAt(child, index6) {
          if (child.parent === this) {
            this.setChildIndex(child, index6);
            return child;
          }
          const childMat = child.worldTransform.clone();
          child.removeFromParent();
          this.addChildAt(child, index6);
          const newMatrix = this.worldTransform.clone();
          newMatrix.invert();
          childMat.prepend(newMatrix);
          child.setFromMatrix(childMat);
          return child;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/filters/FilterEffect.mjs
  var FilterEffect;
  var init_FilterEffect = __esm({
    "node_modules/pixi.js/lib/filters/FilterEffect.mjs"() {
      "use strict";
      FilterEffect = class {
        constructor() {
          this.pipe = "filter";
          this.priority = 1;
        }
        destroy() {
          for (let i2 = 0; i2 < this.filters.length; i2++) {
            this.filters[i2].destroy();
          }
          this.filters = null;
          this.filterArea = null;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs
  var MaskEffectManagerClass, MaskEffectManager;
  var init_MaskEffectManager = __esm({
    "node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs"() {
      init_Extensions();
      init_PoolGroup();
      MaskEffectManagerClass = class {
        constructor() {
          this._effectClasses = [];
          this._tests = [];
          this._initialized = false;
        }
        init() {
          if (this._initialized)
            return;
          this._initialized = true;
          this._effectClasses.forEach((test2) => {
            this.add({
              test: test2.test,
              maskClass: test2
            });
          });
        }
        add(test2) {
          this._tests.push(test2);
        }
        getMaskEffect(item) {
          if (!this._initialized)
            this.init();
          for (let i2 = 0; i2 < this._tests.length; i2++) {
            const test2 = this._tests[i2];
            if (test2.test(item)) {
              return BigPool.get(test2.maskClass, item);
            }
          }
          return item;
        }
        returnMaskEffect(effect) {
          BigPool.return(effect);
        }
      };
      MaskEffectManager = new MaskEffectManagerClass();
      extensions.handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);
    }
  });

  // node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs
  var effectsMixin;
  var init_effectsMixin = __esm({
    "node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs"() {
      init_FilterEffect();
      init_MaskEffectManager();
      effectsMixin = {
        _maskEffect: null,
        _maskOptions: {
          inverse: false
        },
        _filterEffect: null,
        /**
         * @todo Needs docs.
         * @memberof scene.Container#
         * @type {Array<Effect>}
         */
        effects: [],
        /**
         * @todo Needs docs.
         * @param effect - The effect to add.
         * @memberof scene.Container#
         * @ignore
         */
        addEffect(effect) {
          const index6 = this.effects.indexOf(effect);
          if (index6 !== -1)
            return;
          this.effects.push(effect);
          this.effects.sort((a2, b2) => a2.priority - b2.priority);
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.structureDidChange = true;
          }
          this._updateIsSimple();
        },
        /**
         * @todo Needs docs.
         * @param effect - The effect to remove.
         * @memberof scene.Container#
         * @ignore
         */
        removeEffect(effect) {
          const index6 = this.effects.indexOf(effect);
          if (index6 === -1)
            return;
          this.effects.splice(index6, 1);
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
          this._updateIsSimple();
        },
        set mask(value12) {
          const effect = this._maskEffect;
          if (effect?.mask === value12)
            return;
          if (effect) {
            this.removeEffect(effect);
            MaskEffectManager.returnMaskEffect(effect);
            this._maskEffect = null;
          }
          if (value12 === null || value12 === void 0)
            return;
          this._maskEffect = MaskEffectManager.getMaskEffect(value12);
          this.addEffect(this._maskEffect);
        },
        /**
         * Used to set mask and control mask options.
         * @param options
         * @example
         * import { Graphics, Sprite } from 'pixi.js';
         *
         * const graphics = new Graphics();
         * graphics.beginFill(0xFF3300);
         * graphics.drawRect(50, 250, 100, 100);
         * graphics.endFill();
         *
         * const sprite = new Sprite(texture);
         * sprite.setMask({
         *     mask: graphics,
         *     inverse: true,
         * });
         * @memberof scene.Container#
         */
        setMask(options2) {
          this._maskOptions = {
            ...this._maskOptions,
            ...options2
          };
          if (options2.mask) {
            this.mask = options2.mask;
          }
        },
        /**
         * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
         * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
         * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it
         * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.
         * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.
         * To remove a mask, set this property to `null`.
         *
         * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
         * @example
         * import { Graphics, Sprite } from 'pixi.js';
         *
         * const graphics = new Graphics();
         * graphics.beginFill(0xFF3300);
         * graphics.drawRect(50, 250, 100, 100);
         * graphics.endFill();
         *
         * const sprite = new Sprite(texture);
         * sprite.mask = graphics;
         * @memberof scene.Container#
         */
        get mask() {
          return this._maskEffect?.mask;
        },
        set filters(value12) {
          if (!Array.isArray(value12) && value12)
            value12 = [value12];
          const effect = this._filterEffect || (this._filterEffect = new FilterEffect());
          value12 = value12;
          const hasFilters = value12?.length > 0;
          const hadFilters = effect.filters?.length > 0;
          const didChange = hasFilters !== hadFilters;
          value12 = Array.isArray(value12) ? value12.slice(0) : value12;
          effect.filters = Object.freeze(value12);
          if (didChange) {
            if (hasFilters) {
              this.addEffect(effect);
            } else {
              this.removeEffect(effect);
              effect.filters = value12 ?? null;
            }
          }
        },
        /**
         * Sets the filters for the displayObject.
         * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
         * To remove filters simply set this property to `'null'`.
         * @memberof scene.Container#
         */
        get filters() {
          return this._filterEffect?.filters;
        },
        set filterArea(value12) {
          this._filterEffect || (this._filterEffect = new FilterEffect());
          this._filterEffect.filterArea = value12;
        },
        /**
         * The area the filter is applied to. This is used as more of an optimization
         * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.
         *
         * Also works as an interaction mask.
         * @memberof scene.Container#
         */
        get filterArea() {
          return this._filterEffect?.filterArea;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs
  var findMixin;
  var init_findMixin = __esm({
    "node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs"() {
      init_deprecation();
      findMixin = {
        /**
         * The instance label of the object.
         * @memberof scene.Container#
         * @member {string} label
         */
        label: null,
        /**
         * The instance name of the object.
         * @deprecated since 8.0.0
         * @see scene.Container#label
         * @member {string} name
         * @memberof scene.Container#
         */
        get name() {
          deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
          return this.label;
        },
        set name(value12) {
          deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
          this.label = value12;
        },
        /**
         * @method getChildByName
         * @deprecated since 8.0.0
         * @param {string} name - Instance name.
         * @param {boolean}[deep=false] - Whether to search recursively
         * @returns {Container} The child with the specified name.
         * @see scene.Container#getChildByLabel
         * @memberof scene.Container#
         */
        getChildByName(name16, deep = false) {
          return this.getChildByLabel(name16, deep);
        },
        /**
         * Returns the first child in the container with the specified label.
         *
         * Recursive searches are done in a pre-order traversal.
         * @memberof scene.Container#
         * @param {string|RegExp} label - Instance label.
         * @param {boolean}[deep=false] - Whether to search recursively
         * @returns {Container} The child with the specified label.
         */
        getChildByLabel(label4, deep = false) {
          const children2 = this.children;
          for (let i2 = 0; i2 < children2.length; i2++) {
            const child = children2[i2];
            if (child.label === label4 || label4 instanceof RegExp && label4.test(child.label))
              return child;
          }
          if (deep) {
            for (let i2 = 0; i2 < children2.length; i2++) {
              const child = children2[i2];
              const found = child.getChildByLabel(label4, true);
              if (found) {
                return found;
              }
            }
          }
          return null;
        },
        /**
         * Returns all children in the container with the specified label.
         * @memberof scene.Container#
         * @param {string|RegExp} label - Instance label.
         * @param {boolean}[deep=false] - Whether to search recursively
         * @param {Container[]} [out=[]] - The array to store matching children in.
         * @returns {Container[]} An array of children with the specified label.
         */
        getChildrenByLabel(label4, deep = false, out2 = []) {
          const children2 = this.children;
          for (let i2 = 0; i2 < children2.length; i2++) {
            const child = children2[i2];
            if (child.label === label4 || label4 instanceof RegExp && label4.test(child.label)) {
              out2.push(child);
            }
          }
          if (deep) {
            for (let i2 = 0; i2 < children2.length; i2++) {
              children2[i2].getChildrenByLabel(label4, true, out2);
            }
          }
          return out2;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs
  var tempPoints, Rectangle;
  var init_Rectangle = __esm({
    "node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs"() {
      init_Point();
      tempPoints = [new Point(), new Point(), new Point(), new Point()];
      Rectangle = class _Rectangle {
        /**
         * @param x - The X coordinate of the upper-left corner of the rectangle
         * @param y - The Y coordinate of the upper-left corner of the rectangle
         * @param width - The overall width of the rectangle
         * @param height - The overall height of the rectangle
         */
        constructor(x2 = 0, y2 = 0, width8 = 0, height8 = 0) {
          this.type = "rectangle";
          this.x = Number(x2);
          this.y = Number(y2);
          this.width = Number(width8);
          this.height = Number(height8);
        }
        /** Returns the left edge of the rectangle. */
        get left() {
          return this.x;
        }
        /** Returns the right edge of the rectangle. */
        get right() {
          return this.x + this.width;
        }
        /** Returns the top edge of the rectangle. */
        get top() {
          return this.y;
        }
        /** Returns the bottom edge of the rectangle. */
        get bottom() {
          return this.y + this.height;
        }
        /** Determines whether the Rectangle is empty. */
        isEmpty() {
          return this.left === this.right || this.top === this.bottom;
        }
        /** A constant empty rectangle. This is a new object every time the property is accessed */
        static get EMPTY() {
          return new _Rectangle(0, 0, 0, 0);
        }
        /**
         * Creates a clone of this Rectangle
         * @returns a copy of the rectangle
         */
        clone() {
          return new _Rectangle(this.x, this.y, this.width, this.height);
        }
        /**
         * Converts a Bounds object to a Rectangle object.
         * @param bounds - The bounds to copy and convert to a rectangle.
         * @returns Returns itself.
         */
        copyFromBounds(bounds) {
          this.x = bounds.minX;
          this.y = bounds.minY;
          this.width = bounds.maxX - bounds.minX;
          this.height = bounds.maxY - bounds.minY;
          return this;
        }
        /**
         * Copies another rectangle to this one.
         * @param rectangle - The rectangle to copy from.
         * @returns Returns itself.
         */
        copyFrom(rectangle) {
          this.x = rectangle.x;
          this.y = rectangle.y;
          this.width = rectangle.width;
          this.height = rectangle.height;
          return this;
        }
        /**
         * Copies this rectangle to another one.
         * @param rectangle - The rectangle to copy to.
         * @returns Returns given parameter.
         */
        copyTo(rectangle) {
          rectangle.copyFrom(this);
          return rectangle;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this Rectangle
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @returns Whether the x/y coordinates are within this Rectangle
         */
        contains(x2, y2) {
          if (this.width <= 0 || this.height <= 0) {
            return false;
          }
          if (x2 >= this.x && x2 < this.x + this.width) {
            if (y2 >= this.y && y2 < this.y + this.height) {
              return true;
            }
          }
          return false;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @param strokeWidth - The width of the line to check
         * @returns Whether the x/y coordinates are within this rectangle
         */
        strokeContains(x2, y2, strokeWidth) {
          const { width: width8, height: height8 } = this;
          if (width8 <= 0 || height8 <= 0)
            return false;
          const _x = this.x;
          const _y = this.y;
          const outerLeft = _x - strokeWidth / 2;
          const outerRight = _x + width8 + strokeWidth / 2;
          const outerTop = _y - strokeWidth / 2;
          const outerBottom = _y + height8 + strokeWidth / 2;
          const innerLeft = _x + strokeWidth / 2;
          const innerRight = _x + width8 - strokeWidth / 2;
          const innerTop = _y + strokeWidth / 2;
          const innerBottom = _y + height8 - strokeWidth / 2;
          return x2 >= outerLeft && x2 <= outerRight && y2 >= outerTop && y2 <= outerBottom && !(x2 > innerLeft && x2 < innerRight && y2 > innerTop && y2 < innerBottom);
        }
        /**
         * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
         * Returns true only if the area of the intersection is >0, this means that Rectangles
         * sharing a side are not overlapping. Another side effect is that an arealess rectangle
         * (width or height equal to zero) can't intersect any other rectangle.
         * @param {Rectangle} other - The Rectangle to intersect with `this`.
         * @param {Matrix} transform - The transformation matrix of `other`.
         * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
         */
        intersects(other, transform2) {
          if (!transform2) {
            const x02 = this.x < other.x ? other.x : this.x;
            const x12 = this.right > other.right ? other.right : this.right;
            if (x12 <= x02) {
              return false;
            }
            const y02 = this.y < other.y ? other.y : this.y;
            const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
            return y12 > y02;
          }
          const x0 = this.left;
          const x1 = this.right;
          const y0 = this.top;
          const y1 = this.bottom;
          if (x1 <= x0 || y1 <= y0) {
            return false;
          }
          const lt2 = tempPoints[0].set(other.left, other.top);
          const lb = tempPoints[1].set(other.left, other.bottom);
          const rt = tempPoints[2].set(other.right, other.top);
          const rb = tempPoints[3].set(other.right, other.bottom);
          if (rt.x <= lt2.x || lb.y <= lt2.y) {
            return false;
          }
          const s2 = Math.sign(transform2.a * transform2.d - transform2.b * transform2.c);
          if (s2 === 0) {
            return false;
          }
          transform2.apply(lt2, lt2);
          transform2.apply(lb, lb);
          transform2.apply(rt, rt);
          transform2.apply(rb, rb);
          if (Math.max(lt2.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt2.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt2.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt2.y, lb.y, rt.y, rb.y) >= y1) {
            return false;
          }
          const nx = s2 * (lb.y - lt2.y);
          const ny = s2 * (lt2.x - lb.x);
          const n00 = nx * x0 + ny * y0;
          const n10 = nx * x1 + ny * y0;
          const n01 = nx * x0 + ny * y1;
          const n11 = nx * x1 + ny * y1;
          if (Math.max(n00, n10, n01, n11) <= nx * lt2.x + ny * lt2.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
            return false;
          }
          const mx = s2 * (lt2.y - rt.y);
          const my = s2 * (rt.x - lt2.x);
          const m00 = mx * x0 + my * y0;
          const m10 = mx * x1 + my * y0;
          const m01 = mx * x0 + my * y1;
          const m11 = mx * x1 + my * y1;
          if (Math.max(m00, m10, m01, m11) <= mx * lt2.x + my * lt2.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
            return false;
          }
          return true;
        }
        /**
         * Pads the rectangle making it grow in all directions.
         * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
         * @param paddingX - The horizontal padding amount.
         * @param paddingY - The vertical padding amount.
         * @returns Returns itself.
         */
        pad(paddingX = 0, paddingY = paddingX) {
          this.x -= paddingX;
          this.y -= paddingY;
          this.width += paddingX * 2;
          this.height += paddingY * 2;
          return this;
        }
        /**
         * Fits this rectangle around the passed one.
         * @param rectangle - The rectangle to fit.
         * @returns Returns itself.
         */
        fit(rectangle) {
          const x1 = Math.max(this.x, rectangle.x);
          const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
          const y1 = Math.max(this.y, rectangle.y);
          const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
          this.x = x1;
          this.width = Math.max(x2 - x1, 0);
          this.y = y1;
          this.height = Math.max(y2 - y1, 0);
          return this;
        }
        /**
         * Enlarges rectangle that way its corners lie on grid
         * @param resolution - resolution
         * @param eps - precision
         * @returns Returns itself.
         */
        ceil(resolution = 1, eps = 1e-3) {
          const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
          const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
          this.x = Math.floor((this.x + eps) * resolution) / resolution;
          this.y = Math.floor((this.y + eps) * resolution) / resolution;
          this.width = x2 - this.x;
          this.height = y2 - this.y;
          return this;
        }
        /**
         * Enlarges this rectangle to include the passed rectangle.
         * @param rectangle - The rectangle to include.
         * @returns Returns itself.
         */
        enlarge(rectangle) {
          const x1 = Math.min(this.x, rectangle.x);
          const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
          const y1 = Math.min(this.y, rectangle.y);
          const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
          this.x = x1;
          this.width = x2 - x1;
          this.y = y1;
          this.height = y2 - y1;
          return this;
        }
        /**
         * Returns the framing rectangle of the rectangle as a Rectangle object
         * @param out - optional rectangle to store the result
         * @returns The framing rectangle
         */
        getBounds(out2) {
          out2 = out2 || new _Rectangle();
          out2.copyFrom(this);
          return out2;
        }
        toString() {
          return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs
  var defaultMatrix, Bounds;
  var init_Bounds = __esm({
    "node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs"() {
      init_Matrix();
      init_Rectangle();
      defaultMatrix = new Matrix();
      Bounds = class _Bounds {
        constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
          this.minX = Infinity;
          this.minY = Infinity;
          this.maxX = -Infinity;
          this.maxY = -Infinity;
          this.matrix = defaultMatrix;
          this.minX = minX;
          this.minY = minY;
          this.maxX = maxX;
          this.maxY = maxY;
        }
        /**
         * Checks if bounds are empty.
         * @returns - True if empty.
         */
        isEmpty() {
          return this.minX > this.maxX || this.minY > this.maxY;
        }
        /** The bounding rectangle of the bounds. */
        get rectangle() {
          if (!this._rectangle) {
            this._rectangle = new Rectangle();
          }
          const rectangle = this._rectangle;
          if (this.minX > this.maxX || this.minY > this.maxY) {
            rectangle.x = 0;
            rectangle.y = 0;
            rectangle.width = 0;
            rectangle.height = 0;
          } else {
            rectangle.copyFromBounds(this);
          }
          return rectangle;
        }
        /** Clears the bounds and resets. */
        clear() {
          this.minX = Infinity;
          this.minY = Infinity;
          this.maxX = -Infinity;
          this.maxY = -Infinity;
          this.matrix = defaultMatrix;
          return this;
        }
        /**
         * Sets the bounds.
         * @param x0 - left X of frame
         * @param y0 - top Y of frame
         * @param x1 - right X of frame
         * @param y1 - bottom Y of frame
         */
        set(x0, y0, x1, y1) {
          this.minX = x0;
          this.minY = y0;
          this.maxX = x1;
          this.maxY = y1;
        }
        /**
         * Adds sprite frame
         * @param x0 - left X of frame
         * @param y0 - top Y of frame
         * @param x1 - right X of frame
         * @param y1 - bottom Y of frame
         * @param matrix
         */
        addFrame(x0, y0, x1, y1, matrix) {
          matrix || (matrix = this.matrix);
          const a2 = matrix.a;
          const b2 = matrix.b;
          const c2 = matrix.c;
          const d2 = matrix.d;
          const tx = matrix.tx;
          const ty = matrix.ty;
          let minX = this.minX;
          let minY = this.minY;
          let maxX = this.maxX;
          let maxY = this.maxY;
          let x2 = a2 * x0 + c2 * y0 + tx;
          let y2 = b2 * x0 + d2 * y0 + ty;
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY)
            maxY = y2;
          x2 = a2 * x1 + c2 * y0 + tx;
          y2 = b2 * x1 + d2 * y0 + ty;
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY)
            maxY = y2;
          x2 = a2 * x0 + c2 * y1 + tx;
          y2 = b2 * x0 + d2 * y1 + ty;
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY)
            maxY = y2;
          x2 = a2 * x1 + c2 * y1 + tx;
          y2 = b2 * x1 + d2 * y1 + ty;
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY)
            maxY = y2;
          this.minX = minX;
          this.minY = minY;
          this.maxX = maxX;
          this.maxY = maxY;
        }
        /**
         * Adds a rectangle to the bounds.
         * @param rect - The rectangle to be added.
         * @param matrix - The matrix to apply to the bounds.
         */
        addRect(rect, matrix) {
          this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);
        }
        /**
         * Adds other {@link Bounds}.
         * @param bounds - The Bounds to be added
         * @param matrix
         */
        addBounds(bounds, matrix) {
          this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);
        }
        /**
         * Adds other Bounds, masked with Bounds.
         * @param mask - The Bounds to be added.
         */
        addBoundsMask(mask) {
          this.minX = this.minX > mask.minX ? this.minX : mask.minX;
          this.minY = this.minY > mask.minY ? this.minY : mask.minY;
          this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;
          this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;
        }
        /**
         * Adds other Bounds, multiplied with matrix.
         * @param matrix - The matrix to apply to the bounds.
         */
        applyMatrix(matrix) {
          const minX = this.minX;
          const minY = this.minY;
          const maxX = this.maxX;
          const maxY = this.maxY;
          const { a: a2, b: b2, c: c2, d: d2, tx, ty } = matrix;
          let x2 = a2 * minX + c2 * minY + tx;
          let y2 = b2 * minX + d2 * minY + ty;
          this.minX = x2;
          this.minY = y2;
          this.maxX = x2;
          this.maxY = y2;
          x2 = a2 * maxX + c2 * minY + tx;
          y2 = b2 * maxX + d2 * minY + ty;
          this.minX = x2 < this.minX ? x2 : this.minX;
          this.minY = y2 < this.minY ? y2 : this.minY;
          this.maxX = x2 > this.maxX ? x2 : this.maxX;
          this.maxY = y2 > this.maxY ? y2 : this.maxY;
          x2 = a2 * minX + c2 * maxY + tx;
          y2 = b2 * minX + d2 * maxY + ty;
          this.minX = x2 < this.minX ? x2 : this.minX;
          this.minY = y2 < this.minY ? y2 : this.minY;
          this.maxX = x2 > this.maxX ? x2 : this.maxX;
          this.maxY = y2 > this.maxY ? y2 : this.maxY;
          x2 = a2 * maxX + c2 * maxY + tx;
          y2 = b2 * maxX + d2 * maxY + ty;
          this.minX = x2 < this.minX ? x2 : this.minX;
          this.minY = y2 < this.minY ? y2 : this.minY;
          this.maxX = x2 > this.maxX ? x2 : this.maxX;
          this.maxY = y2 > this.maxY ? y2 : this.maxY;
        }
        /**
         * Resizes the bounds object to include the given rectangle.
         * @param rect - The rectangle to be included.
         */
        fit(rect) {
          if (this.minX < rect.left)
            this.minX = rect.left;
          if (this.maxX > rect.right)
            this.maxX = rect.right;
          if (this.minY < rect.top)
            this.minY = rect.top;
          if (this.maxY > rect.bottom)
            this.maxY = rect.bottom;
          return this;
        }
        /**
         * Resizes the bounds object to include the given bounds.
         * @param left - The left value of the bounds.
         * @param right - The right value of the bounds.
         * @param top - The top value of the bounds.
         * @param bottom - The bottom value of the bounds.
         */
        fitBounds(left, right, top4, bottom3) {
          if (this.minX < left)
            this.minX = left;
          if (this.maxX > right)
            this.maxX = right;
          if (this.minY < top4)
            this.minY = top4;
          if (this.maxY > bottom3)
            this.maxY = bottom3;
          return this;
        }
        /**
         * Pads bounds object, making it grow in all directions.
         * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
         * @param paddingX - The horizontal padding amount.
         * @param paddingY - The vertical padding amount.
         */
        pad(paddingX, paddingY = paddingX) {
          this.minX -= paddingX;
          this.maxX += paddingX;
          this.minY -= paddingY;
          this.maxY += paddingY;
          return this;
        }
        /** Ceils the bounds. */
        ceil() {
          this.minX = Math.floor(this.minX);
          this.minY = Math.floor(this.minY);
          this.maxX = Math.ceil(this.maxX);
          this.maxY = Math.ceil(this.maxY);
          return this;
        }
        /** Clones the bounds. */
        clone() {
          return new _Bounds(this.minX, this.minY, this.maxX, this.maxY);
        }
        /**
         * Scales the bounds by the given values
         * @param x - The X value to scale by.
         * @param y - The Y value to scale by.
         */
        scale(x2, y2 = x2) {
          this.minX *= x2;
          this.minY *= y2;
          this.maxX *= x2;
          this.maxY *= y2;
          return this;
        }
        /** the x value of the bounds. */
        get x() {
          return this.minX;
        }
        set x(value12) {
          const width8 = this.maxX - this.minX;
          this.minX = value12;
          this.maxX = value12 + width8;
        }
        /** the y value of the bounds. */
        get y() {
          return this.minY;
        }
        set y(value12) {
          const height8 = this.maxY - this.minY;
          this.minY = value12;
          this.maxY = value12 + height8;
        }
        /** the width value of the bounds. */
        get width() {
          return this.maxX - this.minX;
        }
        set width(value12) {
          this.maxX = this.minX + value12;
        }
        /** the height value of the bounds. */
        get height() {
          return this.maxY - this.minY;
        }
        set height(value12) {
          this.maxY = this.minY + value12;
        }
        /** the left value of the bounds. */
        get left() {
          return this.minX;
        }
        /** the right value of the bounds. */
        get right() {
          return this.maxX;
        }
        /** the top value of the bounds. */
        get top() {
          return this.minY;
        }
        /** the bottom value of the bounds. */
        get bottom() {
          return this.maxY;
        }
        /** Is the bounds positive. */
        get isPositive() {
          return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
        }
        get isValid() {
          return this.minX + this.minY !== Infinity;
        }
        /**
         * Adds screen vertices from array
         * @param vertexData - calculated vertices
         * @param beginOffset - begin offset
         * @param endOffset - end offset, excluded
         * @param matrix
         */
        addVertexData(vertexData, beginOffset, endOffset, matrix) {
          let minX = this.minX;
          let minY = this.minY;
          let maxX = this.maxX;
          let maxY = this.maxY;
          matrix || (matrix = this.matrix);
          const a2 = matrix.a;
          const b2 = matrix.b;
          const c2 = matrix.c;
          const d2 = matrix.d;
          const tx = matrix.tx;
          const ty = matrix.ty;
          for (let i2 = beginOffset; i2 < endOffset; i2 += 2) {
            const localX = vertexData[i2];
            const localY = vertexData[i2 + 1];
            const x2 = a2 * localX + c2 * localY + tx;
            const y2 = b2 * localX + d2 * localY + ty;
            minX = x2 < minX ? x2 : minX;
            minY = y2 < minY ? y2 : minY;
            maxX = x2 > maxX ? x2 : maxX;
            maxY = y2 > maxY ? y2 : maxY;
          }
          this.minX = minX;
          this.minY = minY;
          this.maxX = maxX;
          this.maxY = maxY;
        }
        /**
         * Checks if the point is contained within the bounds.
         * @param x - x coordinate
         * @param y - y coordinate
         */
        containsPoint(x2, y2) {
          if (this.minX <= x2 && this.minY <= y2 && this.maxX >= x2 && this.maxY >= y2) {
            return true;
          }
          return false;
        }
        toString() {
          return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs
  var matrixPool, boundsPool;
  var init_matrixAndBoundsPool = __esm({
    "node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs"() {
      init_Matrix();
      init_Pool();
      init_Bounds();
      matrixPool = new Pool(Matrix);
      boundsPool = new Pool(Bounds);
    }
  });

  // node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs
  function getGlobalBounds(target5, skipUpdateTransform, bounds) {
    bounds.clear();
    let parentTransform;
    let pooledMatrix;
    if (target5.parent) {
      if (!skipUpdateTransform) {
        pooledMatrix = matrixPool.get().identity();
        parentTransform = updateTransformBackwards(target5, pooledMatrix);
      } else {
        parentTransform = target5.parent.worldTransform;
      }
    } else {
      parentTransform = Matrix.IDENTITY;
    }
    _getGlobalBounds(target5, bounds, parentTransform, skipUpdateTransform);
    if (pooledMatrix) {
      matrixPool.return(pooledMatrix);
    }
    if (!bounds.isValid) {
      bounds.set(0, 0, 0, 0);
    }
    return bounds;
  }
  function _getGlobalBounds(target5, bounds, parentTransform, skipUpdateTransform) {
    if (!target5.visible || !target5.measurable)
      return;
    let worldTransform;
    if (!skipUpdateTransform) {
      target5.updateLocalTransform();
      worldTransform = matrixPool.get();
      worldTransform.appendFrom(target5.localTransform, parentTransform);
    } else {
      worldTransform = target5.worldTransform;
    }
    const parentBounds = bounds;
    const preserveBounds = !!target5.effects.length;
    if (preserveBounds) {
      bounds = boundsPool.get().clear();
    }
    if (target5.boundsArea) {
      bounds.addRect(target5.boundsArea, worldTransform);
    } else {
      if (target5.addBounds) {
        bounds.matrix = worldTransform;
        target5.addBounds(bounds);
      }
      for (let i2 = 0; i2 < target5.children.length; i2++) {
        _getGlobalBounds(target5.children[i2], bounds, worldTransform, skipUpdateTransform);
      }
    }
    if (preserveBounds) {
      for (let i2 = 0; i2 < target5.effects.length; i2++) {
        target5.effects[i2].addBounds?.(bounds);
      }
      parentBounds.addBounds(bounds, Matrix.IDENTITY);
      boundsPool.return(bounds);
    }
    if (!skipUpdateTransform) {
      matrixPool.return(worldTransform);
    }
  }
  function updateTransformBackwards(target5, parentTransform) {
    const parent2 = target5.parent;
    if (parent2) {
      updateTransformBackwards(parent2, parentTransform);
      parent2.updateLocalTransform();
      parentTransform.append(parent2.localTransform);
    }
    return parentTransform;
  }
  var init_getGlobalBounds = __esm({
    "node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs"() {
      init_Matrix();
      init_matrixAndBoundsPool();
    }
  });

  // node_modules/pixi.js/lib/utils/logging/warn.mjs
  function warn2(...args) {
    if (warnCount === maxWarnings)
      return;
    warnCount++;
    if (warnCount === maxWarnings) {
      console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.");
    } else {
      console.warn("PixiJS Warning: ", ...args);
    }
  }
  var warnCount, maxWarnings;
  var init_warn = __esm({
    "node_modules/pixi.js/lib/utils/logging/warn.mjs"() {
      "use strict";
      warnCount = 0;
      maxWarnings = 500;
    }
  });

  // node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs
  function getLocalBounds(target5, bounds, relativeMatrix) {
    bounds.clear();
    relativeMatrix || (relativeMatrix = Matrix.IDENTITY);
    _getLocalBounds(target5, bounds, relativeMatrix, target5, true);
    if (!bounds.isValid) {
      bounds.set(0, 0, 0, 0);
    }
    return bounds;
  }
  function _getLocalBounds(target5, bounds, parentTransform, rootContainer, isRoot) {
    let relativeTransform;
    if (!isRoot) {
      if (!target5.visible || !target5.measurable)
        return;
      target5.updateLocalTransform();
      const localTransform = target5.localTransform;
      relativeTransform = matrixPool.get();
      relativeTransform.appendFrom(localTransform, parentTransform);
    } else {
      relativeTransform = matrixPool.get();
      relativeTransform = parentTransform.copyTo(relativeTransform);
    }
    const parentBounds = bounds;
    const preserveBounds = !!target5.effects.length;
    if (preserveBounds) {
      bounds = boundsPool.get().clear();
    }
    if (target5.boundsArea) {
      bounds.addRect(target5.boundsArea, relativeTransform);
    } else {
      if (target5.renderPipeId) {
        bounds.matrix = relativeTransform;
        target5.addBounds(bounds);
      }
      const children2 = target5.children;
      for (let i2 = 0; i2 < children2.length; i2++) {
        _getLocalBounds(children2[i2], bounds, relativeTransform, rootContainer, false);
      }
    }
    if (preserveBounds) {
      for (let i2 = 0; i2 < target5.effects.length; i2++) {
        target5.effects[i2].addLocalBounds?.(bounds, rootContainer);
      }
      parentBounds.addBounds(bounds, Matrix.IDENTITY);
      boundsPool.return(bounds);
    }
    matrixPool.return(relativeTransform);
  }
  var init_getLocalBounds = __esm({
    "node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs"() {
      init_Matrix();
      init_matrixAndBoundsPool();
    }
  });

  // node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs
  function checkChildrenDidChange(container, previousData) {
    const children2 = container.children;
    for (let i2 = 0; i2 < children2.length; i2++) {
      const child = children2[i2];
      const uid3 = child.uid;
      const didChange = (child._didViewChangeTick & 65535) << 16 | child._didContainerChangeTick & 65535;
      const index6 = previousData.index;
      if (previousData.data[index6] !== uid3 || previousData.data[index6 + 1] !== didChange) {
        previousData.data[previousData.index] = uid3;
        previousData.data[previousData.index + 1] = didChange;
        previousData.didChange = true;
      }
      previousData.index = index6 + 2;
      if (child.children.length) {
        checkChildrenDidChange(child, previousData);
      }
    }
    return previousData.didChange;
  }
  var init_checkChildrenDidChange = __esm({
    "node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs
  var tempMatrix2, measureMixin;
  var init_measureMixin = __esm({
    "node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs"() {
      init_Matrix();
      init_Bounds();
      init_getGlobalBounds();
      init_getLocalBounds();
      init_checkChildrenDidChange();
      tempMatrix2 = new Matrix();
      measureMixin = {
        _localBoundsCacheId: -1,
        _localBoundsCacheData: null,
        _setWidth(value12, localWidth) {
          const sign2 = Math.sign(this.scale.x) || 1;
          if (localWidth !== 0) {
            this.scale.x = value12 / localWidth * sign2;
          } else {
            this.scale.x = sign2;
          }
        },
        _setHeight(value12, localHeight) {
          const sign2 = Math.sign(this.scale.y) || 1;
          if (localHeight !== 0) {
            this.scale.y = value12 / localHeight * sign2;
          } else {
            this.scale.y = sign2;
          }
        },
        /**
         * Retrieves the local bounds of the container as a Bounds object.
         * @returns - The bounding area.
         * @memberof scene.Container#
         */
        getLocalBounds() {
          if (!this._localBoundsCacheData) {
            this._localBoundsCacheData = {
              data: [],
              index: 1,
              didChange: false,
              localBounds: new Bounds()
            };
          }
          const localBoundsCacheData = this._localBoundsCacheData;
          localBoundsCacheData.index = 1;
          localBoundsCacheData.didChange = false;
          if (localBoundsCacheData.data[0] !== this._didViewChangeTick) {
            localBoundsCacheData.didChange = true;
            localBoundsCacheData.data[0] = this._didViewChangeTick;
          }
          checkChildrenDidChange(this, localBoundsCacheData);
          if (localBoundsCacheData.didChange) {
            getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix2);
          }
          return localBoundsCacheData.localBounds;
        },
        /**
         * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.
         * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from
         *  being updated. This means the calculation returned MAY be out of date BUT will give you a
         *  nice performance boost.
         * @param bounds - Optional bounds to store the result of the bounds calculation.
         * @returns - The minimum axis-aligned rectangle in world space that fits around this object.
         * @memberof scene.Container#
         */
        getBounds(skipUpdate, bounds) {
          return getGlobalBounds(this, skipUpdate, bounds || new Bounds());
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs
  var onRenderMixin;
  var init_onRenderMixin = __esm({
    "node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs"() {
      "use strict";
      onRenderMixin = {
        _onRender: null,
        set onRender(func) {
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (!func) {
            if (this._onRender) {
              renderGroup?.removeOnRender(this);
            }
            this._onRender = null;
            return;
          }
          if (!this._onRender) {
            renderGroup?.addOnRender(this);
          }
          this._onRender = func;
        },
        /**
         * This callback is used when the container is rendered. This is where you should add your custom
         * logic that is needed to be run every frame.
         *
         * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different
         * and "updateTransform" is no longer called every frame
         * @example
         * const container = new Container();
         * container.onRender = () => {
         *    container.rotation += 0.01;
         * };
         * @memberof scene.Container#
         */
        get onRender() {
          return this._onRender;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs
  function sortChildren(a2, b2) {
    return a2._zIndex - b2._zIndex;
  }
  var sortMixin;
  var init_sortMixin = __esm({
    "node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs"() {
      "use strict";
      sortMixin = {
        _zIndex: 0,
        /**
         * Should children be sorted by zIndex at the next render call.
         *
         * Will get automatically set to true if a new child is added, or if a child's zIndex changes.
         * @type {boolean}
         * @memberof scene.Container#
         */
        sortDirty: false,
        /**
         * If set to true, the container will sort its children by `zIndex` value
         * when the next render is called, or manually if `sortChildren()` is called.
         *
         * This actually changes the order of elements in the array, so should be treated
         * as a basic solution that is not performant compared to other solutions,
         * such as {@link https://github.com/pixijs/layers PixiJS Layers}
         *
         * Also be aware of that this may not work nicely with the `addChildAt()` function,
         * as the `zIndex` sorting may cause the child to automatically sorted to another position.
         * @type {boolean}
         * @memberof scene.Container#
         */
        sortableChildren: false,
        /**
         * The zIndex of the container.
         *
         * Setting this value, will automatically set the parent to be sortable. Children will be automatically
         * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
         * and thus rendered on top of other display objects within the same container.
         * @see scene.Container#sortableChildren
         * @memberof scene.Container#
         */
        get zIndex() {
          return this._zIndex;
        },
        set zIndex(value12) {
          if (this._zIndex === value12)
            return;
          this._zIndex = value12;
          this.depthOfChildModified();
        },
        depthOfChildModified() {
          if (this.parent) {
            this.parent.sortableChildren = true;
            this.parent.sortDirty = true;
          }
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
        },
        /**
         * Sorts children by zIndex.
         * @memberof scene.Container#
         */
        sortChildren() {
          if (!this.sortDirty)
            return;
          this.sortDirty = false;
          this.children.sort(sortChildren);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs
  var toLocalGlobalMixin;
  var init_toLocalGlobalMixin = __esm({
    "node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs"() {
      init_Matrix();
      init_Point();
      init_getGlobalBounds();
      toLocalGlobalMixin = {
        /**
         * Returns the global position of the container.
         * @param point - The optional point to write the global value to.
         * @param skipUpdate - Should we skip the update transform.
         * @returns - The updated point.
         * @memberof scene.Container#
         */
        getGlobalPosition(point = new Point(), skipUpdate = false) {
          if (this.parent) {
            this.parent.toGlobal(this._position, point, skipUpdate);
          } else {
            point.x = this._position.x;
            point.y = this._position.y;
          }
          return point;
        },
        /**
         * Calculates the global position of the container.
         * @param position - The world origin to calculate from.
         * @param point - A Point object in which to store the value, optional
         *  (otherwise will create a new Point).
         * @param skipUpdate - Should we skip the update transform.
         * @returns - A point object representing the position of this object.
         * @memberof scene.Container#
         */
        toGlobal(position2, point, skipUpdate = false) {
          if (!skipUpdate) {
            this.updateLocalTransform();
            const globalMatrix = updateTransformBackwards(this, new Matrix());
            globalMatrix.append(this.localTransform);
            return globalMatrix.apply(position2, point);
          }
          return this.worldTransform.apply(position2, point);
        },
        /**
         * Calculates the local position of the container relative to another point.
         * @param position - The world origin to calculate from.
         * @param from - The Container to calculate the global position from.
         * @param point - A Point object in which to store the value, optional
         *  (otherwise will create a new Point).
         * @param skipUpdate - Should we skip the update transform
         * @returns - A point object representing the position of this object
         * @memberof scene.Container#
         */
        toLocal(position2, from3, point, skipUpdate) {
          if (from3) {
            position2 = from3.toGlobal(position2, point, skipUpdate);
          }
          if (!skipUpdate) {
            this.updateLocalTransform();
            const globalMatrix = updateTransformBackwards(this, new Matrix());
            globalMatrix.append(this.localTransform);
            return globalMatrix.applyInverse(position2, point);
          }
          return this.worldTransform.applyInverse(position2, point);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs
  var _tick, InstructionSet;
  var init_InstructionSet = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs"() {
      init_uid();
      _tick = 0;
      InstructionSet = class {
        constructor() {
          this.uid = uid("instructionSet");
          this.instructions = [];
          this.instructionSize = 0;
          this.renderables = [];
          this.tick = 0;
        }
        /** reset the instruction set so it can be reused set size back to 0 */
        reset() {
          this.instructionSize = 0;
          this.tick = _tick++;
        }
        /**
         * Add an instruction to the set
         * @param instruction - add an instruction to the set
         */
        add(instruction) {
          this.instructions[this.instructionSize++] = instruction;
        }
        /**
         * Log the instructions to the console (for debugging)
         * @internal
         * @ignore
         */
        log() {
          this.instructions.length = this.instructionSize;
          console.table(this.instructions, ["type", "action"]);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/container/RenderGroup.mjs
  var RenderGroup;
  var init_RenderGroup = __esm({
    "node_modules/pixi.js/lib/scene/container/RenderGroup.mjs"() {
      init_Matrix();
      init_InstructionSet();
      RenderGroup = class {
        constructor() {
          this.renderPipeId = "renderGroup";
          this.root = null;
          this.canBundle = false;
          this.renderGroupParent = null;
          this.renderGroupChildren = [];
          this.worldTransform = new Matrix();
          this.worldColorAlpha = 4294967295;
          this.worldColor = 16777215;
          this.worldAlpha = 1;
          this.childrenToUpdate = /* @__PURE__ */ Object.create(null);
          this.updateTick = 0;
          this.childrenRenderablesToUpdate = { list: [], index: 0 };
          this.structureDidChange = true;
          this.instructionSet = new InstructionSet();
          this._onRenderContainers = [];
        }
        init(root) {
          this.root = root;
          if (root._onRender)
            this.addOnRender(root);
          root.didChange = true;
          const children2 = root.children;
          for (let i2 = 0; i2 < children2.length; i2++) {
            this.addChild(children2[i2]);
          }
        }
        reset() {
          this.renderGroupChildren.length = 0;
          for (const i2 in this.childrenToUpdate) {
            const childrenAtDepth = this.childrenToUpdate[i2];
            childrenAtDepth.list.fill(null);
            childrenAtDepth.index = 0;
          }
          this.childrenRenderablesToUpdate.index = 0;
          this.childrenRenderablesToUpdate.list.fill(null);
          this.root = null;
          this.updateTick = 0;
          this.structureDidChange = true;
          this._onRenderContainers.length = 0;
          this.renderGroupParent = null;
        }
        get localTransform() {
          return this.root.localTransform;
        }
        addRenderGroupChild(renderGroupChild) {
          if (renderGroupChild.renderGroupParent) {
            renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);
          }
          renderGroupChild.renderGroupParent = this;
          this.renderGroupChildren.push(renderGroupChild);
        }
        _removeRenderGroupChild(renderGroupChild) {
          const index6 = this.renderGroupChildren.indexOf(renderGroupChild);
          if (index6 > -1) {
            this.renderGroupChildren.splice(index6, 1);
          }
          renderGroupChild.renderGroupParent = null;
        }
        addChild(child) {
          this.structureDidChange = true;
          child.parentRenderGroup = this;
          child.updateTick = -1;
          if (child.parent === this.root) {
            child.relativeRenderGroupDepth = 1;
          } else {
            child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;
          }
          child.didChange = true;
          this.onChildUpdate(child);
          if (child.renderGroup) {
            this.addRenderGroupChild(child.renderGroup);
            return;
          }
          if (child._onRender)
            this.addOnRender(child);
          const children2 = child.children;
          for (let i2 = 0; i2 < children2.length; i2++) {
            this.addChild(children2[i2]);
          }
        }
        removeChild(child) {
          this.structureDidChange = true;
          if (child._onRender) {
            if (!child.renderGroup) {
              this.removeOnRender(child);
            }
          }
          child.parentRenderGroup = null;
          if (child.renderGroup) {
            this._removeRenderGroupChild(child.renderGroup);
            return;
          }
          const children2 = child.children;
          for (let i2 = 0; i2 < children2.length; i2++) {
            this.removeChild(children2[i2]);
          }
        }
        removeChildren(children2) {
          for (let i2 = 0; i2 < children2.length; i2++) {
            this.removeChild(children2[i2]);
          }
        }
        onChildUpdate(child) {
          let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];
          if (!childrenToUpdate) {
            childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {
              index: 0,
              list: []
            };
          }
          childrenToUpdate.list[childrenToUpdate.index++] = child;
        }
        updateRenderable(renderable) {
          if (renderable.globalDisplayStatus < 7)
            return;
          this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable);
          renderable.didViewUpdate = false;
        }
        onChildViewUpdate(child) {
          this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;
        }
        get isRenderable() {
          return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
        }
        /**
         * adding a container to the onRender list will make sure the user function
         * passed in to the user defined 'onRender` callBack
         * @param container - the container to add to the onRender list
         */
        addOnRender(container) {
          this._onRenderContainers.push(container);
        }
        removeOnRender(container) {
          this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);
        }
        runOnRender() {
          for (let i2 = 0; i2 < this._onRenderContainers.length; i2++) {
            this._onRenderContainers[i2]._onRender();
          }
        }
        destroy() {
          this.renderGroupParent = null;
          this.root = null;
          this.childrenRenderablesToUpdate = null;
          this.childrenToUpdate = null;
          this.renderGroupChildren = null;
          this._onRenderContainers = null;
          this.instructionSet = null;
        }
        getChildren(out2 = []) {
          const children2 = this.root.children;
          for (let i2 = 0; i2 < children2.length; i2++) {
            this._getChildren(children2[i2], out2);
          }
          return out2;
        }
        _getChildren(container, out2 = []) {
          out2.push(container);
          if (container.renderGroup)
            return out2;
          const children2 = container.children;
          for (let i2 = 0; i2 < children2.length; i2++) {
            this._getChildren(children2[i2], out2);
          }
          return out2;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs
  function assignWithIgnore(target5, options2, ignore = {}) {
    for (const key in options2) {
      if (!ignore[key] && options2[key] !== void 0) {
        target5[key] = options2[key];
      }
    }
  }
  var init_assignWithIgnore = __esm({
    "node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/container/Container.mjs
  var defaultSkew, defaultPivot, defaultScale, UPDATE_COLOR, UPDATE_BLEND, UPDATE_VISIBLE, Container;
  var init_Container = __esm({
    "node_modules/pixi.js/lib/scene/container/Container.mjs"() {
      init_eventemitter3();
      init_Color();
      init_cullingMixin();
      init_Matrix();
      init_const();
      init_ObservablePoint();
      init_uid();
      init_deprecation();
      init_PoolGroup();
      init_childrenHelperMixin();
      init_effectsMixin();
      init_findMixin();
      init_measureMixin();
      init_onRenderMixin();
      init_sortMixin();
      init_toLocalGlobalMixin();
      init_RenderGroup();
      init_assignWithIgnore();
      defaultSkew = new ObservablePoint(null);
      defaultPivot = new ObservablePoint(null);
      defaultScale = new ObservablePoint(null, 1, 1);
      UPDATE_COLOR = 1;
      UPDATE_BLEND = 2;
      UPDATE_VISIBLE = 4;
      Container = class _Container extends eventemitter3_default {
        constructor(options2 = {}) {
          super();
          this.uid = uid("renderable");
          this._updateFlags = 15;
          this.renderGroup = null;
          this.parentRenderGroup = null;
          this.parentRenderGroupIndex = 0;
          this.didChange = false;
          this.didViewUpdate = false;
          this.relativeRenderGroupDepth = 0;
          this.children = [];
          this.parent = null;
          this.includeInBuild = true;
          this.measurable = true;
          this.isSimple = true;
          this.updateTick = -1;
          this.localTransform = new Matrix();
          this.relativeGroupTransform = new Matrix();
          this.groupTransform = this.relativeGroupTransform;
          this.destroyed = false;
          this._position = new ObservablePoint(this, 0, 0);
          this._scale = defaultScale;
          this._pivot = defaultPivot;
          this._skew = defaultSkew;
          this._cx = 1;
          this._sx = 0;
          this._cy = 0;
          this._sy = 1;
          this._rotation = 0;
          this.localColor = 16777215;
          this.localAlpha = 1;
          this.groupAlpha = 1;
          this.groupColor = 16777215;
          this.groupColorAlpha = 4294967295;
          this.localBlendMode = "inherit";
          this.groupBlendMode = "normal";
          this.localDisplayStatus = 7;
          this.globalDisplayStatus = 7;
          this._didContainerChangeTick = 0;
          this._didViewChangeTick = 0;
          this._didLocalTransformChangeId = -1;
          this.effects = [];
          assignWithIgnore(this, options2, {
            children: true,
            parent: true,
            effects: true
          });
          options2.children?.forEach((child) => this.addChild(child));
          options2.parent?.addChild(this);
        }
        /**
         * Mixes all enumerable properties and methods from a source object to Container.
         * @param source - The source of properties and methods to mix in.
         */
        static mixin(source3) {
          Object.defineProperties(_Container.prototype, Object.getOwnPropertyDescriptors(source3));
        }
        /**
         * We now use the _didContainerChangeTick and _didViewChangeTick to track changes
         * @deprecated since 8.2.6
         * @ignore
         */
        set _didChangeId(value12) {
          this._didViewChangeTick = value12 >> 12 & 4095;
          this._didContainerChangeTick = value12 & 4095;
        }
        get _didChangeId() {
          return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;
        }
        /**
         * Adds one or more children to the container.
         *
         * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
         * @param {...Container} children - The Container(s) to add to the container
         * @returns {Container} - The first child that was added.
         */
        addChild(...children2) {
          if (!this.allowChildren) {
            deprecation(v8_0_0, "addChild: Only Containers will be allowed to add children in v8.0.0");
          }
          if (children2.length > 1) {
            for (let i2 = 0; i2 < children2.length; i2++) {
              this.addChild(children2[i2]);
            }
            return children2[0];
          }
          const child = children2[0];
          if (child.parent === this) {
            this.children.splice(this.children.indexOf(child), 1);
            this.children.push(child);
            if (this.parentRenderGroup) {
              this.parentRenderGroup.structureDidChange = true;
            }
            return child;
          }
          if (child.parent) {
            child.parent.removeChild(child);
          }
          this.children.push(child);
          if (this.sortableChildren)
            this.sortDirty = true;
          child.parent = this;
          child.didChange = true;
          child._updateFlags = 15;
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.addChild(child);
          }
          this.emit("childAdded", child, this, this.children.length - 1);
          child.emit("added", this);
          this._didViewChangeTick++;
          if (child._zIndex !== 0) {
            child.depthOfChildModified();
          }
          return child;
        }
        /**
         * Removes one or more children from the container.
         * @param {...Container} children - The Container(s) to remove
         * @returns {Container} The first child that was removed.
         */
        removeChild(...children2) {
          if (children2.length > 1) {
            for (let i2 = 0; i2 < children2.length; i2++) {
              this.removeChild(children2[i2]);
            }
            return children2[0];
          }
          const child = children2[0];
          const index6 = this.children.indexOf(child);
          if (index6 > -1) {
            this._didViewChangeTick++;
            this.children.splice(index6, 1);
            if (this.renderGroup) {
              this.renderGroup.removeChild(child);
            } else if (this.parentRenderGroup) {
              this.parentRenderGroup.removeChild(child);
            }
            child.parent = null;
            this.emit("childRemoved", child, this, index6);
            child.emit("removed", this);
          }
          return child;
        }
        /** @ignore */
        _onUpdate(point) {
          if (point) {
            if (point === this._skew) {
              this._updateSkew();
            }
          }
          this._didContainerChangeTick++;
          if (this.didChange)
            return;
          this.didChange = true;
          if (this.parentRenderGroup) {
            this.parentRenderGroup.onChildUpdate(this);
          }
        }
        set isRenderGroup(value12) {
          if (!!this.renderGroup === value12)
            return;
          if (value12) {
            this.enableRenderGroup();
          } else {
            this.disableRenderGroup();
          }
        }
        /**
         * Returns true if this container is a render group.
         * This means that it will be rendered as a separate pass, with its own set of instructions
         */
        get isRenderGroup() {
          return !!this.renderGroup;
        }
        /**
         * Calling this enables a render group for this container.
         * This means it will be rendered as a separate set of instructions.
         * The transform of the container will also be handled on the GPU rather than the CPU.
         */
        enableRenderGroup() {
          if (this.renderGroup)
            return;
          const parentRenderGroup = this.parentRenderGroup;
          parentRenderGroup?.removeChild(this);
          this.renderGroup = BigPool.get(RenderGroup, this);
          this.groupTransform = Matrix.IDENTITY;
          parentRenderGroup?.addChild(this);
          this._updateIsSimple();
        }
        /** This will disable the render group for this container. */
        disableRenderGroup() {
          if (!this.renderGroup)
            return;
          const parentRenderGroup = this.parentRenderGroup;
          parentRenderGroup?.removeChild(this);
          BigPool.return(this.renderGroup);
          this.renderGroup = null;
          this.groupTransform = this.relativeGroupTransform;
          parentRenderGroup?.addChild(this);
          this._updateIsSimple();
        }
        /** @ignore */
        _updateIsSimple() {
          this.isSimple = !this.renderGroup && this.effects.length === 0;
        }
        /**
         * Current transform of the object based on world (parent) factors.
         * @readonly
         */
        get worldTransform() {
          this._worldTransform || (this._worldTransform = new Matrix());
          if (this.renderGroup) {
            this._worldTransform.copyFrom(this.renderGroup.worldTransform);
          } else if (this.parentRenderGroup) {
            this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);
          }
          return this._worldTransform;
        }
        // / ////// transform related stuff
        /**
         * The position of the container on the x axis relative to the local coordinates of the parent.
         * An alias to position.x
         */
        get x() {
          return this._position.x;
        }
        set x(value12) {
          this._position.x = value12;
        }
        /**
         * The position of the container on the y axis relative to the local coordinates of the parent.
         * An alias to position.y
         */
        get y() {
          return this._position.y;
        }
        set y(value12) {
          this._position.y = value12;
        }
        /**
         * The coordinate of the object relative to the local coordinates of the parent.
         * @since 4.0.0
         */
        get position() {
          return this._position;
        }
        set position(value12) {
          this._position.copyFrom(value12);
        }
        /**
         * The rotation of the object in radians.
         * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
         */
        get rotation() {
          return this._rotation;
        }
        set rotation(value12) {
          if (this._rotation !== value12) {
            this._rotation = value12;
            this._onUpdate(this._skew);
          }
        }
        /**
         * The angle of the object in degrees.
         * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
         */
        get angle() {
          return this.rotation * RAD_TO_DEG;
        }
        set angle(value12) {
          this.rotation = value12 * DEG_TO_RAD;
        }
        /**
         * The center of rotation, scaling, and skewing for this display object in its local space. The `position`
         * is the projection of `pivot` in the parent's local space.
         *
         * By default, the pivot is the origin (0, 0).
         * @since 4.0.0
         */
        get pivot() {
          if (this._pivot === defaultPivot) {
            this._pivot = new ObservablePoint(this, 0, 0);
          }
          return this._pivot;
        }
        set pivot(value12) {
          if (this._pivot === defaultPivot) {
            this._pivot = new ObservablePoint(this, 0, 0);
          }
          typeof value12 === "number" ? this._pivot.set(value12) : this._pivot.copyFrom(value12);
        }
        /**
         * The skew factor for the object in radians.
         * @since 4.0.0
         */
        get skew() {
          if (this._skew === defaultSkew) {
            this._skew = new ObservablePoint(this, 0, 0);
          }
          return this._skew;
        }
        set skew(value12) {
          if (this._skew === defaultSkew) {
            this._skew = new ObservablePoint(this, 0, 0);
          }
          this._skew.copyFrom(value12);
        }
        /**
         * The scale factors of this object along the local coordinate axes.
         *
         * The default scale is (1, 1).
         * @since 4.0.0
         */
        get scale() {
          if (this._scale === defaultScale) {
            this._scale = new ObservablePoint(this, 1, 1);
          }
          return this._scale;
        }
        set scale(value12) {
          if (this._scale === defaultScale) {
            this._scale = new ObservablePoint(this, 0, 0);
          }
          typeof value12 === "number" ? this._scale.set(value12) : this._scale.copyFrom(value12);
        }
        /**
         * The width of the Container, setting this will actually modify the scale to achieve the value set.
         * @memberof scene.Container#
         */
        get width() {
          return Math.abs(this.scale.x * this.getLocalBounds().width);
        }
        set width(value12) {
          const localWidth = this.getLocalBounds().width;
          this._setWidth(value12, localWidth);
        }
        /**
         * The height of the Container, setting this will actually modify the scale to achieve the value set.
         * @memberof scene.Container#
         */
        get height() {
          return Math.abs(this.scale.y * this.getLocalBounds().height);
        }
        set height(value12) {
          const localHeight = this.getLocalBounds().height;
          this._setHeight(value12, localHeight);
        }
        /**
         * Retrieves the size of the container as a [Size]{@link Size} object.
         * This is faster than get the width and height separately.
         * @param out - Optional object to store the size in.
         * @returns - The size of the container.
         * @memberof scene.Container#
         */
        getSize(out2) {
          if (!out2) {
            out2 = {};
          }
          const bounds = this.getLocalBounds();
          out2.width = Math.abs(this.scale.x * bounds.width);
          out2.height = Math.abs(this.scale.y * bounds.height);
          return out2;
        }
        /**
         * Sets the size of the container to the specified width and height.
         * This is faster than setting the width and height separately.
         * @param value - This can be either a number or a [Size]{@link Size} object.
         * @param height - The height to set. Defaults to the value of `width` if not provided.
         * @memberof scene.Container#
         */
        setSize(value12, height8) {
          const size5 = this.getLocalBounds();
          if (typeof value12 === "object") {
            height8 = value12.height ?? value12.width;
            value12 = value12.width;
          } else {
            height8 ?? (height8 = value12);
          }
          value12 !== void 0 && this._setWidth(value12, size5.width);
          height8 !== void 0 && this._setHeight(height8, size5.height);
        }
        /** Called when the skew or the rotation changes. */
        _updateSkew() {
          const rotation = this._rotation;
          const skew = this._skew;
          this._cx = Math.cos(rotation + skew._y);
          this._sx = Math.sin(rotation + skew._y);
          this._cy = -Math.sin(rotation - skew._x);
          this._sy = Math.cos(rotation - skew._x);
        }
        /**
         * Updates the transform properties of the container (accepts partial values).
         * @param {object} opts - The options for updating the transform.
         * @param {number} opts.x - The x position of the container.
         * @param {number} opts.y - The y position of the container.
         * @param {number} opts.scaleX - The scale factor on the x-axis.
         * @param {number} opts.scaleY - The scale factor on the y-axis.
         * @param {number} opts.rotation - The rotation of the container, in radians.
         * @param {number} opts.skewX - The skew factor on the x-axis.
         * @param {number} opts.skewY - The skew factor on the y-axis.
         * @param {number} opts.pivotX - The x coordinate of the pivot point.
         * @param {number} opts.pivotY - The y coordinate of the pivot point.
         */
        updateTransform(opts) {
          this.position.set(
            typeof opts.x === "number" ? opts.x : this.position.x,
            typeof opts.y === "number" ? opts.y : this.position.y
          );
          this.scale.set(
            typeof opts.scaleX === "number" ? opts.scaleX || 1 : this.scale.x,
            typeof opts.scaleY === "number" ? opts.scaleY || 1 : this.scale.y
          );
          this.rotation = typeof opts.rotation === "number" ? opts.rotation : this.rotation;
          this.skew.set(
            typeof opts.skewX === "number" ? opts.skewX : this.skew.x,
            typeof opts.skewY === "number" ? opts.skewY : this.skew.y
          );
          this.pivot.set(
            typeof opts.pivotX === "number" ? opts.pivotX : this.pivot.x,
            typeof opts.pivotY === "number" ? opts.pivotY : this.pivot.y
          );
          return this;
        }
        /**
         * Updates the local transform using the given matrix.
         * @param matrix - The matrix to use for updating the transform.
         */
        setFromMatrix(matrix) {
          matrix.decompose(this);
        }
        /** Updates the local transform. */
        updateLocalTransform() {
          const localTransformChangeId = this._didContainerChangeTick;
          if (this._didLocalTransformChangeId === localTransformChangeId)
            return;
          this._didLocalTransformChangeId = localTransformChangeId;
          const lt2 = this.localTransform;
          const scale = this._scale;
          const pivot = this._pivot;
          const position2 = this._position;
          const sx = scale._x;
          const sy = scale._y;
          const px = pivot._x;
          const py = pivot._y;
          lt2.a = this._cx * sx;
          lt2.b = this._sx * sx;
          lt2.c = this._cy * sy;
          lt2.d = this._sy * sy;
          lt2.tx = position2._x - (px * lt2.a + py * lt2.c);
          lt2.ty = position2._y - (px * lt2.b + py * lt2.d);
        }
        // / ///// color related stuff
        set alpha(value12) {
          if (value12 === this.localAlpha)
            return;
          this.localAlpha = value12;
          this._updateFlags |= UPDATE_COLOR;
          this._onUpdate();
        }
        /** The opacity of the object. */
        get alpha() {
          return this.localAlpha;
        }
        set tint(value12) {
          const tempColor = Color.shared.setValue(value12 ?? 16777215);
          const bgr = tempColor.toBgrNumber();
          if (bgr === this.localColor)
            return;
          this.localColor = bgr;
          this._updateFlags |= UPDATE_COLOR;
          this._onUpdate();
        }
        /**
         * The tint applied to the sprite. This is a hex value.
         *
         * A value of 0xFFFFFF will remove any tint effect.
         * @default 0xFFFFFF
         */
        get tint() {
          const bgr = this.localColor;
          return ((bgr & 255) << 16) + (bgr & 65280) + (bgr >> 16 & 255);
        }
        // / //////////////// blend related stuff
        set blendMode(value12) {
          if (this.localBlendMode === value12)
            return;
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
          this._updateFlags |= UPDATE_BLEND;
          this.localBlendMode = value12;
          this._onUpdate();
        }
        /**
         * The blend mode to be applied to the sprite. Apply a value of `'normal'` to reset the blend mode.
         * @default 'normal'
         */
        get blendMode() {
          return this.localBlendMode;
        }
        // / ///////// VISIBILITY / RENDERABLE /////////////////
        /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */
        get visible() {
          return !!(this.localDisplayStatus & 2);
        }
        set visible(value12) {
          const valueNumber = value12 ? 2 : 0;
          if ((this.localDisplayStatus & 2) === valueNumber)
            return;
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
          this._updateFlags |= UPDATE_VISIBLE;
          this.localDisplayStatus ^= 2;
          this._onUpdate();
        }
        /** @ignore */
        get culled() {
          return !(this.localDisplayStatus & 4);
        }
        /** @ignore */
        set culled(value12) {
          const valueNumber = value12 ? 0 : 4;
          if ((this.localDisplayStatus & 4) === valueNumber)
            return;
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
          this._updateFlags |= UPDATE_VISIBLE;
          this.localDisplayStatus ^= 4;
          this._onUpdate();
        }
        /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */
        get renderable() {
          return !!(this.localDisplayStatus & 1);
        }
        set renderable(value12) {
          const valueNumber = value12 ? 1 : 0;
          if ((this.localDisplayStatus & 1) === valueNumber)
            return;
          this._updateFlags |= UPDATE_VISIBLE;
          this.localDisplayStatus ^= 1;
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
          this._onUpdate();
        }
        /** Whether or not the object should be rendered. */
        get isRenderable() {
          return this.localDisplayStatus === 7 && this.groupAlpha > 0;
        }
        /**
         * Removes all internal references and listeners as well as removes children from the display list.
         * Do not use a Container after calling `destroy`.
         * @param options - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
         *  method called as well. 'options' will be passed on to those calls.
         * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children
         * is set to true it should destroy the texture of the child sprite
         * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.
         * If options.children is set to true it should destroy the texture source of the child sprite
         * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.
         * If options.children is set to true it should destroy the context of the child graphics
         */
        destroy(options2 = false) {
          if (this.destroyed)
            return;
          this.destroyed = true;
          let oldChildren;
          if (this.children.length) {
            oldChildren = this.removeChildren(0, this.children.length);
          }
          this.removeFromParent();
          this.parent = null;
          this._maskEffect = null;
          this._filterEffect = null;
          this.effects = null;
          this._position = null;
          this._scale = null;
          this._pivot = null;
          this._skew = null;
          this.emit("destroyed", this);
          this.removeAllListeners();
          const destroyChildren = typeof options2 === "boolean" ? options2 : options2?.children;
          if (destroyChildren && oldChildren) {
            for (let i2 = 0; i2 < oldChildren.length; ++i2) {
              oldChildren[i2].destroy(options2);
            }
          }
          this.renderGroup?.destroy();
          this.renderGroup = null;
        }
      };
      Container.mixin(childrenHelperMixin);
      Container.mixin(toLocalGlobalMixin);
      Container.mixin(onRenderMixin);
      Container.mixin(measureMixin);
      Container.mixin(effectsMixin);
      Container.mixin(findMixin);
      Container.mixin(sortMixin);
      Container.mixin(cullingMixin);
    }
  });

  // node_modules/pixi.js/lib/events/FederatedEvent.mjs
  var FederatedEvent;
  var init_FederatedEvent = __esm({
    "node_modules/pixi.js/lib/events/FederatedEvent.mjs"() {
      init_Point();
      FederatedEvent = class _FederatedEvent {
        /**
         * @param manager - The event boundary which manages this event. Propagation can only occur
         *  within the boundary's jurisdiction.
         */
        constructor(manager) {
          this.bubbles = true;
          this.cancelBubble = true;
          this.cancelable = false;
          this.composed = false;
          this.defaultPrevented = false;
          this.eventPhase = _FederatedEvent.prototype.NONE;
          this.propagationStopped = false;
          this.propagationImmediatelyStopped = false;
          this.layer = new Point();
          this.page = new Point();
          this.NONE = 0;
          this.CAPTURING_PHASE = 1;
          this.AT_TARGET = 2;
          this.BUBBLING_PHASE = 3;
          this.manager = manager;
        }
        /** @readonly */
        get layerX() {
          return this.layer.x;
        }
        /** @readonly */
        get layerY() {
          return this.layer.y;
        }
        /** @readonly */
        get pageX() {
          return this.page.x;
        }
        /** @readonly */
        get pageY() {
          return this.page.y;
        }
        /**
         * Fallback for the deprecated @code{InteractionEvent.data}.
         * @deprecated since 7.0.0
         */
        get data() {
          return this;
        }
        /** The propagation path for this event. Alias for {@link EventBoundary.propagationPath}. */
        composedPath() {
          if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
            this.path = this.target ? this.manager.propagationPath(this.target) : [];
          }
          return this.path;
        }
        /**
         * Unimplemented method included for implementing the DOM interface {@code Event}. It will throw an {@code Error}.
         * @deprecated
         * @param _type
         * @param _bubbles
         * @param _cancelable
         */
        initEvent(_type, _bubbles, _cancelable) {
          throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
        }
        /**
         * Unimplemented method included for implementing the DOM interface {@code UIEvent}. It will throw an {@code Error}.
         * @deprecated
         * @param _typeArg
         * @param _bubblesArg
         * @param _cancelableArg
         * @param _viewArg
         * @param _detailArg
         */
        initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
          throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
        }
        /** Prevent default behavior of PixiJS and the user agent. */
        preventDefault() {
          if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
            this.nativeEvent.preventDefault();
          }
          this.defaultPrevented = true;
        }
        /**
         * Stop this event from propagating to any addition listeners, including on the
         * {@link FederatedEventTarget.currentTarget currentTarget} and also the following
         * event targets on the propagation path.
         */
        stopImmediatePropagation() {
          this.propagationImmediatelyStopped = true;
        }
        /**
         * Stop this event from propagating to the next {@link FederatedEventTarget}. The rest of the listeners
         * on the {@link FederatedEventTarget.currentTarget currentTarget} will still be notified.
         */
        stopPropagation() {
          this.propagationStopped = true;
        }
      };
    }
  });

  // node_modules/ismobilejs/esm/isMobile.js
  function createMatch(userAgent2) {
    return function(regex2) {
      return regex2.test(userAgent2);
    };
  }
  function isMobile(param) {
    var nav2 = {
      userAgent: "",
      platform: "",
      maxTouchPoints: 0
    };
    if (!param && typeof navigator !== "undefined") {
      nav2 = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        maxTouchPoints: navigator.maxTouchPoints || 0
      };
    } else if (typeof param === "string") {
      nav2.userAgent = param;
    } else if (param && param.userAgent) {
      nav2 = {
        userAgent: param.userAgent,
        platform: param.platform,
        maxTouchPoints: param.maxTouchPoints || 0
      };
    }
    var userAgent2 = nav2.userAgent;
    var tmp = userAgent2.split("[FBAN");
    if (typeof tmp[1] !== "undefined") {
      userAgent2 = tmp[0];
    }
    tmp = userAgent2.split("Twitter");
    if (typeof tmp[1] !== "undefined") {
      userAgent2 = tmp[0];
    }
    var match2 = createMatch(userAgent2);
    var result = {
      apple: {
        phone: match2(appleIphone) && !match2(windowsPhone),
        ipod: match2(appleIpod),
        tablet: !match2(appleIphone) && (match2(appleTablet) || isAppleTabletOnIos13(nav2)) && !match2(windowsPhone),
        universal: match2(appleUniversal),
        device: (match2(appleIphone) || match2(appleIpod) || match2(appleTablet) || match2(appleUniversal) || isAppleTabletOnIos13(nav2)) && !match2(windowsPhone)
      },
      amazon: {
        phone: match2(amazonPhone),
        tablet: !match2(amazonPhone) && match2(amazonTablet),
        device: match2(amazonPhone) || match2(amazonTablet)
      },
      android: {
        phone: !match2(windowsPhone) && match2(amazonPhone) || !match2(windowsPhone) && match2(androidPhone),
        tablet: !match2(windowsPhone) && !match2(amazonPhone) && !match2(androidPhone) && (match2(amazonTablet) || match2(androidTablet)),
        device: !match2(windowsPhone) && (match2(amazonPhone) || match2(amazonTablet) || match2(androidPhone) || match2(androidTablet)) || match2(/\bokhttp\b/i)
      },
      windows: {
        phone: match2(windowsPhone),
        tablet: match2(windowsTablet),
        device: match2(windowsPhone) || match2(windowsTablet)
      },
      other: {
        blackberry: match2(otherBlackBerry),
        blackberry10: match2(otherBlackBerry10),
        opera: match2(otherOpera),
        firefox: match2(otherFirefox),
        chrome: match2(otherChrome),
        device: match2(otherBlackBerry) || match2(otherBlackBerry10) || match2(otherOpera) || match2(otherFirefox) || match2(otherChrome)
      },
      any: false,
      phone: false,
      tablet: false
    };
    result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
    result.phone = result.apple.phone || result.android.phone || result.windows.phone;
    result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
    return result;
  }
  var appleIphone, appleIpod, appleTablet, appleUniversal, androidPhone, androidTablet, amazonPhone, amazonTablet, windowsPhone, windowsTablet, otherBlackBerry, otherBlackBerry10, otherOpera, otherChrome, otherFirefox, isAppleTabletOnIos13;
  var init_isMobile = __esm({
    "node_modules/ismobilejs/esm/isMobile.js"() {
      appleIphone = /iPhone/i;
      appleIpod = /iPod/i;
      appleTablet = /iPad/i;
      appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
      androidPhone = /\bAndroid(?:.+)Mobile\b/i;
      androidTablet = /Android/i;
      amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
      amazonTablet = /Silk/i;
      windowsPhone = /Windows Phone/i;
      windowsTablet = /\bWindows(?:.+)ARM\b/i;
      otherBlackBerry = /BlackBerry/i;
      otherBlackBerry10 = /BB10/i;
      otherOpera = /Opera Mini/i;
      otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
      otherFirefox = /Mobile(?:.+)Firefox\b/i;
      isAppleTabletOnIos13 = function(navigator3) {
        return typeof navigator3 !== "undefined" && navigator3.platform === "MacIntel" && typeof navigator3.maxTouchPoints === "number" && navigator3.maxTouchPoints > 1 && typeof MSStream === "undefined";
      };
    }
  });

  // node_modules/ismobilejs/esm/index.js
  var init_esm = __esm({
    "node_modules/ismobilejs/esm/index.js"() {
      init_isMobile();
      init_isMobile();
    }
  });

  // node_modules/pixi.js/lib/utils/browser/isMobile.mjs
  var isMobileCall, isMobile2;
  var init_isMobile2 = __esm({
    "node_modules/pixi.js/lib/utils/browser/isMobile.mjs"() {
      init_esm();
      isMobileCall = isMobile.default ?? isMobile;
      isMobile2 = isMobileCall(globalThis.navigator);
    }
  });

  // node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs
  var KEY_CODE_TAB, DIV_TOUCH_SIZE, DIV_TOUCH_POS_X, DIV_TOUCH_POS_Y, DIV_TOUCH_ZINDEX, DIV_HOOK_SIZE, DIV_HOOK_POS_X, DIV_HOOK_POS_Y, DIV_HOOK_ZINDEX, AccessibilitySystem;
  var init_AccessibilitySystem = __esm({
    "node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs"() {
      init_FederatedEvent();
      init_Extensions();
      init_isMobile2();
      init_removeItems();
      KEY_CODE_TAB = 9;
      DIV_TOUCH_SIZE = 100;
      DIV_TOUCH_POS_X = 0;
      DIV_TOUCH_POS_Y = 0;
      DIV_TOUCH_ZINDEX = 2;
      DIV_HOOK_SIZE = 1;
      DIV_HOOK_POS_X = -1e3;
      DIV_HOOK_POS_Y = -1e3;
      DIV_HOOK_ZINDEX = 2;
      AccessibilitySystem = class {
        // 2fps
        // eslint-disable-next-line jsdoc/require-param
        /**
         * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer
         */
        constructor(renderer, _mobileInfo = isMobile2) {
          this._mobileInfo = _mobileInfo;
          this.debug = false;
          this._isActive = false;
          this._isMobileAccessibility = false;
          this._pool = [];
          this._renderId = 0;
          this._children = [];
          this._androidUpdateCount = 0;
          this._androidUpdateFrequency = 500;
          this._hookDiv = null;
          if (_mobileInfo.tablet || _mobileInfo.phone) {
            this._createTouchHook();
          }
          const div5 = document.createElement("div");
          div5.style.width = `${DIV_TOUCH_SIZE}px`;
          div5.style.height = `${DIV_TOUCH_SIZE}px`;
          div5.style.position = "absolute";
          div5.style.top = `${DIV_TOUCH_POS_X}px`;
          div5.style.left = `${DIV_TOUCH_POS_Y}px`;
          div5.style.zIndex = DIV_TOUCH_ZINDEX.toString();
          this._div = div5;
          this._renderer = renderer;
          this._onKeyDown = this._onKeyDown.bind(this);
          this._onMouseMove = this._onMouseMove.bind(this);
          globalThis.addEventListener("keydown", this._onKeyDown, false);
        }
        /**
         * Value of `true` if accessibility is currently active and accessibility layers are showing.
         * @member {boolean}
         * @readonly
         */
        get isActive() {
          return this._isActive;
        }
        /**
         * Value of `true` if accessibility is enabled for touch devices.
         * @member {boolean}
         * @readonly
         */
        get isMobileAccessibility() {
          return this._isMobileAccessibility;
        }
        get hookDiv() {
          return this._hookDiv;
        }
        /**
         * Creates the touch hooks.
         * @private
         */
        _createTouchHook() {
          const hookDiv = document.createElement("button");
          hookDiv.style.width = `${DIV_HOOK_SIZE}px`;
          hookDiv.style.height = `${DIV_HOOK_SIZE}px`;
          hookDiv.style.position = "absolute";
          hookDiv.style.top = `${DIV_HOOK_POS_X}px`;
          hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;
          hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
          hookDiv.style.backgroundColor = "#FF0000";
          hookDiv.title = "select to enable accessibility for this content";
          hookDiv.addEventListener("focus", () => {
            this._isMobileAccessibility = true;
            this._activate();
            this._destroyTouchHook();
          });
          document.body.appendChild(hookDiv);
          this._hookDiv = hookDiv;
        }
        /**
         * Destroys the touch hooks.
         * @private
         */
        _destroyTouchHook() {
          if (!this._hookDiv) {
            return;
          }
          document.body.removeChild(this._hookDiv);
          this._hookDiv = null;
        }
        /**
         * Activating will cause the Accessibility layer to be shown.
         * This is called when a user presses the tab key.
         * @private
         */
        _activate() {
          if (this._isActive) {
            return;
          }
          this._isActive = true;
          globalThis.document.addEventListener("mousemove", this._onMouseMove, true);
          globalThis.removeEventListener("keydown", this._onKeyDown, false);
          this._renderer.runners.postrender.add(this);
          this._renderer.view.canvas.parentNode?.appendChild(this._div);
        }
        /**
         * Deactivating will cause the Accessibility layer to be hidden.
         * This is called when a user moves the mouse.
         * @private
         */
        _deactivate() {
          if (!this._isActive || this._isMobileAccessibility) {
            return;
          }
          this._isActive = false;
          globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
          globalThis.addEventListener("keydown", this._onKeyDown, false);
          this._renderer.runners.postrender.remove(this);
          this._div.parentNode?.removeChild(this._div);
        }
        /**
         * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.
         * @private
         * @param {Container} container - The Container to check.
         */
        _updateAccessibleObjects(container) {
          if (!container.visible || !container.accessibleChildren) {
            return;
          }
          if (container.accessible && container.isInteractive()) {
            if (!container._accessibleActive) {
              this._addChild(container);
            }
            container._renderId = this._renderId;
          }
          const children2 = container.children;
          if (children2) {
            for (let i2 = 0; i2 < children2.length; i2++) {
              this._updateAccessibleObjects(children2[i2]);
            }
          }
        }
        /**
         * Runner init called, view is available at this point.
         * @ignore
         */
        init(options2) {
          this.debug = options2?.debug ?? this.debug;
          this._renderer.runners.postrender.remove(this);
        }
        /**
         * Runner postrender was called, ensure that all divs are mapped correctly to their Containers.
         * Only fires while active.
         * @ignore
         */
        postrender() {
          const now3 = performance.now();
          if (this._mobileInfo.android.device && now3 < this._androidUpdateCount) {
            return;
          }
          this._androidUpdateCount = now3 + this._androidUpdateFrequency;
          if (!this._renderer.renderingToScreen || !this._renderer.view.canvas) {
            return;
          }
          if (this._renderer.lastObjectRendered) {
            this._updateAccessibleObjects(this._renderer.lastObjectRendered);
          }
          const { x: x2, y: y2, width: width8, height: height8 } = this._renderer.view.canvas.getBoundingClientRect();
          const { width: viewWidth, height: viewHeight, resolution } = this._renderer;
          const sx = width8 / viewWidth * resolution;
          const sy = height8 / viewHeight * resolution;
          let div5 = this._div;
          div5.style.left = `${x2}px`;
          div5.style.top = `${y2}px`;
          div5.style.width = `${viewWidth}px`;
          div5.style.height = `${viewHeight}px`;
          for (let i2 = 0; i2 < this._children.length; i2++) {
            const child = this._children[i2];
            if (child._renderId !== this._renderId) {
              child._accessibleActive = false;
              removeItems(this._children, i2, 1);
              this._div.removeChild(child._accessibleDiv);
              this._pool.push(child._accessibleDiv);
              child._accessibleDiv = null;
              i2--;
            } else {
              div5 = child._accessibleDiv;
              let hitArea = child.hitArea;
              const wt = child.worldTransform;
              if (child.hitArea) {
                div5.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`;
                div5.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`;
                div5.style.width = `${hitArea.width * wt.a * sx}px`;
                div5.style.height = `${hitArea.height * wt.d * sy}px`;
              } else {
                hitArea = child.getBounds().rectangle;
                this._capHitArea(hitArea);
                div5.style.left = `${hitArea.x * sx}px`;
                div5.style.top = `${hitArea.y * sy}px`;
                div5.style.width = `${hitArea.width * sx}px`;
                div5.style.height = `${hitArea.height * sy}px`;
                if (div5.title !== child.accessibleTitle && child.accessibleTitle !== null) {
                  div5.title = child.accessibleTitle || "";
                }
                if (div5.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
                  div5.setAttribute("aria-label", child.accessibleHint || "");
                }
              }
              if (child.accessibleTitle !== div5.title || child.tabIndex !== div5.tabIndex) {
                div5.title = child.accessibleTitle || "";
                div5.tabIndex = child.tabIndex;
                if (this.debug) {
                  this._updateDebugHTML(div5);
                }
              }
            }
          }
          this._renderId++;
        }
        /**
         * private function that will visually add the information to the
         * accessibility div
         * @param {HTMLElement} div -
         */
        _updateDebugHTML(div5) {
          div5.innerHTML = `type: ${div5.type}</br> title : ${div5.title}</br> tabIndex: ${div5.tabIndex}`;
        }
        /**
         * Adjust the hit area based on the bounds of a display object
         * @param {Rectangle} hitArea - Bounds of the child
         */
        _capHitArea(hitArea) {
          if (hitArea.x < 0) {
            hitArea.width += hitArea.x;
            hitArea.x = 0;
          }
          if (hitArea.y < 0) {
            hitArea.height += hitArea.y;
            hitArea.y = 0;
          }
          const { width: viewWidth, height: viewHeight } = this._renderer;
          if (hitArea.x + hitArea.width > viewWidth) {
            hitArea.width = viewWidth - hitArea.x;
          }
          if (hitArea.y + hitArea.height > viewHeight) {
            hitArea.height = viewHeight - hitArea.y;
          }
        }
        /**
         * Adds a Container to the accessibility manager
         * @private
         * @param {Container} container - The child to make accessible.
         */
        _addChild(container) {
          let div5 = this._pool.pop();
          if (!div5) {
            div5 = document.createElement("button");
            div5.style.width = `${DIV_TOUCH_SIZE}px`;
            div5.style.height = `${DIV_TOUCH_SIZE}px`;
            div5.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
            div5.style.position = "absolute";
            div5.style.zIndex = DIV_TOUCH_ZINDEX.toString();
            div5.style.borderStyle = "none";
            if (navigator.userAgent.toLowerCase().includes("chrome")) {
              div5.setAttribute("aria-live", "off");
            } else {
              div5.setAttribute("aria-live", "polite");
            }
            if (navigator.userAgent.match(/rv:.*Gecko\//)) {
              div5.setAttribute("aria-relevant", "additions");
            } else {
              div5.setAttribute("aria-relevant", "text");
            }
            div5.addEventListener("click", this._onClick.bind(this));
            div5.addEventListener("focus", this._onFocus.bind(this));
            div5.addEventListener("focusout", this._onFocusOut.bind(this));
          }
          div5.style.pointerEvents = container.accessiblePointerEvents;
          div5.type = container.accessibleType;
          if (container.accessibleTitle && container.accessibleTitle !== null) {
            div5.title = container.accessibleTitle;
          } else if (!container.accessibleHint || container.accessibleHint === null) {
            div5.title = `container ${container.tabIndex}`;
          }
          if (container.accessibleHint && container.accessibleHint !== null) {
            div5.setAttribute("aria-label", container.accessibleHint);
          }
          if (this.debug) {
            this._updateDebugHTML(div5);
          }
          container._accessibleActive = true;
          container._accessibleDiv = div5;
          div5.container = container;
          this._children.push(container);
          this._div.appendChild(container._accessibleDiv);
          container._accessibleDiv.tabIndex = container.tabIndex;
        }
        /**
         * Dispatch events with the EventSystem.
         * @param e
         * @param type
         * @private
         */
        _dispatchEvent(e2, type) {
          const { container: target5 } = e2.target;
          const boundary = this._renderer.events.rootBoundary;
          const event = Object.assign(new FederatedEvent(boundary), { target: target5 });
          boundary.rootTarget = this._renderer.lastObjectRendered;
          type.forEach((type2) => boundary.dispatchEvent(event, type2));
        }
        /**
         * Maps the div button press to pixi's EventSystem (click)
         * @private
         * @param {MouseEvent} e - The click event.
         */
        _onClick(e2) {
          this._dispatchEvent(e2, ["click", "pointertap", "tap"]);
        }
        /**
         * Maps the div focus events to pixi's EventSystem (mouseover)
         * @private
         * @param {FocusEvent} e - The focus event.
         */
        _onFocus(e2) {
          if (!e2.target.getAttribute("aria-live")) {
            e2.target.setAttribute("aria-live", "assertive");
          }
          this._dispatchEvent(e2, ["mouseover"]);
        }
        /**
         * Maps the div focus events to pixi's EventSystem (mouseout)
         * @private
         * @param {FocusEvent} e - The focusout event.
         */
        _onFocusOut(e2) {
          if (!e2.target.getAttribute("aria-live")) {
            e2.target.setAttribute("aria-live", "polite");
          }
          this._dispatchEvent(e2, ["mouseout"]);
        }
        /**
         * Is called when a key is pressed
         * @private
         * @param {KeyboardEvent} e - The keydown event.
         */
        _onKeyDown(e2) {
          if (e2.keyCode !== KEY_CODE_TAB) {
            return;
          }
          this._activate();
        }
        /**
         * Is called when the mouse moves across the renderer element
         * @private
         * @param {MouseEvent} e - The mouse event.
         */
        _onMouseMove(e2) {
          if (e2.movementX === 0 && e2.movementY === 0) {
            return;
          }
          this._deactivate();
        }
        /** Destroys the accessibility manager */
        destroy() {
          this._destroyTouchHook();
          this._div = null;
          globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
          globalThis.removeEventListener("keydown", this._onKeyDown);
          this._pool = null;
          this._children = null;
          this._renderer = null;
        }
      };
      AccessibilitySystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "accessibility"
      };
    }
  });

  // node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs
  var accessibilityTarget;
  var init_accessibilityTarget = __esm({
    "node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs"() {
      "use strict";
      accessibilityTarget = {
        /**
         * Flag for if the object is accessible. If true AccessibilityManager will overlay a
         * shadow div with attributes set
         * @member {boolean}
         * @memberof scene.Container#
         */
        accessible: false,
        /**
         * Sets the title attribute of the shadow div
         * If accessibleTitle AND accessibleHint has not been this will default to 'container [tabIndex]'
         * @member {string}
         * @memberof scene.Container#
         */
        accessibleTitle: null,
        /**
         * Sets the aria-label attribute of the shadow div
         * @member {string}
         * @memberof scene.Container#
         */
        accessibleHint: null,
        /**
         * @member {number}
         * @memberof scene.Container#
         * @todo Needs docs.
         */
        tabIndex: 0,
        /**
         * @member {boolean}
         * @memberof scene.Container#
         * @private
         */
        _accessibleActive: false,
        /**
         * @memberof scene.Container#
         * @private
         */
        _accessibleDiv: null,
        /**
         * Specify the type of div the accessible layer is. Screen readers treat the element differently
         * depending on this type. Defaults to button.
         * @member {string}
         * @memberof scene.Container#
         * @default 'button'
         */
        accessibleType: "button",
        /**
         * Specify the pointer-events the accessible div will use
         * Defaults to auto.
         * @type {PointerEvents}
         * @memberof scene.Container#
         * @default 'auto'
         */
        accessiblePointerEvents: "auto",
        /**
         * Setting to false will prevent any children inside this container to
         * be accessible. Defaults to true.
         * @member {boolean}
         * @memberof scene.Container#
         * @default true
         */
        accessibleChildren: true,
        /**
         * @member {number}
         * @memberof scene.Container#
         * @private
         */
        _renderId: -1
      };
    }
  });

  // node_modules/pixi.js/lib/accessibility/init.mjs
  var init_init = __esm({
    "node_modules/pixi.js/lib/accessibility/init.mjs"() {
      init_Extensions();
      init_Container();
      init_AccessibilitySystem();
      init_accessibilityTarget();
      extensions.add(AccessibilitySystem);
      Container.mixin(accessibilityTarget);
    }
  });

  // node_modules/pixi.js/lib/app/ResizePlugin.mjs
  var ResizePlugin;
  var init_ResizePlugin = __esm({
    "node_modules/pixi.js/lib/app/ResizePlugin.mjs"() {
      init_Extensions();
      ResizePlugin = class {
        /**
         * Initialize the plugin with scope of application instance
         * @static
         * @private
         * @param {object} [options] - See application options
         */
        static init(options2) {
          Object.defineProperty(
            this,
            "resizeTo",
            /**
             * The HTML element or window to automatically resize the
             * renderer's view element to match width and height.
             * @member {Window|HTMLElement}
             * @name resizeTo
             * @memberof app.Application#
             */
            {
              set(dom) {
                globalThis.removeEventListener("resize", this.queueResize);
                this._resizeTo = dom;
                if (dom) {
                  globalThis.addEventListener("resize", this.queueResize);
                  this.resize();
                }
              },
              get() {
                return this._resizeTo;
              }
            }
          );
          this.queueResize = () => {
            if (!this._resizeTo) {
              return;
            }
            this._cancelResize();
            this._resizeId = requestAnimationFrame(() => this.resize());
          };
          this._cancelResize = () => {
            if (this._resizeId) {
              cancelAnimationFrame(this._resizeId);
              this._resizeId = null;
            }
          };
          this.resize = () => {
            if (!this._resizeTo) {
              return;
            }
            this._cancelResize();
            let width8;
            let height8;
            if (this._resizeTo === globalThis.window) {
              width8 = globalThis.innerWidth;
              height8 = globalThis.innerHeight;
            } else {
              const { clientWidth: clientWidth2, clientHeight: clientHeight2 } = this._resizeTo;
              width8 = clientWidth2;
              height8 = clientHeight2;
            }
            this.renderer.resize(width8, height8);
            this.render();
          };
          this._resizeId = null;
          this._resizeTo = null;
          this.resizeTo = options2.resizeTo || null;
        }
        /**
         * Clean up the ticker, scoped to application
         * @static
         * @private
         */
        static destroy() {
          globalThis.removeEventListener("resize", this.queueResize);
          this._cancelResize();
          this._cancelResize = null;
          this.queueResize = null;
          this.resizeTo = null;
          this.resize = null;
        }
      };
      ResizePlugin.extension = ExtensionType.Application;
    }
  });

  // node_modules/pixi.js/lib/ticker/const.mjs
  var UPDATE_PRIORITY;
  var init_const2 = __esm({
    "node_modules/pixi.js/lib/ticker/const.mjs"() {
      "use strict";
      UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {
        UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
        UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
        UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
        UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
        UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
        return UPDATE_PRIORITY2;
      })(UPDATE_PRIORITY || {});
    }
  });

  // node_modules/pixi.js/lib/ticker/TickerListener.mjs
  var TickerListener;
  var init_TickerListener = __esm({
    "node_modules/pixi.js/lib/ticker/TickerListener.mjs"() {
      "use strict";
      TickerListener = class {
        /**
         * Constructor
         * @private
         * @param fn - The listener function to be added for one update
         * @param context - The listener context
         * @param priority - The priority for emitting
         * @param once - If the handler should fire once
         */
        constructor(fn, context3 = null, priority = 0, once = false) {
          this.next = null;
          this.previous = null;
          this._destroyed = false;
          this._fn = fn;
          this._context = context3;
          this.priority = priority;
          this._once = once;
        }
        /**
         * Simple compare function to figure out if a function and context match.
         * @param fn - The listener function to be added for one update
         * @param context - The listener context
         * @returns `true` if the listener match the arguments
         */
        match(fn, context3 = null) {
          return this._fn === fn && this._context === context3;
        }
        /**
         * Emit by calling the current function.
         * @param ticker - The ticker emitting.
         * @returns Next ticker
         */
        emit(ticker) {
          if (this._fn) {
            if (this._context) {
              this._fn.call(this._context, ticker);
            } else {
              this._fn(ticker);
            }
          }
          const redirect = this.next;
          if (this._once) {
            this.destroy(true);
          }
          if (this._destroyed) {
            this.next = null;
          }
          return redirect;
        }
        /**
         * Connect to the list.
         * @param previous - Input node, previous listener
         */
        connect(previous) {
          this.previous = previous;
          if (previous.next) {
            previous.next.previous = this;
          }
          this.next = previous.next;
          previous.next = this;
        }
        /**
         * Destroy and don't use after this.
         * @param hard - `true` to remove the `next` reference, this
         *        is considered a hard destroy. Soft destroy maintains the next reference.
         * @returns The listener to redirect while emitting or removing.
         */
        destroy(hard = false) {
          this._destroyed = true;
          this._fn = null;
          this._context = null;
          if (this.previous) {
            this.previous.next = this.next;
          }
          if (this.next) {
            this.next.previous = this.previous;
          }
          const redirect = this.next;
          this.next = hard ? null : redirect;
          this.previous = null;
          return redirect;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/ticker/Ticker.mjs
  var _Ticker, Ticker;
  var init_Ticker = __esm({
    "node_modules/pixi.js/lib/ticker/Ticker.mjs"() {
      init_const2();
      init_TickerListener();
      _Ticker = class _Ticker2 {
        constructor() {
          this.autoStart = false;
          this.deltaTime = 1;
          this.lastTime = -1;
          this.speed = 1;
          this.started = false;
          this._requestId = null;
          this._maxElapsedMS = 100;
          this._minElapsedMS = 0;
          this._protected = false;
          this._lastFrame = -1;
          this._head = new TickerListener(null, null, Infinity);
          this.deltaMS = 1 / _Ticker2.targetFPMS;
          this.elapsedMS = 1 / _Ticker2.targetFPMS;
          this._tick = (time3) => {
            this._requestId = null;
            if (this.started) {
              this.update(time3);
              if (this.started && this._requestId === null && this._head.next) {
                this._requestId = requestAnimationFrame(this._tick);
              }
            }
          };
        }
        /**
         * Conditionally requests a new animation frame.
         * If a frame has not already been requested, and if the internal
         * emitter has listeners, a new frame is requested.
         * @private
         */
        _requestIfNeeded() {
          if (this._requestId === null && this._head.next) {
            this.lastTime = performance.now();
            this._lastFrame = this.lastTime;
            this._requestId = requestAnimationFrame(this._tick);
          }
        }
        /**
         * Conditionally cancels a pending animation frame.
         * @private
         */
        _cancelIfNeeded() {
          if (this._requestId !== null) {
            cancelAnimationFrame(this._requestId);
            this._requestId = null;
          }
        }
        /**
         * Conditionally requests a new animation frame.
         * If the ticker has been started it checks if a frame has not already
         * been requested, and if the internal emitter has listeners. If these
         * conditions are met, a new frame is requested. If the ticker has not
         * been started, but autoStart is `true`, then the ticker starts now,
         * and continues with the previous conditions to request a new frame.
         * @private
         */
        _startIfPossible() {
          if (this.started) {
            this._requestIfNeeded();
          } else if (this.autoStart) {
            this.start();
          }
        }
        /**
         * Register a handler for tick events. Calls continuously unless
         * it is removed or the ticker is stopped.
         * @param fn - The listener function to be added for updates
         * @param context - The listener context
         * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting
         * @returns This instance of a ticker
         */
        add(fn, context3, priority = UPDATE_PRIORITY.NORMAL) {
          return this._addListener(new TickerListener(fn, context3, priority));
        }
        /**
         * Add a handler for the tick event which is only execute once.
         * @param fn - The listener function to be added for one update
         * @param context - The listener context
         * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting
         * @returns This instance of a ticker
         */
        addOnce(fn, context3, priority = UPDATE_PRIORITY.NORMAL) {
          return this._addListener(new TickerListener(fn, context3, priority, true));
        }
        /**
         * Internally adds the event handler so that it can be sorted by priority.
         * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
         * before the rendering.
         * @private
         * @param listener - Current listener being added.
         * @returns This instance of a ticker
         */
        _addListener(listener) {
          let current = this._head.next;
          let previous = this._head;
          if (!current) {
            listener.connect(previous);
          } else {
            while (current) {
              if (listener.priority > current.priority) {
                listener.connect(previous);
                break;
              }
              previous = current;
              current = current.next;
            }
            if (!listener.previous) {
              listener.connect(previous);
            }
          }
          this._startIfPossible();
          return this;
        }
        /**
         * Removes any handlers matching the function and context parameters.
         * If no handlers are left after removing, then it cancels the animation frame.
         * @param fn - The listener function to be removed
         * @param context - The listener context to be removed
         * @returns This instance of a ticker
         */
        remove(fn, context3) {
          let listener = this._head.next;
          while (listener) {
            if (listener.match(fn, context3)) {
              listener = listener.destroy();
            } else {
              listener = listener.next;
            }
          }
          if (!this._head.next) {
            this._cancelIfNeeded();
          }
          return this;
        }
        /**
         * The number of listeners on this ticker, calculated by walking through linked list
         * @readonly
         * @member {number}
         */
        get count() {
          if (!this._head) {
            return 0;
          }
          let count2 = 0;
          let current = this._head;
          while (current = current.next) {
            count2++;
          }
          return count2;
        }
        /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */
        start() {
          if (!this.started) {
            this.started = true;
            this._requestIfNeeded();
          }
        }
        /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */
        stop() {
          if (this.started) {
            this.started = false;
            this._cancelIfNeeded();
          }
        }
        /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */
        destroy() {
          if (!this._protected) {
            this.stop();
            let listener = this._head.next;
            while (listener) {
              listener = listener.destroy(true);
            }
            this._head.destroy();
            this._head = null;
          }
        }
        /**
         * Triggers an update. An update entails setting the
         * current {@link ticker.Ticker#elapsedMS|elapsedMS},
         * the current {@link ticker.Ticker#deltaTime|deltaTime},
         * invoking all listeners with current deltaTime,
         * and then finally setting {@link ticker.Ticker#lastTime|lastTime}
         * with the value of currentTime that was provided.
         * This method will be called automatically by animation
         * frame callbacks if the ticker instance has been started
         * and listeners are added.
         * @param {number} [currentTime=performance.now()] - the current time of execution
         */
        update(currentTime2 = performance.now()) {
          let elapsedMS;
          if (currentTime2 > this.lastTime) {
            elapsedMS = this.elapsedMS = currentTime2 - this.lastTime;
            if (elapsedMS > this._maxElapsedMS) {
              elapsedMS = this._maxElapsedMS;
            }
            elapsedMS *= this.speed;
            if (this._minElapsedMS) {
              const delta = currentTime2 - this._lastFrame | 0;
              if (delta < this._minElapsedMS) {
                return;
              }
              this._lastFrame = currentTime2 - delta % this._minElapsedMS;
            }
            this.deltaMS = elapsedMS;
            this.deltaTime = this.deltaMS * _Ticker2.targetFPMS;
            const head5 = this._head;
            let listener = head5.next;
            while (listener) {
              listener = listener.emit(this);
            }
            if (!head5.next) {
              this._cancelIfNeeded();
            }
          } else {
            this.deltaTime = this.deltaMS = this.elapsedMS = 0;
          }
          this.lastTime = currentTime2;
        }
        /**
         * The frames per second at which this ticker is running.
         * The default is approximately 60 in most modern browsers.
         * **Note:** This does not factor in the value of
         * {@link ticker.Ticker#speed|speed}, which is specific
         * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.
         * @member {number}
         * @readonly
         */
        get FPS() {
          return 1e3 / this.elapsedMS;
        }
        /**
         * Manages the maximum amount of milliseconds allowed to
         * elapse between invoking {@link ticker.Ticker#update|update}.
         * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},
         * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.
         * When setting this property it is clamped to a value between
         * `0` and `Ticker.targetFPMS * 1000`.
         * @member {number}
         * @default 10
         */
        get minFPS() {
          return 1e3 / this._maxElapsedMS;
        }
        set minFPS(fps) {
          const minFPS = Math.min(this.maxFPS, fps);
          const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker2.targetFPMS);
          this._maxElapsedMS = 1 / minFPMS;
        }
        /**
         * Manages the minimum amount of milliseconds required to
         * elapse between invoking {@link ticker.Ticker#update|update}.
         * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.
         * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
         * Otherwise it will be at least `minFPS`
         * @member {number}
         * @default 0
         */
        get maxFPS() {
          if (this._minElapsedMS) {
            return Math.round(1e3 / this._minElapsedMS);
          }
          return 0;
        }
        set maxFPS(fps) {
          if (fps === 0) {
            this._minElapsedMS = 0;
          } else {
            const maxFPS = Math.max(this.minFPS, fps);
            this._minElapsedMS = 1 / (maxFPS / 1e3);
          }
        }
        /**
         * The shared ticker instance used by {@link AnimatedSprite} and by
         * {@link VideoResource} to update animation frames / video textures.
         *
         * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.
         *
         * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.
         * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
         * @example
         * import { Ticker } from 'pixi.js';
         *
         * const ticker = Ticker.shared;
         * // Set this to prevent starting this ticker when listeners are added.
         * // By default this is true only for the Ticker.shared instance.
         * ticker.autoStart = false;
         *
         * // FYI, call this to ensure the ticker is stopped. It should be stopped
         * // if you have not attempted to render anything yet.
         * ticker.stop();
         *
         * // Call this when you are ready for a running shared ticker.
         * ticker.start();
         * @example
         * import { autoDetectRenderer, Container } from 'pixi.js';
         *
         * // You may use the shared ticker to render...
         * const renderer = autoDetectRenderer();
         * const stage = new Container();
         * document.body.appendChild(renderer.view);
         * ticker.add((time) => renderer.render(stage));
         *
         * // Or you can just update it manually.
         * ticker.autoStart = false;
         * ticker.stop();
         * const animate = (time) => {
         *     ticker.update(time);
         *     renderer.render(stage);
         *     requestAnimationFrame(animate);
         * };
         * animate(performance.now());
         * @member {ticker.Ticker}
         * @readonly
         * @static
         */
        static get shared() {
          if (!_Ticker2._shared) {
            const shared = _Ticker2._shared = new _Ticker2();
            shared.autoStart = true;
            shared._protected = true;
          }
          return _Ticker2._shared;
        }
        /**
         * The system ticker instance used by {@link BasePrepare} for core timing
         * functionality that shouldn't usually need to be paused, unlike the `shared`
         * ticker which drives visual animations and rendering which may want to be paused.
         *
         * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.
         * @member {ticker.Ticker}
         * @readonly
         * @static
         */
        static get system() {
          if (!_Ticker2._system) {
            const system = _Ticker2._system = new _Ticker2();
            system.autoStart = true;
            system._protected = true;
          }
          return _Ticker2._system;
        }
      };
      _Ticker.targetFPMS = 0.06;
      Ticker = _Ticker;
    }
  });

  // node_modules/pixi.js/lib/app/TickerPlugin.mjs
  var TickerPlugin;
  var init_TickerPlugin = __esm({
    "node_modules/pixi.js/lib/app/TickerPlugin.mjs"() {
      init_Extensions();
      init_const2();
      init_Ticker();
      TickerPlugin = class {
        /**
         * Initialize the plugin with scope of application instance
         * @static
         * @private
         * @param {object} [options] - See application options
         */
        static init(options2) {
          options2 = Object.assign({
            autoStart: true,
            sharedTicker: false
          }, options2);
          Object.defineProperty(
            this,
            "ticker",
            {
              set(ticker) {
                if (this._ticker) {
                  this._ticker.remove(this.render, this);
                }
                this._ticker = ticker;
                if (ticker) {
                  ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
                }
              },
              get() {
                return this._ticker;
              }
            }
          );
          this.stop = () => {
            this._ticker.stop();
          };
          this.start = () => {
            this._ticker.start();
          };
          this._ticker = null;
          this.ticker = options2.sharedTicker ? Ticker.shared : new Ticker();
          if (options2.autoStart) {
            this.start();
          }
        }
        /**
         * Clean up the ticker, scoped to application.
         * @static
         * @private
         */
        static destroy() {
          if (this._ticker) {
            const oldTicker = this._ticker;
            this.ticker = null;
            oldTicker.destroy();
          }
        }
      };
      TickerPlugin.extension = ExtensionType.Application;
    }
  });

  // node_modules/pixi.js/lib/app/init.mjs
  var init_init2 = __esm({
    "node_modules/pixi.js/lib/app/init.mjs"() {
      init_Extensions();
      init_ResizePlugin();
      init_TickerPlugin();
      extensions.add(ResizePlugin);
      extensions.add(TickerPlugin);
    }
  });

  // node_modules/pixi.js/lib/events/EventTicker.mjs
  var EventsTickerClass, EventsTicker;
  var init_EventTicker = __esm({
    "node_modules/pixi.js/lib/events/EventTicker.mjs"() {
      init_const2();
      init_Ticker();
      EventsTickerClass = class {
        constructor() {
          this.interactionFrequency = 10;
          this._deltaTime = 0;
          this._didMove = false;
          this._tickerAdded = false;
          this._pauseUpdate = true;
        }
        /**
         * Initializes the event ticker.
         * @param events - The event system.
         */
        init(events) {
          this.removeTickerListener();
          this.events = events;
          this.interactionFrequency = 10;
          this._deltaTime = 0;
          this._didMove = false;
          this._tickerAdded = false;
          this._pauseUpdate = true;
        }
        /** Whether to pause the update checks or not. */
        get pauseUpdate() {
          return this._pauseUpdate;
        }
        set pauseUpdate(paused2) {
          this._pauseUpdate = paused2;
        }
        /** Adds the ticker listener. */
        addTickerListener() {
          if (this._tickerAdded || !this.domElement) {
            return;
          }
          Ticker.system.add(this._tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);
          this._tickerAdded = true;
        }
        /** Removes the ticker listener. */
        removeTickerListener() {
          if (!this._tickerAdded) {
            return;
          }
          Ticker.system.remove(this._tickerUpdate, this);
          this._tickerAdded = false;
        }
        /** Sets flag to not fire extra events when the user has already moved there mouse */
        pointerMoved() {
          this._didMove = true;
        }
        /** Updates the state of interactive objects. */
        _update() {
          if (!this.domElement || this._pauseUpdate) {
            return;
          }
          if (this._didMove) {
            this._didMove = false;
            return;
          }
          const rootPointerEvent = this.events["_rootPointerEvent"];
          if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {
            return;
          }
          globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
            clientX: rootPointerEvent.clientX,
            clientY: rootPointerEvent.clientY,
            pointerType: rootPointerEvent.pointerType,
            pointerId: rootPointerEvent.pointerId
          }));
        }
        /**
         * Updates the state of interactive objects if at least {@link interactionFrequency}
         * milliseconds have passed since the last invocation.
         *
         * Invoked by a throttled ticker update from {@link Ticker.system}.
         * @param ticker - The throttled ticker.
         */
        _tickerUpdate(ticker) {
          this._deltaTime += ticker.deltaTime;
          if (this._deltaTime < this.interactionFrequency) {
            return;
          }
          this._deltaTime = 0;
          this._update();
        }
      };
      EventsTicker = new EventsTickerClass();
    }
  });

  // node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs
  var FederatedMouseEvent;
  var init_FederatedMouseEvent = __esm({
    "node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs"() {
      init_Point();
      init_FederatedEvent();
      FederatedMouseEvent = class extends FederatedEvent {
        constructor() {
          super(...arguments);
          this.client = new Point();
          this.movement = new Point();
          this.offset = new Point();
          this.global = new Point();
          this.screen = new Point();
        }
        /** @readonly */
        get clientX() {
          return this.client.x;
        }
        /** @readonly */
        get clientY() {
          return this.client.y;
        }
        /**
         * Alias for {@link FederatedMouseEvent.clientX this.clientX}.
         * @readonly
         */
        get x() {
          return this.clientX;
        }
        /**
         * Alias for {@link FederatedMouseEvent.clientY this.clientY}.
         * @readonly
         */
        get y() {
          return this.clientY;
        }
        /** @readonly */
        get movementX() {
          return this.movement.x;
        }
        /** @readonly */
        get movementY() {
          return this.movement.y;
        }
        /** @readonly */
        get offsetX() {
          return this.offset.x;
        }
        /** @readonly */
        get offsetY() {
          return this.offset.y;
        }
        /** @readonly */
        get globalX() {
          return this.global.x;
        }
        /** @readonly */
        get globalY() {
          return this.global.y;
        }
        /**
         * The pointer coordinates in the renderer's screen. Alias for {@code screen.x}.
         * @readonly
         */
        get screenX() {
          return this.screen.x;
        }
        /**
         * The pointer coordinates in the renderer's screen. Alias for {@code screen.y}.
         * @readonly
         */
        get screenY() {
          return this.screen.y;
        }
        /**
         * This will return the local coordinates of the specified container for this InteractionData
         * @param {Container} container - The Container that you would like the local
         *  coords off
         * @param {PointData} point - A Point object in which to store the value, optional (otherwise
         *  will create a new point)
         * @param {PointData} globalPos - A Point object containing your custom global coords, optional
         *  (otherwise will use the current global coords)
         * @returns - A point containing the coordinates of the InteractionData position relative
         *  to the Container
         */
        getLocalPosition(container, point, globalPos) {
          return container.worldTransform.applyInverse(globalPos || this.global, point);
        }
        /**
         * Whether the modifier key was pressed when this event natively occurred.
         * @param key - The modifier key.
         */
        getModifierState(key) {
          return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
        }
        /**
         * Not supported.
         * @param _typeArg
         * @param _canBubbleArg
         * @param _cancelableArg
         * @param _viewArg
         * @param _detailArg
         * @param _screenXArg
         * @param _screenYArg
         * @param _clientXArg
         * @param _clientYArg
         * @param _ctrlKeyArg
         * @param _altKeyArg
         * @param _shiftKeyArg
         * @param _metaKeyArg
         * @param _buttonArg
         * @param _relatedTargetArg
         * @deprecated since 7.0.0
         */
        // eslint-disable-next-line max-params
        initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
          throw new Error("Method not implemented.");
        }
      };
    }
  });

  // node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs
  var FederatedPointerEvent;
  var init_FederatedPointerEvent = __esm({
    "node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs"() {
      init_FederatedMouseEvent();
      FederatedPointerEvent = class extends FederatedMouseEvent {
        constructor() {
          super(...arguments);
          this.width = 0;
          this.height = 0;
          this.isPrimary = false;
        }
        // Only included for completeness for now
        getCoalescedEvents() {
          if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
            return [this];
          }
          return [];
        }
        // Only included for completeness for now
        getPredictedEvents() {
          throw new Error("getPredictedEvents is not supported!");
        }
      };
    }
  });

  // node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs
  var FederatedWheelEvent;
  var init_FederatedWheelEvent = __esm({
    "node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs"() {
      init_FederatedMouseEvent();
      FederatedWheelEvent = class extends FederatedMouseEvent {
        constructor() {
          super(...arguments);
          this.DOM_DELTA_PIXEL = 0;
          this.DOM_DELTA_LINE = 1;
          this.DOM_DELTA_PAGE = 2;
        }
      };
      FederatedWheelEvent.DOM_DELTA_PIXEL = 0;
      FederatedWheelEvent.DOM_DELTA_LINE = 1;
      FederatedWheelEvent.DOM_DELTA_PAGE = 2;
    }
  });

  // node_modules/pixi.js/lib/events/EventBoundary.mjs
  var PROPAGATION_LIMIT, tempHitLocation, tempLocalMapping, EventBoundary;
  var init_EventBoundary = __esm({
    "node_modules/pixi.js/lib/events/EventBoundary.mjs"() {
      init_eventemitter3();
      init_Point();
      init_warn();
      init_EventTicker();
      init_FederatedMouseEvent();
      init_FederatedPointerEvent();
      init_FederatedWheelEvent();
      PROPAGATION_LIMIT = 2048;
      tempHitLocation = new Point();
      tempLocalMapping = new Point();
      EventBoundary = class {
        /**
         * @param rootTarget - The holder of the event boundary.
         */
        constructor(rootTarget) {
          this.dispatch = new eventemitter3_default();
          this.moveOnAll = false;
          this.enableGlobalMoveEvents = true;
          this.mappingState = {
            trackingData: {}
          };
          this.eventPool = /* @__PURE__ */ new Map();
          this._allInteractiveElements = [];
          this._hitElements = [];
          this._isPointerMoveEvent = false;
          this.rootTarget = rootTarget;
          this.hitPruneFn = this.hitPruneFn.bind(this);
          this.hitTestFn = this.hitTestFn.bind(this);
          this.mapPointerDown = this.mapPointerDown.bind(this);
          this.mapPointerMove = this.mapPointerMove.bind(this);
          this.mapPointerOut = this.mapPointerOut.bind(this);
          this.mapPointerOver = this.mapPointerOver.bind(this);
          this.mapPointerUp = this.mapPointerUp.bind(this);
          this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
          this.mapWheel = this.mapWheel.bind(this);
          this.mappingTable = {};
          this.addEventMapping("pointerdown", this.mapPointerDown);
          this.addEventMapping("pointermove", this.mapPointerMove);
          this.addEventMapping("pointerout", this.mapPointerOut);
          this.addEventMapping("pointerleave", this.mapPointerOut);
          this.addEventMapping("pointerover", this.mapPointerOver);
          this.addEventMapping("pointerup", this.mapPointerUp);
          this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
          this.addEventMapping("wheel", this.mapWheel);
        }
        /**
         * Adds an event mapping for the event `type` handled by `fn`.
         *
         * Event mappings can be used to implement additional or custom events. They take an event
         * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events
         * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.
         *
         * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden
         * instead.
         * @param type - The type of upstream event to map.
         * @param fn - The mapping method. The context of this function must be bound manually, if desired.
         */
        addEventMapping(type, fn) {
          if (!this.mappingTable[type]) {
            this.mappingTable[type] = [];
          }
          this.mappingTable[type].push({
            fn,
            priority: 0
          });
          this.mappingTable[type].sort((a2, b2) => a2.priority - b2.priority);
        }
        /**
         * Dispatches the given event
         * @param e - The event to dispatch.
         * @param type - The type of event to dispatch. Defaults to `e.type`.
         */
        dispatchEvent(e2, type) {
          e2.propagationStopped = false;
          e2.propagationImmediatelyStopped = false;
          this.propagate(e2, type);
          this.dispatch.emit(type || e2.type, e2);
        }
        /**
         * Maps the given upstream event through the event boundary and propagates it downstream.
         * @param e - The event to map.
         */
        mapEvent(e2) {
          if (!this.rootTarget) {
            return;
          }
          const mappers = this.mappingTable[e2.type];
          if (mappers) {
            for (let i2 = 0, j2 = mappers.length; i2 < j2; i2++) {
              mappers[i2].fn(e2);
            }
          } else {
            warn2(`[EventBoundary]: Event mapping not defined for ${e2.type}`);
          }
        }
        /**
         * Finds the Container that is the target of a event at the given coordinates.
         *
         * The passed (x,y) coordinates are in the world space above this event boundary.
         * @param x - The x coordinate of the event.
         * @param y - The y coordinate of the event.
         */
        hitTest(x2, y2) {
          EventsTicker.pauseUpdate = true;
          const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;
          const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";
          const invertedPath = this[fn](
            this.rootTarget,
            this.rootTarget.eventMode,
            tempHitLocation.set(x2, y2),
            this.hitTestFn,
            this.hitPruneFn
          );
          return invertedPath && invertedPath[0];
        }
        /**
         * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its
         * target {@code e.target}.
         * @param e - The event to propagate.
         * @param type - The type of event to propagate. Defaults to `e.type`.
         */
        propagate(e2, type) {
          if (!e2.target) {
            return;
          }
          const composedPath = e2.composedPath();
          e2.eventPhase = e2.CAPTURING_PHASE;
          for (let i2 = 0, j2 = composedPath.length - 1; i2 < j2; i2++) {
            e2.currentTarget = composedPath[i2];
            this.notifyTarget(e2, type);
            if (e2.propagationStopped || e2.propagationImmediatelyStopped)
              return;
          }
          e2.eventPhase = e2.AT_TARGET;
          e2.currentTarget = e2.target;
          this.notifyTarget(e2, type);
          if (e2.propagationStopped || e2.propagationImmediatelyStopped)
            return;
          e2.eventPhase = e2.BUBBLING_PHASE;
          for (let i2 = composedPath.length - 2; i2 >= 0; i2--) {
            e2.currentTarget = composedPath[i2];
            this.notifyTarget(e2, type);
            if (e2.propagationStopped || e2.propagationImmediatelyStopped)
              return;
          }
        }
        /**
         * Emits the event {@code e} to all interactive containers. The event is propagated in the bubbling phase always.
         *
         * This is used in the `globalpointermove` event.
         * @param e - The emitted event.
         * @param type - The listeners to notify.
         * @param targets - The targets to notify.
         */
        all(e2, type, targets = this._allInteractiveElements) {
          if (targets.length === 0)
            return;
          e2.eventPhase = e2.BUBBLING_PHASE;
          const events = Array.isArray(type) ? type : [type];
          for (let i2 = targets.length - 1; i2 >= 0; i2--) {
            events.forEach((event) => {
              e2.currentTarget = targets[i2];
              this.notifyTarget(e2, event);
            });
          }
        }
        /**
         * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed
         * {@code target}. The last element in the path is {@code target}.
         * @param target - The target to find the propagation path to.
         */
        propagationPath(target5) {
          const propagationPath = [target5];
          for (let i2 = 0; i2 < PROPAGATION_LIMIT && (target5 !== this.rootTarget && target5.parent); i2++) {
            if (!target5.parent) {
              throw new Error("Cannot find propagation path to disconnected target");
            }
            propagationPath.push(target5.parent);
            target5 = target5.parent;
          }
          propagationPath.reverse();
          return propagationPath;
        }
        hitTestMoveRecursive(currentTarget, eventMode, location2, testFn, pruneFn, ignore = false) {
          let shouldReturn = false;
          if (this._interactivePrune(currentTarget))
            return null;
          if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
            EventsTicker.pauseUpdate = false;
          }
          if (currentTarget.interactiveChildren && currentTarget.children) {
            const children2 = currentTarget.children;
            for (let i2 = children2.length - 1; i2 >= 0; i2--) {
              const child = children2[i2];
              const nestedHit = this.hitTestMoveRecursive(
                child,
                this._isInteractive(eventMode) ? eventMode : child.eventMode,
                location2,
                testFn,
                pruneFn,
                ignore || pruneFn(currentTarget, location2)
              );
              if (nestedHit) {
                if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                  continue;
                }
                const isInteractive = currentTarget.isInteractive();
                if (nestedHit.length > 0 || isInteractive) {
                  if (isInteractive)
                    this._allInteractiveElements.push(currentTarget);
                  nestedHit.push(currentTarget);
                }
                if (this._hitElements.length === 0)
                  this._hitElements = nestedHit;
                shouldReturn = true;
              }
            }
          }
          const isInteractiveMode = this._isInteractive(eventMode);
          const isInteractiveTarget = currentTarget.isInteractive();
          if (isInteractiveTarget && isInteractiveTarget)
            this._allInteractiveElements.push(currentTarget);
          if (ignore || this._hitElements.length > 0)
            return null;
          if (shouldReturn)
            return this._hitElements;
          if (isInteractiveMode && (!pruneFn(currentTarget, location2) && testFn(currentTarget, location2))) {
            return isInteractiveTarget ? [currentTarget] : [];
          }
          return null;
        }
        /**
         * Recursive implementation for {@link EventBoundary.hitTest hitTest}.
         * @param currentTarget - The Container that is to be hit tested.
         * @param eventMode - The event mode for the `currentTarget` or one of its parents.
         * @param location - The location that is being tested for overlap.
         * @param testFn - Callback that determines whether the target passes hit testing. This callback
         *  can assume that `pruneFn` failed to prune the container.
         * @param pruneFn - Callback that determiness whether the target and all of its children
         *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees
         *  of the scene graph.
         * @returns An array holding the hit testing target and all its ancestors in order. The first element
         *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite
         *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.
         */
        hitTestRecursive(currentTarget, eventMode, location2, testFn, pruneFn) {
          if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location2)) {
            return null;
          }
          if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
            EventsTicker.pauseUpdate = false;
          }
          if (currentTarget.interactiveChildren && currentTarget.children) {
            const children2 = currentTarget.children;
            const relativeLocation = location2;
            for (let i2 = children2.length - 1; i2 >= 0; i2--) {
              const child = children2[i2];
              const nestedHit = this.hitTestRecursive(
                child,
                this._isInteractive(eventMode) ? eventMode : child.eventMode,
                relativeLocation,
                testFn,
                pruneFn
              );
              if (nestedHit) {
                if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                  continue;
                }
                const isInteractive = currentTarget.isInteractive();
                if (nestedHit.length > 0 || isInteractive)
                  nestedHit.push(currentTarget);
                return nestedHit;
              }
            }
          }
          const isInteractiveMode = this._isInteractive(eventMode);
          const isInteractiveTarget = currentTarget.isInteractive();
          if (isInteractiveMode && testFn(currentTarget, location2)) {
            return isInteractiveTarget ? [currentTarget] : [];
          }
          return null;
        }
        _isInteractive(int) {
          return int === "static" || int === "dynamic";
        }
        _interactivePrune(container) {
          if (!container || !container.visible || !container.renderable || !container.includeInBuild || !container.measurable) {
            return true;
          }
          if (container.eventMode === "none") {
            return true;
          }
          if (container.eventMode === "passive" && !container.interactiveChildren) {
            return true;
          }
          return false;
        }
        /**
         * Checks whether the container or any of its children cannot pass the hit test at all.
         *
         * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}
         * and {@link Container._maskEffect} for pruning.
         * @param container - The container to prune.
         * @param location - The location to test for overlap.
         */
        hitPruneFn(container, location2) {
          if (container.hitArea) {
            container.worldTransform.applyInverse(location2, tempLocalMapping);
            if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {
              return true;
            }
          }
          if (container.effects && container.effects.length) {
            for (let i2 = 0; i2 < container.effects.length; i2++) {
              const effect = container.effects[i2];
              if (effect.containsPoint) {
                const effectContainsPoint = effect.containsPoint(location2, this.hitTestFn);
                if (!effectContainsPoint) {
                  return true;
                }
              }
            }
          }
          return false;
        }
        /**
         * Checks whether the container passes hit testing for the given location.
         * @param container - The container to test.
         * @param location - The location to test for overlap.
         * @returns - Whether `container` passes hit testing for `location`.
         */
        hitTestFn(container, location2) {
          if (container.hitArea) {
            return true;
          }
          if (container?.containsPoint) {
            container.worldTransform.applyInverse(location2, tempLocalMapping);
            return container.containsPoint(tempLocalMapping);
          }
          return false;
        }
        /**
         * Notify all the listeners to the event's `currentTarget`.
         *
         * If the `currentTarget` contains the property `on<type>`, then it is called here,
         * simulating the behavior from version 6.x and prior.
         * @param e - The event passed to the target.
         * @param type - The type of event to notify. Defaults to `e.type`.
         */
        notifyTarget(e2, type) {
          if (!e2.currentTarget.isInteractive()) {
            return;
          }
          type = type ?? e2.type;
          const handlerKey = `on${type}`;
          e2.currentTarget[handlerKey]?.(e2);
          const key = e2.eventPhase === e2.CAPTURING_PHASE || e2.eventPhase === e2.AT_TARGET ? `${type}capture` : type;
          this._notifyListeners(e2, key);
          if (e2.eventPhase === e2.AT_TARGET) {
            this._notifyListeners(e2, type);
          }
        }
        /**
         * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.
         *
         * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.
         * @param from - The upstream `pointerdown` event.
         */
        mapPointerDown(from3) {
          if (!(from3 instanceof FederatedPointerEvent)) {
            warn2("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const e2 = this.createPointerEvent(from3);
          this.dispatchEvent(e2, "pointerdown");
          if (e2.pointerType === "touch") {
            this.dispatchEvent(e2, "touchstart");
          } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
            const isRightButton = e2.button === 2;
            this.dispatchEvent(e2, isRightButton ? "rightdown" : "mousedown");
          }
          const trackingData = this.trackingData(from3.pointerId);
          trackingData.pressTargetsByButton[from3.button] = e2.composedPath();
          this.freeEvent(e2);
        }
        /**
         * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.
         *
         * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,
         * `mousemove`, and `touchmove` events are fired as well for specific pointer types.
         * @param from - The upstream `pointermove` event.
         */
        mapPointerMove(from3) {
          if (!(from3 instanceof FederatedPointerEvent)) {
            warn2("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          this._allInteractiveElements.length = 0;
          this._hitElements.length = 0;
          this._isPointerMoveEvent = true;
          const e2 = this.createPointerEvent(from3);
          this._isPointerMoveEvent = false;
          const isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
          const trackingData = this.trackingData(from3.pointerId);
          const outTarget = this.findMountedTarget(trackingData.overTargets);
          if (trackingData.overTargets?.length > 0 && outTarget !== e2.target) {
            const outType = from3.type === "mousemove" ? "mouseout" : "pointerout";
            const outEvent = this.createPointerEvent(from3, outType, outTarget);
            this.dispatchEvent(outEvent, "pointerout");
            if (isMouse)
              this.dispatchEvent(outEvent, "mouseout");
            if (!e2.composedPath().includes(outTarget)) {
              const leaveEvent = this.createPointerEvent(from3, "pointerleave", outTarget);
              leaveEvent.eventPhase = leaveEvent.AT_TARGET;
              while (leaveEvent.target && !e2.composedPath().includes(leaveEvent.target)) {
                leaveEvent.currentTarget = leaveEvent.target;
                this.notifyTarget(leaveEvent);
                if (isMouse)
                  this.notifyTarget(leaveEvent, "mouseleave");
                leaveEvent.target = leaveEvent.target.parent;
              }
              this.freeEvent(leaveEvent);
            }
            this.freeEvent(outEvent);
          }
          if (outTarget !== e2.target) {
            const overType = from3.type === "mousemove" ? "mouseover" : "pointerover";
            const overEvent = this.clonePointerEvent(e2, overType);
            this.dispatchEvent(overEvent, "pointerover");
            if (isMouse)
              this.dispatchEvent(overEvent, "mouseover");
            let overTargetAncestor = outTarget?.parent;
            while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
              if (overTargetAncestor === e2.target)
                break;
              overTargetAncestor = overTargetAncestor.parent;
            }
            const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
            if (didPointerEnter) {
              const enterEvent = this.clonePointerEvent(e2, "pointerenter");
              enterEvent.eventPhase = enterEvent.AT_TARGET;
              while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {
                enterEvent.currentTarget = enterEvent.target;
                this.notifyTarget(enterEvent);
                if (isMouse)
                  this.notifyTarget(enterEvent, "mouseenter");
                enterEvent.target = enterEvent.target.parent;
              }
              this.freeEvent(enterEvent);
            }
            this.freeEvent(overEvent);
          }
          const allMethods = [];
          const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
          this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e2, "pointermove");
          allowGlobalPointerEvents && allMethods.push("globalpointermove");
          if (e2.pointerType === "touch") {
            this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e2, "touchmove");
            allowGlobalPointerEvents && allMethods.push("globaltouchmove");
          }
          if (isMouse) {
            this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e2, "mousemove");
            allowGlobalPointerEvents && allMethods.push("globalmousemove");
            this.cursor = e2.target?.cursor;
          }
          if (allMethods.length > 0) {
            this.all(e2, allMethods);
          }
          this._allInteractiveElements.length = 0;
          this._hitElements.length = 0;
          trackingData.overTargets = e2.composedPath();
          this.freeEvent(e2);
        }
        /**
         * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.
         *
         * The tracking data for the specific pointer gets a new `overTarget`.
         * @param from - The upstream `pointerover` event.
         */
        mapPointerOver(from3) {
          if (!(from3 instanceof FederatedPointerEvent)) {
            warn2("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const trackingData = this.trackingData(from3.pointerId);
          const e2 = this.createPointerEvent(from3);
          const isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
          this.dispatchEvent(e2, "pointerover");
          if (isMouse)
            this.dispatchEvent(e2, "mouseover");
          if (e2.pointerType === "mouse")
            this.cursor = e2.target?.cursor;
          const enterEvent = this.clonePointerEvent(e2, "pointerenter");
          enterEvent.eventPhase = enterEvent.AT_TARGET;
          while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
            enterEvent.currentTarget = enterEvent.target;
            this.notifyTarget(enterEvent);
            if (isMouse)
              this.notifyTarget(enterEvent, "mouseenter");
            enterEvent.target = enterEvent.target.parent;
          }
          trackingData.overTargets = e2.composedPath();
          this.freeEvent(e2);
          this.freeEvent(enterEvent);
        }
        /**
         * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.
         *
         * The tracking data for the specific pointer is cleared of a `overTarget`.
         * @param from - The upstream `pointerout` event.
         */
        mapPointerOut(from3) {
          if (!(from3 instanceof FederatedPointerEvent)) {
            warn2("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const trackingData = this.trackingData(from3.pointerId);
          if (trackingData.overTargets) {
            const isMouse = from3.pointerType === "mouse" || from3.pointerType === "pen";
            const outTarget = this.findMountedTarget(trackingData.overTargets);
            const outEvent = this.createPointerEvent(from3, "pointerout", outTarget);
            this.dispatchEvent(outEvent);
            if (isMouse)
              this.dispatchEvent(outEvent, "mouseout");
            const leaveEvent = this.createPointerEvent(from3, "pointerleave", outTarget);
            leaveEvent.eventPhase = leaveEvent.AT_TARGET;
            while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
              leaveEvent.currentTarget = leaveEvent.target;
              this.notifyTarget(leaveEvent);
              if (isMouse)
                this.notifyTarget(leaveEvent, "mouseleave");
              leaveEvent.target = leaveEvent.target.parent;
            }
            trackingData.overTargets = null;
            this.freeEvent(outEvent);
            this.freeEvent(leaveEvent);
          }
          this.cursor = null;
        }
        /**
         * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,
         * and `click`/`rightclick`/`pointertap` events, in that order.
         *
         * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific
         * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,
         * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for
         * specific pointer types.
         * @param from - The upstream `pointerup` event.
         */
        mapPointerUp(from3) {
          if (!(from3 instanceof FederatedPointerEvent)) {
            warn2("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const now3 = performance.now();
          const e2 = this.createPointerEvent(from3);
          this.dispatchEvent(e2, "pointerup");
          if (e2.pointerType === "touch") {
            this.dispatchEvent(e2, "touchend");
          } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
            const isRightButton = e2.button === 2;
            this.dispatchEvent(e2, isRightButton ? "rightup" : "mouseup");
          }
          const trackingData = this.trackingData(from3.pointerId);
          const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from3.button]);
          let clickTarget = pressTarget;
          if (pressTarget && !e2.composedPath().includes(pressTarget)) {
            let currentTarget = pressTarget;
            while (currentTarget && !e2.composedPath().includes(currentTarget)) {
              e2.currentTarget = currentTarget;
              this.notifyTarget(e2, "pointerupoutside");
              if (e2.pointerType === "touch") {
                this.notifyTarget(e2, "touchendoutside");
              } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
                const isRightButton = e2.button === 2;
                this.notifyTarget(e2, isRightButton ? "rightupoutside" : "mouseupoutside");
              }
              currentTarget = currentTarget.parent;
            }
            delete trackingData.pressTargetsByButton[from3.button];
            clickTarget = currentTarget;
          }
          if (clickTarget) {
            const clickEvent = this.clonePointerEvent(e2, "click");
            clickEvent.target = clickTarget;
            clickEvent.path = null;
            if (!trackingData.clicksByButton[from3.button]) {
              trackingData.clicksByButton[from3.button] = {
                clickCount: 0,
                target: clickEvent.target,
                timeStamp: now3
              };
            }
            const clickHistory = trackingData.clicksByButton[from3.button];
            if (clickHistory.target === clickEvent.target && now3 - clickHistory.timeStamp < 200) {
              ++clickHistory.clickCount;
            } else {
              clickHistory.clickCount = 1;
            }
            clickHistory.target = clickEvent.target;
            clickHistory.timeStamp = now3;
            clickEvent.detail = clickHistory.clickCount;
            if (clickEvent.pointerType === "mouse") {
              const isRightButton = clickEvent.button === 2;
              this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
            } else if (clickEvent.pointerType === "touch") {
              this.dispatchEvent(clickEvent, "tap");
            }
            this.dispatchEvent(clickEvent, "pointertap");
            this.freeEvent(clickEvent);
          }
          this.freeEvent(e2);
        }
        /**
         * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original
         * `pointerdown` target to `rootTarget`.
         *
         * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the
         * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)
         *
         * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer
         * types. The tracking data for the specific pointer is cleared of a `pressTarget`.
         * @param from - The upstream `pointerupoutside` event.
         */
        mapPointerUpOutside(from3) {
          if (!(from3 instanceof FederatedPointerEvent)) {
            warn2("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const trackingData = this.trackingData(from3.pointerId);
          const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from3.button]);
          const e2 = this.createPointerEvent(from3);
          if (pressTarget) {
            let currentTarget = pressTarget;
            while (currentTarget) {
              e2.currentTarget = currentTarget;
              this.notifyTarget(e2, "pointerupoutside");
              if (e2.pointerType === "touch") {
                this.notifyTarget(e2, "touchendoutside");
              } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
                this.notifyTarget(e2, e2.button === 2 ? "rightupoutside" : "mouseupoutside");
              }
              currentTarget = currentTarget.parent;
            }
            delete trackingData.pressTargetsByButton[from3.button];
          }
          this.freeEvent(e2);
        }
        /**
         * Maps the upstream `wheel` event to a downstream `wheel` event.
         * @param from - The upstream `wheel` event.
         */
        mapWheel(from3) {
          if (!(from3 instanceof FederatedWheelEvent)) {
            warn2("EventBoundary cannot map a non-wheel event as a wheel event");
            return;
          }
          const wheelEvent = this.createWheelEvent(from3);
          this.dispatchEvent(wheelEvent);
          this.freeEvent(wheelEvent);
        }
        /**
         * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.
         *
         * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`
         * or `pointerover` target was unmounted from the scene graph.
         * @param propagationPath - The propagation path was valid in the past.
         * @returns - The most specific event-target still mounted at the same location in the scene graph.
         */
        findMountedTarget(propagationPath) {
          if (!propagationPath) {
            return null;
          }
          let currentTarget = propagationPath[0];
          for (let i2 = 1; i2 < propagationPath.length; i2++) {
            if (propagationPath[i2].parent === currentTarget) {
              currentTarget = propagationPath[i2];
            } else {
              break;
            }
          }
          return currentTarget;
        }
        /**
         * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.
         *
         * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
         * @param from - The {@code originalEvent} for the returned event.
         * @param [type=from.type] - The type of the returned event.
         * @param target - The target of the returned event.
         */
        createPointerEvent(from3, type, target5) {
          const event = this.allocateEvent(FederatedPointerEvent);
          this.copyPointerData(from3, event);
          this.copyMouseData(from3, event);
          this.copyData(from3, event);
          event.nativeEvent = from3.nativeEvent;
          event.originalEvent = from3;
          event.target = target5 ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];
          if (typeof type === "string") {
            event.type = type;
          }
          return event;
        }
        /**
         * Creates a wheel event whose {@code originalEvent} is {@code from}.
         *
         * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
         * @param from - The upstream wheel event.
         */
        createWheelEvent(from3) {
          const event = this.allocateEvent(FederatedWheelEvent);
          this.copyWheelData(from3, event);
          this.copyMouseData(from3, event);
          this.copyData(from3, event);
          event.nativeEvent = from3.nativeEvent;
          event.originalEvent = from3;
          event.target = this.hitTest(event.global.x, event.global.y);
          return event;
        }
        /**
         * Clones the event {@code from}, with an optional {@code type} override.
         *
         * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
         * @param from - The event to clone.
         * @param [type=from.type] - The type of the returned event.
         */
        clonePointerEvent(from3, type) {
          const event = this.allocateEvent(FederatedPointerEvent);
          event.nativeEvent = from3.nativeEvent;
          event.originalEvent = from3.originalEvent;
          this.copyPointerData(from3, event);
          this.copyMouseData(from3, event);
          this.copyData(from3, event);
          event.target = from3.target;
          event.path = from3.composedPath().slice();
          event.type = type ?? event.type;
          return event;
        }
        /**
         * Copies wheel {@link FederatedWheelEvent} data from {@code from} into {@code to}.
         *
         * The following properties are copied:
         * + deltaMode
         * + deltaX
         * + deltaY
         * + deltaZ
         * @param from - The event to copy data from.
         * @param to - The event to copy data into.
         */
        copyWheelData(from3, to3) {
          to3.deltaMode = from3.deltaMode;
          to3.deltaX = from3.deltaX;
          to3.deltaY = from3.deltaY;
          to3.deltaZ = from3.deltaZ;
        }
        /**
         * Copies pointer {@link FederatedPointerEvent} data from {@code from} into {@code to}.
         *
         * The following properties are copied:
         * + pointerId
         * + width
         * + height
         * + isPrimary
         * + pointerType
         * + pressure
         * + tangentialPressure
         * + tiltX
         * + tiltY
         * @param from - The event to copy data from.
         * @param to - The event to copy data into.
         */
        copyPointerData(from3, to3) {
          if (!(from3 instanceof FederatedPointerEvent && to3 instanceof FederatedPointerEvent))
            return;
          to3.pointerId = from3.pointerId;
          to3.width = from3.width;
          to3.height = from3.height;
          to3.isPrimary = from3.isPrimary;
          to3.pointerType = from3.pointerType;
          to3.pressure = from3.pressure;
          to3.tangentialPressure = from3.tangentialPressure;
          to3.tiltX = from3.tiltX;
          to3.tiltY = from3.tiltY;
          to3.twist = from3.twist;
        }
        /**
         * Copies mouse {@link FederatedMouseEvent} data from {@code from} to {@code to}.
         *
         * The following properties are copied:
         * + altKey
         * + button
         * + buttons
         * + clientX
         * + clientY
         * + metaKey
         * + movementX
         * + movementY
         * + pageX
         * + pageY
         * + x
         * + y
         * + screen
         * + shiftKey
         * + global
         * @param from - The event to copy data from.
         * @param to - The event to copy data into.
         */
        copyMouseData(from3, to3) {
          if (!(from3 instanceof FederatedMouseEvent && to3 instanceof FederatedMouseEvent))
            return;
          to3.altKey = from3.altKey;
          to3.button = from3.button;
          to3.buttons = from3.buttons;
          to3.client.copyFrom(from3.client);
          to3.ctrlKey = from3.ctrlKey;
          to3.metaKey = from3.metaKey;
          to3.movement.copyFrom(from3.movement);
          to3.screen.copyFrom(from3.screen);
          to3.shiftKey = from3.shiftKey;
          to3.global.copyFrom(from3.global);
        }
        /**
         * Copies base {@link FederatedEvent} data from {@code from} into {@code to}.
         *
         * The following properties are copied:
         * + isTrusted
         * + srcElement
         * + timeStamp
         * + type
         * @param from - The event to copy data from.
         * @param to - The event to copy data into.
         */
        copyData(from3, to3) {
          to3.isTrusted = from3.isTrusted;
          to3.srcElement = from3.srcElement;
          to3.timeStamp = performance.now();
          to3.type = from3.type;
          to3.detail = from3.detail;
          to3.view = from3.view;
          to3.which = from3.which;
          to3.layer.copyFrom(from3.layer);
          to3.page.copyFrom(from3.page);
        }
        /**
         * @param id - The pointer ID.
         * @returns The tracking data stored for the given pointer. If no data exists, a blank
         *  state will be created.
         */
        trackingData(id5) {
          if (!this.mappingState.trackingData[id5]) {
            this.mappingState.trackingData[id5] = {
              pressTargetsByButton: {},
              clicksByButton: {},
              overTarget: null
            };
          }
          return this.mappingState.trackingData[id5];
        }
        /**
         * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.
         *
         * This allocation is constructor-agnostic, as long as it only takes one argument - this event
         * boundary.
         * @param constructor - The event's constructor.
         */
        allocateEvent(constructor) {
          if (!this.eventPool.has(constructor)) {
            this.eventPool.set(constructor, []);
          }
          const event = this.eventPool.get(constructor).pop() || new constructor(this);
          event.eventPhase = event.NONE;
          event.currentTarget = null;
          event.defaultPrevented = false;
          event.path = null;
          event.target = null;
          return event;
        }
        /**
         * Frees the event and puts it back into the event pool.
         *
         * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.
         *
         * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}
         * not be freed. This is because of the possibility that the same event is freed twice, which can cause
         * it to be allocated twice & result in overwriting.
         * @param event - The event to be freed.
         * @throws Error if the event is managed by another event boundary.
         */
        freeEvent(event) {
          if (event.manager !== this)
            throw new Error("It is illegal to free an event not managed by this EventBoundary!");
          const constructor = event.constructor;
          if (!this.eventPool.has(constructor)) {
            this.eventPool.set(constructor, []);
          }
          this.eventPool.get(constructor).push(event);
        }
        /**
         * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag
         * is set on the event.
         * @param e - The event to call each listener with.
         * @param type - The event key.
         */
        _notifyListeners(e2, type) {
          const listeners = e2.currentTarget._events[type];
          if (!listeners)
            return;
          if ("fn" in listeners) {
            if (listeners.once)
              e2.currentTarget.removeListener(type, listeners.fn, void 0, true);
            listeners.fn.call(listeners.context, e2);
          } else {
            for (let i2 = 0, j2 = listeners.length; i2 < j2 && !e2.propagationImmediatelyStopped; i2++) {
              if (listeners[i2].once)
                e2.currentTarget.removeListener(type, listeners[i2].fn, void 0, true);
              listeners[i2].fn.call(listeners[i2].context, e2);
            }
          }
        }
      };
    }
  });

  // node_modules/pixi.js/lib/events/EventSystem.mjs
  var MOUSE_POINTER_ID, TOUCH_TO_POINTER, _EventSystem, EventSystem;
  var init_EventSystem = __esm({
    "node_modules/pixi.js/lib/events/EventSystem.mjs"() {
      init_Extensions();
      init_EventBoundary();
      init_EventTicker();
      init_FederatedPointerEvent();
      init_FederatedWheelEvent();
      MOUSE_POINTER_ID = 1;
      TOUCH_TO_POINTER = {
        touchstart: "pointerdown",
        touchend: "pointerup",
        touchendoutside: "pointerupoutside",
        touchmove: "pointermove",
        touchcancel: "pointercancel"
      };
      _EventSystem = class _EventSystem2 {
        /**
         * @param {Renderer} renderer
         */
        constructor(renderer) {
          this.supportsTouchEvents = "ontouchstart" in globalThis;
          this.supportsPointerEvents = !!globalThis.PointerEvent;
          this.domElement = null;
          this.resolution = 1;
          this.renderer = renderer;
          this.rootBoundary = new EventBoundary(null);
          EventsTicker.init(this);
          this.autoPreventDefault = true;
          this._eventsAdded = false;
          this._rootPointerEvent = new FederatedPointerEvent(null);
          this._rootWheelEvent = new FederatedWheelEvent(null);
          this.cursorStyles = {
            default: "inherit",
            pointer: "pointer"
          };
          this.features = new Proxy({ ..._EventSystem2.defaultEventFeatures }, {
            set: (target5, key, value12) => {
              if (key === "globalMove") {
                this.rootBoundary.enableGlobalMoveEvents = value12;
              }
              target5[key] = value12;
              return true;
            }
          });
          this._onPointerDown = this._onPointerDown.bind(this);
          this._onPointerMove = this._onPointerMove.bind(this);
          this._onPointerUp = this._onPointerUp.bind(this);
          this._onPointerOverOut = this._onPointerOverOut.bind(this);
          this.onWheel = this.onWheel.bind(this);
        }
        /**
         * The default interaction mode for all display objects.
         * @see Container.eventMode
         * @type {EventMode}
         * @readonly
         * @since 7.2.0
         */
        static get defaultEventMode() {
          return this._defaultEventMode;
        }
        /**
         * Runner init called, view is available at this point.
         * @ignore
         */
        init(options2) {
          const { canvas: canvas2, resolution } = this.renderer;
          this.setTargetElement(canvas2);
          this.resolution = resolution;
          _EventSystem2._defaultEventMode = options2.eventMode ?? "passive";
          Object.assign(this.features, options2.eventFeatures ?? {});
          this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
        }
        /**
         * Handle changing resolution.
         * @ignore
         */
        resolutionChange(resolution) {
          this.resolution = resolution;
        }
        /** Destroys all event listeners and detaches the renderer. */
        destroy() {
          this.setTargetElement(null);
          this.renderer = null;
          this._currentCursor = null;
        }
        /**
         * Sets the current cursor mode, handling any callbacks or CSS style changes.
         * @param mode - cursor mode, a key from the cursorStyles dictionary
         */
        setCursor(mode) {
          mode = mode || "default";
          let applyStyles = true;
          if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
            applyStyles = false;
          }
          if (this._currentCursor === mode) {
            return;
          }
          this._currentCursor = mode;
          const style3 = this.cursorStyles[mode];
          if (style3) {
            switch (typeof style3) {
              case "string":
                if (applyStyles) {
                  this.domElement.style.cursor = style3;
                }
                break;
              case "function":
                style3(mode);
                break;
              case "object":
                if (applyStyles) {
                  Object.assign(this.domElement.style, style3);
                }
                break;
            }
          } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
            this.domElement.style.cursor = mode;
          }
        }
        /**
         * The global pointer event.
         * Useful for getting the pointer position without listening to events.
         * @since 7.2.0
         */
        get pointer() {
          return this._rootPointerEvent;
        }
        /**
         * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.
         * @param nativeEvent - The native mouse/pointer/touch event.
         */
        _onPointerDown(nativeEvent) {
          if (!this.features.click)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          const events = this._normalizeToPointerData(nativeEvent);
          if (this.autoPreventDefault && events[0].isNormalized) {
            const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
            if (cancelable) {
              nativeEvent.preventDefault();
            }
          }
          for (let i2 = 0, j2 = events.length; i2 < j2; i2++) {
            const nativeEvent2 = events[i2];
            const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent2);
            this.rootBoundary.mapEvent(federatedEvent);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        /**
         * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.
         * @param nativeEvent - The native mouse/pointer/touch events.
         */
        _onPointerMove(nativeEvent) {
          if (!this.features.move)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          EventsTicker.pointerMoved();
          const normalizedEvents = this._normalizeToPointerData(nativeEvent);
          for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
            this.rootBoundary.mapEvent(event);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        /**
         * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.
         * @param nativeEvent - The native mouse/pointer/touch event.
         */
        _onPointerUp(nativeEvent) {
          if (!this.features.click)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          let target5 = nativeEvent.target;
          if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
            target5 = nativeEvent.composedPath()[0];
          }
          const outside = target5 !== this.domElement ? "outside" : "";
          const normalizedEvents = this._normalizeToPointerData(nativeEvent);
          for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
            event.type += outside;
            this.rootBoundary.mapEvent(event);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        /**
         * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.
         * @param nativeEvent - The native mouse/pointer/touch event.
         */
        _onPointerOverOut(nativeEvent) {
          if (!this.features.click)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          const normalizedEvents = this._normalizeToPointerData(nativeEvent);
          for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
            this.rootBoundary.mapEvent(event);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        /**
         * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.
         * @param nativeEvent - The native wheel event.
         */
        onWheel(nativeEvent) {
          if (!this.features.wheel)
            return;
          const wheelEvent = this.normalizeWheelEvent(nativeEvent);
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          this.rootBoundary.mapEvent(wheelEvent);
        }
        /**
         * Sets the {@link EventSystem#domElement domElement} and binds event listeners.
         *
         * To deregister the current DOM element without setting a new one, pass {@code null}.
         * @param element - The new DOM element.
         */
        setTargetElement(element) {
          this._removeEvents();
          this.domElement = element;
          EventsTicker.domElement = element;
          this._addEvents();
        }
        /** Register event listeners on {@link Renderer#domElement this.domElement}. */
        _addEvents() {
          if (this._eventsAdded || !this.domElement) {
            return;
          }
          EventsTicker.addTickerListener();
          const style3 = this.domElement.style;
          if (style3) {
            if (globalThis.navigator.msPointerEnabled) {
              style3.msContentZooming = "none";
              style3.msTouchAction = "none";
            } else if (this.supportsPointerEvents) {
              style3.touchAction = "none";
            }
          }
          if (this.supportsPointerEvents) {
            globalThis.document.addEventListener("pointermove", this._onPointerMove, true);
            this.domElement.addEventListener("pointerdown", this._onPointerDown, true);
            this.domElement.addEventListener("pointerleave", this._onPointerOverOut, true);
            this.domElement.addEventListener("pointerover", this._onPointerOverOut, true);
            globalThis.addEventListener("pointerup", this._onPointerUp, true);
          } else {
            globalThis.document.addEventListener("mousemove", this._onPointerMove, true);
            this.domElement.addEventListener("mousedown", this._onPointerDown, true);
            this.domElement.addEventListener("mouseout", this._onPointerOverOut, true);
            this.domElement.addEventListener("mouseover", this._onPointerOverOut, true);
            globalThis.addEventListener("mouseup", this._onPointerUp, true);
            if (this.supportsTouchEvents) {
              this.domElement.addEventListener("touchstart", this._onPointerDown, true);
              this.domElement.addEventListener("touchend", this._onPointerUp, true);
              this.domElement.addEventListener("touchmove", this._onPointerMove, true);
            }
          }
          this.domElement.addEventListener("wheel", this.onWheel, {
            passive: true,
            capture: true
          });
          this._eventsAdded = true;
        }
        /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */
        _removeEvents() {
          if (!this._eventsAdded || !this.domElement) {
            return;
          }
          EventsTicker.removeTickerListener();
          const style3 = this.domElement.style;
          if (style3) {
            if (globalThis.navigator.msPointerEnabled) {
              style3.msContentZooming = "";
              style3.msTouchAction = "";
            } else if (this.supportsPointerEvents) {
              style3.touchAction = "";
            }
          }
          if (this.supportsPointerEvents) {
            globalThis.document.removeEventListener("pointermove", this._onPointerMove, true);
            this.domElement.removeEventListener("pointerdown", this._onPointerDown, true);
            this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, true);
            this.domElement.removeEventListener("pointerover", this._onPointerOverOut, true);
            globalThis.removeEventListener("pointerup", this._onPointerUp, true);
          } else {
            globalThis.document.removeEventListener("mousemove", this._onPointerMove, true);
            this.domElement.removeEventListener("mousedown", this._onPointerDown, true);
            this.domElement.removeEventListener("mouseout", this._onPointerOverOut, true);
            this.domElement.removeEventListener("mouseover", this._onPointerOverOut, true);
            globalThis.removeEventListener("mouseup", this._onPointerUp, true);
            if (this.supportsTouchEvents) {
              this.domElement.removeEventListener("touchstart", this._onPointerDown, true);
              this.domElement.removeEventListener("touchend", this._onPointerUp, true);
              this.domElement.removeEventListener("touchmove", this._onPointerMove, true);
            }
          }
          this.domElement.removeEventListener("wheel", this.onWheel, true);
          this.domElement = null;
          this._eventsAdded = false;
        }
        /**
         * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The
         * resulting value is stored in the point. This takes into account the fact that the DOM
         * element could be scaled and positioned anywhere on the screen.
         * @param  {PointData} point - the point that the result will be stored in
         * @param  {number} x - the x coord of the position to map
         * @param  {number} y - the y coord of the position to map
         */
        mapPositionToPoint(point, x2, y2) {
          const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
            x: 0,
            y: 0,
            width: this.domElement.width,
            height: this.domElement.height,
            left: 0,
            top: 0
          };
          const resolutionMultiplier = 1 / this.resolution;
          point.x = (x2 - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
          point.y = (y2 - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
        }
        /**
         * Ensures that the original event object contains all data that a regular pointer event would have
         * @param event - The original event data from a touch or mouse event
         * @returns An array containing a single normalized pointer event, in the case of a pointer
         *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches
         */
        _normalizeToPointerData(event) {
          const normalizedEvents = [];
          if (this.supportsTouchEvents && event instanceof TouchEvent) {
            for (let i2 = 0, li = event.changedTouches.length; i2 < li; i2++) {
              const touch = event.changedTouches[i2];
              if (typeof touch.button === "undefined")
                touch.button = 0;
              if (typeof touch.buttons === "undefined")
                touch.buttons = 1;
              if (typeof touch.isPrimary === "undefined") {
                touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
              }
              if (typeof touch.width === "undefined")
                touch.width = touch.radiusX || 1;
              if (typeof touch.height === "undefined")
                touch.height = touch.radiusY || 1;
              if (typeof touch.tiltX === "undefined")
                touch.tiltX = 0;
              if (typeof touch.tiltY === "undefined")
                touch.tiltY = 0;
              if (typeof touch.pointerType === "undefined")
                touch.pointerType = "touch";
              if (typeof touch.pointerId === "undefined")
                touch.pointerId = touch.identifier || 0;
              if (typeof touch.pressure === "undefined")
                touch.pressure = touch.force || 0.5;
              if (typeof touch.twist === "undefined")
                touch.twist = 0;
              if (typeof touch.tangentialPressure === "undefined")
                touch.tangentialPressure = 0;
              if (typeof touch.layerX === "undefined")
                touch.layerX = touch.offsetX = touch.clientX;
              if (typeof touch.layerY === "undefined")
                touch.layerY = touch.offsetY = touch.clientY;
              touch.isNormalized = true;
              touch.type = event.type;
              normalizedEvents.push(touch);
            }
          } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
            const tempEvent = event;
            if (typeof tempEvent.isPrimary === "undefined")
              tempEvent.isPrimary = true;
            if (typeof tempEvent.width === "undefined")
              tempEvent.width = 1;
            if (typeof tempEvent.height === "undefined")
              tempEvent.height = 1;
            if (typeof tempEvent.tiltX === "undefined")
              tempEvent.tiltX = 0;
            if (typeof tempEvent.tiltY === "undefined")
              tempEvent.tiltY = 0;
            if (typeof tempEvent.pointerType === "undefined")
              tempEvent.pointerType = "mouse";
            if (typeof tempEvent.pointerId === "undefined")
              tempEvent.pointerId = MOUSE_POINTER_ID;
            if (typeof tempEvent.pressure === "undefined")
              tempEvent.pressure = 0.5;
            if (typeof tempEvent.twist === "undefined")
              tempEvent.twist = 0;
            if (typeof tempEvent.tangentialPressure === "undefined")
              tempEvent.tangentialPressure = 0;
            tempEvent.isNormalized = true;
            normalizedEvents.push(tempEvent);
          } else {
            normalizedEvents.push(event);
          }
          return normalizedEvents;
        }
        /**
         * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.
         *
         * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across
         * multiple native wheel events.
         * @param nativeEvent - The native wheel event that occurred on the canvas.
         * @returns A federated wheel event.
         */
        normalizeWheelEvent(nativeEvent) {
          const event = this._rootWheelEvent;
          this._transferMouseData(event, nativeEvent);
          event.deltaX = nativeEvent.deltaX;
          event.deltaY = nativeEvent.deltaY;
          event.deltaZ = nativeEvent.deltaZ;
          event.deltaMode = nativeEvent.deltaMode;
          this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
          event.global.copyFrom(event.screen);
          event.offset.copyFrom(event.screen);
          event.nativeEvent = nativeEvent;
          event.type = nativeEvent.type;
          return event;
        }
        /**
         * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.
         * @param event
         * @param nativeEvent
         */
        _bootstrapEvent(event, nativeEvent) {
          event.originalEvent = null;
          event.nativeEvent = nativeEvent;
          event.pointerId = nativeEvent.pointerId;
          event.width = nativeEvent.width;
          event.height = nativeEvent.height;
          event.isPrimary = nativeEvent.isPrimary;
          event.pointerType = nativeEvent.pointerType;
          event.pressure = nativeEvent.pressure;
          event.tangentialPressure = nativeEvent.tangentialPressure;
          event.tiltX = nativeEvent.tiltX;
          event.tiltY = nativeEvent.tiltY;
          event.twist = nativeEvent.twist;
          this._transferMouseData(event, nativeEvent);
          this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
          event.global.copyFrom(event.screen);
          event.offset.copyFrom(event.screen);
          event.isTrusted = nativeEvent.isTrusted;
          if (event.type === "pointerleave") {
            event.type = "pointerout";
          }
          if (event.type.startsWith("mouse")) {
            event.type = event.type.replace("mouse", "pointer");
          }
          if (event.type.startsWith("touch")) {
            event.type = TOUCH_TO_POINTER[event.type] || event.type;
          }
          return event;
        }
        /**
         * Transfers base & mouse event data from the {@code nativeEvent} to the federated event.
         * @param event
         * @param nativeEvent
         */
        _transferMouseData(event, nativeEvent) {
          event.isTrusted = nativeEvent.isTrusted;
          event.srcElement = nativeEvent.srcElement;
          event.timeStamp = performance.now();
          event.type = nativeEvent.type;
          event.altKey = nativeEvent.altKey;
          event.button = nativeEvent.button;
          event.buttons = nativeEvent.buttons;
          event.client.x = nativeEvent.clientX;
          event.client.y = nativeEvent.clientY;
          event.ctrlKey = nativeEvent.ctrlKey;
          event.metaKey = nativeEvent.metaKey;
          event.movement.x = nativeEvent.movementX;
          event.movement.y = nativeEvent.movementY;
          event.page.x = nativeEvent.pageX;
          event.page.y = nativeEvent.pageY;
          event.relatedTarget = null;
          event.shiftKey = nativeEvent.shiftKey;
        }
      };
      _EventSystem.extension = {
        name: "events",
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.CanvasSystem,
          ExtensionType.WebGPUSystem
        ],
        priority: -1
      };
      _EventSystem.defaultEventFeatures = {
        /** Enables pointer events associated with pointer movement. */
        move: true,
        /** Enables global pointer move events. */
        globalMove: true,
        /** Enables pointer events associated with clicking. */
        click: true,
        /** Enables wheel events. */
        wheel: true
      };
      EventSystem = _EventSystem;
    }
  });

  // node_modules/pixi.js/lib/events/FederatedEventTarget.mjs
  var FederatedContainer;
  var init_FederatedEventTarget = __esm({
    "node_modules/pixi.js/lib/events/FederatedEventTarget.mjs"() {
      init_EventSystem();
      init_FederatedEvent();
      FederatedContainer = {
        /**
         * Property-based event handler for the `click` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onclick = (event) => {
         *  //some function here that happens on click
         * }
         */
        onclick: null,
        /**
         * Property-based event handler for the `mousedown` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onmousedown = (event) => {
         *  //some function here that happens on mousedown
         * }
         */
        onmousedown: null,
        /**
         * Property-based event handler for the `mouseenter` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onmouseenter = (event) => {
         *  //some function here that happens on mouseenter
         * }
         */
        onmouseenter: null,
        /**
         * Property-based event handler for the `mouseleave` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onmouseleave = (event) => {
         *  //some function here that happens on mouseleave
         * }
         */
        onmouseleave: null,
        /**
         * Property-based event handler for the `mousemove` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onmousemove = (event) => {
         *  //some function here that happens on mousemove
         * }
         */
        onmousemove: null,
        /**
         * Property-based event handler for the `globalmousemove` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onglobalmousemove = (event) => {
         *  //some function here that happens on globalmousemove
         * }
         */
        onglobalmousemove: null,
        /**
         * Property-based event handler for the `mouseout` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onmouseout = (event) => {
         *  //some function here that happens on mouseout
         * }
         */
        onmouseout: null,
        /**
         * Property-based event handler for the `mouseover` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onmouseover = (event) => {
         *  //some function here that happens on mouseover
         * }
         */
        onmouseover: null,
        /**
         * Property-based event handler for the `mouseup` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onmouseup = (event) => {
         *  //some function here that happens on mouseup
         * }
         */
        onmouseup: null,
        /**
         * Property-based event handler for the `mouseupoutside` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onmouseupoutside = (event) => {
         *  //some function here that happens on mouseupoutside
         * }
         */
        onmouseupoutside: null,
        /**
         * Property-based event handler for the `pointercancel` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointercancel = (event) => {
         *  //some function here that happens on pointercancel
         * }
         */
        onpointercancel: null,
        /**
         * Property-based event handler for the `pointerdown` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointerdown = (event) => {
         *  //some function here that happens on pointerdown
         * }
         */
        onpointerdown: null,
        /**
         * Property-based event handler for the `pointerenter` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointerenter = (event) => {
         *  //some function here that happens on pointerenter
         * }
         */
        onpointerenter: null,
        /**
         * Property-based event handler for the `pointerleave` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointerleave = (event) => {
         *  //some function here that happens on pointerleave
         * }
         */
        onpointerleave: null,
        /**
         * Property-based event handler for the `pointermove` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointermove = (event) => {
         *  //some function here that happens on pointermove
         * }
         */
        onpointermove: null,
        /**
         * Property-based event handler for the `globalpointermove` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onglobalpointermove = (event) => {
         *  //some function here that happens on globalpointermove
         * }
         */
        onglobalpointermove: null,
        /**
         * Property-based event handler for the `pointerout` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointerout = (event) => {
         *  //some function here that happens on pointerout
         * }
         */
        onpointerout: null,
        /**
         * Property-based event handler for the `pointerover` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointerover = (event) => {
         *  //some function here that happens on pointerover
         * }
         */
        onpointerover: null,
        /**
         * Property-based event handler for the `pointertap` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointertap = (event) => {
         *  //some function here that happens on pointertap
         * }
         */
        onpointertap: null,
        /**
         * Property-based event handler for the `pointerup` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointerup = (event) => {
         *  //some function here that happens on pointerup
         * }
         */
        onpointerup: null,
        /**
         * Property-based event handler for the `pointerupoutside` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onpointerupoutside = (event) => {
         *  //some function here that happens on pointerupoutside
         * }
         */
        onpointerupoutside: null,
        /**
         * Property-based event handler for the `rightclick` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onrightclick = (event) => {
         *  //some function here that happens on rightclick
         * }
         */
        onrightclick: null,
        /**
         * Property-based event handler for the `rightdown` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onrightdown = (event) => {
         *  //some function here that happens on rightdown
         * }
         */
        onrightdown: null,
        /**
         * Property-based event handler for the `rightup` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onrightup = (event) => {
         *  //some function here that happens on rightup
         * }
         */
        onrightup: null,
        /**
         * Property-based event handler for the `rightupoutside` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onrightupoutside = (event) => {
         *  //some function here that happens on rightupoutside
         * }
         */
        onrightupoutside: null,
        /**
         * Property-based event handler for the `tap` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.ontap = (event) => {
         *  //some function here that happens on tap
         * }
         */
        ontap: null,
        /**
         * Property-based event handler for the `touchcancel` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.ontouchcancel = (event) => {
         *  //some function here that happens on touchcancel
         * }
         */
        ontouchcancel: null,
        /**
         * Property-based event handler for the `touchend` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.ontouchend = (event) => {
         *  //some function here that happens on touchend
         * }
         */
        ontouchend: null,
        /**
         * Property-based event handler for the `touchendoutside` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.ontouchendoutside = (event) => {
         *  //some function here that happens on touchendoutside
         * }
         */
        ontouchendoutside: null,
        /**
         * Property-based event handler for the `touchmove` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.ontouchmove = (event) => {
         *  //some function here that happens on touchmove
         * }
         */
        ontouchmove: null,
        /**
         * Property-based event handler for the `globaltouchmove` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onglobaltouchmove = (event) => {
         *  //some function here that happens on globaltouchmove
         * }
         */
        onglobaltouchmove: null,
        /**
         * Property-based event handler for the `touchstart` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.ontouchstart = (event) => {
         *  //some function here that happens on touchstart
         * }
         */
        ontouchstart: null,
        /**
         * Property-based event handler for the `wheel` event.
         * @memberof scene.Container#
         * @default null
         * @example
         * this.onwheel = (event) => {
         *  //some function here that happens on wheel
         * }
         */
        onwheel: null,
        /**
         * Enable interaction events for the Container. Touch, pointer and mouse
         * @memberof scene.Container#
         */
        get interactive() {
          return this.eventMode === "dynamic" || this.eventMode === "static";
        },
        set interactive(value12) {
          this.eventMode = value12 ? "static" : "passive";
        },
        /**
         * @ignore
         */
        _internalEventMode: void 0,
        /**
         * Enable interaction events for the Container. Touch, pointer and mouse.
         * There are 5 types of interaction settings:
         * - `'none'`: Ignores all interaction events, even on its children.
         * - `'passive'`: **(default)** Does not emit events and ignores all hit testing on itself and non-interactive children.
         * Interactive children will still emit events.
         * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7
         * - `'static'`: Emit events and is hit tested. Same as `interaction = true` in v7
         * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from a ticker to
         * allow for interaction when the mouse isn't moving
         * @example
         * import { Sprite } from 'pixi.js';
         *
         * const sprite = new Sprite(texture);
         * sprite.eventMode = 'static';
         * sprite.on('tap', (event) => {
         *     // Handle event
         * });
         * @memberof scene.Container#
         * @since 7.2.0
         */
        get eventMode() {
          return this._internalEventMode ?? EventSystem.defaultEventMode;
        },
        set eventMode(value12) {
          this._internalEventMode = value12;
        },
        /**
         * Determines if the container is interactive or not
         * @returns {boolean} Whether the container is interactive or not
         * @memberof scene.Container#
         * @since 7.2.0
         * @example
         * import { Sprite } from 'pixi.js';
         *
         * const sprite = new Sprite(texture);
         * sprite.eventMode = 'static';
         * sprite.isInteractive(); // true
         *
         * sprite.eventMode = 'dynamic';
         * sprite.isInteractive(); // true
         *
         * sprite.eventMode = 'none';
         * sprite.isInteractive(); // false
         *
         * sprite.eventMode = 'passive';
         * sprite.isInteractive(); // false
         *
         * sprite.eventMode = 'auto';
         * sprite.isInteractive(); // false
         */
        isInteractive() {
          return this.eventMode === "static" || this.eventMode === "dynamic";
        },
        /**
         * Determines if the children to the container can be clicked/touched
         * Setting this to false allows PixiJS to bypass a recursive `hitTest` function
         * @memberof scene.Container#
         */
        interactiveChildren: true,
        /**
         * Interaction shape. Children will be hit first, then this shape will be checked.
         * Setting this will cause this shape to be checked in hit tests rather than the container's bounds.
         * @example
         * import { Rectangle, Sprite } from 'pixi.js';
         *
         * const sprite = new Sprite(texture);
         * sprite.interactive = true;
         * sprite.hitArea = new Rectangle(0, 0, 100, 100);
         * @member {IHitArea}
         * @memberof scene.Container#
         */
        hitArea: null,
        /**
         * Unlike `on` or `addListener` which are methods from EventEmitter, `addEventListener`
         * seeks to be compatible with the DOM's `addEventListener` with support for options.
         * @memberof scene.Container
         * @param type - The type of event to listen to.
         * @param listener - The listener callback or object.
         * @param options - Listener options, used for capture phase.
         * @example
         * // Tell the user whether they did a single, double, triple, or nth click.
         * button.addEventListener('click', {
         *     handleEvent(e): {
         *         let prefix;
         *
         *         switch (e.detail) {
         *             case 1: prefix = 'single'; break;
         *             case 2: prefix = 'double'; break;
         *             case 3: prefix = 'triple'; break;
         *             default: prefix = e.detail + 'th'; break;
         *         }
         *
         *         console.log('That was a ' + prefix + 'click');
         *     }
         * });
         *
         * // But skip the first click!
         * button.parent.addEventListener('click', function blockClickOnce(e) {
         *     e.stopImmediatePropagation();
         *     button.parent.removeEventListener('click', blockClickOnce, true);
         * }, {
         *     capture: true,
         * });
         */
        addEventListener(type, listener, options2) {
          const capture = typeof options2 === "boolean" && options2 || typeof options2 === "object" && options2.capture;
          const signal = typeof options2 === "object" ? options2.signal : void 0;
          const once = typeof options2 === "object" ? options2.once === true : false;
          const context3 = typeof listener === "function" ? void 0 : listener;
          type = capture ? `${type}capture` : type;
          const listenerFn = typeof listener === "function" ? listener : listener.handleEvent;
          const emitter = this;
          if (signal) {
            signal.addEventListener("abort", () => {
              emitter.off(type, listenerFn, context3);
            });
          }
          if (once) {
            emitter.once(type, listenerFn, context3);
          } else {
            emitter.on(type, listenerFn, context3);
          }
        },
        /**
         * Unlike `off` or `removeListener` which are methods from EventEmitter, `removeEventListener`
         * seeks to be compatible with the DOM's `removeEventListener` with support for options.
         * @memberof scene.Container
         * @param type - The type of event the listener is bound to.
         * @param listener - The listener callback or object.
         * @param options - The original listener options. This is required to deregister a capture phase listener.
         */
        removeEventListener(type, listener, options2) {
          const capture = typeof options2 === "boolean" && options2 || typeof options2 === "object" && options2.capture;
          const context3 = typeof listener === "function" ? void 0 : listener;
          type = capture ? `${type}capture` : type;
          listener = typeof listener === "function" ? listener : listener.handleEvent;
          this.off(type, listener, context3);
        },
        /**
         * Dispatch the event on this {@link Container} using the event's {@link EventBoundary}.
         *
         * The target of the event is set to `this` and the `defaultPrevented` flag is cleared before dispatch.
         * @memberof scene.Container
         * @param e - The event to dispatch.
         * @returns Whether the {@link FederatedEvent.preventDefault preventDefault}() method was not invoked.
         * @example
         * // Reuse a click event!
         * button.dispatchEvent(clickEvent);
         */
        dispatchEvent(e2) {
          if (!(e2 instanceof FederatedEvent)) {
            throw new Error("Container cannot propagate events outside of the Federated Events API");
          }
          e2.defaultPrevented = false;
          e2.path = null;
          e2.target = this;
          e2.manager.dispatchEvent(e2);
          return !e2.defaultPrevented;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/events/init.mjs
  var init_init3 = __esm({
    "node_modules/pixi.js/lib/events/init.mjs"() {
      init_Extensions();
      init_Container();
      init_EventSystem();
      init_FederatedEventTarget();
      extensions.add(EventSystem);
      Container.mixin(FederatedContainer);
    }
  });

  // node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs
  var LoaderParserPriority;
  var init_LoaderParser = __esm({
    "node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs"() {
      "use strict";
      LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {
        LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";
        LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";
        LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";
        return LoaderParserPriority2;
      })(LoaderParserPriority || {});
    }
  });

  // node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs
  var BrowserAdapter;
  var init_BrowserAdapter = __esm({
    "node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs"() {
      "use strict";
      BrowserAdapter = {
        createCanvas: (width8, height8) => {
          const canvas2 = document.createElement("canvas");
          canvas2.width = width8;
          canvas2.height = height8;
          return canvas2;
        },
        getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
        getWebGLRenderingContext: () => WebGLRenderingContext,
        getNavigator: () => navigator,
        getBaseUrl: () => document.baseURI ?? window.location.href,
        getFontFaceSet: () => document.fonts,
        fetch: (url2, options2) => fetch(url2, options2),
        parseXML: (xml) => {
          const parser2 = new DOMParser();
          return parser2.parseFromString(xml, "text/xml");
        }
      };
    }
  });

  // node_modules/pixi.js/lib/environment/adapter.mjs
  var currentAdapter, DOMAdapter;
  var init_adapter = __esm({
    "node_modules/pixi.js/lib/environment/adapter.mjs"() {
      init_BrowserAdapter();
      currentAdapter = BrowserAdapter;
      DOMAdapter = {
        /**
         * Returns the current adapter.
         * @returns {environment.Adapter} The current adapter.
         */
        get() {
          return currentAdapter;
        },
        /**
         * Sets the current adapter.
         * @param adapter - The new adapter.
         */
        set(adapter) {
          currentAdapter = adapter;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/utils/path.mjs
  function assertPath(path2) {
    if (typeof path2 !== "string") {
      throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
    }
  }
  function removeUrlParams(url2) {
    const re = url2.split("?")[0];
    return re.split("#")[0];
  }
  function escapeRegExp(string2) {
    return string2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function replaceAll2(str, find4, replace5) {
    return str.replace(new RegExp(escapeRegExp(find4), "g"), replace5);
  }
  function normalizeStringPosix(path2, allowAboveRoot) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code = -1;
    for (let i2 = 0; i2 <= path2.length; ++i2) {
      if (i2 < path2.length) {
        code = path2.charCodeAt(i2);
      } else if (code === 47) {
        break;
      } else {
        code = 47;
      }
      if (code === 47) {
        if (lastSlash === i2 - 1 || dots === 1) {
        } else if (lastSlash !== i2 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i2;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i2;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0) {
              res += "/..";
            } else {
              res = "..";
            }
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) {
            res += `/${path2.slice(lastSlash + 1, i2)}`;
          } else {
            res = path2.slice(lastSlash + 1, i2);
          }
          lastSegmentLength = i2 - lastSlash - 1;
        }
        lastSlash = i2;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  var path;
  var init_path = __esm({
    "node_modules/pixi.js/lib/utils/path.mjs"() {
      init_adapter();
      path = {
        /**
         * Converts a path to posix format.
         * @param path - The path to convert to posix
         */
        toPosix(path2) {
          return replaceAll2(path2, "\\", "/");
        },
        /**
         * Checks if the path is a URL e.g. http://, https://
         * @param path - The path to check
         */
        isUrl(path2) {
          return /^https?:/.test(this.toPosix(path2));
        },
        /**
         * Checks if the path is a data URL
         * @param path - The path to check
         */
        isDataUrl(path2) {
          return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
        },
        /**
         * Checks if the path is a blob URL
         * @param path - The path to check
         */
        isBlobUrl(path2) {
          return path2.startsWith("blob:");
        },
        /**
         * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/
         * This will return true for windows file paths
         * @param path - The path to check
         */
        hasProtocol(path2) {
          return /^[^/:]+:/.test(this.toPosix(path2));
        },
        /**
         * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/
         * @param path - The path to get the protocol from
         */
        getProtocol(path2) {
          assertPath(path2);
          path2 = this.toPosix(path2);
          const matchFile = /^file:\/\/\//.exec(path2);
          if (matchFile) {
            return matchFile[0];
          }
          const matchProtocol = /^[^/:]+:\/{0,2}/.exec(path2);
          if (matchProtocol) {
            return matchProtocol[0];
          }
          return "";
        },
        /**
         * Converts URL to an absolute path.
         * When loading from a Web Worker, we must use absolute paths.
         * If the URL is already absolute we return it as is
         * If it's not, we convert it
         * @param url - The URL to test
         * @param customBaseUrl - The base URL to use
         * @param customRootUrl - The root URL to use
         */
        toAbsolute(url2, customBaseUrl, customRootUrl) {
          assertPath(url2);
          if (this.isDataUrl(url2) || this.isBlobUrl(url2))
            return url2;
          const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));
          const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
          url2 = this.toPosix(url2);
          if (url2.startsWith("/")) {
            return path.join(rootUrl, url2.slice(1));
          }
          const absolutePath = this.isAbsolute(url2) ? url2 : this.join(baseUrl, url2);
          return absolutePath;
        },
        /**
         * Normalizes the given path, resolving '..' and '.' segments
         * @param path - The path to normalize
         */
        normalize(path2) {
          assertPath(path2);
          if (path2.length === 0)
            return ".";
          if (this.isDataUrl(path2) || this.isBlobUrl(path2))
            return path2;
          path2 = this.toPosix(path2);
          let protocol2 = "";
          const isAbsolute = path2.startsWith("/");
          if (this.hasProtocol(path2)) {
            protocol2 = this.rootname(path2);
            path2 = path2.slice(protocol2.length);
          }
          const trailingSeparator = path2.endsWith("/");
          path2 = normalizeStringPosix(path2, false);
          if (path2.length > 0 && trailingSeparator)
            path2 += "/";
          if (isAbsolute)
            return `/${path2}`;
          return protocol2 + path2;
        },
        /**
         * Determines if path is an absolute path.
         * Absolute paths can be urls, data urls, or paths on disk
         * @param path - The path to test
         */
        isAbsolute(path2) {
          assertPath(path2);
          path2 = this.toPosix(path2);
          if (this.hasProtocol(path2))
            return true;
          return path2.startsWith("/");
        },
        /**
         * Joins all given path segments together using the platform-specific separator as a delimiter,
         * then normalizes the resulting path
         * @param segments - The segments of the path to join
         */
        join(...segments) {
          if (segments.length === 0) {
            return ".";
          }
          let joined;
          for (let i2 = 0; i2 < segments.length; ++i2) {
            const arg = segments[i2];
            assertPath(arg);
            if (arg.length > 0) {
              if (joined === void 0)
                joined = arg;
              else {
                const prevArg = segments[i2 - 1] ?? "";
                if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {
                  joined += `/../${arg}`;
                } else {
                  joined += `/${arg}`;
                }
              }
            }
          }
          if (joined === void 0) {
            return ".";
          }
          return this.normalize(joined);
        },
        /**
         * Returns the directory name of a path
         * @param path - The path to parse
         */
        dirname(path2) {
          assertPath(path2);
          if (path2.length === 0)
            return ".";
          path2 = this.toPosix(path2);
          let code = path2.charCodeAt(0);
          const hasRoot = code === 47;
          let end = -1;
          let matchedSlash = true;
          const proto = this.getProtocol(path2);
          const origpath = path2;
          path2 = path2.slice(proto.length);
          for (let i2 = path2.length - 1; i2 >= 1; --i2) {
            code = path2.charCodeAt(i2);
            if (code === 47) {
              if (!matchedSlash) {
                end = i2;
                break;
              }
            } else {
              matchedSlash = false;
            }
          }
          if (end === -1)
            return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
          if (hasRoot && end === 1)
            return "//";
          return proto + path2.slice(0, end);
        },
        /**
         * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/
         * @param path - The path to parse
         */
        rootname(path2) {
          assertPath(path2);
          path2 = this.toPosix(path2);
          let root = "";
          if (path2.startsWith("/"))
            root = "/";
          else {
            root = this.getProtocol(path2);
          }
          if (this.isUrl(path2)) {
            const index6 = path2.indexOf("/", root.length);
            if (index6 !== -1) {
              root = path2.slice(0, index6);
            } else
              root = path2;
            if (!root.endsWith("/"))
              root += "/";
          }
          return root;
        },
        /**
         * Returns the last portion of a path
         * @param path - The path to test
         * @param ext - Optional extension to remove
         */
        basename(path2, ext) {
          assertPath(path2);
          if (ext)
            assertPath(ext);
          path2 = removeUrlParams(this.toPosix(path2));
          let start3 = 0;
          let end = -1;
          let matchedSlash = true;
          let i2;
          if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
            if (ext.length === path2.length && ext === path2)
              return "";
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i2 = path2.length - 1; i2 >= 0; --i2) {
              const code = path2.charCodeAt(i2);
              if (code === 47) {
                if (!matchedSlash) {
                  start3 = i2 + 1;
                  break;
                }
              } else {
                if (firstNonSlashEnd === -1) {
                  matchedSlash = false;
                  firstNonSlashEnd = i2 + 1;
                }
                if (extIdx >= 0) {
                  if (code === ext.charCodeAt(extIdx)) {
                    if (--extIdx === -1) {
                      end = i2;
                    }
                  } else {
                    extIdx = -1;
                    end = firstNonSlashEnd;
                  }
                }
              }
            }
            if (start3 === end)
              end = firstNonSlashEnd;
            else if (end === -1)
              end = path2.length;
            return path2.slice(start3, end);
          }
          for (i2 = path2.length - 1; i2 >= 0; --i2) {
            if (path2.charCodeAt(i2) === 47) {
              if (!matchedSlash) {
                start3 = i2 + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i2 + 1;
            }
          }
          if (end === -1)
            return "";
          return path2.slice(start3, end);
        },
        /**
         * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last
         * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than
         * the first character of the basename of path, an empty string is returned.
         * @param path - The path to parse
         */
        extname(path2) {
          assertPath(path2);
          path2 = removeUrlParams(this.toPosix(path2));
          let startDot = -1;
          let startPart = 0;
          let end = -1;
          let matchedSlash = true;
          let preDotState = 0;
          for (let i2 = path2.length - 1; i2 >= 0; --i2) {
            const code = path2.charCodeAt(i2);
            if (code === 47) {
              if (!matchedSlash) {
                startPart = i2 + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i2 + 1;
            }
            if (code === 46) {
              if (startDot === -1)
                startDot = i2;
              else if (preDotState !== 1)
                preDotState = 1;
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            return "";
          }
          return path2.slice(startDot, end);
        },
        /**
         * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.
         * @param path - The path to parse
         */
        parse(path2) {
          assertPath(path2);
          const ret = { root: "", dir: "", base: "", ext: "", name: "" };
          if (path2.length === 0)
            return ret;
          path2 = removeUrlParams(this.toPosix(path2));
          let code = path2.charCodeAt(0);
          const isAbsolute = this.isAbsolute(path2);
          let start3;
          const protocol2 = "";
          ret.root = this.rootname(path2);
          if (isAbsolute || this.hasProtocol(path2)) {
            start3 = 1;
          } else {
            start3 = 0;
          }
          let startDot = -1;
          let startPart = 0;
          let end = -1;
          let matchedSlash = true;
          let i2 = path2.length - 1;
          let preDotState = 0;
          for (; i2 >= start3; --i2) {
            code = path2.charCodeAt(i2);
            if (code === 47) {
              if (!matchedSlash) {
                startPart = i2 + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i2 + 1;
            }
            if (code === 46) {
              if (startDot === -1)
                startDot = i2;
              else if (preDotState !== 1)
                preDotState = 1;
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            if (end !== -1) {
              if (startPart === 0 && isAbsolute)
                ret.base = ret.name = path2.slice(1, end);
              else
                ret.base = ret.name = path2.slice(startPart, end);
            }
          } else {
            if (startPart === 0 && isAbsolute) {
              ret.name = path2.slice(1, startDot);
              ret.base = path2.slice(1, end);
            } else {
              ret.name = path2.slice(startPart, startDot);
              ret.base = path2.slice(startPart, end);
            }
            ret.ext = path2.slice(startDot, end);
          }
          ret.dir = this.dirname(path2);
          if (protocol2)
            ret.dir = protocol2 + ret.dir;
          return ret;
        },
        sep: "/",
        delimiter: ":",
        joinExtensions: [".html"]
      };
    }
  });

  // node_modules/pixi.js/lib/assets/utils/convertToList.mjs
  var convertToList;
  var init_convertToList = __esm({
    "node_modules/pixi.js/lib/assets/utils/convertToList.mjs"() {
      "use strict";
      convertToList = (input, transform2, forceTransform = false) => {
        if (!Array.isArray(input)) {
          input = [input];
        }
        if (!transform2) {
          return input;
        }
        return input.map((item) => {
          if (typeof item === "string" || forceTransform) {
            return transform2(item);
          }
          return item;
        });
      };
    }
  });

  // node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs
  function processX(base2, ids, depth, result, tags2) {
    const id5 = ids[depth];
    for (let i2 = 0; i2 < id5.length; i2++) {
      const value12 = id5[i2];
      if (depth < ids.length - 1) {
        processX(base2.replace(result[depth], value12), ids, depth + 1, result, tags2);
      } else {
        tags2.push(base2.replace(result[depth], value12));
      }
    }
  }
  function createStringVariations(string2) {
    const regex2 = /\{(.*?)\}/g;
    const result = string2.match(regex2);
    const tags2 = [];
    if (result) {
      const ids = [];
      result.forEach((vars) => {
        const split3 = vars.substring(1, vars.length - 1).split(",");
        ids.push(split3);
      });
      processX(string2, ids, 0, result, tags2);
    } else {
      tags2.push(string2);
    }
    return tags2;
  }
  var init_createStringVariations = __esm({
    "node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs
  var isSingleItem;
  var init_isSingleItem = __esm({
    "node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs"() {
      "use strict";
      isSingleItem = (item) => !Array.isArray(item);
    }
  });

  // node_modules/pixi.js/lib/assets/resolver/Resolver.mjs
  function getUrlExtension(url2) {
    return url2.split(".").pop().split("?").shift().split("#").shift();
  }
  var Resolver;
  var init_Resolver = __esm({
    "node_modules/pixi.js/lib/assets/resolver/Resolver.mjs"() {
      init_warn();
      init_path();
      init_convertToList();
      init_createStringVariations();
      init_isSingleItem();
      Resolver = class {
        constructor() {
          this._defaultBundleIdentifierOptions = {
            connector: "-",
            createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
            extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
          };
          this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
          this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
          this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
          this._assetMap = {};
          this._preferredOrder = [];
          this._parsers = [];
          this._resolverHash = {};
          this._bundles = {};
        }
        /**
         * Override how the resolver deals with generating bundle ids.
         * must be called before any bundles are added
         * @param bundleIdentifier - the bundle identifier options
         */
        setBundleIdentifier(bundleIdentifier) {
          this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
          this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
          this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
          if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
            throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
          }
        }
        /**
         * Let the resolver know which assets you prefer to use when resolving assets.
         * Multiple prefer user defined rules can be added.
         * @example
         * resolver.prefer({
         *     // first look for something with the correct format, and then then correct resolution
         *     priority: ['format', 'resolution'],
         *     params:{
         *         format:'webp', // prefer webp images
         *         resolution: 2, // prefer a resolution of 2
         *     }
         * })
         * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);
         * resolver.resolveUrl('foo') // => 'bar@2x.webp'
         * @param preferOrders - the prefer options
         */
        prefer(...preferOrders) {
          preferOrders.forEach((prefer) => {
            this._preferredOrder.push(prefer);
            if (!prefer.priority) {
              prefer.priority = Object.keys(prefer.params);
            }
          });
          this._resolverHash = {};
        }
        /**
         * Set the base path to prepend to all urls when resolving
         * @example
         * resolver.basePath = 'https://home.com/';
         * resolver.add('foo', 'bar.ong');
         * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'
         * @param basePath - the base path to use
         */
        set basePath(basePath) {
          this._basePath = basePath;
        }
        get basePath() {
          return this._basePath;
        }
        /**
         * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the
         * default value for browsers is `window.location.origin`
         * @example
         * // Application hosted on https://home.com/some-path/index.html
         * resolver.basePath = 'https://home.com/some-path/';
         * resolver.rootPath = 'https://home.com/';
         * resolver.add('foo', '/bar.png');
         * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'
         * @param rootPath - the root path to use
         */
        set rootPath(rootPath) {
          this._rootPath = rootPath;
        }
        get rootPath() {
          return this._rootPath;
        }
        /**
         * All the active URL parsers that help the parser to extract information and create
         * an asset object-based on parsing the URL itself.
         *
         * Can be added using the extensions API
         * @example
         * resolver.add('foo', [
         *     {
         *         resolution: 2,
         *         format: 'png',
         *         src: 'image@2x.png',
         *     },
         *     {
         *         resolution:1,
         *         format:'png',
         *         src: 'image.png',
         *     },
         * ]);
         *
         * // With a url parser the information such as resolution and file format could extracted from the url itself:
         * extensions.add({
         *     extension: ExtensionType.ResolveParser,
         *     test: loadTextures.test, // test if url ends in an image
         *     parse: (value: string) =>
         *     ({
         *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),
         *         format: value.split('.').pop(),
         *         src: value,
         *     }),
         * });
         *
         * // Now resolution and format can be extracted from the url
         * resolver.add('foo', [
         *     'image@2x.png',
         *     'image.png',
         * ]);
         */
        get parsers() {
          return this._parsers;
        }
        /** Used for testing, this resets the resolver to its initial state */
        reset() {
          this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
          this._assetMap = {};
          this._preferredOrder = [];
          this._resolverHash = {};
          this._rootPath = null;
          this._basePath = null;
          this._manifest = null;
          this._bundles = {};
          this._defaultSearchParams = null;
        }
        /**
         * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.
         * @param searchParams - the default url parameters to append when resolving urls
         */
        setDefaultSearchParams(searchParams) {
          if (typeof searchParams === "string") {
            this._defaultSearchParams = searchParams;
          } else {
            const queryValues = searchParams;
            this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
          }
        }
        /**
         * Returns the aliases for a given asset
         * @param asset - the asset to get the aliases for
         */
        getAlias(asset) {
          const { alias, src: src9 } = asset;
          const aliasesToUse = convertToList(
            alias || src9,
            (value12) => {
              if (typeof value12 === "string")
                return value12;
              if (Array.isArray(value12))
                return value12.map((v2) => v2?.src ?? v2);
              if (value12?.src)
                return value12.src;
              return value12;
            },
            true
          );
          return aliasesToUse;
        }
        /**
         * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.
         * generally a manifest would be built using a tool.
         * @param manifest - the manifest to add to the resolver
         */
        addManifest(manifest) {
          if (this._manifest) {
            warn2("[Resolver] Manifest already exists, this will be overwritten");
          }
          this._manifest = manifest;
          manifest.bundles.forEach((bundle) => {
            this.addBundle(bundle.name, bundle.assets);
          });
        }
        /**
         * This adds a bundle of assets in one go so that you can resolve them as a group.
         * For example you could add a bundle for each screen in you pixi app
         * @example
         * resolver.addBundle('animals', [
         *  { alias: 'bunny', src: 'bunny.png' },
         *  { alias: 'chicken', src: 'chicken.png' },
         *  { alias: 'thumper', src: 'thumper.png' },
         * ]);
         * // or
         * resolver.addBundle('animals', {
         *     bunny: 'bunny.png',
         *     chicken: 'chicken.png',
         *     thumper: 'thumper.png',
         * });
         *
         * const resolvedAssets = await resolver.resolveBundle('animals');
         * @param bundleId - The id of the bundle to add
         * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key
         */
        addBundle(bundleId, assets) {
          const assetNames = [];
          let convertedAssets = assets;
          if (!Array.isArray(assets)) {
            convertedAssets = Object.entries(assets).map(([alias, src9]) => {
              if (typeof src9 === "string" || Array.isArray(src9)) {
                return { alias, src: src9 };
              }
              return { alias, ...src9 };
            });
          }
          convertedAssets.forEach((asset) => {
            const srcs = asset.src;
            const aliases = asset.alias;
            let ids;
            if (typeof aliases === "string") {
              const bundleAssetId = this._createBundleAssetId(bundleId, aliases);
              assetNames.push(bundleAssetId);
              ids = [aliases, bundleAssetId];
            } else {
              const bundleIds = aliases.map((name16) => this._createBundleAssetId(bundleId, name16));
              assetNames.push(...bundleIds);
              ids = [...aliases, ...bundleIds];
            }
            this.add({
              ...asset,
              ...{
                alias: ids,
                src: srcs
              }
            });
          });
          this._bundles[bundleId] = assetNames;
        }
        /**
         * Tells the resolver what keys are associated with witch asset.
         * The most important thing the resolver does
         * @example
         * // Single key, single asset:
         * resolver.add({alias: 'foo', src: 'bar.png');
         * resolver.resolveUrl('foo') // => 'bar.png'
         *
         * // Multiple keys, single asset:
         * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});
         * resolver.resolveUrl('foo') // => 'bar.png'
         * resolver.resolveUrl('boo') // => 'bar.png'
         *
         * // Multiple keys, multiple assets:
         * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});
         * resolver.resolveUrl('foo') // => 'bar.png'
         *
         * // Add custom data attached to the resolver
         * Resolver.add({
         *     alias: 'bunnyBooBooSmooth',
         *     src: 'bunny{png,webp}',
         *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options
         * });
         *
         * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }
         * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver
         */
        add(aliases) {
          const assets = [];
          if (Array.isArray(aliases)) {
            assets.push(...aliases);
          } else {
            assets.push(aliases);
          }
          let keyCheck;
          keyCheck = (key) => {
            if (this.hasKey(key)) {
              warn2(`[Resolver] already has key: ${key} overwriting`);
            }
          };
          const assetArray = convertToList(assets);
          assetArray.forEach((asset) => {
            const { src: src9 } = asset;
            let { data, format, loadParser } = asset;
            const srcsToUse = convertToList(src9).map((src22) => {
              if (typeof src22 === "string") {
                return createStringVariations(src22);
              }
              return Array.isArray(src22) ? src22 : [src22];
            });
            const aliasesToUse = this.getAlias(asset);
            Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);
            const resolvedAssets = [];
            srcsToUse.forEach((srcs) => {
              srcs.forEach((src22) => {
                let formattedAsset = {};
                if (typeof src22 !== "object") {
                  formattedAsset.src = src22;
                  for (let i2 = 0; i2 < this._parsers.length; i2++) {
                    const parser2 = this._parsers[i2];
                    if (parser2.test(src22)) {
                      formattedAsset = parser2.parse(src22);
                      break;
                    }
                  }
                } else {
                  data = src22.data ?? data;
                  format = src22.format ?? format;
                  loadParser = src22.loadParser ?? loadParser;
                  formattedAsset = {
                    ...formattedAsset,
                    ...src22
                  };
                }
                if (!aliasesToUse) {
                  throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);
                }
                formattedAsset = this._buildResolvedAsset(formattedAsset, {
                  aliases: aliasesToUse,
                  data,
                  format,
                  loadParser
                });
                resolvedAssets.push(formattedAsset);
              });
            });
            aliasesToUse.forEach((alias) => {
              this._assetMap[alias] = resolvedAssets;
            });
          });
        }
        // TODO: this needs an overload like load did in Assets
        /**
         * If the resolver has had a manifest set via setManifest, this will return the assets urls for
         * a given bundleId or bundleIds.
         * @example
         * // Manifest Example
         * const manifest = {
         *     bundles: [
         *         {
         *             name: 'load-screen',
         *             assets: [
         *                 {
         *                     alias: 'background',
         *                     src: 'sunset.png',
         *                 },
         *                 {
         *                     alias: 'bar',
         *                     src: 'load-bar.{png,webp}',
         *                 },
         *             ],
         *         },
         *         {
         *             name: 'game-screen',
         *             assets: [
         *                 {
         *                     alias: 'character',
         *                     src: 'robot.png',
         *                 },
         *                 {
         *                     alias: 'enemy',
         *                     src: 'bad-guy.png',
         *                 },
         *             ],
         *         },
         *     ]
         * };
         *
         * resolver.setManifest(manifest);
         * const resolved = resolver.resolveBundle('load-screen');
         * @param bundleIds - The bundle ids to resolve
         * @returns All the bundles assets or a hash of assets for each bundle specified
         */
        resolveBundle(bundleIds) {
          const singleAsset = isSingleItem(bundleIds);
          bundleIds = convertToList(bundleIds);
          const out2 = {};
          bundleIds.forEach((bundleId) => {
            const assetNames = this._bundles[bundleId];
            if (assetNames) {
              const results = this.resolve(assetNames);
              const assets = {};
              for (const key in results) {
                const asset = results[key];
                assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
              }
              out2[bundleId] = assets;
            }
          });
          return singleAsset ? out2[bundleIds[0]] : out2;
        }
        /**
         * Does exactly what resolve does, but returns just the URL rather than the whole asset object
         * @param key - The key or keys to resolve
         * @returns - The URLs associated with the key(s)
         */
        resolveUrl(key) {
          const result = this.resolve(key);
          if (typeof key !== "string") {
            const out2 = {};
            for (const i2 in result) {
              out2[i2] = result[i2].src;
            }
            return out2;
          }
          return result.src;
        }
        resolve(keys6) {
          const singleAsset = isSingleItem(keys6);
          keys6 = convertToList(keys6);
          const result = {};
          keys6.forEach((key) => {
            if (!this._resolverHash[key]) {
              if (this._assetMap[key]) {
                let assets = this._assetMap[key];
                const preferredOrder = this._getPreferredOrder(assets);
                preferredOrder?.priority.forEach((priorityKey) => {
                  preferredOrder.params[priorityKey].forEach((value12) => {
                    const filteredAssets = assets.filter((asset) => {
                      if (asset[priorityKey]) {
                        return asset[priorityKey] === value12;
                      }
                      return false;
                    });
                    if (filteredAssets.length) {
                      assets = filteredAssets;
                    }
                  });
                });
                this._resolverHash[key] = assets[0];
              } else {
                this._resolverHash[key] = this._buildResolvedAsset({
                  alias: [key],
                  src: key
                }, {});
              }
            }
            result[key] = this._resolverHash[key];
          });
          return singleAsset ? result[keys6[0]] : result;
        }
        /**
         * Checks if an asset with a given key exists in the resolver
         * @param key - The key of the asset
         */
        hasKey(key) {
          return !!this._assetMap[key];
        }
        /**
         * Checks if a bundle with the given key exists in the resolver
         * @param key - The key of the bundle
         */
        hasBundle(key) {
          return !!this._bundles[key];
        }
        /**
         * Internal function for figuring out what prefer criteria an asset should use.
         * @param assets
         */
        _getPreferredOrder(assets) {
          for (let i2 = 0; i2 < assets.length; i2++) {
            const asset = assets[0];
            const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
            if (preferred) {
              return preferred;
            }
          }
          return this._preferredOrder[0];
        }
        /**
         * Appends the default url parameters to the url
         * @param url - The url to append the default parameters to
         * @returns - The url with the default parameters appended
         */
        _appendDefaultSearchParams(url2) {
          if (!this._defaultSearchParams)
            return url2;
          const paramConnector = /\?/.test(url2) ? "&" : "?";
          return `${url2}${paramConnector}${this._defaultSearchParams}`;
        }
        _buildResolvedAsset(formattedAsset, data) {
          const { aliases, data: assetData, loadParser, format } = data;
          if (this._basePath || this._rootPath) {
            formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
          }
          formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];
          formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
          formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };
          formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;
          formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);
          return formattedAsset;
        }
      };
      Resolver.RETINA_PREFIX = /@([0-9\.]+)x/;
    }
  });

  // node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs
  var copySearchParams;
  var init_copySearchParams = __esm({
    "node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs"() {
      "use strict";
      copySearchParams = (targetUrl, sourceUrl) => {
        const searchParams = sourceUrl.split("?")[1];
        if (searchParams) {
          targetUrl += `?${searchParams}`;
        }
        return targetUrl;
      };
    }
  });

  // node_modules/pixi.js/lib/maths/matrix/groupD8.mjs
  function init5() {
    for (let i2 = 0; i2 < 16; i2++) {
      const row = [];
      rotationCayley.push(row);
      for (let j2 = 0; j2 < 16; j2++) {
        const _ux = signum(ux[i2] * ux[j2] + vx[i2] * uy[j2]);
        const _uy = signum(uy[i2] * ux[j2] + vy[i2] * uy[j2]);
        const _vx = signum(ux[i2] * vx[j2] + vx[i2] * vy[j2]);
        const _vy = signum(uy[i2] * vx[j2] + vy[i2] * vy[j2]);
        for (let k2 = 0; k2 < 16; k2++) {
          if (ux[k2] === _ux && uy[k2] === _uy && vx[k2] === _vx && vy[k2] === _vy) {
            row.push(k2);
            break;
          }
        }
      }
    }
    for (let i2 = 0; i2 < 16; i2++) {
      const mat = new Matrix();
      mat.set(ux[i2], uy[i2], vx[i2], vy[i2], 0, 0);
      rotationMatrices.push(mat);
    }
  }
  var ux, uy, vx, vy, rotationCayley, rotationMatrices, signum, groupD8;
  var init_groupD8 = __esm({
    "node_modules/pixi.js/lib/maths/matrix/groupD8.mjs"() {
      init_Matrix();
      ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
      uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
      vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
      vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
      rotationCayley = [];
      rotationMatrices = [];
      signum = Math.sign;
      init5();
      groupD8 = {
        /**
         * | Rotation | Direction |
         * |----------|-----------|
         * | 0°       | East      |
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        E: 0,
        /**
         * | Rotation | Direction |
         * |----------|-----------|
         * | 45°↻     | Southeast |
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        SE: 1,
        /**
         * | Rotation | Direction |
         * |----------|-----------|
         * | 90°↻     | South     |
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        S: 2,
        /**
         * | Rotation | Direction |
         * |----------|-----------|
         * | 135°↻    | Southwest |
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        SW: 3,
        /**
         * | Rotation | Direction |
         * |----------|-----------|
         * | 180°     | West      |
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        W: 4,
        /**
         * | Rotation    | Direction    |
         * |-------------|--------------|
         * | -135°/225°↻ | Northwest    |
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        NW: 5,
        /**
         * | Rotation    | Direction    |
         * |-------------|--------------|
         * | -90°/270°↻  | North        |
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        N: 6,
        /**
         * | Rotation    | Direction    |
         * |-------------|--------------|
         * | -45°/315°↻  | Northeast    |
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        NE: 7,
        /**
         * Reflection about Y-axis.
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        MIRROR_VERTICAL: 8,
        /**
         * Reflection about the main diagonal.
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        MAIN_DIAGONAL: 10,
        /**
         * Reflection about X-axis.
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        MIRROR_HORIZONTAL: 12,
        /**
         * Reflection about reverse diagonal.
         * @memberof maths.groupD8
         * @constant {GD8Symmetry}
         */
        REVERSE_DIAGONAL: 14,
        /**
         * @memberof maths.groupD8
         * @param {GD8Symmetry} ind - sprite rotation angle.
         * @returns {GD8Symmetry} The X-component of the U-axis
         *    after rotating the axes.
         */
        uX: (ind) => ux[ind],
        /**
         * @memberof maths.groupD8
         * @param {GD8Symmetry} ind - sprite rotation angle.
         * @returns {GD8Symmetry} The Y-component of the U-axis
         *    after rotating the axes.
         */
        uY: (ind) => uy[ind],
        /**
         * @memberof maths.groupD8
         * @param {GD8Symmetry} ind - sprite rotation angle.
         * @returns {GD8Symmetry} The X-component of the V-axis
         *    after rotating the axes.
         */
        vX: (ind) => vx[ind],
        /**
         * @memberof maths.groupD8
         * @param {GD8Symmetry} ind - sprite rotation angle.
         * @returns {GD8Symmetry} The Y-component of the V-axis
         *    after rotating the axes.
         */
        vY: (ind) => vy[ind],
        /**
         * @memberof maths.groupD8
         * @param {GD8Symmetry} rotation - symmetry whose opposite
         *   is needed. Only rotations have opposite symmetries while
         *   reflections don't.
         * @returns {GD8Symmetry} The opposite symmetry of `rotation`
         */
        inv: (rotation) => {
          if (rotation & 8) {
            return rotation & 15;
          }
          return -rotation & 7;
        },
        /**
         * Composes the two D8 operations.
         *
         * Taking `^` as reflection:
         *
         * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
         * |-------|-----|-----|-----|-----|------|-------|-------|-------|
         * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
         * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
         * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
         * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
         * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
         * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
         * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
         * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
         *
         * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
         * @memberof maths.groupD8
         * @param {GD8Symmetry} rotationSecond - Second operation, which
         *   is the row in the above cayley table.
         * @param {GD8Symmetry} rotationFirst - First operation, which
         *   is the column in the above cayley table.
         * @returns {GD8Symmetry} Composed operation
         */
        add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
        /**
         * Reverse of `add`.
         * @memberof maths.groupD8
         * @param {GD8Symmetry} rotationSecond - Second operation
         * @param {GD8Symmetry} rotationFirst - First operation
         * @returns {GD8Symmetry} Result
         */
        sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
        /**
         * Adds 180 degrees to rotation, which is a commutative
         * operation.
         * @memberof maths.groupD8
         * @param {number} rotation - The number to rotate.
         * @returns {number} Rotated number
         */
        rotate180: (rotation) => rotation ^ 4,
        /**
         * Checks if the rotation angle is vertical, i.e. south
         * or north. It doesn't work for reflections.
         * @memberof maths.groupD8
         * @param {GD8Symmetry} rotation - The number to check.
         * @returns {boolean} Whether or not the direction is vertical
         */
        isVertical: (rotation) => (rotation & 3) === 2,
        // rotation % 4 === 2
        /**
         * Approximates the vector `V(dx,dy)` into one of the
         * eight directions provided by `groupD8`.
         * @memberof maths.groupD8
         * @param {number} dx - X-component of the vector
         * @param {number} dy - Y-component of the vector
         * @returns {GD8Symmetry} Approximation of the vector into
         *  one of the eight symmetries.
         */
        byDirection: (dx, dy) => {
          if (Math.abs(dx) * 2 <= Math.abs(dy)) {
            if (dy >= 0) {
              return groupD8.S;
            }
            return groupD8.N;
          } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
            if (dx > 0) {
              return groupD8.E;
            }
            return groupD8.W;
          } else if (dy > 0) {
            if (dx > 0) {
              return groupD8.SE;
            }
            return groupD8.SW;
          } else if (dx > 0) {
            return groupD8.NE;
          }
          return groupD8.NW;
        },
        /**
         * Helps sprite to compensate texture packer rotation.
         * @memberof maths.groupD8
         * @param {Matrix} matrix - sprite world matrix
         * @param {GD8Symmetry} rotation - The rotation factor to use.
         * @param {number} tx - sprite anchoring
         * @param {number} ty - sprite anchoring
         */
        matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
          const mat = rotationMatrices[groupD8.inv(rotation)];
          mat.tx = tx;
          mat.ty = ty;
          matrix.append(mat);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/utils/misc/NOOP.mjs
  var NOOP;
  var init_NOOP = __esm({
    "node_modules/pixi.js/lib/utils/misc/NOOP.mjs"() {
      "use strict";
      NOOP = () => {
      };
    }
  });

  // node_modules/pixi.js/lib/maths/misc/pow2.mjs
  function nextPow2(v2) {
    v2 += v2 === 0 ? 1 : 0;
    --v2;
    v2 |= v2 >>> 1;
    v2 |= v2 >>> 2;
    v2 |= v2 >>> 4;
    v2 |= v2 >>> 8;
    v2 |= v2 >>> 16;
    return v2 + 1;
  }
  function isPow2(v2) {
    return !(v2 & v2 - 1) && !!v2;
  }
  var init_pow2 = __esm({
    "node_modules/pixi.js/lib/maths/misc/pow2.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs
  function definedProps(obj) {
    const result = {};
    for (const key in obj) {
      if (obj[key] !== void 0) {
        result[key] = obj[key];
      }
    }
    return result;
  }
  var init_definedProps = __esm({
    "node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs
  function createResourceIdFromString(value12) {
    const id5 = idHash[value12];
    if (id5 === void 0) {
      idHash[value12] = uid("resource");
    }
    return id5;
  }
  var idHash, _TextureStyle, TextureStyle;
  var init_TextureStyle = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs"() {
      init_eventemitter3();
      init_uid();
      init_deprecation();
      idHash = /* @__PURE__ */ Object.create(null);
      _TextureStyle = class _TextureStyle2 extends eventemitter3_default {
        /**
         * @param options - options for the style
         */
        constructor(options2 = {}) {
          super();
          this._resourceType = "textureSampler";
          this._touched = 0;
          this._maxAnisotropy = 1;
          this.destroyed = false;
          options2 = { ..._TextureStyle2.defaultOptions, ...options2 };
          this.addressMode = options2.addressMode;
          this.addressModeU = options2.addressModeU ?? this.addressModeU;
          this.addressModeV = options2.addressModeV ?? this.addressModeV;
          this.addressModeW = options2.addressModeW ?? this.addressModeW;
          this.scaleMode = options2.scaleMode;
          this.magFilter = options2.magFilter ?? this.magFilter;
          this.minFilter = options2.minFilter ?? this.minFilter;
          this.mipmapFilter = options2.mipmapFilter ?? this.mipmapFilter;
          this.lodMinClamp = options2.lodMinClamp;
          this.lodMaxClamp = options2.lodMaxClamp;
          this.compare = options2.compare;
          this.maxAnisotropy = options2.maxAnisotropy ?? 1;
        }
        set addressMode(value12) {
          this.addressModeU = value12;
          this.addressModeV = value12;
          this.addressModeW = value12;
        }
        /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
        get addressMode() {
          return this.addressModeU;
        }
        set wrapMode(value12) {
          deprecation(v8_0_0, "TextureStyle.wrapMode is now TextureStyle.addressMode");
          this.addressMode = value12;
        }
        get wrapMode() {
          return this.addressMode;
        }
        set scaleMode(value12) {
          this.magFilter = value12;
          this.minFilter = value12;
          this.mipmapFilter = value12;
        }
        /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
        get scaleMode() {
          return this.magFilter;
        }
        /** Specifies the maximum anisotropy value clamp used by the sampler. */
        set maxAnisotropy(value12) {
          this._maxAnisotropy = Math.min(value12, 16);
          if (this._maxAnisotropy > 1) {
            this.scaleMode = "linear";
          }
        }
        get maxAnisotropy() {
          return this._maxAnisotropy;
        }
        // TODO - move this to WebGL?
        get _resourceId() {
          return this._sharedResourceId || this._generateResourceId();
        }
        update() {
          this.emit("change", this);
          this._sharedResourceId = null;
        }
        _generateResourceId() {
          const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
          this._sharedResourceId = createResourceIdFromString(bigKey);
          return this._resourceId;
        }
        /** Destroys the style */
        destroy() {
          this.destroyed = true;
          this.emit("destroy", this);
          this.emit("change", this);
          this.removeAllListeners();
        }
      };
      _TextureStyle.defaultOptions = {
        addressMode: "clamp-to-edge",
        scaleMode: "linear"
      };
      TextureStyle = _TextureStyle;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs
  var _TextureSource, TextureSource;
  var init_TextureSource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs"() {
      init_eventemitter3();
      init_pow2();
      init_definedProps();
      init_uid();
      init_TextureStyle();
      _TextureSource = class _TextureSource2 extends eventemitter3_default {
        /**
         * @param options - options for creating a new TextureSource
         */
        constructor(options2 = {}) {
          super();
          this.options = options2;
          this.uid = uid("textureSource");
          this._resourceType = "textureSource";
          this._resourceId = uid("resource");
          this.uploadMethodId = "unknown";
          this._resolution = 1;
          this.pixelWidth = 1;
          this.pixelHeight = 1;
          this.width = 1;
          this.height = 1;
          this.sampleCount = 1;
          this.mipLevelCount = 1;
          this.autoGenerateMipmaps = false;
          this.format = "rgba8unorm";
          this.dimension = "2d";
          this.antialias = false;
          this._touched = 0;
          this._batchTick = -1;
          this._textureBindLocation = -1;
          options2 = { ..._TextureSource2.defaultOptions, ...options2 };
          this.label = options2.label ?? "";
          this.resource = options2.resource;
          this.autoGarbageCollect = options2.autoGarbageCollect;
          this._resolution = options2.resolution;
          if (options2.width) {
            this.pixelWidth = options2.width * this._resolution;
          } else {
            this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;
          }
          if (options2.height) {
            this.pixelHeight = options2.height * this._resolution;
          } else {
            this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;
          }
          this.width = this.pixelWidth / this._resolution;
          this.height = this.pixelHeight / this._resolution;
          this.format = options2.format;
          this.dimension = options2.dimensions;
          this.mipLevelCount = options2.mipLevelCount;
          this.autoGenerateMipmaps = options2.autoGenerateMipmaps;
          this.sampleCount = options2.sampleCount;
          this.antialias = options2.antialias;
          this.alphaMode = options2.alphaMode;
          this.style = new TextureStyle(definedProps(options2));
          this.destroyed = false;
          this._refreshPOT();
        }
        /** returns itself */
        get source() {
          return this;
        }
        /** the style of the texture */
        get style() {
          return this._style;
        }
        set style(value12) {
          if (this.style === value12)
            return;
          this._style?.off("change", this._onStyleChange, this);
          this._style = value12;
          this._style?.on("change", this._onStyleChange, this);
          this._onStyleChange();
        }
        /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
        get addressMode() {
          return this._style.addressMode;
        }
        set addressMode(value12) {
          this._style.addressMode = value12;
        }
        /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
        get repeatMode() {
          return this._style.addressMode;
        }
        set repeatMode(value12) {
          this._style.addressMode = value12;
        }
        /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */
        get magFilter() {
          return this._style.magFilter;
        }
        set magFilter(value12) {
          this._style.magFilter = value12;
        }
        /** Specifies the sampling behavior when the sample footprint is larger than one texel. */
        get minFilter() {
          return this._style.minFilter;
        }
        set minFilter(value12) {
          this._style.minFilter = value12;
        }
        /** Specifies behavior for sampling between mipmap levels. */
        get mipmapFilter() {
          return this._style.mipmapFilter;
        }
        set mipmapFilter(value12) {
          this._style.mipmapFilter = value12;
        }
        /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
        get lodMinClamp() {
          return this._style.lodMinClamp;
        }
        set lodMinClamp(value12) {
          this._style.lodMinClamp = value12;
        }
        /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
        get lodMaxClamp() {
          return this._style.lodMaxClamp;
        }
        set lodMaxClamp(value12) {
          this._style.lodMaxClamp = value12;
        }
        _onStyleChange() {
          this.emit("styleChange", this);
        }
        /** call this if you have modified the texture outside of the constructor */
        update() {
          if (this.resource) {
            const resolution = this._resolution;
            const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);
            if (didResize)
              return;
          }
          this.emit("update", this);
        }
        /** Destroys this texture source */
        destroy() {
          this.destroyed = true;
          this.emit("destroy", this);
          this.emit("change", this);
          if (this._style) {
            this._style.destroy();
            this._style = null;
          }
          this.uploadMethodId = null;
          this.resource = null;
          this.removeAllListeners();
        }
        /**
         * This will unload the Texture source from the GPU. This will free up the GPU memory
         * As soon as it is required fore rendering, it will be re-uploaded.
         */
        unload() {
          this._resourceId = uid("resource");
          this.emit("change", this);
          this.emit("unload", this);
        }
        /** the width of the resource. This is the REAL pure number, not accounting resolution   */
        get resourceWidth() {
          const { resource } = this;
          return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;
        }
        /** the height of the resource. This is the REAL pure number, not accounting resolution */
        get resourceHeight() {
          const { resource } = this;
          return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;
        }
        /**
         * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture
         * but will the size of the texture when rendered.
         *
         * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel
         * density will have increased)
         */
        get resolution() {
          return this._resolution;
        }
        set resolution(resolution) {
          if (this._resolution === resolution)
            return;
          this._resolution = resolution;
          this.width = this.pixelWidth / resolution;
          this.height = this.pixelHeight / resolution;
        }
        /**
         * Resize the texture, this is handy if you want to use the texture as a render texture
         * @param width - the new width of the texture
         * @param height - the new height of the texture
         * @param resolution - the new resolution of the texture
         * @returns - if the texture was resized
         */
        resize(width8, height8, resolution) {
          resolution = resolution || this._resolution;
          width8 = width8 || this.width;
          height8 = height8 || this.height;
          const newPixelWidth = Math.round(width8 * resolution);
          const newPixelHeight = Math.round(height8 * resolution);
          this.width = newPixelWidth / resolution;
          this.height = newPixelHeight / resolution;
          this._resolution = resolution;
          if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {
            return false;
          }
          this._refreshPOT();
          this.pixelWidth = newPixelWidth;
          this.pixelHeight = newPixelHeight;
          this.emit("resize", this);
          this._resourceId = uid("resource");
          this.emit("change", this);
          return true;
        }
        /**
         * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.
         * This is only important for RenderTexture instances, as standard Texture instances will have their
         * mipmaps generated on upload. You should call this method after you make any change to the texture
         *
         * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,
         * We want you, the developer to specify when this action should happen.
         *
         * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,
         */
        updateMipmaps() {
          if (this.autoGenerateMipmaps && this.mipLevelCount > 1) {
            this.emit("updateMipmaps", this);
          }
        }
        set wrapMode(value12) {
          this._style.wrapMode = value12;
        }
        get wrapMode() {
          return this._style.wrapMode;
        }
        set scaleMode(value12) {
          this._style.scaleMode = value12;
        }
        /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
        get scaleMode() {
          return this._style.scaleMode;
        }
        /**
         * Refresh check for isPowerOfTwo texture based on size
         * @private
         */
        _refreshPOT() {
          this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);
        }
        static test(_resource) {
          throw new Error("Unimplemented");
        }
      };
      _TextureSource.defaultOptions = {
        resolution: 1,
        format: "bgra8unorm",
        alphaMode: "premultiply-alpha-on-upload",
        dimensions: "2d",
        mipLevelCount: 1,
        autoGenerateMipmaps: false,
        sampleCount: 1,
        antialias: false,
        autoGarbageCollect: false
      };
      TextureSource = _TextureSource;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs
  var BufferImageSource;
  var init_BufferImageSource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs"() {
      init_Extensions();
      init_TextureSource();
      BufferImageSource = class extends TextureSource {
        constructor(options2) {
          const buffer = options2.resource || new Float32Array(options2.width * options2.height * 4);
          let format = options2.format;
          if (!format) {
            if (buffer instanceof Float32Array) {
              format = "rgba32float";
            } else if (buffer instanceof Int32Array) {
              format = "rgba32uint";
            } else if (buffer instanceof Uint32Array) {
              format = "rgba32uint";
            } else if (buffer instanceof Int16Array) {
              format = "rgba16uint";
            } else if (buffer instanceof Uint16Array) {
              format = "rgba16uint";
            } else if (buffer instanceof Int8Array) {
              format = "bgra8unorm";
            } else {
              format = "bgra8unorm";
            }
          }
          super({
            ...options2,
            resource: buffer,
            format
          });
          this.uploadMethodId = "buffer";
        }
        static test(resource) {
          return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;
        }
      };
      BufferImageSource.extension = ExtensionType.TextureSource;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs
  var tempMat, TextureMatrix;
  var init_TextureMatrix = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs"() {
      init_Matrix();
      tempMat = new Matrix();
      TextureMatrix = class {
        /**
         * @param texture - observed texture
         * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
         */
        constructor(texture, clampMargin) {
          this.mapCoord = new Matrix();
          this.uClampFrame = new Float32Array(4);
          this.uClampOffset = new Float32Array(2);
          this._textureID = -1;
          this._updateID = 0;
          this.clampOffset = 0;
          if (typeof clampMargin === "undefined") {
            this.clampMargin = texture.width < 10 ? 0 : 0.5;
          } else {
            this.clampMargin = clampMargin;
          }
          this.isSimple = false;
          this.texture = texture;
        }
        /** Texture property. */
        get texture() {
          return this._texture;
        }
        set texture(value12) {
          if (this.texture === value12)
            return;
          this._texture?.removeListener("update", this.update, this);
          this._texture = value12;
          this._texture.addListener("update", this.update, this);
          this.update();
        }
        /**
         * Multiplies uvs array to transform
         * @param uvs - mesh uvs
         * @param [out=uvs] - output
         * @returns - output
         */
        multiplyUvs(uvs, out2) {
          if (out2 === void 0) {
            out2 = uvs;
          }
          const mat = this.mapCoord;
          for (let i2 = 0; i2 < uvs.length; i2 += 2) {
            const x2 = uvs[i2];
            const y2 = uvs[i2 + 1];
            out2[i2] = x2 * mat.a + y2 * mat.c + mat.tx;
            out2[i2 + 1] = x2 * mat.b + y2 * mat.d + mat.ty;
          }
          return out2;
        }
        /**
         * Updates matrices if texture was changed
         * @returns - whether or not it was updated
         */
        update() {
          const tex = this._texture;
          this._updateID++;
          const uvs = tex.uvs;
          this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
          const orig = tex.orig;
          const trim2 = tex.trim;
          if (trim2) {
            tempMat.set(
              orig.width / trim2.width,
              0,
              0,
              orig.height / trim2.height,
              -trim2.x / trim2.width,
              -trim2.y / trim2.height
            );
            this.mapCoord.append(tempMat);
          }
          const texBase = tex.source;
          const frame = this.uClampFrame;
          const margin = this.clampMargin / texBase._resolution;
          const offset = this.clampOffset / texBase._resolution;
          frame[0] = (tex.frame.x + margin + offset) / texBase.width;
          frame[1] = (tex.frame.y + margin + offset) / texBase.height;
          frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;
          frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;
          this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;
          this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;
          this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;
          return true;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs
  var Texture;
  var init_Texture = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs"() {
      init_eventemitter3();
      init_groupD8();
      init_Rectangle();
      init_uid();
      init_deprecation();
      init_NOOP();
      init_BufferImageSource();
      init_TextureSource();
      init_TextureMatrix();
      Texture = class extends eventemitter3_default {
        /**
         * @param {rendering.TextureOptions} options - Options for the texture
         */
        constructor({
          source: source3,
          label: label4,
          frame,
          orig,
          trim: trim2,
          defaultAnchor,
          defaultBorders,
          rotate,
          dynamic
        } = {}) {
          super();
          this.uid = uid("texture");
          this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };
          this.frame = new Rectangle();
          this.noFrame = false;
          this.dynamic = false;
          this.isTexture = true;
          this.label = label4;
          this.source = source3?.source ?? new TextureSource();
          this.noFrame = !frame;
          if (frame) {
            this.frame.copyFrom(frame);
          } else {
            const { width: width8, height: height8 } = this._source;
            this.frame.width = width8;
            this.frame.height = height8;
          }
          this.orig = orig || this.frame;
          this.trim = trim2;
          this.rotate = rotate ?? 0;
          this.defaultAnchor = defaultAnchor;
          this.defaultBorders = defaultBorders;
          this.destroyed = false;
          this.dynamic = dynamic || false;
          this.updateUvs();
        }
        set source(value12) {
          if (this._source) {
            this._source.off("resize", this.update, this);
          }
          this._source = value12;
          value12.on("resize", this.update, this);
          this.emit("update", this);
        }
        /** the underlying source of the texture (equivalent of baseTexture in v7) */
        get source() {
          return this._source;
        }
        /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */
        get textureMatrix() {
          if (!this._textureMatrix) {
            this._textureMatrix = new TextureMatrix(this);
          }
          return this._textureMatrix;
        }
        /** The width of the Texture in pixels. */
        get width() {
          return this.orig.width;
        }
        /** The height of the Texture in pixels. */
        get height() {
          return this.orig.height;
        }
        /** Call this function when you have modified the frame of this texture. */
        updateUvs() {
          const { uvs, frame } = this;
          const { width: width8, height: height8 } = this._source;
          const nX = frame.x / width8;
          const nY = frame.y / height8;
          const nW = frame.width / width8;
          const nH = frame.height / height8;
          let rotate = this.rotate;
          if (rotate) {
            const w2 = nW / 2;
            const h2 = nH / 2;
            const cX = nX + w2;
            const cY = nY + h2;
            rotate = groupD8.add(rotate, groupD8.NW);
            uvs.x0 = cX + w2 * groupD8.uX(rotate);
            uvs.y0 = cY + h2 * groupD8.uY(rotate);
            rotate = groupD8.add(rotate, 2);
            uvs.x1 = cX + w2 * groupD8.uX(rotate);
            uvs.y1 = cY + h2 * groupD8.uY(rotate);
            rotate = groupD8.add(rotate, 2);
            uvs.x2 = cX + w2 * groupD8.uX(rotate);
            uvs.y2 = cY + h2 * groupD8.uY(rotate);
            rotate = groupD8.add(rotate, 2);
            uvs.x3 = cX + w2 * groupD8.uX(rotate);
            uvs.y3 = cY + h2 * groupD8.uY(rotate);
          } else {
            uvs.x0 = nX;
            uvs.y0 = nY;
            uvs.x1 = nX + nW;
            uvs.y1 = nY;
            uvs.x2 = nX + nW;
            uvs.y2 = nY + nH;
            uvs.x3 = nX;
            uvs.y3 = nY + nH;
          }
        }
        /**
         * Destroys this texture
         * @param destroySource - Destroy the source when the texture is destroyed.
         */
        destroy(destroySource = false) {
          if (this._source) {
            if (destroySource) {
              this._source.destroy();
              this._source = null;
            }
          }
          this._textureMatrix = null;
          this.destroyed = true;
          this.emit("destroy", this);
          this.removeAllListeners();
        }
        /**
         * Call this if you have modified the `texture outside` of the constructor.
         *
         * If you have modified this texture's source, you must separately call `texture.source.update()` to see those changes.
         */
        update() {
          if (this.noFrame) {
            this.frame.width = this._source.width;
            this.frame.height = this._source.height;
          }
          this.updateUvs();
          this.emit("update", this);
        }
        /** @deprecated since 8.0.0 */
        get baseTexture() {
          deprecation(v8_0_0, "Texture.baseTexture is now Texture.source");
          return this._source;
        }
      };
      Texture.EMPTY = new Texture({
        label: "EMPTY",
        source: new TextureSource({
          label: "EMPTY"
        })
      });
      Texture.EMPTY.destroy = NOOP;
      Texture.WHITE = new Texture({
        source: new BufferImageSource({
          resource: new Uint8Array([255, 255, 255, 255]),
          width: 1,
          height: 1,
          alphaMode: "premultiply-alpha-on-upload",
          label: "WHITE"
        }),
        label: "WHITE"
      });
      Texture.WHITE.destroy = NOOP;
    }
  });

  // node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs
  var _Spritesheet, Spritesheet;
  var init_Spritesheet = __esm({
    "node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs"() {
      init_Rectangle();
      init_Texture();
      _Spritesheet = class _Spritesheet2 {
        /**
         * @param texture - Reference to the source BaseTexture object.
         * @param {object} data - Spritesheet image data.
         */
        constructor(texture, data) {
          this.linkedSheets = [];
          this._texture = texture instanceof Texture ? texture : null;
          this.textureSource = texture.source;
          this.textures = {};
          this.animations = {};
          this.data = data;
          const metaResolution = parseFloat(data.meta.scale);
          if (metaResolution) {
            this.resolution = metaResolution;
            texture.source.resolution = this.resolution;
          } else {
            this.resolution = texture.source._resolution;
          }
          this._frames = this.data.frames;
          this._frameKeys = Object.keys(this._frames);
          this._batchIndex = 0;
          this._callback = null;
        }
        /**
         * Parser spritesheet from loaded data. This is done asynchronously
         * to prevent creating too many Texture within a single process.
         */
        parse() {
          return new Promise((resolve) => {
            this._callback = resolve;
            this._batchIndex = 0;
            if (this._frameKeys.length <= _Spritesheet2.BATCH_SIZE) {
              this._processFrames(0);
              this._processAnimations();
              this._parseComplete();
            } else {
              this._nextBatch();
            }
          });
        }
        /**
         * Process a batch of frames
         * @param initialFrameIndex - The index of frame to start.
         */
        _processFrames(initialFrameIndex) {
          let frameIndex = initialFrameIndex;
          const maxFrames = _Spritesheet2.BATCH_SIZE;
          while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
            const i2 = this._frameKeys[frameIndex];
            const data = this._frames[i2];
            const rect = data.frame;
            if (rect) {
              let frame = null;
              let trim2 = null;
              const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
              const orig = new Rectangle(
                0,
                0,
                Math.floor(sourceSize.w) / this.resolution,
                Math.floor(sourceSize.h) / this.resolution
              );
              if (data.rotated) {
                frame = new Rectangle(
                  Math.floor(rect.x) / this.resolution,
                  Math.floor(rect.y) / this.resolution,
                  Math.floor(rect.h) / this.resolution,
                  Math.floor(rect.w) / this.resolution
                );
              } else {
                frame = new Rectangle(
                  Math.floor(rect.x) / this.resolution,
                  Math.floor(rect.y) / this.resolution,
                  Math.floor(rect.w) / this.resolution,
                  Math.floor(rect.h) / this.resolution
                );
              }
              if (data.trimmed !== false && data.spriteSourceSize) {
                trim2 = new Rectangle(
                  Math.floor(data.spriteSourceSize.x) / this.resolution,
                  Math.floor(data.spriteSourceSize.y) / this.resolution,
                  Math.floor(rect.w) / this.resolution,
                  Math.floor(rect.h) / this.resolution
                );
              }
              this.textures[i2] = new Texture({
                source: this.textureSource,
                frame,
                orig,
                trim: trim2,
                rotate: data.rotated ? 2 : 0,
                defaultAnchor: data.anchor,
                defaultBorders: data.borders,
                label: i2.toString()
              });
            }
            frameIndex++;
          }
        }
        /** Parse animations config. */
        _processAnimations() {
          const animations = this.data.animations || {};
          for (const animName in animations) {
            this.animations[animName] = [];
            for (let i2 = 0; i2 < animations[animName].length; i2++) {
              const frameName = animations[animName][i2];
              this.animations[animName].push(this.textures[frameName]);
            }
          }
        }
        /** The parse has completed. */
        _parseComplete() {
          const callback = this._callback;
          this._callback = null;
          this._batchIndex = 0;
          callback.call(this, this.textures);
        }
        /** Begin the next batch of textures. */
        _nextBatch() {
          this._processFrames(this._batchIndex * _Spritesheet2.BATCH_SIZE);
          this._batchIndex++;
          setTimeout(() => {
            if (this._batchIndex * _Spritesheet2.BATCH_SIZE < this._frameKeys.length) {
              this._nextBatch();
            } else {
              this._processAnimations();
              this._parseComplete();
            }
          }, 0);
        }
        /**
         * Destroy Spritesheet and don't use after this.
         * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well
         */
        destroy(destroyBase = false) {
          for (const i2 in this.textures) {
            this.textures[i2].destroy();
          }
          this._frames = null;
          this._frameKeys = null;
          this.data = null;
          this.textures = null;
          if (destroyBase) {
            this._texture?.destroy();
            this.textureSource.destroy();
          }
          this._texture = null;
          this.textureSource = null;
          this.linkedSheets = [];
        }
      };
      _Spritesheet.BATCH_SIZE = 1e3;
      Spritesheet = _Spritesheet;
    }
  });

  // node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs
  function getCacheableAssets(keys6, asset, ignoreMultiPack) {
    const out2 = {};
    keys6.forEach((key) => {
      out2[key] = asset;
    });
    Object.keys(asset.textures).forEach((key) => {
      out2[key] = asset.textures[key];
    });
    if (!ignoreMultiPack) {
      const basePath = path.dirname(keys6[0]);
      asset.linkedSheets.forEach((item, i2) => {
        const out22 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i2]}`], item, true);
        Object.assign(out2, out22);
      });
    }
    return out2;
  }
  var validImages, spritesheetAsset;
  var init_spritesheetAsset = __esm({
    "node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs"() {
      init_LoaderParser();
      init_Resolver();
      init_copySearchParams();
      init_Extensions();
      init_Texture();
      init_path();
      init_Spritesheet();
      validImages = [
        "jpg",
        "png",
        "jpeg",
        "avif",
        "webp",
        "basis",
        "etc2",
        "bc7",
        "bc6h",
        "bc5",
        "bc4",
        "bc3",
        "bc2",
        "bc1",
        "eac",
        "astc"
      ];
      spritesheetAsset = {
        extension: ExtensionType.Asset,
        /** Handle the caching of the related Spritesheet Textures */
        cache: {
          test: (asset) => asset instanceof Spritesheet,
          getCacheableAssets: (keys6, asset) => getCacheableAssets(keys6, asset, false)
        },
        /** Resolve the resolution of the asset. */
        resolver: {
          extension: {
            type: ExtensionType.ResolveParser,
            name: "resolveSpritesheet"
          },
          test: (value12) => {
            const tempURL = value12.split("?")[0];
            const split3 = tempURL.split(".");
            const extension = split3.pop();
            const format = split3.pop();
            return extension === "json" && validImages.includes(format);
          },
          parse: (value12) => {
            const split3 = value12.split(".");
            return {
              resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value12)?.[1] ?? "1"),
              format: split3[split3.length - 2],
              src: value12
            };
          }
        },
        /**
         * Loader plugin that parses sprite sheets!
         * once the JSON has been loaded this checks to see if the JSON is spritesheet data.
         * If it is, we load the spritesheets image and parse the data into Spritesheet
         * All textures in the sprite sheet are then added to the cache
         */
        loader: {
          name: "spritesheetLoader",
          extension: {
            type: ExtensionType.LoadParser,
            priority: LoaderParserPriority.Normal,
            name: "spritesheetLoader"
          },
          async testParse(asset, options2) {
            return path.extname(options2.src).toLowerCase() === ".json" && !!asset.frames;
          },
          async parse(asset, options2, loader) {
            const {
              texture: imageTexture,
              // if user need to use preloaded texture
              imageFilename
              // if user need to use custom filename (not from jsonFile.meta.image)
            } = options2?.data ?? {};
            let basePath = path.dirname(options2.src);
            if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
              basePath += "/";
            }
            let texture;
            if (imageTexture instanceof Texture) {
              texture = imageTexture;
            } else {
              const imagePath = copySearchParams(basePath + (imageFilename ?? asset.meta.image), options2.src);
              const assets = await loader.load([imagePath]);
              texture = assets[imagePath];
            }
            const spritesheet = new Spritesheet(
              texture.source,
              asset
            );
            await spritesheet.parse();
            const multiPacks = asset?.meta?.related_multi_packs;
            if (Array.isArray(multiPacks)) {
              const promises = [];
              for (const item of multiPacks) {
                if (typeof item !== "string") {
                  continue;
                }
                let itemUrl = basePath + item;
                if (options2.data?.ignoreMultiPack) {
                  continue;
                }
                itemUrl = copySearchParams(itemUrl, options2.src);
                promises.push(loader.load({
                  src: itemUrl,
                  data: {
                    ignoreMultiPack: true
                  }
                }));
              }
              const res = await Promise.all(promises);
              spritesheet.linkedSheets = res;
              res.forEach((item) => {
                item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
              });
            }
            return spritesheet;
          },
          async unload(spritesheet, _resolvedAsset, loader) {
            await loader.unload(spritesheet.textureSource._sourceOrigin);
            spritesheet.destroy(false);
          }
        }
      };
    }
  });

  // node_modules/pixi.js/lib/spritesheet/init.mjs
  var init_init4 = __esm({
    "node_modules/pixi.js/lib/spritesheet/init.mjs"() {
      init_Extensions();
      init_spritesheetAsset();
      extensions.add(spritesheetAsset);
    }
  });

  // node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs
  function updateQuadBounds(bounds, anchor, texture, padding) {
    const { width: width8, height: height8 } = texture.orig;
    const trim2 = texture.trim;
    if (trim2) {
      const sourceWidth = trim2.width;
      const sourceHeight = trim2.height;
      bounds.minX = trim2.x - anchor._x * width8 - padding;
      bounds.maxX = bounds.minX + sourceWidth;
      bounds.minY = trim2.y - anchor._y * height8 - padding;
      bounds.maxY = bounds.minY + sourceHeight;
    } else {
      bounds.minX = -anchor._x * width8 - padding;
      bounds.maxX = bounds.minX + width8;
      bounds.minY = -anchor._y * height8 - padding;
      bounds.maxY = bounds.minY + height8;
    }
    return;
  }
  var init_updateQuadBounds = __esm({
    "node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/view/ViewContainer.mjs
  var ViewContainer;
  var init_ViewContainer = __esm({
    "node_modules/pixi.js/lib/scene/view/ViewContainer.mjs"() {
      init_Bounds();
      init_Container();
      ViewContainer = class extends Container {
        constructor() {
          super(...arguments);
          this.canBundle = true;
          this.allowChildren = false;
          this._roundPixels = 0;
          this._lastUsed = 0;
          this._lastInstructionTick = -1;
          this._bounds = new Bounds(0, 1, 0, 0);
          this._boundsDirty = true;
        }
        /** @private */
        _updateBounds() {
        }
        /**
         * Whether or not to round the x/y position of the sprite.
         * @type {boolean}
         */
        get roundPixels() {
          return !!this._roundPixels;
        }
        set roundPixels(value12) {
          this._roundPixels = value12 ? 1 : 0;
        }
        /**
         * Checks if the object contains the given point.
         * @param point - The point to check
         */
        containsPoint(point) {
          const bounds = this.bounds;
          const { x: x2, y: y2 } = point;
          return x2 >= bounds.minX && x2 <= bounds.maxX && y2 >= bounds.minY && y2 <= bounds.maxY;
        }
        /** @private */
        onViewUpdate() {
          this._didViewChangeTick++;
          if (this.didViewUpdate)
            return;
          this.didViewUpdate = true;
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.onChildViewUpdate(this);
          }
        }
        destroy(options2) {
          super.destroy(options2);
          this._bounds = null;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/sprite/Sprite.mjs
  var Sprite;
  var init_Sprite = __esm({
    "node_modules/pixi.js/lib/scene/sprite/Sprite.mjs"() {
      init_ObservablePoint();
      init_Texture();
      init_updateQuadBounds();
      init_ViewContainer();
      Sprite = class _Sprite extends ViewContainer {
        /**
         * @param options - The options for creating the sprite.
         */
        constructor(options2 = Texture.EMPTY) {
          if (options2 instanceof Texture) {
            options2 = { texture: options2 };
          }
          const { texture = Texture.EMPTY, anchor, roundPixels, width: width8, height: height8, ...rest } = options2;
          super({
            label: "Sprite",
            ...rest
          });
          this.renderPipeId = "sprite";
          this.batched = true;
          this._sourceBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
          this._sourceBoundsDirty = true;
          this._anchor = new ObservablePoint(
            {
              _onUpdate: () => {
                this.onViewUpdate();
              }
            }
          );
          if (anchor) {
            this.anchor = anchor;
          } else if (texture.defaultAnchor) {
            this.anchor = texture.defaultAnchor;
          }
          this.texture = texture;
          this.allowChildren = false;
          this.roundPixels = roundPixels ?? false;
          if (width8 !== void 0)
            this.width = width8;
          if (height8 !== void 0)
            this.height = height8;
        }
        /**
         * Helper function that creates a new sprite based on the source you provide.
         * The source can be - frame id, image, video, canvas element, video element, texture
         * @param source - Source to create texture from
         * @param [skipCache] - Whether to skip the cache or not
         * @returns The newly created sprite
         */
        static from(source3, skipCache = false) {
          if (source3 instanceof Texture) {
            return new _Sprite(source3);
          }
          return new _Sprite(Texture.from(source3, skipCache));
        }
        set texture(value12) {
          value12 || (value12 = Texture.EMPTY);
          const currentTexture = this._texture;
          if (currentTexture === value12)
            return;
          if (currentTexture && currentTexture.dynamic)
            currentTexture.off("update", this.onViewUpdate, this);
          if (value12.dynamic)
            value12.on("update", this.onViewUpdate, this);
          this._texture = value12;
          if (this._width) {
            this._setWidth(this._width, this._texture.orig.width);
          }
          if (this._height) {
            this._setHeight(this._height, this._texture.orig.height);
          }
          this.onViewUpdate();
        }
        /** The texture that the sprite is using. */
        get texture() {
          return this._texture;
        }
        /**
         * The local bounds of the sprite.
         * @type {rendering.Bounds}
         */
        get bounds() {
          if (this._boundsDirty) {
            this._updateBounds();
            this._boundsDirty = false;
          }
          return this._bounds;
        }
        /**
         * The bounds of the sprite, taking the texture's trim into account.
         * @type {rendering.Bounds}
         */
        get sourceBounds() {
          if (this._sourceBoundsDirty) {
            this._updateSourceBounds();
            this._sourceBoundsDirty = false;
          }
          return this._sourceBounds;
        }
        /**
         * Checks if the object contains the given point.
         * @param point - The point to check
         */
        containsPoint(point) {
          const bounds = this.sourceBounds;
          if (point.x >= bounds.maxX && point.x <= bounds.minX) {
            if (point.y >= bounds.maxY && point.y <= bounds.minY) {
              return true;
            }
          }
          return false;
        }
        /**
         * Adds the bounds of this object to the bounds object.
         * @param bounds - The output bounds object.
         */
        addBounds(bounds) {
          const _bounds = this._texture.trim ? this.sourceBounds : this.bounds;
          bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);
        }
        onViewUpdate() {
          this._sourceBoundsDirty = this._boundsDirty = true;
          super.onViewUpdate();
        }
        _updateBounds() {
          updateQuadBounds(this._bounds, this._anchor, this._texture, 0);
        }
        _updateSourceBounds() {
          const anchor = this._anchor;
          const texture = this._texture;
          const sourceBounds = this._sourceBounds;
          const { width: width8, height: height8 } = texture.orig;
          sourceBounds.maxX = -anchor._x * width8;
          sourceBounds.minX = sourceBounds.maxX + width8;
          sourceBounds.maxY = -anchor._y * height8;
          sourceBounds.minY = sourceBounds.maxY + height8;
        }
        /**
         * Destroys this sprite renderable and optionally its texture.
         * @param options - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
         * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
         */
        destroy(options2 = false) {
          super.destroy(options2);
          const destroyTexture = typeof options2 === "boolean" ? options2 : options2?.texture;
          if (destroyTexture) {
            const destroyTextureSource = typeof options2 === "boolean" ? options2 : options2?.textureSource;
            this._texture.destroy(destroyTextureSource);
          }
          this._texture = null;
          this._bounds = null;
          this._sourceBounds = null;
          this._anchor = null;
        }
        /**
         * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
         * and passed to the constructor.
         *
         * The default is `(0,0)`, this means the sprite's origin is the top left.
         *
         * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
         *
         * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
         *
         * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
         * @example
         * import { Sprite } from 'pixi.js';
         *
         * const sprite = new Sprite({texture: Texture.WHITE});
         * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
         */
        get anchor() {
          return this._anchor;
        }
        set anchor(value12) {
          typeof value12 === "number" ? this._anchor.set(value12) : this._anchor.copyFrom(value12);
        }
        /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
        get width() {
          return Math.abs(this.scale.x) * this._texture.orig.width;
        }
        set width(value12) {
          this._setWidth(value12, this._texture.orig.width);
          this._width = value12;
        }
        /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
        get height() {
          return Math.abs(this.scale.y) * this._texture.orig.height;
        }
        set height(value12) {
          this._setHeight(value12, this._texture.orig.height);
          this._height = value12;
        }
        /**
         * Retrieves the size of the Sprite as a [Size]{@link Size} object.
         * This is faster than get the width and height separately.
         * @param out - Optional object to store the size in.
         * @returns - The size of the Sprite.
         */
        getSize(out2) {
          out2 || (out2 = {});
          out2.width = Math.abs(this.scale.x) * this._texture.orig.width;
          out2.height = Math.abs(this.scale.y) * this._texture.orig.height;
          return out2;
        }
        /**
         * Sets the size of the Sprite to the specified width and height.
         * This is faster than setting the width and height separately.
         * @param value - This can be either a number or a [Size]{@link Size} object.
         * @param height - The height to set. Defaults to the value of `width` if not provided.
         */
        setSize(value12, height8) {
          if (typeof value12 === "object") {
            height8 = value12.height ?? value12.width;
            value12 = value12.width;
          } else {
            height8 ?? (height8 = value12);
          }
          value12 !== void 0 && this._setWidth(value12, this._texture.orig.width);
          height8 !== void 0 && this._setHeight(height8, this._texture.orig.height);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs
  function addMaskBounds(mask, bounds, skipUpdateTransform) {
    const boundsToMask = tempBounds;
    mask.measurable = true;
    getGlobalBounds(mask, skipUpdateTransform, boundsToMask);
    bounds.addBoundsMask(boundsToMask);
    mask.measurable = false;
  }
  var tempBounds;
  var init_addMaskBounds = __esm({
    "node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs"() {
      init_Bounds();
      init_getGlobalBounds();
      tempBounds = new Bounds();
    }
  });

  // node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs
  function addMaskLocalBounds(mask, bounds, localRoot) {
    const boundsToMask = boundsPool.get();
    mask.measurable = true;
    const tempMatrix6 = matrixPool.get().identity();
    const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix6);
    getLocalBounds(mask, boundsToMask, relativeMask);
    mask.measurable = false;
    bounds.addBoundsMask(boundsToMask);
    matrixPool.return(tempMatrix6);
    boundsPool.return(boundsToMask);
  }
  function getMatrixRelativeToParent(target5, root, matrix) {
    if (!target5) {
      warn2("Mask bounds, renderable is not inside the root container");
      return matrix;
    }
    if (target5 !== root) {
      getMatrixRelativeToParent(target5.parent, root, matrix);
      target5.updateLocalTransform();
      matrix.append(target5.localTransform);
    }
    return matrix;
  }
  var init_addMaskLocalBounds = __esm({
    "node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs"() {
      init_getLocalBounds();
      init_matrixAndBoundsPool();
      init_warn();
    }
  });

  // node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs
  var AlphaMask;
  var init_AlphaMask = __esm({
    "node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs"() {
      init_Extensions();
      init_Sprite();
      init_addMaskBounds();
      init_addMaskLocalBounds();
      AlphaMask = class {
        constructor(options2) {
          this.priority = 0;
          this.inverse = false;
          this.pipe = "alphaMask";
          if (options2?.mask) {
            this.init(options2.mask);
          }
        }
        init(mask) {
          this.mask = mask;
          this.renderMaskToTexture = !(mask instanceof Sprite);
          this.mask.renderable = this.renderMaskToTexture;
          this.mask.includeInBuild = !this.renderMaskToTexture;
          this.mask.measurable = false;
        }
        reset() {
          this.mask.measurable = true;
          this.mask = null;
        }
        addBounds(bounds, skipUpdateTransform) {
          if (!this.inverse) {
            addMaskBounds(this.mask, bounds, skipUpdateTransform);
          }
        }
        addLocalBounds(bounds, localRoot) {
          addMaskLocalBounds(this.mask, bounds, localRoot);
        }
        containsPoint(point, hitTestFn) {
          const mask = this.mask;
          return hitTestFn(mask, point);
        }
        destroy() {
          this.reset();
        }
        static test(mask) {
          return mask instanceof Sprite;
        }
      };
      AlphaMask.extension = ExtensionType.MaskEffect;
    }
  });

  // node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs
  var ColorMask;
  var init_ColorMask = __esm({
    "node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs"() {
      init_Extensions();
      ColorMask = class {
        constructor(options2) {
          this.priority = 0;
          this.pipe = "colorMask";
          if (options2?.mask) {
            this.init(options2.mask);
          }
        }
        init(mask) {
          this.mask = mask;
        }
        destroy() {
        }
        static test(mask) {
          return typeof mask === "number";
        }
      };
      ColorMask.extension = ExtensionType.MaskEffect;
    }
  });

  // node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs
  var StencilMask;
  var init_StencilMask = __esm({
    "node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs"() {
      init_Extensions();
      init_Container();
      init_addMaskBounds();
      init_addMaskLocalBounds();
      StencilMask = class {
        constructor(options2) {
          this.priority = 0;
          this.pipe = "stencilMask";
          if (options2?.mask) {
            this.init(options2.mask);
          }
        }
        init(mask) {
          this.mask = mask;
          this.mask.includeInBuild = false;
          this.mask.measurable = false;
        }
        reset() {
          this.mask.measurable = true;
          this.mask.includeInBuild = true;
          this.mask = null;
        }
        addBounds(bounds, skipUpdateTransform) {
          addMaskBounds(this.mask, bounds, skipUpdateTransform);
        }
        addLocalBounds(bounds, localRoot) {
          addMaskLocalBounds(this.mask, bounds, localRoot);
        }
        containsPoint(point, hitTestFn) {
          const mask = this.mask;
          return hitTestFn(mask, point);
        }
        destroy() {
          this.reset();
        }
        static test(mask) {
          return mask instanceof Container;
        }
      };
      StencilMask.extension = ExtensionType.MaskEffect;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs
  var CanvasSource;
  var init_CanvasSource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs"() {
      init_adapter();
      init_Extensions();
      init_TextureSource();
      CanvasSource = class extends TextureSource {
        constructor(options2) {
          if (!options2.resource) {
            options2.resource = DOMAdapter.get().createCanvas();
          }
          if (!options2.width) {
            options2.width = options2.resource.width;
            if (!options2.autoDensity) {
              options2.width /= options2.resolution;
            }
          }
          if (!options2.height) {
            options2.height = options2.resource.height;
            if (!options2.autoDensity) {
              options2.height /= options2.resolution;
            }
          }
          super(options2);
          this.uploadMethodId = "image";
          this.autoDensity = options2.autoDensity;
          const canvas2 = options2.resource;
          if (this.pixelWidth !== canvas2.width || this.pixelWidth !== canvas2.height) {
            this.resizeCanvas();
          }
          this.transparent = !!options2.transparent;
        }
        resizeCanvas() {
          if (this.autoDensity) {
            this.resource.style.width = `${this.width}px`;
            this.resource.style.height = `${this.height}px`;
          }
          if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {
            this.resource.width = this.pixelWidth;
            this.resource.height = this.pixelHeight;
          }
        }
        resize(width8 = this.width, height8 = this.height, resolution = this._resolution) {
          const didResize = super.resize(width8, height8, resolution);
          if (didResize) {
            this.resizeCanvas();
          }
          return didResize;
        }
        static test(resource) {
          return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;
        }
        /**
         * Returns the 2D rendering context for the canvas.
         * Caches the context after creating it.
         * @returns The 2D rendering context of the canvas.
         */
        get context2D() {
          return this._context2D || (this._context2D = this.resource.getContext("2d"));
        }
      };
      CanvasSource.extension = ExtensionType.TextureSource;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs
  var ImageSource;
  var init_ImageSource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs"() {
      init_adapter();
      init_Extensions();
      init_warn();
      init_TextureSource();
      ImageSource = class extends TextureSource {
        constructor(options2) {
          if (options2.resource && (globalThis.HTMLImageElement && options2.resource instanceof HTMLImageElement)) {
            const canvas2 = DOMAdapter.get().createCanvas(options2.resource.width, options2.resource.height);
            const context3 = canvas2.getContext("2d");
            context3.drawImage(options2.resource, 0, 0, options2.resource.width, options2.resource.height);
            options2.resource = canvas2;
            warn2("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.");
          }
          super(options2);
          this.uploadMethodId = "image";
          this.autoGarbageCollect = true;
        }
        static test(resource) {
          return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== "undefined" && resource instanceof ImageBitmap || globalThis.VideoFrame && resource instanceof VideoFrame;
        }
      };
      ImageSource.extension = ExtensionType.TextureSource;
    }
  });

  // node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs
  async function detectVideoAlphaMode() {
    promise ?? (promise = (async () => {
      const canvas2 = document.createElement("canvas");
      const gl = canvas2.getContext("webgl");
      if (!gl) {
        return "premultiply-alpha-on-upload";
      }
      const video = await new Promise((resolve) => {
        const video2 = document.createElement("video");
        video2.onloadeddata = () => resolve(video2);
        video2.onerror = () => resolve(null);
        video2.autoplay = false;
        video2.crossOrigin = "anonymous";
        video2.preload = "auto";
        video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=";
        video2.load();
      });
      if (!video) {
        return "premultiply-alpha-on-upload";
      }
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      const framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(
        gl.FRAMEBUFFER,
        gl.COLOR_ATTACHMENT0,
        gl.TEXTURE_2D,
        texture,
        0
      );
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
      const pixel = new Uint8Array(4);
      gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
      gl.deleteFramebuffer(framebuffer);
      gl.deleteTexture(texture);
      gl.getExtension("WEBGL_lose_context")?.loseContext();
      return pixel[0] <= pixel[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
    })());
    return promise;
  }
  var promise;
  var init_detectVideoAlphaMode = __esm({
    "node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs
  var _VideoSource, VideoSource;
  var init_VideoSource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs"() {
      init_Extensions();
      init_Ticker();
      init_detectVideoAlphaMode();
      init_TextureSource();
      _VideoSource = class _VideoSource2 extends TextureSource {
        constructor(options2) {
          super(options2);
          this.isReady = false;
          this.uploadMethodId = "video";
          options2 = {
            ..._VideoSource2.defaultOptions,
            ...options2
          };
          this._autoUpdate = true;
          this._isConnectedToTicker = false;
          this._updateFPS = options2.updateFPS || 0;
          this._msToNextUpdate = 0;
          this.autoPlay = options2.autoPlay !== false;
          this.alphaMode = options2.alphaMode ?? "premultiply-alpha-on-upload";
          this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);
          this._videoFrameRequestCallbackHandle = null;
          this._load = null;
          this._resolve = null;
          this._reject = null;
          this._onCanPlay = this._onCanPlay.bind(this);
          this._onCanPlayThrough = this._onCanPlayThrough.bind(this);
          this._onError = this._onError.bind(this);
          this._onPlayStart = this._onPlayStart.bind(this);
          this._onPlayStop = this._onPlayStop.bind(this);
          this._onSeeked = this._onSeeked.bind(this);
          if (options2.autoLoad !== false) {
            void this.load();
          }
        }
        /** Update the video frame if the source is not destroyed and meets certain conditions. */
        updateFrame() {
          if (this.destroyed) {
            return;
          }
          if (this._updateFPS) {
            const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;
            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
          }
          if (!this._updateFPS || this._msToNextUpdate <= 0) {
            this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
          }
          if (this.isValid) {
            this.update();
          }
        }
        /** Callback to update the video frame and potentially request the next frame update. */
        _videoFrameRequestCallback() {
          this.updateFrame();
          if (this.destroyed) {
            this._videoFrameRequestCallbackHandle = null;
          } else {
            this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
              this._videoFrameRequestCallback
            );
          }
        }
        /**
         * Checks if the resource has valid dimensions.
         * @returns {boolean} True if width and height are set, otherwise false.
         */
        get isValid() {
          return !!this.resource.videoWidth && !!this.resource.videoHeight;
        }
        /**
         * Start preloading the video resource.
         * @returns {Promise<this>} Handle the validate event
         */
        async load() {
          if (this._load) {
            return this._load;
          }
          const source3 = this.resource;
          const options2 = this.options;
          if ((source3.readyState === source3.HAVE_ENOUGH_DATA || source3.readyState === source3.HAVE_FUTURE_DATA) && source3.width && source3.height) {
            source3.complete = true;
          }
          source3.addEventListener("play", this._onPlayStart);
          source3.addEventListener("pause", this._onPlayStop);
          source3.addEventListener("seeked", this._onSeeked);
          if (!this._isSourceReady()) {
            if (!options2.preload) {
              source3.addEventListener("canplay", this._onCanPlay);
            }
            source3.addEventListener("canplaythrough", this._onCanPlayThrough);
            source3.addEventListener("error", this._onError, true);
          } else {
            this._mediaReady();
          }
          this.alphaMode = await detectVideoAlphaMode();
          this._load = new Promise((resolve, reject) => {
            if (this.isValid) {
              resolve(this);
            } else {
              this._resolve = resolve;
              this._reject = reject;
              if (options2.preloadTimeoutMs !== void 0) {
                this._preloadTimeout = setTimeout(() => {
                  this._onError(new ErrorEvent(`Preload exceeded timeout of ${options2.preloadTimeoutMs}ms`));
                });
              }
              source3.load();
            }
          });
          return this._load;
        }
        /**
         * Handle video error events.
         * @param event - The error event
         */
        _onError(event) {
          this.resource.removeEventListener("error", this._onError, true);
          this.emit("error", event);
          if (this._reject) {
            this._reject(event);
            this._reject = null;
            this._resolve = null;
          }
        }
        /**
         * Checks if the underlying source is playing.
         * @returns True if playing.
         */
        _isSourcePlaying() {
          const source3 = this.resource;
          return !source3.paused && !source3.ended;
        }
        /**
         * Checks if the underlying source is ready for playing.
         * @returns True if ready.
         */
        _isSourceReady() {
          const source3 = this.resource;
          return source3.readyState > 2;
        }
        /** Runs the update loop when the video is ready to play. */
        _onPlayStart() {
          if (!this.isValid) {
            this._mediaReady();
          }
          this._configureAutoUpdate();
        }
        /** Stops the update loop when a pause event is triggered. */
        _onPlayStop() {
          this._configureAutoUpdate();
        }
        /** Handles behavior when the video completes seeking to the current playback position. */
        _onSeeked() {
          if (this._autoUpdate && !this._isSourcePlaying()) {
            this._msToNextUpdate = 0;
            this.updateFrame();
            this._msToNextUpdate = 0;
          }
        }
        _onCanPlay() {
          const source3 = this.resource;
          source3.removeEventListener("canplay", this._onCanPlay);
          this._mediaReady();
        }
        _onCanPlayThrough() {
          const source3 = this.resource;
          source3.removeEventListener("canplaythrough", this._onCanPlay);
          if (this._preloadTimeout) {
            clearTimeout(this._preloadTimeout);
            this._preloadTimeout = void 0;
          }
          this._mediaReady();
        }
        /** Fired when the video is loaded and ready to play. */
        _mediaReady() {
          const source3 = this.resource;
          if (this.isValid) {
            this.isReady = true;
            this.resize(source3.videoWidth, source3.videoHeight);
          }
          this._msToNextUpdate = 0;
          this.updateFrame();
          this._msToNextUpdate = 0;
          if (this._resolve) {
            this._resolve(this);
            this._resolve = null;
            this._reject = null;
          }
          if (this._isSourcePlaying()) {
            this._onPlayStart();
          } else if (this.autoPlay) {
            void this.resource.play();
          }
        }
        /** Cleans up resources and event listeners associated with this texture. */
        destroy() {
          this._configureAutoUpdate();
          const source3 = this.resource;
          if (source3) {
            source3.removeEventListener("play", this._onPlayStart);
            source3.removeEventListener("pause", this._onPlayStop);
            source3.removeEventListener("seeked", this._onSeeked);
            source3.removeEventListener("canplay", this._onCanPlay);
            source3.removeEventListener("canplaythrough", this._onCanPlayThrough);
            source3.removeEventListener("error", this._onError, true);
            source3.pause();
            source3.src = "";
            source3.load();
          }
          super.destroy();
        }
        /** Should the base texture automatically update itself, set to true by default. */
        get autoUpdate() {
          return this._autoUpdate;
        }
        set autoUpdate(value12) {
          if (value12 !== this._autoUpdate) {
            this._autoUpdate = value12;
            this._configureAutoUpdate();
          }
        }
        /**
         * How many times a second to update the texture from the video.
         * Leave at 0 to update at every render.
         * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
         */
        get updateFPS() {
          return this._updateFPS;
        }
        set updateFPS(value12) {
          if (value12 !== this._updateFPS) {
            this._updateFPS = value12;
            this._configureAutoUpdate();
          }
        }
        /**
         * Configures the updating mechanism based on the current state and settings.
         *
         * This method decides between using the browser's native video frame callback or a custom ticker
         * for updating the video frame. It ensures optimal performance and responsiveness
         * based on the video's state, playback status, and the desired frames-per-second setting.
         *
         * - If `_autoUpdate` is enabled and the video source is playing:
         *   - It will prefer the native video frame callback if available and no specific FPS is set.
         *   - Otherwise, it will use a custom ticker for manual updates.
         * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.
         */
        _configureAutoUpdate() {
          if (this._autoUpdate && this._isSourcePlaying()) {
            if (!this._updateFPS && this.resource.requestVideoFrameCallback) {
              if (this._isConnectedToTicker) {
                Ticker.shared.remove(this.updateFrame, this);
                this._isConnectedToTicker = false;
                this._msToNextUpdate = 0;
              }
              if (this._videoFrameRequestCallbackHandle === null) {
                this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
                  this._videoFrameRequestCallback
                );
              }
            } else {
              if (this._videoFrameRequestCallbackHandle !== null) {
                this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
                this._videoFrameRequestCallbackHandle = null;
              }
              if (!this._isConnectedToTicker) {
                Ticker.shared.add(this.updateFrame, this);
                this._isConnectedToTicker = true;
                this._msToNextUpdate = 0;
              }
            }
          } else {
            if (this._videoFrameRequestCallbackHandle !== null) {
              this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
              this._videoFrameRequestCallbackHandle = null;
            }
            if (this._isConnectedToTicker) {
              Ticker.shared.remove(this.updateFrame, this);
              this._isConnectedToTicker = false;
              this._msToNextUpdate = 0;
            }
          }
        }
        static test(resource) {
          return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement;
        }
      };
      _VideoSource.extension = ExtensionType.TextureSource;
      _VideoSource.defaultOptions = {
        ...TextureSource.defaultOptions,
        /** If true, the video will start loading immediately. */
        autoLoad: true,
        /** If true, the video will start playing as soon as it is loaded. */
        autoPlay: true,
        /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */
        updateFPS: 0,
        /** If true, the video will be loaded with the `crossorigin` attribute. */
        crossorigin: true,
        /** If true, the video will loop when it ends. */
        loop: false,
        /** If true, the video will be muted. */
        muted: true,
        /** If true, the video will play inline. */
        playsinline: true,
        /** If true, the video will be preloaded. */
        preload: false
      };
      _VideoSource.MIME_TYPES = {
        ogv: "video/ogg",
        mov: "video/quicktime",
        m4v: "video/mp4"
      };
      VideoSource = _VideoSource;
    }
  });

  // node_modules/pixi.js/lib/assets/cache/Cache.mjs
  var CacheClass, Cache;
  var init_Cache = __esm({
    "node_modules/pixi.js/lib/assets/cache/Cache.mjs"() {
      init_warn();
      init_convertToList();
      CacheClass = class {
        constructor() {
          this._parsers = [];
          this._cache = /* @__PURE__ */ new Map();
          this._cacheMap = /* @__PURE__ */ new Map();
        }
        /** Clear all entries. */
        reset() {
          this._cacheMap.clear();
          this._cache.clear();
        }
        /**
         * Check if the key exists
         * @param key - The key to check
         */
        has(key) {
          return this._cache.has(key);
        }
        /**
         * Fetch entry by key
         * @param key - The key of the entry to get
         */
        get(key) {
          const result = this._cache.get(key);
          if (!result) {
            warn2(`[Assets] Asset id ${key} was not found in the Cache`);
          }
          return result;
        }
        /**
         * Set a value by key or keys name
         * @param key - The key or keys to set
         * @param value - The value to store in the cache or from which cacheable assets will be derived.
         */
        set(key, value12) {
          const keys6 = convertToList(key);
          let cacheableAssets;
          for (let i2 = 0; i2 < this.parsers.length; i2++) {
            const parser2 = this.parsers[i2];
            if (parser2.test(value12)) {
              cacheableAssets = parser2.getCacheableAssets(keys6, value12);
              break;
            }
          }
          const cacheableMap = new Map(Object.entries(cacheableAssets || {}));
          if (!cacheableAssets) {
            keys6.forEach((key2) => {
              cacheableMap.set(key2, value12);
            });
          }
          const cacheKeys = [...cacheableMap.keys()];
          const cachedAssets = {
            cacheKeys,
            keys: keys6
          };
          keys6.forEach((key2) => {
            this._cacheMap.set(key2, cachedAssets);
          });
          cacheKeys.forEach((key2) => {
            const val = cacheableAssets ? cacheableAssets[key2] : value12;
            if (this._cache.has(key2) && this._cache.get(key2) !== val) {
              warn2("[Cache] already has key:", key2);
            }
            this._cache.set(key2, cacheableMap.get(key2));
          });
        }
        /**
         * Remove entry by key
         *
         * This function will also remove any associated alias from the cache also.
         * @param key - The key of the entry to remove
         */
        remove(key) {
          if (!this._cacheMap.has(key)) {
            warn2(`[Assets] Asset id ${key} was not found in the Cache`);
            return;
          }
          const cacheMap2 = this._cacheMap.get(key);
          const cacheKeys = cacheMap2.cacheKeys;
          cacheKeys.forEach((key2) => {
            this._cache.delete(key2);
          });
          cacheMap2.keys.forEach((key2) => {
            this._cacheMap.delete(key2);
          });
        }
        /** All loader parsers registered */
        get parsers() {
          return this._parsers;
        }
      };
      Cache = new CacheClass();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs
  function textureSourceFrom(options2 = {}) {
    const hasResource = options2 && options2.resource;
    const res = hasResource ? options2.resource : options2;
    const opts = hasResource ? options2 : { resource: options2 };
    for (let i2 = 0; i2 < sources.length; i2++) {
      const Source = sources[i2];
      if (Source.test(res)) {
        return new Source(opts);
      }
    }
    throw new Error(`Could not find a source type for resource: ${opts.resource}`);
  }
  function resourceToTexture(options2 = {}, skipCache = false) {
    const hasResource = options2 && options2.resource;
    const resource = hasResource ? options2.resource : options2;
    const opts = hasResource ? options2 : { resource: options2 };
    if (!skipCache && Cache.has(resource)) {
      return Cache.get(resource);
    }
    const texture = new Texture({ source: textureSourceFrom(opts) });
    texture.on("destroy", () => {
      if (Cache.has(resource)) {
        Cache.remove(resource);
      }
    });
    if (!skipCache) {
      Cache.set(resource, texture);
    }
    return texture;
  }
  function textureFrom(id5, skipCache = false) {
    if (typeof id5 === "string") {
      return Cache.get(id5);
    } else if (id5 instanceof TextureSource) {
      return new Texture({ source: id5 });
    }
    return resourceToTexture(id5, skipCache);
  }
  var sources;
  var init_textureFrom = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs"() {
      init_Cache();
      init_Extensions();
      init_TextureSource();
      init_Texture();
      sources = [];
      extensions.handleByList(ExtensionType.TextureSource, sources);
      Texture.from = textureFrom;
      TextureSource.from = textureSourceFrom;
    }
  });

  // node_modules/pixi.js/lib/rendering/init.mjs
  var init_init5 = __esm({
    "node_modules/pixi.js/lib/rendering/init.mjs"() {
      init_Extensions();
      init_AlphaMask();
      init_ColorMask();
      init_StencilMask();
      init_BufferImageSource();
      init_CanvasSource();
      init_ImageSource();
      init_VideoSource();
      init_textureFrom();
      extensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs
  var BindGroup;
  var init_BindGroup = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs"() {
      "use strict";
      BindGroup = class {
        /**
         * Create a new instance eof the Bind Group.
         * @param resources - The resources that are bound together for use by a shader.
         */
        constructor(resources) {
          this.resources = /* @__PURE__ */ Object.create(null);
          this._dirty = true;
          let index6 = 0;
          for (const i2 in resources) {
            const resource = resources[i2];
            this.setResource(resource, index6++);
          }
          this._updateKey();
        }
        /**
         * Updates the key if its flagged as dirty. This is used internally to
         * match this bind group to a WebGPU BindGroup.
         * @internal
         * @ignore
         */
        _updateKey() {
          if (!this._dirty)
            return;
          this._dirty = false;
          const keyParts = [];
          let index6 = 0;
          for (const i2 in this.resources) {
            keyParts[index6++] = this.resources[i2]._resourceId;
          }
          this._key = keyParts.join("|");
        }
        /**
         * Set a resource at a given index. this function will
         * ensure that listeners will be removed from the current resource
         * and added to the new resource.
         * @param resource - The resource to set.
         * @param index - The index to set the resource at.
         */
        setResource(resource, index6) {
          const currentResource = this.resources[index6];
          if (resource === currentResource)
            return;
          if (currentResource) {
            resource.off?.("change", this.onResourceChange, this);
          }
          resource.on?.("change", this.onResourceChange, this);
          this.resources[index6] = resource;
          this._dirty = true;
        }
        /**
         * Returns the resource at the current specified index.
         * @param index - The index of the resource to get.
         * @returns - The resource at the specified index.
         */
        getResource(index6) {
          return this.resources[index6];
        }
        /**
         * Used internally to 'touch' each resource, to ensure that the GC
         * knows that all resources in this bind group are still being used.
         * @param tick - The current tick.
         * @internal
         * @ignore
         */
        _touch(tick) {
          const resources = this.resources;
          for (const i2 in resources) {
            resources[i2]._touched = tick;
          }
        }
        /** Destroys this bind group and removes all listeners. */
        destroy() {
          const resources = this.resources;
          for (const i2 in resources) {
            const resource = resources[i2];
            resource.off?.("change", this.onResourceChange, this);
          }
          this.resources = null;
        }
        onResourceChange(resource) {
          this._dirty = true;
          if (resource.destroyed) {
            const resources = this.resources;
            for (const i2 in resources) {
              if (resources[i2] === resource) {
                resources[i2] = null;
              }
            }
          } else {
            this._updateKey();
          }
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs
  function getTestContext() {
    if (!context || context?.isContextLost()) {
      const canvas2 = DOMAdapter.get().createCanvas();
      context = canvas2.getContext("webgl", {});
    }
    return context;
  }
  var context;
  var init_getTestContext = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs"() {
      init_adapter();
    }
  });

  // node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs
  function generateIfTestSrc(maxIfs) {
    let src9 = "";
    for (let i2 = 0; i2 < maxIfs; ++i2) {
      if (i2 > 0) {
        src9 += "\nelse ";
      }
      if (i2 < maxIfs - 1) {
        src9 += `if(test == ${i2}.0){}`;
      }
    }
    return src9;
  }
  function checkMaxIfStatementsInShader(maxIfs, gl) {
    if (maxIfs === 0) {
      throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    }
    const shader = gl.createShader(gl.FRAGMENT_SHADER);
    try {
      while (true) {
        const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
        gl.shaderSource(shader, fragmentSrc);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          maxIfs = maxIfs / 2 | 0;
        } else {
          break;
        }
      }
    } finally {
      gl.deleteShader(shader);
    }
    return maxIfs;
  }
  var fragTemplate;
  var init_checkMaxIfStatementsInShader = __esm({
    "node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs"() {
      "use strict";
      fragTemplate = [
        "precision mediump float;",
        "void main(void){",
        "float test = 0.1;",
        "%forloop%",
        "gl_FragColor = vec4(0.0);",
        "}"
      ].join("\n");
    }
  });

  // node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs
  function getMaxTexturesPerBatch() {
    if (maxTexturesPerBatchCache)
      return maxTexturesPerBatchCache;
    const gl = getTestContext();
    maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    maxTexturesPerBatchCache = checkMaxIfStatementsInShader(
      maxTexturesPerBatchCache,
      gl
    );
    gl.getExtension("WEBGL_lose_context")?.loseContext();
    return maxTexturesPerBatchCache;
  }
  var maxTexturesPerBatchCache;
  var init_maxRecommendedTextures = __esm({
    "node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs"() {
      init_getTestContext();
      init_checkMaxIfStatementsInShader();
      maxTexturesPerBatchCache = null;
    }
  });

  // node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs
  function getTextureBatchBindGroup(textures, size5) {
    let uid3 = 2166136261;
    for (let i2 = 0; i2 < size5; i2++) {
      uid3 ^= textures[i2].uid;
      uid3 = Math.imul(uid3, 16777619);
      uid3 >>>= 0;
    }
    return cachedGroups[uid3] || generateTextureBatchBindGroup(textures, size5, uid3);
  }
  function generateTextureBatchBindGroup(textures, size5, key) {
    const bindGroupResources = {};
    let bindIndex = 0;
    if (!maxTextures)
      maxTextures = getMaxTexturesPerBatch();
    for (let i2 = 0; i2 < maxTextures; i2++) {
      const texture = i2 < size5 ? textures[i2] : Texture.EMPTY.source;
      bindGroupResources[bindIndex++] = texture.source;
      bindGroupResources[bindIndex++] = texture.style;
    }
    const bindGroup = new BindGroup(bindGroupResources);
    cachedGroups[key] = bindGroup;
    return bindGroup;
  }
  var cachedGroups, maxTextures;
  var init_getTextureBatchBindGroup = __esm({
    "node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs"() {
      init_BindGroup();
      init_Texture();
      init_maxRecommendedTextures();
      cachedGroups = {};
      maxTextures = 0;
    }
  });

  // node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs
  var ViewableBuffer;
  var init_ViewableBuffer = __esm({
    "node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs"() {
      "use strict";
      ViewableBuffer = class {
        constructor(sizeOrBuffer) {
          if (typeof sizeOrBuffer === "number") {
            this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
          } else if (sizeOrBuffer instanceof Uint8Array) {
            this.rawBinaryData = sizeOrBuffer.buffer;
          } else {
            this.rawBinaryData = sizeOrBuffer;
          }
          this.uint32View = new Uint32Array(this.rawBinaryData);
          this.float32View = new Float32Array(this.rawBinaryData);
          this.size = this.rawBinaryData.byteLength;
        }
        /** View on the raw binary data as a `Int8Array`. */
        get int8View() {
          if (!this._int8View) {
            this._int8View = new Int8Array(this.rawBinaryData);
          }
          return this._int8View;
        }
        /** View on the raw binary data as a `Uint8Array`. */
        get uint8View() {
          if (!this._uint8View) {
            this._uint8View = new Uint8Array(this.rawBinaryData);
          }
          return this._uint8View;
        }
        /**  View on the raw binary data as a `Int16Array`. */
        get int16View() {
          if (!this._int16View) {
            this._int16View = new Int16Array(this.rawBinaryData);
          }
          return this._int16View;
        }
        /** View on the raw binary data as a `Int32Array`. */
        get int32View() {
          if (!this._int32View) {
            this._int32View = new Int32Array(this.rawBinaryData);
          }
          return this._int32View;
        }
        /** View on the raw binary data as a `Float64Array`. */
        get float64View() {
          if (!this._float64Array) {
            this._float64Array = new Float64Array(this.rawBinaryData);
          }
          return this._float64Array;
        }
        /** View on the raw binary data as a `BigUint64Array`. */
        get bigUint64View() {
          if (!this._bigUint64Array) {
            this._bigUint64Array = new BigUint64Array(this.rawBinaryData);
          }
          return this._bigUint64Array;
        }
        /**
         * Returns the view of the given type.
         * @param type - One of `int8`, `uint8`, `int16`,
         *    `uint16`, `int32`, `uint32`, and `float32`.
         * @returns - typed array of given type
         */
        view(type) {
          return this[`${type}View`];
        }
        /** Destroys all buffer references. Do not use after calling this. */
        destroy() {
          this.rawBinaryData = null;
          this._int8View = null;
          this._uint8View = null;
          this._int16View = null;
          this.uint16View = null;
          this._int32View = null;
          this.uint32View = null;
          this.float32View = null;
        }
        /**
         * Returns the size of the given type in bytes.
         * @param type - One of `int8`, `uint8`, `int16`,
         *   `uint16`, `int32`, `uint32`, and `float32`.
         * @returns - size of the type in bytes
         */
        static sizeOf(type) {
          switch (type) {
            case "int8":
            case "uint8":
              return 1;
            case "int16":
            case "uint16":
              return 2;
            case "int32":
            case "uint32":
            case "float32":
              return 4;
            default:
              throw new Error(`${type} isn't a valid view type`);
          }
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs
  function fastCopy(sourceBuffer, destinationBuffer) {
    const lengthDouble = sourceBuffer.byteLength / 8 | 0;
    const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);
    const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);
    destinationFloat64View.set(sourceFloat64View);
    const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;
    if (remainingBytes > 0) {
      const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);
      const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);
      destinationUint8View.set(sourceUint8View);
    }
  }
  var init_fastCopy = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs
  var BLEND_TO_NPM, STENCIL_MODES;
  var init_const3 = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs"() {
      "use strict";
      BLEND_TO_NPM = {
        normal: "normal-npm",
        add: "add-npm",
        screen: "screen-npm"
      };
      STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {
        STENCIL_MODES2[STENCIL_MODES2["DISABLED"] = 0] = "DISABLED";
        STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_ADD"] = 1] = "RENDERING_MASK_ADD";
        STENCIL_MODES2[STENCIL_MODES2["MASK_ACTIVE"] = 2] = "MASK_ACTIVE";
        STENCIL_MODES2[STENCIL_MODES2["INVERSE_MASK_ACTIVE"] = 3] = "INVERSE_MASK_ACTIVE";
        STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_REMOVE"] = 4] = "RENDERING_MASK_REMOVE";
        STENCIL_MODES2[STENCIL_MODES2["NONE"] = 5] = "NONE";
        return STENCIL_MODES2;
      })(STENCIL_MODES || {});
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs
  function getAdjustedBlendModeBlend(blendMode, textureSource) {
    if (textureSource.alphaMode === "no-premultiply-alpha") {
      return BLEND_TO_NPM[blendMode] || blendMode;
    }
    return blendMode;
  }
  var init_getAdjustedBlendModeBlend = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs"() {
      init_const3();
    }
  });

  // node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs
  var BatchTextureArray;
  var init_BatchTextureArray = __esm({
    "node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs"() {
      "use strict";
      BatchTextureArray = class {
        constructor() {
          this.ids = /* @__PURE__ */ Object.create(null);
          this.textures = [];
          this.count = 0;
        }
        /** Clear the textures and their locations. */
        clear() {
          for (let i2 = 0; i2 < this.count; i2++) {
            const t3 = this.textures[i2];
            this.textures[i2] = null;
            this.ids[t3.uid] = null;
          }
          this.count = 0;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs
  function getBatchFromPool() {
    return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();
  }
  function returnBatchToPool(batch) {
    batchPool[batchPoolIndex++] = batch;
  }
  var Batch, batchPool, batchPoolIndex, BATCH_TICK, _Batcher, Batcher;
  var init_Batcher = __esm({
    "node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs"() {
      init_uid();
      init_ViewableBuffer();
      init_fastCopy();
      init_getAdjustedBlendModeBlend();
      init_maxRecommendedTextures();
      init_BatchTextureArray();
      Batch = class {
        constructor() {
          this.renderPipeId = "batch";
          this.action = "startBatch";
          this.start = 0;
          this.size = 0;
          this.textures = new BatchTextureArray();
          this.blendMode = "normal";
          this.canBundle = true;
        }
        destroy() {
          this.textures = null;
          this.gpuBindGroup = null;
          this.bindGroup = null;
          this.batcher = null;
        }
      };
      batchPool = [];
      batchPoolIndex = 0;
      BATCH_TICK = 0;
      _Batcher = class _Batcher2 {
        constructor(options2 = {}) {
          this.uid = uid("batcher");
          this.dirty = true;
          this.batchIndex = 0;
          this.batches = [];
          this._elements = [];
          _Batcher2.defaultOptions.maxTextures = _Batcher2.defaultOptions.maxTextures ?? getMaxTexturesPerBatch();
          options2 = { ..._Batcher2.defaultOptions, ...options2 };
          const { maxTextures: maxTextures2, attributesInitialSize, indicesInitialSize } = options2;
          this.attributeBuffer = new ViewableBuffer(attributesInitialSize * 4);
          this.indexBuffer = new Uint16Array(indicesInitialSize);
          this.maxTextures = maxTextures2;
        }
        begin() {
          this.elementSize = 0;
          this.elementStart = 0;
          this.indexSize = 0;
          this.attributeSize = 0;
          for (let i2 = 0; i2 < this.batchIndex; i2++) {
            returnBatchToPool(this.batches[i2]);
          }
          this.batchIndex = 0;
          this._batchIndexStart = 0;
          this._batchIndexSize = 0;
          this.dirty = true;
        }
        add(batchableObject) {
          this._elements[this.elementSize++] = batchableObject;
          batchableObject._indexStart = this.indexSize;
          batchableObject._attributeStart = this.attributeSize;
          batchableObject._batcher = this;
          this.indexSize += batchableObject.indexSize;
          this.attributeSize += batchableObject.attributeSize * this.vertexSize;
        }
        checkAndUpdateTexture(batchableObject, texture) {
          const textureId = batchableObject._batch.textures.ids[texture._source.uid];
          if (!textureId && textureId !== 0)
            return false;
          batchableObject._textureId = textureId;
          batchableObject.texture = texture;
          return true;
        }
        updateElement(batchableObject) {
          this.dirty = true;
          const attributeBuffer = this.attributeBuffer;
          if (batchableObject.packAsQuad) {
            this.packQuadAttributes(
              batchableObject,
              attributeBuffer.float32View,
              attributeBuffer.uint32View,
              batchableObject._attributeStart,
              batchableObject._textureId
            );
          } else {
            this.packAttributes(
              batchableObject,
              attributeBuffer.float32View,
              attributeBuffer.uint32View,
              batchableObject._attributeStart,
              batchableObject._textureId
            );
          }
        }
        /**
         * breaks the batcher. This happens when a batch gets too big,
         * or we need to switch to a different type of rendering (a filter for example)
         * @param instructionSet
         */
        break(instructionSet) {
          const elements2 = this._elements;
          if (!elements2[this.elementStart])
            return;
          let batch = getBatchFromPool();
          let textureBatch = batch.textures;
          textureBatch.clear();
          const firstElement = elements2[this.elementStart];
          let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);
          if (this.attributeSize * 4 > this.attributeBuffer.size) {
            this._resizeAttributeBuffer(this.attributeSize * 4);
          }
          if (this.indexSize > this.indexBuffer.length) {
            this._resizeIndexBuffer(this.indexSize);
          }
          const f32 = this.attributeBuffer.float32View;
          const u32 = this.attributeBuffer.uint32View;
          const indexBuffer = this.indexBuffer;
          let size5 = this._batchIndexSize;
          let start3 = this._batchIndexStart;
          let action2 = "startBatch";
          const maxTextures2 = this.maxTextures;
          for (let i2 = this.elementStart; i2 < this.elementSize; ++i2) {
            const element = elements2[i2];
            elements2[i2] = null;
            const texture = element.texture;
            const source3 = texture._source;
            const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source3);
            const breakRequired = blendMode !== adjustedBlendMode;
            if (source3._batchTick === BATCH_TICK && !breakRequired) {
              element._textureId = source3._textureBindLocation;
              size5 += element.indexSize;
              if (element.packAsQuad) {
                this.packQuadAttributes(
                  element,
                  f32,
                  u32,
                  element._attributeStart,
                  element._textureId
                );
                this.packQuadIndex(
                  indexBuffer,
                  element._indexStart,
                  element._attributeStart / this.vertexSize
                );
              } else {
                this.packAttributes(
                  element,
                  f32,
                  u32,
                  element._attributeStart,
                  element._textureId
                );
                this.packIndex(
                  element,
                  indexBuffer,
                  element._indexStart,
                  element._attributeStart / this.vertexSize
                );
              }
              element._batch = batch;
              continue;
            }
            source3._batchTick = BATCH_TICK;
            if (textureBatch.count >= maxTextures2 || breakRequired) {
              this._finishBatch(
                batch,
                start3,
                size5 - start3,
                textureBatch,
                blendMode,
                instructionSet,
                action2
              );
              action2 = "renderBatch";
              start3 = size5;
              blendMode = adjustedBlendMode;
              batch = getBatchFromPool();
              textureBatch = batch.textures;
              textureBatch.clear();
              ++BATCH_TICK;
            }
            element._textureId = source3._textureBindLocation = textureBatch.count;
            textureBatch.ids[source3.uid] = textureBatch.count;
            textureBatch.textures[textureBatch.count++] = source3;
            element._batch = batch;
            size5 += element.indexSize;
            if (element.packAsQuad) {
              this.packQuadAttributes(
                element,
                f32,
                u32,
                element._attributeStart,
                element._textureId
              );
              this.packQuadIndex(
                indexBuffer,
                element._indexStart,
                element._attributeStart / this.vertexSize
              );
            } else {
              this.packAttributes(
                element,
                f32,
                u32,
                element._attributeStart,
                element._textureId
              );
              this.packIndex(
                element,
                indexBuffer,
                element._indexStart,
                element._attributeStart / this.vertexSize
              );
            }
          }
          if (textureBatch.count > 0) {
            this._finishBatch(
              batch,
              start3,
              size5 - start3,
              textureBatch,
              blendMode,
              instructionSet,
              action2
            );
            start3 = size5;
            ++BATCH_TICK;
          }
          this.elementStart = this.elementSize;
          this._batchIndexStart = start3;
          this._batchIndexSize = size5;
        }
        _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, instructionSet, action2) {
          batch.gpuBindGroup = null;
          batch.bindGroup = null;
          batch.action = action2;
          batch.batcher = this;
          batch.textures = textureBatch;
          batch.blendMode = blendMode;
          batch.start = indexStart;
          batch.size = indexSize;
          ++BATCH_TICK;
          this.batches[this.batchIndex++] = batch;
          instructionSet.add(batch);
        }
        finish(instructionSet) {
          this.break(instructionSet);
        }
        /**
         * Resizes the attribute buffer to the given size (1 = 1 float32)
         * @param size - the size in vertices to ensure (not bytes!)
         */
        ensureAttributeBuffer(size5) {
          if (size5 * 4 <= this.attributeBuffer.size)
            return;
          this._resizeAttributeBuffer(size5 * 4);
        }
        /**
         * Resizes the index buffer to the given size (1 = 1 float32)
         * @param size - the size in vertices to ensure (not bytes!)
         */
        ensureIndexBuffer(size5) {
          if (size5 <= this.indexBuffer.length)
            return;
          this._resizeIndexBuffer(size5);
        }
        _resizeAttributeBuffer(size5) {
          const newSize = Math.max(size5, this.attributeBuffer.size * 2);
          const newArrayBuffer = new ViewableBuffer(newSize);
          fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);
          this.attributeBuffer = newArrayBuffer;
        }
        _resizeIndexBuffer(size5) {
          const indexBuffer = this.indexBuffer;
          let newSize = Math.max(size5, indexBuffer.length * 1.5);
          newSize += newSize % 2;
          const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);
          if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {
            for (let i2 = 0; i2 < indexBuffer.length; i2++) {
              newIndexBuffer[i2] = indexBuffer[i2];
            }
          } else {
            fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);
          }
          this.indexBuffer = newIndexBuffer;
        }
        packQuadIndex(indexBuffer, index6, indicesOffset) {
          indexBuffer[index6] = indicesOffset + 0;
          indexBuffer[index6 + 1] = indicesOffset + 1;
          indexBuffer[index6 + 2] = indicesOffset + 2;
          indexBuffer[index6 + 3] = indicesOffset + 0;
          indexBuffer[index6 + 4] = indicesOffset + 2;
          indexBuffer[index6 + 5] = indicesOffset + 3;
        }
        packIndex(element, indexBuffer, index6, indicesOffset) {
          const indices = element.indices;
          const size5 = element.indexSize;
          const indexOffset = element.indexOffset;
          const attributeOffset = element.attributeOffset;
          for (let i2 = 0; i2 < size5; i2++) {
            indexBuffer[index6++] = indicesOffset + indices[i2 + indexOffset] - attributeOffset;
          }
        }
        destroy() {
          for (let i2 = 0; i2 < this.batches.length; i2++) {
            returnBatchToPool(this.batches[i2]);
          }
          this.batches = null;
          for (let i2 = 0; i2 < this._elements.length; i2++) {
            this._elements[i2]._batch = null;
          }
          this._elements = null;
          this.indexBuffer = null;
          this.attributeBuffer.destroy();
          this.attributeBuffer = null;
        }
      };
      _Batcher.defaultOptions = {
        maxTextures: null,
        attributesInitialSize: 4,
        indicesInitialSize: 6
      };
      Batcher = _Batcher;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs
  var BufferUsage;
  var init_const4 = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs"() {
      "use strict";
      BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {
        BufferUsage2[BufferUsage2["MAP_READ"] = 1] = "MAP_READ";
        BufferUsage2[BufferUsage2["MAP_WRITE"] = 2] = "MAP_WRITE";
        BufferUsage2[BufferUsage2["COPY_SRC"] = 4] = "COPY_SRC";
        BufferUsage2[BufferUsage2["COPY_DST"] = 8] = "COPY_DST";
        BufferUsage2[BufferUsage2["INDEX"] = 16] = "INDEX";
        BufferUsage2[BufferUsage2["VERTEX"] = 32] = "VERTEX";
        BufferUsage2[BufferUsage2["UNIFORM"] = 64] = "UNIFORM";
        BufferUsage2[BufferUsage2["STORAGE"] = 128] = "STORAGE";
        BufferUsage2[BufferUsage2["INDIRECT"] = 256] = "INDIRECT";
        BufferUsage2[BufferUsage2["QUERY_RESOLVE"] = 512] = "QUERY_RESOLVE";
        BufferUsage2[BufferUsage2["STATIC"] = 1024] = "STATIC";
        return BufferUsage2;
      })(BufferUsage || {});
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs
  var Buffer2;
  var init_Buffer = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs"() {
      init_eventemitter3();
      init_uid();
      init_const4();
      Buffer2 = class extends eventemitter3_default {
        /**
         * Creates a new Buffer with the given options
         * @param options - the options for the buffer
         */
        constructor(options2) {
          let { data, size: size5 } = options2;
          const { usage, label: label4, shrinkToFit } = options2;
          super();
          this.uid = uid("buffer");
          this._resourceType = "buffer";
          this._resourceId = uid("resource");
          this._touched = 0;
          this._updateID = 1;
          this.shrinkToFit = true;
          this.destroyed = false;
          if (data instanceof Array) {
            data = new Float32Array(data);
          }
          this._data = data;
          size5 = size5 ?? data?.byteLength;
          const mappedAtCreation = !!data;
          this.descriptor = {
            size: size5,
            usage,
            mappedAtCreation,
            label: label4
          };
          this.shrinkToFit = shrinkToFit ?? true;
        }
        /** the data in the buffer */
        get data() {
          return this._data;
        }
        set data(value12) {
          this.setDataWithSize(value12, value12.length, true);
        }
        /** whether the buffer is static or not */
        get static() {
          return !!(this.descriptor.usage & BufferUsage.STATIC);
        }
        set static(value12) {
          if (value12) {
            this.descriptor.usage |= BufferUsage.STATIC;
          } else {
            this.descriptor.usage &= ~BufferUsage.STATIC;
          }
        }
        /**
         * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.
         * If you only want to update a subset of the buffer, you can pass in the size of the data.
         * @param value - the data to set
         * @param size - the size of the data in bytes
         * @param syncGPU - should the buffer be updated on the GPU immediately?
         */
        setDataWithSize(value12, size5, syncGPU) {
          this._updateID++;
          this._updateSize = size5 * value12.BYTES_PER_ELEMENT;
          if (this._data === value12) {
            if (syncGPU)
              this.emit("update", this);
            return;
          }
          const oldData = this._data;
          this._data = value12;
          if (oldData.length !== value12.length) {
            if (!this.shrinkToFit && value12.byteLength < oldData.byteLength) {
              if (syncGPU)
                this.emit("update", this);
            } else {
              this.descriptor.size = value12.byteLength;
              this._resourceId = uid("resource");
              this.emit("change", this);
            }
            return;
          }
          if (syncGPU)
            this.emit("update", this);
        }
        /**
         * updates the buffer on the GPU to reflect the data in the buffer.
         * By default it will update the entire buffer. If you only want to update a subset of the buffer,
         * you can pass in the size of the buffer to update.
         * @param sizeInBytes - the new size of the buffer in bytes
         */
        update(sizeInBytes) {
          this._updateSize = sizeInBytes ?? this._updateSize;
          this._updateID++;
          this.emit("update", this);
        }
        /** Destroys the buffer */
        destroy() {
          this.destroyed = true;
          this.emit("destroy", this);
          this.emit("change", this);
          this._data = null;
          this.descriptor = null;
          this.removeAllListeners();
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs
  function ensureIsBuffer(buffer, index6) {
    if (!(buffer instanceof Buffer2)) {
      let usage = index6 ? BufferUsage.INDEX : BufferUsage.VERTEX;
      if (buffer instanceof Array) {
        if (index6) {
          buffer = new Uint32Array(buffer);
          usage = BufferUsage.INDEX | BufferUsage.COPY_DST;
        } else {
          buffer = new Float32Array(buffer);
          usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;
        }
      }
      buffer = new Buffer2({
        data: buffer,
        label: index6 ? "index-mesh-buffer" : "vertex-mesh-buffer",
        usage
      });
    }
    return buffer;
  }
  var init_ensureIsBuffer = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs"() {
      init_Buffer();
      init_const4();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs
  function getGeometryBounds(geometry, attributeId, bounds) {
    const attribute = geometry.getAttribute(attributeId);
    if (!attribute) {
      bounds.minX = 0;
      bounds.minY = 0;
      bounds.maxX = 0;
      bounds.maxY = 0;
      return bounds;
    }
    const data = attribute.buffer.data;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    const byteSize = data.BYTES_PER_ELEMENT;
    const offset = (attribute.offset || 0) / byteSize;
    const stride = (attribute.stride || 2 * 4) / byteSize;
    for (let i2 = offset; i2 < data.length; i2 += stride) {
      const x2 = data[i2];
      const y2 = data[i2 + 1];
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
    }
    bounds.minX = minX;
    bounds.minY = minY;
    bounds.maxX = maxX;
    bounds.maxY = maxY;
    return bounds;
  }
  var init_getGeometryBounds = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs
  function ensureIsAttribute(attribute) {
    if (attribute instanceof Buffer2 || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {
      attribute = {
        buffer: attribute
      };
    }
    attribute.buffer = ensureIsBuffer(attribute.buffer, false);
    return attribute;
  }
  var Geometry;
  var init_Geometry = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs"() {
      init_eventemitter3();
      init_Bounds();
      init_uid();
      init_Buffer();
      init_ensureIsBuffer();
      init_getGeometryBounds();
      Geometry = class extends eventemitter3_default {
        /**
         * Create a new instance of a geometry
         * @param options - The options for the geometry.
         */
        constructor(options2 = {}) {
          super();
          this.uid = uid("geometry");
          this._layoutKey = 0;
          this.instanceCount = 1;
          this._bounds = new Bounds();
          this._boundsDirty = true;
          const { attributes, indexBuffer, topology } = options2;
          this.buffers = [];
          this.attributes = {};
          if (attributes) {
            for (const i2 in attributes) {
              this.addAttribute(i2, attributes[i2]);
            }
          }
          this.instanceCount = options2.instanceCount || 1;
          if (indexBuffer) {
            this.addIndex(indexBuffer);
          }
          this.topology = topology || "triangle-list";
        }
        onBufferUpdate() {
          this._boundsDirty = true;
          this.emit("update", this);
        }
        /**
         * Returns the requested attribute.
         * @param id - The name of the attribute required
         * @returns - The attribute requested.
         */
        getAttribute(id5) {
          return this.attributes[id5];
        }
        /**
         * Returns the index buffer
         * @returns - The index buffer.
         */
        getIndex() {
          return this.indexBuffer;
        }
        /**
         * Returns the requested buffer.
         * @param id - The name of the buffer required.
         * @returns - The buffer requested.
         */
        getBuffer(id5) {
          return this.getAttribute(id5).buffer;
        }
        /**
         * Used to figure out how many vertices there are in this geometry
         * @returns the number of vertices in the geometry
         */
        getSize() {
          for (const i2 in this.attributes) {
            const attribute = this.attributes[i2];
            const buffer = attribute.buffer;
            return buffer.data.length / (attribute.stride / 4 || attribute.size);
          }
          return 0;
        }
        /**
         * Adds an attribute to the geometry.
         * @param name - The name of the attribute to add.
         * @param attributeOption - The attribute option to add.
         */
        addAttribute(name16, attributeOption) {
          const attribute = ensureIsAttribute(attributeOption);
          const bufferIndex = this.buffers.indexOf(attribute.buffer);
          if (bufferIndex === -1) {
            this.buffers.push(attribute.buffer);
            attribute.buffer.on("update", this.onBufferUpdate, this);
            attribute.buffer.on("change", this.onBufferUpdate, this);
          }
          this.attributes[name16] = attribute;
        }
        /**
         * Adds an index buffer to the geometry.
         * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.
         */
        addIndex(indexBuffer) {
          this.indexBuffer = ensureIsBuffer(indexBuffer, true);
          this.buffers.push(this.indexBuffer);
        }
        /** Returns the bounds of the geometry. */
        get bounds() {
          if (!this._boundsDirty)
            return this._bounds;
          this._boundsDirty = false;
          return getGeometryBounds(this, "aPosition", this._bounds);
        }
        /**
         * destroys the geometry.
         * @param destroyBuffers - destroy the buffers associated with this geometry
         */
        destroy(destroyBuffers = false) {
          this.emit("destroy", this);
          this.removeAllListeners();
          if (destroyBuffers) {
            this.buffers.forEach((buffer) => buffer.destroy());
          }
          this.attributes = null;
          this.buffers = null;
          this.indexBuffer = null;
          this._bounds = null;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs
  var placeHolderBufferData, placeHolderIndexData, BatchGeometry;
  var init_BatchGeometry = __esm({
    "node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs"() {
      init_Buffer();
      init_const4();
      init_Geometry();
      placeHolderBufferData = new Float32Array(1);
      placeHolderIndexData = new Uint32Array(1);
      BatchGeometry = class extends Geometry {
        constructor() {
          const vertexSize = 6;
          const attributeBuffer = new Buffer2({
            data: placeHolderBufferData,
            label: "attribute-batch-buffer",
            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,
            shrinkToFit: false
          });
          const indexBuffer = new Buffer2({
            data: placeHolderIndexData,
            label: "index-batch-buffer",
            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,
            // | BufferUsage.STATIC,
            shrinkToFit: false
          });
          const stride = vertexSize * 4;
          super({
            attributes: {
              aPosition: {
                buffer: attributeBuffer,
                format: "float32x2",
                stride,
                offset: 0
              },
              aUV: {
                buffer: attributeBuffer,
                format: "float32x2",
                stride,
                offset: 2 * 4
              },
              aColor: {
                buffer: attributeBuffer,
                format: "unorm8x4",
                stride,
                offset: 4 * 4
              },
              aTextureIdAndRound: {
                buffer: attributeBuffer,
                format: "uint16x2",
                stride,
                offset: 5 * 4
              }
            },
            indexBuffer
          });
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs
  function createIdFromString(value12, groupId) {
    let id5 = idHash2[value12];
    if (id5 === void 0) {
      if (idCounts[groupId] === void 0) {
        idCounts[groupId] = 1;
      }
      idHash2[value12] = id5 = idCounts[groupId]++;
    }
    return id5;
  }
  var idCounts, idHash2;
  var init_createIdFromString = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs"() {
      "use strict";
      idCounts = /* @__PURE__ */ Object.create(null);
      idHash2 = /* @__PURE__ */ Object.create(null);
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs
  function getMaxFragmentPrecision() {
    if (!maxFragmentPrecision) {
      maxFragmentPrecision = "mediump";
      const gl = getTestContext();
      if (gl) {
        if (gl.getShaderPrecisionFormat) {
          const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
          maxFragmentPrecision = shaderFragment.precision ? "highp" : "mediump";
        }
      }
    }
    return maxFragmentPrecision;
  }
  var maxFragmentPrecision;
  var init_getMaxFragmentPrecision = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs"() {
      init_getTestContext();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs
  function addProgramDefines(src9, isES300, isFragment) {
    if (isES300)
      return src9;
    if (isFragment) {
      src9 = src9.replace("out vec4 finalColor;", "");
      return `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${src9}
        `;
    }
    return `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${src9}
        `;
  }
  var init_addProgramDefines = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs
  function ensurePrecision(src9, options2, isFragment) {
    const maxSupportedPrecision = isFragment ? options2.maxSupportedFragmentPrecision : options2.maxSupportedVertexPrecision;
    if (src9.substring(0, 9) !== "precision") {
      let precision = isFragment ? options2.requestedFragmentPrecision : options2.requestedVertexPrecision;
      if (precision === "highp" && maxSupportedPrecision !== "highp") {
        precision = "mediump";
      }
      return `precision ${precision} float;
${src9}`;
    } else if (maxSupportedPrecision !== "highp" && src9.substring(0, 15) === "precision highp") {
      return src9.replace("precision highp", "precision mediump");
    }
    return src9;
  }
  var init_ensurePrecision = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs
  function insertVersion(src9, isES300) {
    if (!isES300)
      return src9;
    return `#version 300 es
${src9}`;
  }
  var init_insertVersion = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs
  function setProgramName(src9, { name: name16 = `pixi-program` }, isFragment = true) {
    name16 = name16.replace(/\s+/g, "-");
    name16 += isFragment ? "-fragment" : "-vertex";
    const nameCache = isFragment ? fragmentNameCache : VertexNameCache;
    if (nameCache[name16]) {
      nameCache[name16]++;
      name16 += `-${nameCache[name16]}`;
    } else {
      nameCache[name16] = 1;
    }
    if (src9.indexOf("#define SHADER_NAME") !== -1)
      return src9;
    const shaderName = `#define SHADER_NAME ${name16}`;
    return `${shaderName}
${src9}`;
  }
  var fragmentNameCache, VertexNameCache;
  var init_setProgramName = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs"() {
      "use strict";
      fragmentNameCache = {};
      VertexNameCache = {};
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs
  function stripVersion(src9, isES300) {
    if (!isES300)
      return src9;
    return src9.replace("#version 300 es", "");
  }
  var init_stripVersion = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs
  var processes, programCache, _GlProgram, GlProgram;
  var init_GlProgram = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs"() {
      init_createIdFromString();
      init_getMaxFragmentPrecision();
      init_addProgramDefines();
      init_ensurePrecision();
      init_insertVersion();
      init_setProgramName();
      init_stripVersion();
      processes = {
        // strips any version headers..
        stripVersion,
        // adds precision string if not already present
        ensurePrecision,
        // add some defines if WebGL1 to make it more compatible with WebGL2 shaders
        addProgramDefines,
        // add the program name to the shader
        setProgramName,
        // add the version string to the shader header
        insertVersion
      };
      programCache = /* @__PURE__ */ Object.create(null);
      _GlProgram = class _GlProgram2 {
        /**
         * Creates a shiny new GlProgram. Used by WebGL renderer.
         * @param options - The options for the program.
         */
        constructor(options2) {
          options2 = { ..._GlProgram2.defaultOptions, ...options2 };
          const isES300 = options2.fragment.indexOf("#version 300 es") !== -1;
          const preprocessorOptions = {
            stripVersion: isES300,
            ensurePrecision: {
              requestedFragmentPrecision: options2.preferredFragmentPrecision,
              requestedVertexPrecision: options2.preferredVertexPrecision,
              maxSupportedVertexPrecision: "highp",
              maxSupportedFragmentPrecision: getMaxFragmentPrecision()
            },
            setProgramName: {
              name: options2.name
            },
            addProgramDefines: isES300,
            insertVersion: isES300
          };
          let fragment3 = options2.fragment;
          let vertex3 = options2.vertex;
          Object.keys(processes).forEach((processKey) => {
            const processOptions = preprocessorOptions[processKey];
            fragment3 = processes[processKey](fragment3, processOptions, true);
            vertex3 = processes[processKey](vertex3, processOptions, false);
          });
          this.fragment = fragment3;
          this.vertex = vertex3;
          this._key = createIdFromString(`${this.vertex}:${this.fragment}`, "gl-program");
        }
        /** destroys the program */
        destroy() {
          this.fragment = null;
          this.vertex = null;
          this._attributeData = null;
          this._uniformData = null;
          this._uniformBlockData = null;
          this.transformFeedbackVaryings = null;
        }
        /**
         * Helper function that creates a program for a given source.
         * It will check the program cache if the program has already been created.
         * If it has that one will be returned, if not a new one will be created and cached.
         * @param options - The options for the program.
         * @returns A program using the same source
         */
        static from(options2) {
          const key = `${options2.vertex}:${options2.fragment}`;
          if (!programCache[key]) {
            programCache[key] = new _GlProgram2(options2);
          }
          return programCache[key];
        }
      };
      _GlProgram.defaultOptions = {
        preferredVertexPrecision: "highp",
        preferredFragmentPrecision: "mediump"
      };
      GlProgram = _GlProgram;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs
  function getAttributeInfoFromFormat(format) {
    return attributeFormatData[format] ?? attributeFormatData.float32;
  }
  var attributeFormatData;
  var init_getAttributeInfoFromFormat = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs"() {
      "use strict";
      attributeFormatData = {
        uint8x2: { size: 2, stride: 2, normalised: false },
        uint8x4: { size: 4, stride: 4, normalised: false },
        sint8x2: { size: 2, stride: 2, normalised: false },
        sint8x4: { size: 4, stride: 4, normalised: false },
        unorm8x2: { size: 2, stride: 2, normalised: true },
        unorm8x4: { size: 4, stride: 4, normalised: true },
        snorm8x2: { size: 2, stride: 2, normalised: true },
        snorm8x4: { size: 4, stride: 4, normalised: true },
        uint16x2: { size: 2, stride: 4, normalised: false },
        uint16x4: { size: 4, stride: 8, normalised: false },
        sint16x2: { size: 2, stride: 4, normalised: false },
        sint16x4: { size: 4, stride: 8, normalised: false },
        unorm16x2: { size: 2, stride: 4, normalised: true },
        unorm16x4: { size: 4, stride: 8, normalised: true },
        snorm16x2: { size: 2, stride: 4, normalised: true },
        snorm16x4: { size: 4, stride: 8, normalised: true },
        float16x2: { size: 2, stride: 4, normalised: false },
        float16x4: { size: 4, stride: 8, normalised: false },
        float32: { size: 1, stride: 4, normalised: false },
        float32x2: { size: 2, stride: 8, normalised: false },
        float32x3: { size: 3, stride: 12, normalised: false },
        float32x4: { size: 4, stride: 16, normalised: false },
        uint32: { size: 1, stride: 4, normalised: false },
        uint32x2: { size: 2, stride: 8, normalised: false },
        uint32x3: { size: 3, stride: 12, normalised: false },
        uint32x4: { size: 4, stride: 16, normalised: false },
        sint32: { size: 1, stride: 4, normalised: false },
        sint32x2: { size: 2, stride: 8, normalised: false },
        sint32x3: { size: 3, stride: 12, normalised: false },
        sint32x4: { size: 4, stride: 16, normalised: false }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs
  function extractAttributesFromGpuProgram({ source: source3, entryPoint }) {
    const results = {};
    const mainVertStart = source3.indexOf(`fn ${entryPoint}`);
    if (mainVertStart !== -1) {
      const arrowFunctionStart = source3.indexOf("->", mainVertStart);
      if (arrowFunctionStart !== -1) {
        const functionArgsSubstring = source3.substring(mainVertStart, arrowFunctionStart);
        const inputsRegex = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
        let match2;
        while ((match2 = inputsRegex.exec(functionArgsSubstring)) !== null) {
          const format = WGSL_TO_VERTEX_TYPES[match2[3]] ?? "float32";
          results[match2[2]] = {
            location: parseInt(match2[1], 10),
            format,
            stride: getAttributeInfoFromFormat(format).stride,
            offset: 0,
            instance: false,
            start: 0
          };
        }
      }
    }
    return results;
  }
  var WGSL_TO_VERTEX_TYPES;
  var init_extractAttributesFromGpuProgram = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs"() {
      init_getAttributeInfoFromFormat();
      WGSL_TO_VERTEX_TYPES = {
        f32: "float32",
        "vec2<f32>": "float32x2",
        "vec3<f32>": "float32x3",
        "vec4<f32>": "float32x4",
        vec2f: "float32x2",
        vec3f: "float32x3",
        vec4f: "float32x4",
        i32: "sint32",
        "vec2<i32>": "sint32x2",
        "vec3<i32>": "sint32x3",
        "vec4<i32>": "sint32x4",
        u32: "uint32",
        "vec2<u32>": "uint32x2",
        "vec3<u32>": "uint32x3",
        "vec4<u32>": "uint32x4",
        bool: "uint32",
        "vec2<bool>": "uint32x2",
        "vec3<bool>": "uint32x3",
        "vec4<bool>": "uint32x4"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs
  function extractStructAndGroups(wgsl2) {
    const linePattern = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g;
    const groupPattern = /@group\((\d+)\)/;
    const bindingPattern = /@binding\((\d+)\)/;
    const namePattern = /var(<[^>]+>)? (\w+)/;
    const typePattern = /:\s*(\w+)/;
    const structPattern = /struct\s+(\w+)\s*{([^}]+)}/g;
    const structMemberPattern = /(\w+)\s*:\s*([\w\<\>]+)/g;
    const structName = /struct\s+(\w+)/;
    const groups = wgsl2.match(linePattern)?.map((item) => ({
      group: parseInt(item.match(groupPattern)[1], 10),
      binding: parseInt(item.match(bindingPattern)[1], 10),
      name: item.match(namePattern)[2],
      isUniform: item.match(namePattern)[1] === "<uniform>",
      type: item.match(typePattern)[1]
    }));
    if (!groups) {
      return {
        groups: [],
        structs: []
      };
    }
    const structs = wgsl2.match(structPattern)?.map((struct) => {
      const name16 = struct.match(structName)[1];
      const members = struct.match(structMemberPattern).reduce((acc, member2) => {
        const [name22, type] = member2.split(":");
        acc[name22.trim()] = type.trim();
        return acc;
      }, {});
      if (!members) {
        return null;
      }
      return { name: name16, members };
    }).filter(({ name: name16 }) => groups.some((group4) => group4.type === name16)) ?? [];
    return {
      groups,
      structs
    };
  }
  var init_extractStructAndGroups = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs
  var ShaderStage;
  var init_const5 = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs"() {
      "use strict";
      ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {
        ShaderStage2[ShaderStage2["VERTEX"] = 1] = "VERTEX";
        ShaderStage2[ShaderStage2["FRAGMENT"] = 2] = "FRAGMENT";
        ShaderStage2[ShaderStage2["COMPUTE"] = 4] = "COMPUTE";
        return ShaderStage2;
      })(ShaderStage || {});
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs
  function generateGpuLayoutGroups({ groups }) {
    const layout = [];
    for (let i2 = 0; i2 < groups.length; i2++) {
      const group4 = groups[i2];
      if (!layout[group4.group]) {
        layout[group4.group] = [];
      }
      if (group4.isUniform) {
        layout[group4.group].push({
          binding: group4.binding,
          visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,
          buffer: {
            type: "uniform"
          }
        });
      } else if (group4.type === "sampler") {
        layout[group4.group].push({
          binding: group4.binding,
          visibility: ShaderStage.FRAGMENT,
          sampler: {
            type: "filtering"
          }
        });
      } else if (group4.type === "texture_2d") {
        layout[group4.group].push({
          binding: group4.binding,
          visibility: ShaderStage.FRAGMENT,
          texture: {
            sampleType: "float",
            viewDimension: "2d",
            multisampled: false
          }
        });
      }
    }
    return layout;
  }
  var init_generateGpuLayoutGroups = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs"() {
      init_const5();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs
  function generateLayoutHash({ groups }) {
    const layout = [];
    for (let i2 = 0; i2 < groups.length; i2++) {
      const group4 = groups[i2];
      if (!layout[group4.group]) {
        layout[group4.group] = {};
      }
      layout[group4.group][group4.name] = group4.binding;
    }
    return layout;
  }
  var init_generateLayoutHash = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs
  function removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {
    const structNameSet = /* @__PURE__ */ new Set();
    const dupeGroupKeySet = /* @__PURE__ */ new Set();
    const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct) => {
      if (structNameSet.has(struct.name)) {
        return false;
      }
      structNameSet.add(struct.name);
      return true;
    });
    const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group4) => {
      const key = `${group4.name}-${group4.binding}`;
      if (dupeGroupKeySet.has(key)) {
        return false;
      }
      dupeGroupKeySet.add(key);
      return true;
    });
    return { structs, groups };
  }
  var init_removeStructAndGroupDuplicates = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs
  var programCache2, GpuProgram;
  var init_GpuProgram = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs"() {
      init_createIdFromString();
      init_extractAttributesFromGpuProgram();
      init_extractStructAndGroups();
      init_generateGpuLayoutGroups();
      init_generateLayoutHash();
      init_removeStructAndGroupDuplicates();
      programCache2 = /* @__PURE__ */ Object.create(null);
      GpuProgram = class _GpuProgram {
        /**
         * Create a new GpuProgram
         * @param options - The options for the gpu program
         */
        constructor(options2) {
          this._layoutKey = 0;
          this._attributeLocationsKey = 0;
          const { fragment: fragment3, vertex: vertex3, layout, gpuLayout, name: name16 } = options2;
          this.name = name16;
          this.fragment = fragment3;
          this.vertex = vertex3;
          if (fragment3.source === vertex3.source) {
            const structsAndGroups = extractStructAndGroups(fragment3.source);
            this.structsAndGroups = structsAndGroups;
          } else {
            const vertexStructsAndGroups = extractStructAndGroups(vertex3.source);
            const fragmentStructsAndGroups = extractStructAndGroups(fragment3.source);
            this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);
          }
          this.layout = layout ?? generateLayoutHash(this.structsAndGroups);
          this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);
          this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== void 0);
          this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== void 0);
          this._generateProgramKey();
        }
        // TODO maker this pure
        _generateProgramKey() {
          const { vertex: vertex3, fragment: fragment3 } = this;
          const bigKey = vertex3.source + fragment3.source + vertex3.entryPoint + fragment3.entryPoint;
          this._layoutKey = createIdFromString(bigKey, "program");
        }
        get attributeData() {
          this._attributeData ?? (this._attributeData = extractAttributesFromGpuProgram(this.vertex));
          return this._attributeData;
        }
        /** destroys the program */
        destroy() {
          this.gpuLayout = null;
          this.layout = null;
          this.structsAndGroups = null;
          this.fragment = null;
          this.vertex = null;
        }
        /**
         * Helper function that creates a program for a given source.
         * It will check the program cache if the program has already been created.
         * If it has that one will be returned, if not a new one will be created and cached.
         * @param options - The options for the program.
         * @returns A program using the same source
         */
        static from(options2) {
          const key = `${options2.vertex.source}:${options2.fragment.source}:${options2.fragment.entryPoint}:${options2.vertex.entryPoint}`;
          if (!programCache2[key]) {
            programCache2[key] = new _GpuProgram(options2);
          }
          return programCache2[key];
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs
  function addBits(srcParts, parts, name16) {
    if (srcParts) {
      for (const i2 in srcParts) {
        const id5 = i2.toLocaleLowerCase();
        const part = parts[id5];
        if (part) {
          let sanitisedPart = srcParts[i2];
          if (i2 === "header") {
            sanitisedPart = sanitisedPart.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "");
          }
          if (name16) {
            part.push(`//----${name16}----//`);
          }
          part.push(sanitisedPart);
        } else {
          warn2(`${i2} placement hook does not exist in shader`);
        }
      }
    }
  }
  var init_addBits = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs"() {
      init_warn();
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs
  function compileHooks(programSrc) {
    const parts = {};
    const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, "")) ?? [];
    partMatches.forEach((hook) => {
      parts[hook] = [];
    });
    return parts;
  }
  var findHooksRx;
  var init_compileHooks = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs"() {
      "use strict";
      findHooksRx = /\{\{(.*?)\}\}/g;
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs
  function extractInputs(fragmentSource, out2) {
    let match2;
    const regex2 = /@in\s+([^;]+);/g;
    while ((match2 = regex2.exec(fragmentSource)) !== null) {
      out2.push(match2[1]);
    }
  }
  function compileInputs(fragments, template, sort2 = false) {
    const results = [];
    extractInputs(template, results);
    fragments.forEach((fragment3) => {
      if (fragment3.header) {
        extractInputs(fragment3.header, results);
      }
    });
    const mainInput = results;
    if (sort2) {
      mainInput.sort();
    }
    const finalString = mainInput.map((inValue, i2) => `       @location(${i2}) ${inValue},`).join("\n");
    let cleanedString = template.replace(/@in\s+[^;]+;\s*/g, "");
    cleanedString = cleanedString.replace("{{in}}", `
${finalString}
`);
    return cleanedString;
  }
  var init_compileInputs = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs
  function extractOutputs(fragmentSource, out2) {
    let match2;
    const regex2 = /@out\s+([^;]+);/g;
    while ((match2 = regex2.exec(fragmentSource)) !== null) {
      out2.push(match2[1]);
    }
  }
  function extractVariableName(value12) {
    const regex2 = /\b(\w+)\s*:/g;
    const match2 = regex2.exec(value12);
    return match2 ? match2[1] : "";
  }
  function stripVariable(value12) {
    const regex2 = /@.*?\s+/g;
    return value12.replace(regex2, "");
  }
  function compileOutputs(fragments, template) {
    const results = [];
    extractOutputs(template, results);
    fragments.forEach((fragment3) => {
      if (fragment3.header) {
        extractOutputs(fragment3.header, results);
      }
    });
    let index6 = 0;
    const mainStruct = results.sort().map((inValue) => {
      if (inValue.indexOf("builtin") > -1) {
        return inValue;
      }
      return `@location(${index6++}) ${inValue}`;
    }).join(",\n");
    const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join("\n");
    const mainEnd = `return VSOutput(
                ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(",\n")});`;
    let compiledCode = template.replace(/@out\s+[^;]+;\s*/g, "");
    compiledCode = compiledCode.replace("{{struct}}", `
${mainStruct}
`);
    compiledCode = compiledCode.replace("{{start}}", `
${mainStart}
`);
    compiledCode = compiledCode.replace("{{return}}", `
${mainEnd}
`);
    return compiledCode;
  }
  var init_compileOutputs = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs
  function injectBits(templateSrc, fragmentParts) {
    let out2 = templateSrc;
    for (const i2 in fragmentParts) {
      const parts = fragmentParts[i2];
      const toInject = parts.join("\n");
      if (toInject.length) {
        out2 = out2.replace(`{{${i2}}}`, `//-----${i2} START-----//
${parts.join("\n")}
//----${i2} FINISH----//`);
      } else {
        out2 = out2.replace(`{{${i2}}}`, "");
      }
    }
    return out2;
  }
  var init_injectBits = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs
  function compileHighShader({
    template,
    bits
  }) {
    const cacheId = generateCacheId(template, bits);
    if (cacheMap[cacheId])
      return cacheMap[cacheId];
    const { vertex: vertex3, fragment: fragment3 } = compileInputsAndOutputs(template, bits);
    cacheMap[cacheId] = compileBits(vertex3, fragment3, bits);
    return cacheMap[cacheId];
  }
  function compileHighShaderGl({
    template,
    bits
  }) {
    const cacheId = generateCacheId(template, bits);
    if (cacheMap[cacheId])
      return cacheMap[cacheId];
    cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);
    return cacheMap[cacheId];
  }
  function compileInputsAndOutputs(template, bits) {
    const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v2) => !!v2);
    const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v2) => !!v2);
    let compiledVertex = compileInputs(vertexFragments, template.vertex, true);
    compiledVertex = compileOutputs(vertexFragments, compiledVertex);
    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);
    return {
      vertex: compiledVertex,
      fragment: compiledFragment
    };
  }
  function generateCacheId(template, bits) {
    return bits.map((highFragment) => {
      if (!bitCacheMap.has(highFragment)) {
        bitCacheMap.set(highFragment, CACHE_UID++);
      }
      return bitCacheMap.get(highFragment);
    }).sort((a2, b2) => a2 - b2).join("-") + template.vertex + template.fragment;
  }
  function compileBits(vertex3, fragment3, bits) {
    const vertexParts = compileHooks(vertex3);
    const fragmentParts = compileHooks(fragment3);
    bits.forEach((shaderBit) => {
      addBits(shaderBit.vertex, vertexParts, shaderBit.name);
      addBits(shaderBit.fragment, fragmentParts, shaderBit.name);
    });
    return {
      vertex: injectBits(vertex3, vertexParts),
      fragment: injectBits(fragment3, fragmentParts)
    };
  }
  var cacheMap, bitCacheMap, CACHE_UID;
  var init_compileHighShader = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs"() {
      init_addBits();
      init_compileHooks();
      init_compileInputs();
      init_compileOutputs();
      init_injectBits();
      cacheMap = /* @__PURE__ */ Object.create(null);
      bitCacheMap = /* @__PURE__ */ new Map();
      CACHE_UID = 0;
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs
  var vertexGPUTemplate, fragmentGPUTemplate, vertexGlTemplate, fragmentGlTemplate;
  var init_defaultProgramTemplate = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs"() {
      "use strict";
      vertexGPUTemplate = /* wgsl */
      `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`;
      fragmentGPUTemplate = /* wgsl */
      `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`;
      vertexGlTemplate = /* glsl */
      `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`;
      fragmentGlTemplate = /* glsl */
      `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
        
        {{end}}
    }
`;
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs
  var globalUniformsBit, globalUniformsBitGl;
  var init_globalUniformsBit = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs"() {
      "use strict";
      globalUniformsBit = {
        name: "global-uniforms-bit",
        vertex: {
          header: (
            /* wgsl */
            `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
          )
        }
      };
      globalUniformsBitGl = {
        name: "global-uniforms-bit",
        vertex: {
          header: (
            /* glsl */
            `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
          )
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs
  function compileHighShaderGpuProgram({ bits, name: name16 }) {
    const source3 = compileHighShader({
      template: {
        fragment: fragmentGPUTemplate,
        vertex: vertexGPUTemplate
      },
      bits: [
        globalUniformsBit,
        ...bits
      ]
    });
    return GpuProgram.from({
      name: name16,
      vertex: {
        source: source3.vertex,
        entryPoint: "main"
      },
      fragment: {
        source: source3.fragment,
        entryPoint: "main"
      }
    });
  }
  function compileHighShaderGlProgram({ bits, name: name16 }) {
    return new GlProgram({
      name: name16,
      ...compileHighShaderGl({
        template: {
          vertex: vertexGlTemplate,
          fragment: fragmentGlTemplate
        },
        bits: [
          globalUniformsBitGl,
          ...bits
        ]
      })
    });
  }
  var init_compileHighShaderToProgram = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs"() {
      init_GlProgram();
      init_GpuProgram();
      init_compileHighShader();
      init_defaultProgramTemplate();
      init_globalUniformsBit();
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs
  var colorBit, colorBitGl;
  var init_colorBit = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs"() {
      "use strict";
      colorBit = {
        name: "color-bit",
        vertex: {
          header: (
            /* wgsl */
            `
            @in aColor: vec4<f32>;
        `
          ),
          main: (
            /* wgsl */
            `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
          )
        }
      };
      colorBitGl = {
        name: "color-bit",
        vertex: {
          header: (
            /* glsl */
            `
            in vec4 aColor;
        `
          ),
          main: (
            /* glsl */
            `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
          )
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs
  function generateBindingSrc(maxTextures2) {
    const src9 = [];
    if (maxTextures2 === 1) {
      src9.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;");
      src9.push("@group(1) @binding(1) var textureSampler1: sampler;");
    } else {
      let bindingIndex = 0;
      for (let i2 = 0; i2 < maxTextures2; i2++) {
        src9.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i2 + 1}: texture_2d<f32>;`);
        src9.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i2 + 1}: sampler;`);
      }
    }
    return src9.join("\n");
  }
  function generateSampleSrc(maxTextures2) {
    const src9 = [];
    if (maxTextures2 === 1) {
      src9.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
    } else {
      src9.push("switch vTextureId {");
      for (let i2 = 0; i2 < maxTextures2; i2++) {
        if (i2 === maxTextures2 - 1) {
          src9.push(`  default:{`);
        } else {
          src9.push(`  case ${i2}:{`);
        }
        src9.push(`      outColor = textureSampleGrad(textureSource${i2 + 1}, textureSampler${i2 + 1}, vUV, uvDx, uvDy);`);
        src9.push(`      break;}`);
      }
      src9.push(`}`);
    }
    return src9.join("\n");
  }
  function generateTextureBatchBit(maxTextures2) {
    if (!textureBatchBitGpuCache[maxTextures2]) {
      textureBatchBitGpuCache[maxTextures2] = {
        name: "texture-batch-bit",
        vertex: {
          header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
          main: `
                vTextureId = aTextureIdAndRound.y;
            `,
          end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
        },
        fragment: {
          header: `
                @in @interpolate(flat) vTextureId: u32;

                ${generateBindingSrc(maxTextures2)}
            `,
          main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${generateSampleSrc(maxTextures2)}
            `
        }
      };
    }
    return textureBatchBitGpuCache[maxTextures2];
  }
  function generateSampleGlSrc(maxTextures2) {
    const src9 = [];
    for (let i2 = 0; i2 < maxTextures2; i2++) {
      if (i2 > 0) {
        src9.push("else");
      }
      if (i2 < maxTextures2 - 1) {
        src9.push(`if(vTextureId < ${i2}.5)`);
      }
      src9.push("{");
      src9.push(`	outColor = texture(uTextures[${i2}], vUV);`);
      src9.push("}");
    }
    return src9.join("\n");
  }
  function generateTextureBatchBitGl(maxTextures2) {
    if (!textureBatchBitGlCache[maxTextures2]) {
      textureBatchBitGlCache[maxTextures2] = {
        name: "texture-batch-bit",
        vertex: {
          header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
          main: `
                vTextureId = aTextureIdAndRound.y;
            `,
          end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
        },
        fragment: {
          header: `
                in float vTextureId;

                uniform sampler2D uTextures[${maxTextures2}];

            `,
          main: `

                ${generateSampleGlSrc(maxTextures2)}
            `
        }
      };
    }
    return textureBatchBitGlCache[maxTextures2];
  }
  var textureBatchBitGpuCache, textureBatchBitGlCache;
  var init_generateTextureBatchBit = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs"() {
      "use strict";
      textureBatchBitGpuCache = {};
      textureBatchBitGlCache = {};
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs
  var roundPixelsBit, roundPixelsBitGl;
  var init_roundPixelsBit = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs"() {
      "use strict";
      roundPixelsBit = {
        name: "round-pixels-bit",
        vertex: {
          header: (
            /* wgsl */
            `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
          )
        }
      };
      roundPixelsBitGl = {
        name: "round-pixels-bit",
        vertex: {
          header: (
            /* glsl */
            `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
          )
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.mjs
  var UNIFORM_TYPES_VALUES, UNIFORM_TYPES_MAP;
  var init_types = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.mjs"() {
      "use strict";
      UNIFORM_TYPES_VALUES = [
        "f32",
        "i32",
        "vec2<f32>",
        "vec3<f32>",
        "vec4<f32>",
        "mat2x2<f32>",
        "mat3x3<f32>",
        "mat4x4<f32>",
        "mat3x2<f32>",
        "mat4x2<f32>",
        "mat2x3<f32>",
        "mat4x3<f32>",
        "mat2x4<f32>",
        "mat3x4<f32>"
      ];
      UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) => {
        acc[type] = true;
        return acc;
      }, {});
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs
  function getDefaultUniformValue(type, size5) {
    switch (type) {
      case "f32":
        return 0;
      case "vec2<f32>":
        return new Float32Array(2 * size5);
      case "vec3<f32>":
        return new Float32Array(3 * size5);
      case "vec4<f32>":
        return new Float32Array(4 * size5);
      case "mat2x2<f32>":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3x3<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4x4<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }
  var init_getDefaultUniformValue = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs
  var _UniformGroup, UniformGroup;
  var init_UniformGroup = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs"() {
      init_uid();
      init_createIdFromString();
      init_types();
      init_getDefaultUniformValue();
      _UniformGroup = class _UniformGroup2 {
        /**
         * Create a new Uniform group
         * @param uniformStructures - The structures of the uniform group
         * @param options - The optional parameters of this uniform group
         */
        constructor(uniformStructures, options2) {
          this._touched = 0;
          this.uid = uid("uniform");
          this._resourceType = "uniformGroup";
          this._resourceId = uid("resource");
          this.isUniformGroup = true;
          this._dirtyId = 0;
          this.destroyed = false;
          options2 = { ..._UniformGroup2.defaultOptions, ...options2 };
          this.uniformStructures = uniformStructures;
          const uniforms = {};
          for (const i2 in uniformStructures) {
            const uniformData = uniformStructures[i2];
            uniformData.name = i2;
            uniformData.size = uniformData.size ?? 1;
            if (!UNIFORM_TYPES_MAP[uniformData.type]) {
              throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(", ")}`);
            }
            uniformData.value ?? (uniformData.value = getDefaultUniformValue(uniformData.type, uniformData.size));
            uniforms[i2] = uniformData.value;
          }
          this.uniforms = uniforms;
          this._dirtyId = 1;
          this.ubo = options2.ubo;
          this.isStatic = options2.isStatic;
          this._signature = createIdFromString(Object.keys(uniforms).map(
            (i2) => `${i2}-${uniformStructures[i2].type}`
          ).join("-"), "uniform-group");
        }
        /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */
        update() {
          this._dirtyId++;
        }
      };
      _UniformGroup.defaultOptions = {
        /** if true the UniformGroup is handled as an Uniform buffer object. */
        ubo: false,
        /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */
        isStatic: false
      };
      UniformGroup = _UniformGroup;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs
  function getBatchSamplersUniformGroup(maxTextures2) {
    let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures2];
    if (batchSamplersUniformGroup)
      return batchSamplersUniformGroup;
    const sampleValues = new Int32Array(maxTextures2);
    for (let i2 = 0; i2 < maxTextures2; i2++) {
      sampleValues[i2] = i2;
    }
    batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures2] = new UniformGroup({
      uTextures: { value: sampleValues, type: `i32`, size: maxTextures2 }
    }, { isStatic: true });
    return batchSamplersUniformGroup;
  }
  var batchSamplersUniformGroupHash;
  var init_getBatchSamplersUniformGroup = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs"() {
      init_UniformGroup();
      batchSamplersUniformGroupHash = {};
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/types.mjs
  var RendererType;
  var init_types2 = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/types.mjs"() {
      "use strict";
      RendererType = /* @__PURE__ */ ((RendererType2) => {
        RendererType2[RendererType2["WEBGL"] = 1] = "WEBGL";
        RendererType2[RendererType2["WEBGPU"] = 2] = "WEBGPU";
        RendererType2[RendererType2["BOTH"] = 3] = "BOTH";
        return RendererType2;
      })(RendererType || {});
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs
  var Shader;
  var init_Shader = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs"() {
      init_eventemitter3();
      init_GlProgram();
      init_BindGroup();
      init_GpuProgram();
      init_types2();
      init_UniformGroup();
      Shader = class _Shader extends eventemitter3_default {
        constructor(options2) {
          super();
          this._uniformBindMap = /* @__PURE__ */ Object.create(null);
          this._ownedBindGroups = [];
          let {
            gpuProgram: gpuProgram3,
            glProgram: glProgram3,
            groups,
            resources,
            compatibleRenderers,
            groupMap
          } = options2;
          this.gpuProgram = gpuProgram3;
          this.glProgram = glProgram3;
          if (compatibleRenderers === void 0) {
            compatibleRenderers = 0;
            if (gpuProgram3)
              compatibleRenderers |= RendererType.WEBGPU;
            if (glProgram3)
              compatibleRenderers |= RendererType.WEBGL;
          }
          this.compatibleRenderers = compatibleRenderers;
          const nameHash = {};
          if (!resources && !groups) {
            resources = {};
          }
          if (resources && groups) {
            throw new Error("[Shader] Cannot have both resources and groups");
          } else if (!gpuProgram3 && groups && !groupMap) {
            throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
          } else if (!gpuProgram3 && groups && groupMap) {
            for (const i2 in groupMap) {
              for (const j2 in groupMap[i2]) {
                const uniformName = groupMap[i2][j2];
                nameHash[uniformName] = {
                  group: i2,
                  binding: j2,
                  name: uniformName
                };
              }
            }
          } else if (gpuProgram3 && groups && !groupMap) {
            const groupData = gpuProgram3.structsAndGroups.groups;
            groupMap = {};
            groupData.forEach((data) => {
              groupMap[data.group] = groupMap[data.group] || {};
              groupMap[data.group][data.binding] = data.name;
              nameHash[data.name] = data;
            });
          } else if (resources) {
            groups = {};
            groupMap = {};
            if (gpuProgram3) {
              const groupData = gpuProgram3.structsAndGroups.groups;
              groupData.forEach((data) => {
                groupMap[data.group] = groupMap[data.group] || {};
                groupMap[data.group][data.binding] = data.name;
                nameHash[data.name] = data;
              });
            }
            let bindTick = 0;
            for (const i2 in resources) {
              if (nameHash[i2])
                continue;
              if (!groups[99]) {
                groups[99] = new BindGroup();
                this._ownedBindGroups.push(groups[99]);
              }
              nameHash[i2] = { group: 99, binding: bindTick, name: i2 };
              groupMap[99] = groupMap[99] || {};
              groupMap[99][bindTick] = i2;
              bindTick++;
            }
            for (const i2 in resources) {
              const name16 = i2;
              let value12 = resources[i2];
              if (!value12.source && !value12._resourceType) {
                value12 = new UniformGroup(value12);
              }
              const data = nameHash[name16];
              if (data) {
                if (!groups[data.group]) {
                  groups[data.group] = new BindGroup();
                  this._ownedBindGroups.push(groups[data.group]);
                }
                groups[data.group].setResource(value12, data.binding);
              }
            }
          }
          this.groups = groups;
          this._uniformBindMap = groupMap;
          this.resources = this._buildResourceAccessor(groups, nameHash);
        }
        /**
         * Sometimes a resource group will be provided later (for example global uniforms)
         * In such cases, this method can be used to let the shader know about the group.
         * @param name - the name of the resource group
         * @param groupIndex - the index of the group (should match the webGPU shader group location)
         * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)
         */
        addResource(name16, groupIndex, bindIndex) {
          var _a2, _b;
          (_a2 = this._uniformBindMap)[groupIndex] || (_a2[groupIndex] = {});
          (_b = this._uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name16);
          if (!this.groups[groupIndex]) {
            this.groups[groupIndex] = new BindGroup();
            this._ownedBindGroups.push(this.groups[groupIndex]);
          }
        }
        _buildResourceAccessor(groups, nameHash) {
          const uniformsOut = {};
          for (const i2 in nameHash) {
            const data = nameHash[i2];
            Object.defineProperty(uniformsOut, data.name, {
              get() {
                return groups[data.group].getResource(data.binding);
              },
              set(value12) {
                groups[data.group].setResource(value12, data.binding);
              }
            });
          }
          return uniformsOut;
        }
        /**
         * Use to destroy the shader when its not longer needed.
         * It will destroy the resources and remove listeners.
         * @param destroyPrograms - if the programs should be destroyed as well.
         * Make sure its not being used by other shaders!
         */
        destroy(destroyPrograms = false) {
          this.emit("destroy", this);
          if (destroyPrograms) {
            this.gpuProgram?.destroy();
            this.glProgram?.destroy();
          }
          this.gpuProgram = null;
          this.glProgram = null;
          this.removeAllListeners();
          this._uniformBindMap = null;
          this._ownedBindGroups.forEach((bindGroup) => {
            bindGroup.destroy();
          });
          this._ownedBindGroups = null;
          this.resources = null;
          this.groups = null;
        }
        static from(options2) {
          const { gpu, gl, ...rest } = options2;
          let gpuProgram3;
          let glProgram3;
          if (gpu) {
            gpuProgram3 = GpuProgram.from(gpu);
          }
          if (gl) {
            glProgram3 = GlProgram.from(gl);
          }
          return new _Shader({
            gpuProgram: gpuProgram3,
            glProgram: glProgram3,
            ...rest
          });
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.mjs
  var DefaultShader;
  var init_DefaultShader = __esm({
    "node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.mjs"() {
      init_compileHighShaderToProgram();
      init_colorBit();
      init_generateTextureBatchBit();
      init_roundPixelsBit();
      init_getBatchSamplersUniformGroup();
      init_Shader();
      DefaultShader = class extends Shader {
        constructor(maxTextures2) {
          const glProgram3 = compileHighShaderGlProgram({
            name: "batch",
            bits: [
              colorBitGl,
              generateTextureBatchBitGl(maxTextures2),
              roundPixelsBitGl
            ]
          });
          const gpuProgram3 = compileHighShaderGpuProgram({
            name: "batch",
            bits: [
              colorBit,
              generateTextureBatchBit(maxTextures2),
              roundPixelsBit
            ]
          });
          super({
            glProgram: glProgram3,
            gpuProgram: gpuProgram3,
            resources: {
              batchSamplers: getBatchSamplersUniformGroup(maxTextures2)
            }
          });
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs
  var defaultShader, _DefaultBatcher, DefaultBatcher;
  var init_DefaultBatcher = __esm({
    "node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs"() {
      init_Extensions();
      init_Batcher();
      init_BatchGeometry();
      init_DefaultShader();
      defaultShader = null;
      _DefaultBatcher = class _DefaultBatcher2 extends Batcher {
        constructor() {
          super(...arguments);
          this.geometry = new BatchGeometry();
          this.shader = defaultShader || (defaultShader = new DefaultShader(this.maxTextures));
          this.name = _DefaultBatcher2.extension.name;
          this.vertexSize = 6;
        }
        /**
         * Packs the attributes of a DefaultBatchableMeshElement into the provided views.
         * @param element - The DefaultBatchableMeshElement to pack.
         * @param float32View - The Float32Array view to pack into.
         * @param uint32View - The Uint32Array view to pack into.
         * @param index - The starting index in the views.
         * @param textureId - The texture ID to use.
         */
        packAttributes(element, float32View, uint32View, index6, textureId) {
          const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;
          const wt = element.transform;
          const a2 = wt.a;
          const b2 = wt.b;
          const c2 = wt.c;
          const d2 = wt.d;
          const tx = wt.tx;
          const ty = wt.ty;
          const { positions, uvs } = element;
          const argb = element.color;
          const offset = element.attributeOffset;
          const end = offset + element.attributeSize;
          for (let i2 = offset; i2 < end; i2++) {
            const i22 = i2 * 2;
            const x2 = positions[i22];
            const y2 = positions[i22 + 1];
            float32View[index6++] = a2 * x2 + c2 * y2 + tx;
            float32View[index6++] = d2 * y2 + b2 * x2 + ty;
            float32View[index6++] = uvs[i22];
            float32View[index6++] = uvs[i22 + 1];
            uint32View[index6++] = argb;
            uint32View[index6++] = textureIdAndRound;
          }
        }
        /**
         * Packs the attributes of a DefaultBatchableQuadElement into the provided views.
         * @param element - The DefaultBatchableQuadElement to pack.
         * @param float32View - The Float32Array view to pack into.
         * @param uint32View - The Uint32Array view to pack into.
         * @param index - The starting index in the views.
         * @param textureId - The texture ID to use.
         */
        packQuadAttributes(element, float32View, uint32View, index6, textureId) {
          const texture = element.texture;
          const wt = element.transform;
          const a2 = wt.a;
          const b2 = wt.b;
          const c2 = wt.c;
          const d2 = wt.d;
          const tx = wt.tx;
          const ty = wt.ty;
          const bounds = element.bounds;
          const w0 = bounds.maxX;
          const w1 = bounds.minX;
          const h0 = bounds.maxY;
          const h1 = bounds.minY;
          const uvs = texture.uvs;
          const argb = element.color;
          const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;
          float32View[index6 + 0] = a2 * w1 + c2 * h1 + tx;
          float32View[index6 + 1] = d2 * h1 + b2 * w1 + ty;
          float32View[index6 + 2] = uvs.x0;
          float32View[index6 + 3] = uvs.y0;
          uint32View[index6 + 4] = argb;
          uint32View[index6 + 5] = textureIdAndRound;
          float32View[index6 + 6] = a2 * w0 + c2 * h1 + tx;
          float32View[index6 + 7] = d2 * h1 + b2 * w0 + ty;
          float32View[index6 + 8] = uvs.x1;
          float32View[index6 + 9] = uvs.y1;
          uint32View[index6 + 10] = argb;
          uint32View[index6 + 11] = textureIdAndRound;
          float32View[index6 + 12] = a2 * w0 + c2 * h0 + tx;
          float32View[index6 + 13] = d2 * h0 + b2 * w0 + ty;
          float32View[index6 + 14] = uvs.x2;
          float32View[index6 + 15] = uvs.y2;
          uint32View[index6 + 16] = argb;
          uint32View[index6 + 17] = textureIdAndRound;
          float32View[index6 + 18] = a2 * w1 + c2 * h0 + tx;
          float32View[index6 + 19] = d2 * h0 + b2 * w1 + ty;
          float32View[index6 + 20] = uvs.x3;
          float32View[index6 + 21] = uvs.y3;
          uint32View[index6 + 22] = argb;
          uint32View[index6 + 23] = textureIdAndRound;
        }
      };
      _DefaultBatcher.extension = {
        type: [
          ExtensionType.Batcher
        ],
        name: "default"
      };
      DefaultBatcher = _DefaultBatcher;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs
  function buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size5, matrix = null) {
    let index6 = 0;
    verticesOffset *= verticesStride;
    uvsOffset *= uvsStride;
    const a2 = matrix.a;
    const b2 = matrix.b;
    const c2 = matrix.c;
    const d2 = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    while (index6 < size5) {
      const x2 = vertices[verticesOffset];
      const y2 = vertices[verticesOffset + 1];
      uvs[uvsOffset] = a2 * x2 + c2 * y2 + tx;
      uvs[uvsOffset + 1] = b2 * x2 + d2 * y2 + ty;
      uvsOffset += uvsStride;
      verticesOffset += verticesStride;
      index6++;
    }
  }
  function buildSimpleUvs(uvs, uvsOffset, uvsStride, size5) {
    let index6 = 0;
    uvsOffset *= uvsStride;
    while (index6 < size5) {
      uvs[uvsOffset] = 0;
      uvs[uvsOffset + 1] = 0;
      uvsOffset += uvsStride;
      index6++;
    }
  }
  var init_buildUvs = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs
  function transformVertices(vertices, m2, offset, stride, size5) {
    const a2 = m2.a;
    const b2 = m2.b;
    const c2 = m2.c;
    const d2 = m2.d;
    const tx = m2.tx;
    const ty = m2.ty;
    offset = offset || 0;
    stride = stride || 2;
    size5 = size5 || vertices.length / stride - offset;
    let index6 = offset * stride;
    for (let i2 = 0; i2 < size5; i2++) {
      const x2 = vertices[index6];
      const y2 = vertices[index6 + 1];
      vertices[index6] = a2 * x2 + c2 * y2 + tx;
      vertices[index6 + 1] = b2 * x2 + d2 * y2 + ty;
      index6 += stride;
    }
  }
  var init_transformVertices = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs
  function multiplyHexColors(color1, color2) {
    if (color1 === 16777215 || !color2)
      return color2;
    if (color2 === 16777215 || !color1)
      return color1;
    const r1 = color1 >> 16 & 255;
    const g1 = color1 >> 8 & 255;
    const b1 = color1 & 255;
    const r2 = color2 >> 16 & 255;
    const g2 = color2 >> 8 & 255;
    const b2 = color2 & 255;
    const r3 = r1 * r2 / 255;
    const g3 = g1 * g2 / 255;
    const b3 = b1 * b2 / 255;
    return (r3 << 16) + (g3 << 8) + b3;
  }
  var init_multiplyHexColors = __esm({
    "node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs
  var identityMatrix2, BatchableGraphics;
  var init_BatchableGraphics = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs"() {
      init_Matrix();
      init_multiplyHexColors();
      identityMatrix2 = new Matrix();
      BatchableGraphics = class {
        constructor() {
          this.packAsQuad = false;
          this.batcherName = "default";
          this.applyTransform = true;
          this.roundPixels = 0;
          this._batcher = null;
          this._batch = null;
        }
        get uvs() {
          return this.geometryData.uvs;
        }
        get positions() {
          return this.geometryData.vertices;
        }
        get indices() {
          return this.geometryData.indices;
        }
        get blendMode() {
          if (this.applyTransform) {
            return this.renderable.groupBlendMode;
          }
          return "normal";
        }
        get color() {
          const rgb = this.baseColor;
          const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;
          const renderable = this.renderable;
          if (renderable) {
            return multiplyHexColors(bgr, renderable.groupColor) + (this.alpha * renderable.groupAlpha * 255 << 24);
          }
          return bgr + (this.alpha * 255 << 24);
        }
        get transform() {
          return this.renderable?.groupTransform || identityMatrix2;
        }
        copyTo(gpuBuffer) {
          gpuBuffer.indexOffset = this.indexOffset;
          gpuBuffer.indexSize = this.indexSize;
          gpuBuffer.attributeOffset = this.attributeOffset;
          gpuBuffer.attributeSize = this.attributeSize;
          gpuBuffer.baseColor = this.baseColor;
          gpuBuffer.alpha = this.alpha;
          gpuBuffer.texture = this.texture;
          gpuBuffer.geometryData = this.geometryData;
        }
        reset() {
          this.applyTransform = true;
          this.renderable = null;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs
  var buildCircle, buildEllipse, buildRoundedRectangle;
  var init_buildCircle = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs"() {
      init_Extensions();
      buildCircle = {
        extension: {
          type: ExtensionType.ShapeBuilder,
          name: "circle"
        },
        build(shape2, points) {
          let x2;
          let y2;
          let dx;
          let dy;
          let rx;
          let ry;
          if (shape2.type === "circle") {
            const circle = shape2;
            x2 = circle.x;
            y2 = circle.y;
            rx = ry = circle.radius;
            dx = dy = 0;
          } else if (shape2.type === "ellipse") {
            const ellipse = shape2;
            x2 = ellipse.x;
            y2 = ellipse.y;
            rx = ellipse.halfWidth;
            ry = ellipse.halfHeight;
            dx = dy = 0;
          } else {
            const roundedRect = shape2;
            const halfWidth = roundedRect.width / 2;
            const halfHeight = roundedRect.height / 2;
            x2 = roundedRect.x + halfWidth;
            y2 = roundedRect.y + halfHeight;
            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
            dx = halfWidth - rx;
            dy = halfHeight - ry;
          }
          if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
            return points;
          }
          const n2 = Math.ceil(2.3 * Math.sqrt(rx + ry));
          const m2 = n2 * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
          if (m2 === 0) {
            return points;
          }
          if (n2 === 0) {
            points[0] = points[6] = x2 + dx;
            points[1] = points[3] = y2 + dy;
            points[2] = points[4] = x2 - dx;
            points[5] = points[7] = y2 - dy;
            return points;
          }
          let j1 = 0;
          let j2 = n2 * 4 + (dx ? 2 : 0) + 2;
          let j3 = j2;
          let j4 = m2;
          let x0 = dx + rx;
          let y0 = dy;
          let x1 = x2 + x0;
          let x22 = x2 - x0;
          let y1 = y2 + y0;
          points[j1++] = x1;
          points[j1++] = y1;
          points[--j2] = y1;
          points[--j2] = x22;
          if (dy) {
            const y222 = y2 - y0;
            points[j3++] = x22;
            points[j3++] = y222;
            points[--j4] = y222;
            points[--j4] = x1;
          }
          for (let i2 = 1; i2 < n2; i2++) {
            const a2 = Math.PI / 2 * (i2 / n2);
            const x02 = dx + Math.cos(a2) * rx;
            const y02 = dy + Math.sin(a2) * ry;
            const x12 = x2 + x02;
            const x222 = x2 - x02;
            const y12 = y2 + y02;
            const y222 = y2 - y02;
            points[j1++] = x12;
            points[j1++] = y12;
            points[--j2] = y12;
            points[--j2] = x222;
            points[j3++] = x222;
            points[j3++] = y222;
            points[--j4] = y222;
            points[--j4] = x12;
          }
          x0 = dx;
          y0 = dy + ry;
          x1 = x2 + x0;
          x22 = x2 - x0;
          y1 = y2 + y0;
          const y22 = y2 - y0;
          points[j1++] = x1;
          points[j1++] = y1;
          points[--j4] = y22;
          points[--j4] = x1;
          if (dx) {
            points[j1++] = x22;
            points[j1++] = y1;
            points[--j4] = y22;
            points[--j4] = x22;
          }
          return points;
        },
        triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
          if (points.length === 0) {
            return;
          }
          let centerX = 0;
          let centerY = 0;
          for (let i2 = 0; i2 < points.length; i2 += 2) {
            centerX += points[i2];
            centerY += points[i2 + 1];
          }
          centerX /= points.length / 2;
          centerY /= points.length / 2;
          let count2 = verticesOffset;
          vertices[count2 * verticesStride] = centerX;
          vertices[count2 * verticesStride + 1] = centerY;
          const centerIndex = count2++;
          for (let i2 = 0; i2 < points.length; i2 += 2) {
            vertices[count2 * verticesStride] = points[i2];
            vertices[count2 * verticesStride + 1] = points[i2 + 1];
            if (i2 > 0) {
              indices[indicesOffset++] = count2;
              indices[indicesOffset++] = centerIndex;
              indices[indicesOffset++] = count2 - 1;
            }
            count2++;
          }
          indices[indicesOffset++] = centerIndex + 1;
          indices[indicesOffset++] = centerIndex;
          indices[indicesOffset++] = count2 - 1;
        }
      };
      buildEllipse = { ...buildCircle, extension: { ...buildCircle.extension, name: "ellipse" } };
      buildRoundedRectangle = { ...buildCircle, extension: { ...buildCircle.extension, name: "roundedRectangle" } };
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/const.mjs
  var closePointEps, curveEps;
  var init_const6 = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/const.mjs"() {
      "use strict";
      closePointEps = 1e-4;
      curveEps = 1e-4;
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs
  function getOrientationOfPoints(points) {
    const m2 = points.length;
    if (m2 < 6) {
      return 1;
    }
    let area = 0;
    for (let i2 = 0, x1 = points[m2 - 2], y1 = points[m2 - 1]; i2 < m2; i2 += 2) {
      const x2 = points[i2];
      const y2 = points[i2 + 1];
      area += (x2 - x1) * (y2 + y1);
      x1 = x2;
      y1 = y2;
    }
    if (area < 0) {
      return -1;
    }
    return 1;
  }
  var init_getOrientationOfPoints = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs
  function square(x2, y2, nx, ny, innerWeight, outerWeight, clockwise, verts) {
    const ix3 = x2 - nx * innerWeight;
    const iy = y2 - ny * innerWeight;
    const ox = x2 + nx * outerWeight;
    const oy = y2 + ny * outerWeight;
    let exx;
    let eyy;
    if (clockwise) {
      exx = ny;
      eyy = -nx;
    } else {
      exx = -ny;
      eyy = nx;
    }
    const eix = ix3 + exx;
    const eiy = iy + eyy;
    const eox = ox + exx;
    const eoy = oy + eyy;
    verts.push(eix, eiy);
    verts.push(eox, eoy);
    return 2;
  }
  function round2(cx, cy, sx, sy, ex, ey, verts, clockwise) {
    const cx2p0x = sx - cx;
    const cy2p0y = sy - cy;
    let angle0 = Math.atan2(cx2p0x, cy2p0y);
    let angle1 = Math.atan2(ex - cx, ey - cy);
    if (clockwise && angle0 < angle1) {
      angle0 += Math.PI * 2;
    } else if (!clockwise && angle0 > angle1) {
      angle1 += Math.PI * 2;
    }
    let startAngle = angle0;
    const angleDiff = angle1 - angle0;
    const absAngleDiff = Math.abs(angleDiff);
    const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
    const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
    const angleInc = angleDiff / segCount;
    startAngle += angleInc;
    if (clockwise) {
      verts.push(cx, cy);
      verts.push(sx, sy);
      for (let i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {
        verts.push(cx, cy);
        verts.push(
          cx + Math.sin(angle) * radius,
          cy + Math.cos(angle) * radius
        );
      }
      verts.push(cx, cy);
      verts.push(ex, ey);
    } else {
      verts.push(sx, sy);
      verts.push(cx, cy);
      for (let i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {
        verts.push(
          cx + Math.sin(angle) * radius,
          cy + Math.cos(angle) * radius
        );
        verts.push(cx, cy);
      }
      verts.push(ex, ey);
      verts.push(cx, cy);
    }
    return segCount * 2;
  }
  function buildLine(points, lineStyle, flipAlignment, closed, vertices, _verticesStride, _verticesOffset, indices, _indicesOffset) {
    const eps = closePointEps;
    if (points.length === 0) {
      return;
    }
    const style3 = lineStyle;
    let alignment = style3.alignment;
    if (lineStyle.alignment !== 0.5) {
      let orientation = getOrientationOfPoints(points);
      if (flipAlignment)
        orientation *= -1;
      alignment = (alignment - 0.5) * orientation + 0.5;
    }
    const firstPoint = new Point(points[0], points[1]);
    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
    const closedShape = closed;
    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
    if (closedShape) {
      points = points.slice();
      if (closedPath) {
        points.pop();
        points.pop();
        lastPoint.set(points[points.length - 2], points[points.length - 1]);
      }
      const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
      const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
      points.unshift(midPointX, midPointY);
      points.push(midPointX, midPointY);
    }
    const verts = vertices;
    const length9 = points.length / 2;
    let indexCount = points.length;
    const indexStart = verts.length / 2;
    const width8 = style3.width / 2;
    const widthSquared = width8 * width8;
    const miterLimitSquared = style3.miterLimit * style3.miterLimit;
    let x0 = points[0];
    let y0 = points[1];
    let x1 = points[2];
    let y1 = points[3];
    let x2 = 0;
    let y2 = 0;
    let perpX = -(y0 - y1);
    let perpY = x0 - x1;
    let perp1x = 0;
    let perp1y = 0;
    let dist2 = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist2;
    perpY /= dist2;
    perpX *= width8;
    perpY *= width8;
    const ratio = alignment;
    const innerWeight = (1 - ratio) * 2;
    const outerWeight = ratio * 2;
    if (!closedShape) {
      if (style3.cap === "round") {
        indexCount += round2(
          x0 - perpX * (innerWeight - outerWeight) * 0.5,
          y0 - perpY * (innerWeight - outerWeight) * 0.5,
          x0 - perpX * innerWeight,
          y0 - perpY * innerWeight,
          x0 + perpX * outerWeight,
          y0 + perpY * outerWeight,
          verts,
          true
        ) + 2;
      } else if (style3.cap === "square") {
        indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);
      }
    }
    verts.push(
      x0 - perpX * innerWeight,
      y0 - perpY * innerWeight
    );
    verts.push(
      x0 + perpX * outerWeight,
      y0 + perpY * outerWeight
    );
    for (let i2 = 1; i2 < length9 - 1; ++i2) {
      x0 = points[(i2 - 1) * 2];
      y0 = points[(i2 - 1) * 2 + 1];
      x1 = points[i2 * 2];
      y1 = points[i2 * 2 + 1];
      x2 = points[(i2 + 1) * 2];
      y2 = points[(i2 + 1) * 2 + 1];
      perpX = -(y0 - y1);
      perpY = x0 - x1;
      dist2 = Math.sqrt(perpX * perpX + perpY * perpY);
      perpX /= dist2;
      perpY /= dist2;
      perpX *= width8;
      perpY *= width8;
      perp1x = -(y1 - y2);
      perp1y = x1 - x2;
      dist2 = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
      perp1x /= dist2;
      perp1y /= dist2;
      perp1x *= width8;
      perp1y *= width8;
      const dx0 = x1 - x0;
      const dy0 = y0 - y1;
      const dx1 = x1 - x2;
      const dy1 = y2 - y1;
      const dot2 = dx0 * dx1 + dy0 * dy1;
      const cross = dy0 * dx1 - dy1 * dx0;
      const clockwise = cross < 0;
      if (Math.abs(cross) < 1e-3 * Math.abs(dot2)) {
        verts.push(
          x1 - perpX * innerWeight,
          y1 - perpY * innerWeight
        );
        verts.push(
          x1 + perpX * outerWeight,
          y1 + perpY * outerWeight
        );
        if (dot2 >= 0) {
          if (style3.join === "round") {
            indexCount += round2(
              x1,
              y1,
              x1 - perpX * innerWeight,
              y1 - perpY * innerWeight,
              x1 - perp1x * innerWeight,
              y1 - perp1y * innerWeight,
              verts,
              false
            ) + 4;
          } else {
            indexCount += 2;
          }
          verts.push(
            x1 - perp1x * outerWeight,
            y1 - perp1y * outerWeight
          );
          verts.push(
            x1 + perp1x * innerWeight,
            y1 + perp1y * innerWeight
          );
        }
        continue;
      }
      const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);
      const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
      const px = (dx0 * c2 - dx1 * c1) / cross;
      const py = (dy1 * c1 - dy0 * c2) / cross;
      const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
      const imx = x1 + (px - x1) * innerWeight;
      const imy = y1 + (py - y1) * innerWeight;
      const omx = x1 - (px - x1) * outerWeight;
      const omy = y1 - (py - y1) * outerWeight;
      const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
      const insideWeight = clockwise ? innerWeight : outerWeight;
      const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
      const insideMiterOk = pDist <= smallerInsideDiagonalSq;
      if (insideMiterOk) {
        if (style3.join === "bevel" || pDist / widthSquared > miterLimitSquared) {
          if (clockwise) {
            verts.push(imx, imy);
            verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
            verts.push(imx, imy);
            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
            verts.push(omx, omy);
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
            verts.push(omx, omy);
          }
          indexCount += 2;
        } else if (style3.join === "round") {
          if (clockwise) {
            verts.push(imx, imy);
            verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
            indexCount += round2(
              x1,
              y1,
              x1 + perpX * outerWeight,
              y1 + perpY * outerWeight,
              x1 + perp1x * outerWeight,
              y1 + perp1y * outerWeight,
              verts,
              true
            ) + 4;
            verts.push(imx, imy);
            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
            verts.push(omx, omy);
            indexCount += round2(
              x1,
              y1,
              x1 - perpX * innerWeight,
              y1 - perpY * innerWeight,
              x1 - perp1x * innerWeight,
              y1 - perp1y * innerWeight,
              verts,
              false
            ) + 4;
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
            verts.push(omx, omy);
          }
        } else {
          verts.push(imx, imy);
          verts.push(omx, omy);
        }
      } else {
        verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
        verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
        if (style3.join === "round") {
          if (clockwise) {
            indexCount += round2(
              x1,
              y1,
              x1 + perpX * outerWeight,
              y1 + perpY * outerWeight,
              x1 + perp1x * outerWeight,
              y1 + perp1y * outerWeight,
              verts,
              true
            ) + 2;
          } else {
            indexCount += round2(
              x1,
              y1,
              x1 - perpX * innerWeight,
              y1 - perpY * innerWeight,
              x1 - perp1x * innerWeight,
              y1 - perp1y * innerWeight,
              verts,
              false
            ) + 2;
          }
        } else if (style3.join === "miter" && pDist / widthSquared <= miterLimitSquared) {
          if (clockwise) {
            verts.push(omx, omy);
            verts.push(omx, omy);
          } else {
            verts.push(imx, imy);
            verts.push(imx, imy);
          }
          indexCount += 2;
        }
        verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
        verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        indexCount += 2;
      }
    }
    x0 = points[(length9 - 2) * 2];
    y0 = points[(length9 - 2) * 2 + 1];
    x1 = points[(length9 - 1) * 2];
    y1 = points[(length9 - 1) * 2 + 1];
    perpX = -(y0 - y1);
    perpY = x0 - x1;
    dist2 = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist2;
    perpY /= dist2;
    perpX *= width8;
    perpY *= width8;
    verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
    verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
    if (!closedShape) {
      if (style3.cap === "round") {
        indexCount += round2(
          x1 - perpX * (innerWeight - outerWeight) * 0.5,
          y1 - perpY * (innerWeight - outerWeight) * 0.5,
          x1 - perpX * innerWeight,
          y1 - perpY * innerWeight,
          x1 + perpX * outerWeight,
          y1 + perpY * outerWeight,
          verts,
          false
        ) + 2;
      } else if (style3.cap === "square") {
        indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);
      }
    }
    const eps2 = curveEps * curveEps;
    for (let i2 = indexStart; i2 < indexCount + indexStart - 2; ++i2) {
      x0 = verts[i2 * 2];
      y0 = verts[i2 * 2 + 1];
      x1 = verts[(i2 + 1) * 2];
      y1 = verts[(i2 + 1) * 2 + 1];
      x2 = verts[(i2 + 2) * 2];
      y2 = verts[(i2 + 2) * 2 + 1];
      if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
        continue;
      }
      indices.push(i2, i2 + 1, i2 + 2);
    }
  }
  var init_buildLine = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs"() {
      init_Point();
      init_const6();
      init_getOrientationOfPoints();
    }
  });

  // node_modules/earcut/src/earcut.js
  var require_earcut = __commonJS({
    "node_modules/earcut/src/earcut.js"(exports, module) {
      "use strict";
      module.exports = earcut2;
      module.exports.default = earcut2;
      function earcut2(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev) return triangles;
        var minX, minY, maxX, maxY, x2, y2, invSize;
        if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];
          for (var i2 = dim; i2 < outerLen; i2 += dim) {
            x2 = data[i2];
            y2 = data[i2 + 1];
            if (x2 < minX) minX = x2;
            if (y2 < minY) minY = y2;
            if (x2 > maxX) maxX = x2;
            if (y2 > maxY) maxY = y2;
          }
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 32767 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
        return triangles;
      }
      function linkedList(data, start3, end, dim, clockwise) {
        var i2, last4;
        if (clockwise === signedArea(data, start3, end, dim) > 0) {
          for (i2 = start3; i2 < end; i2 += dim) last4 = insertNode(i2, data[i2], data[i2 + 1], last4);
        } else {
          for (i2 = end - dim; i2 >= start3; i2 -= dim) last4 = insertNode(i2, data[i2], data[i2 + 1], last4);
        }
        if (last4 && equals(last4, last4.next)) {
          removeNode(last4);
          last4 = last4.next;
        }
        return last4;
      }
      function filterPoints(start3, end) {
        if (!start3) return start3;
        if (!end) end = start3;
        var p2 = start3, again;
        do {
          again = false;
          if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
            removeNode(p2);
            p2 = end = p2.prev;
            if (p2 === p2.next) break;
            again = true;
          } else {
            p2 = p2.next;
          }
        } while (again || p2 !== end);
        return end;
      }
      function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass2) {
        if (!ear) return;
        if (!pass2 && invSize) indexCurve(ear, minX, minY, invSize);
        var stop = ear, prev, next;
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;
          if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);
            removeNode(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }
          ear = next;
          if (ear === stop) {
            if (!pass2) {
              earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            } else if (pass2 === 1) {
              ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
              earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (pass2 === 2) {
              splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
          }
        }
      }
      function isEar(ear) {
        var a2 = ear.prev, b2 = ear, c2 = ear.next;
        if (area(a2, b2, c2) >= 0) return false;
        var ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
        var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var p2 = c2.next;
        while (p2 !== a2) {
          if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
          p2 = p2.next;
        }
        return true;
      }
      function isEarHashed(ear, minX, minY, invSize) {
        var a2 = ear.prev, b2 = ear, c2 = ear.next;
        if (area(a2, b2, c2) >= 0) return false;
        var ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
        var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
        var p2 = ear.prevZ, n2 = ear.nextZ;
        while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
          if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
          p2 = p2.prevZ;
          if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0) return false;
          n2 = n2.nextZ;
        }
        while (p2 && p2.z >= minZ) {
          if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
          p2 = p2.prevZ;
        }
        while (n2 && n2.z <= maxZ) {
          if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0) return false;
          n2 = n2.nextZ;
        }
        return true;
      }
      function cureLocalIntersections(start3, triangles, dim) {
        var p2 = start3;
        do {
          var a2 = p2.prev, b2 = p2.next.next;
          if (!equals(a2, b2) && intersects(a2, p2, p2.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
            triangles.push(a2.i / dim | 0);
            triangles.push(p2.i / dim | 0);
            triangles.push(b2.i / dim | 0);
            removeNode(p2);
            removeNode(p2.next);
            p2 = start3 = b2;
          }
          p2 = p2.next;
        } while (p2 !== start3);
        return filterPoints(p2);
      }
      function splitEarcut(start3, triangles, dim, minX, minY, invSize) {
        var a2 = start3;
        do {
          var b2 = a2.next.next;
          while (b2 !== a2.prev) {
            if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
              var c2 = splitPolygon(a2, b2);
              a2 = filterPoints(a2, a2.next);
              c2 = filterPoints(c2, c2.next);
              earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
              earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
              return;
            }
            b2 = b2.next;
          }
          a2 = a2.next;
        } while (a2 !== start3);
      }
      function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [], i2, len, start3, end, list;
        for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
          start3 = holeIndices[i2] * dim;
          end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
          list = linkedList(data, start3, end, dim, false);
          if (list === list.next) list.steiner = true;
          queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        for (i2 = 0; i2 < queue.length; i2++) {
          outerNode = eliminateHole(queue[i2], outerNode);
        }
        return outerNode;
      }
      function compareX(a2, b2) {
        return a2.x - b2.x;
      }
      function eliminateHole(hole, outerNode) {
        var bridge = findHoleBridge(hole, outerNode);
        if (!bridge) {
          return outerNode;
        }
        var bridgeReverse = splitPolygon(bridge, hole);
        filterPoints(bridgeReverse, bridgeReverse.next);
        return filterPoints(bridge, bridge.next);
      }
      function findHoleBridge(hole, outerNode) {
        var p2 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
        do {
          if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
            var x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
            if (x2 <= hx && x2 > qx) {
              qx = x2;
              m2 = p2.x < p2.next.x ? p2 : p2.next;
              if (x2 === hx) return m2;
            }
          }
          p2 = p2.next;
        } while (p2 !== outerNode);
        if (!m2) return null;
        var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan2;
        p2 = m2;
        do {
          if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
            tan2 = Math.abs(hy - p2.y) / (hx - p2.x);
            if (locallyInside(p2, hole) && (tan2 < tanMin || tan2 === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
              m2 = p2;
              tanMin = tan2;
            }
          }
          p2 = p2.next;
        } while (p2 !== stop);
        return m2;
      }
      function sectorContainsSector(m2, p2) {
        return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
      }
      function indexCurve(start3, minX, minY, invSize) {
        var p2 = start3;
        do {
          if (p2.z === 0) p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
          p2.prevZ = p2.prev;
          p2.nextZ = p2.next;
          p2 = p2.next;
        } while (p2 !== start3);
        p2.prevZ.nextZ = null;
        p2.prevZ = null;
        sortLinked(p2);
      }
      function sortLinked(list) {
        var i2, p2, q, e2, tail4, numMerges, pSize, qSize, inSize = 1;
        do {
          p2 = list;
          list = null;
          tail4 = null;
          numMerges = 0;
          while (p2) {
            numMerges++;
            q = p2;
            pSize = 0;
            for (i2 = 0; i2 < inSize; i2++) {
              pSize++;
              q = q.nextZ;
              if (!q) break;
            }
            qSize = inSize;
            while (pSize > 0 || qSize > 0 && q) {
              if (pSize !== 0 && (qSize === 0 || !q || p2.z <= q.z)) {
                e2 = p2;
                p2 = p2.nextZ;
                pSize--;
              } else {
                e2 = q;
                q = q.nextZ;
                qSize--;
              }
              if (tail4) tail4.nextZ = e2;
              else list = e2;
              e2.prevZ = tail4;
              tail4 = e2;
            }
            p2 = q;
          }
          tail4.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);
        return list;
      }
      function zOrder(x2, y2, minX, minY, invSize) {
        x2 = (x2 - minX) * invSize | 0;
        y2 = (y2 - minY) * invSize | 0;
        x2 = (x2 | x2 << 8) & 16711935;
        x2 = (x2 | x2 << 4) & 252645135;
        x2 = (x2 | x2 << 2) & 858993459;
        x2 = (x2 | x2 << 1) & 1431655765;
        y2 = (y2 | y2 << 8) & 16711935;
        y2 = (y2 | y2 << 4) & 252645135;
        y2 = (y2 | y2 << 2) & 858993459;
        y2 = (y2 | y2 << 1) & 1431655765;
        return x2 | y2 << 1;
      }
      function getLeftmost(start3) {
        var p2 = start3, leftmost = start3;
        do {
          if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y) leftmost = p2;
          p2 = p2.next;
        } while (p2 !== start3);
        return leftmost;
      }
      function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
      }
      function isValidDiagonal(a2, b2) {
        return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && // dones't intersect other edges
        (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && // locally visible
        (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || // does not create opposite-facing sectors
        equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
      }
      function area(p2, q, r2) {
        return (q.y - p2.y) * (r2.x - q.x) - (q.x - p2.x) * (r2.y - q.y);
      }
      function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      }
      function intersects(p1, q1, p2, q2) {
        var o1 = sign2(area(p1, q1, p2));
        var o2 = sign2(area(p1, q1, q2));
        var o3 = sign2(area(p2, q2, p1));
        var o4 = sign2(area(p2, q2, q1));
        if (o1 !== o2 && o3 !== o4) return true;
        if (o1 === 0 && onSegment(p1, p2, q1)) return true;
        if (o2 === 0 && onSegment(p1, q2, q1)) return true;
        if (o3 === 0 && onSegment(p2, p1, q2)) return true;
        if (o4 === 0 && onSegment(p2, q1, q2)) return true;
        return false;
      }
      function onSegment(p2, q, r2) {
        return q.x <= Math.max(p2.x, r2.x) && q.x >= Math.min(p2.x, r2.x) && q.y <= Math.max(p2.y, r2.y) && q.y >= Math.min(p2.y, r2.y);
      }
      function sign2(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
      }
      function intersectsPolygon(a2, b2) {
        var p2 = a2;
        do {
          if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a2, b2)) return true;
          p2 = p2.next;
        } while (p2 !== a2);
        return false;
      }
      function locallyInside(a2, b2) {
        return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
      }
      function middleInside(a2, b2) {
        var p2 = a2, inside2 = false, px = (a2.x + b2.x) / 2, py = (a2.y + b2.y) / 2;
        do {
          if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
            inside2 = !inside2;
          p2 = p2.next;
        } while (p2 !== a2);
        return inside2;
      }
      function splitPolygon(a2, b2) {
        var a22 = new Node2(a2.i, a2.x, a2.y), b22 = new Node2(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
        a2.next = b2;
        b2.prev = a2;
        a22.next = an;
        an.prev = a22;
        b22.next = a22;
        a22.prev = b22;
        bp.next = b22;
        b22.prev = bp;
        return b22;
      }
      function insertNode(i2, x2, y2, last4) {
        var p2 = new Node2(i2, x2, y2);
        if (!last4) {
          p2.prev = p2;
          p2.next = p2;
        } else {
          p2.next = last4.next;
          p2.prev = last4;
          last4.next.prev = p2;
          last4.next = p2;
        }
        return p2;
      }
      function removeNode(p2) {
        p2.next.prev = p2.prev;
        p2.prev.next = p2.next;
        if (p2.prevZ) p2.prevZ.nextZ = p2.nextZ;
        if (p2.nextZ) p2.nextZ.prevZ = p2.prevZ;
      }
      function Node2(i2, x2, y2) {
        this.i = i2;
        this.x = x2;
        this.y = y2;
        this.prev = null;
        this.next = null;
        this.z = 0;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
      }
      earcut2.deviation = function(data, holeIndices, dim, triangles) {
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
        if (hasHoles) {
          for (var i2 = 0, len = holeIndices.length; i2 < len; i2++) {
            var start3 = holeIndices[i2] * dim;
            var end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start3, end, dim));
          }
        }
        var trianglesArea = 0;
        for (i2 = 0; i2 < triangles.length; i2 += 3) {
          var a2 = triangles[i2] * dim;
          var b2 = triangles[i2 + 1] * dim;
          var c2 = triangles[i2 + 2] * dim;
          trianglesArea += Math.abs(
            (data[a2] - data[c2]) * (data[b2 + 1] - data[a2 + 1]) - (data[a2] - data[b2]) * (data[c2 + 1] - data[a2 + 1])
          );
        }
        return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
      };
      function signedArea(data, start3, end, dim) {
        var sum2 = 0;
        for (var i2 = start3, j2 = end - dim; i2 < end; i2 += dim) {
          sum2 += (data[j2] - data[i2]) * (data[i2 + 1] + data[j2 + 1]);
          j2 = i2;
        }
        return sum2;
      }
      earcut2.flatten = function(data) {
        var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
        for (var i2 = 0; i2 < data.length; i2++) {
          for (var j2 = 0; j2 < data[i2].length; j2++) {
            for (var d2 = 0; d2 < dim; d2++) result.vertices.push(data[i2][j2][d2]);
          }
          if (i2 > 0) {
            holeIndex += data[i2 - 1].length;
            result.holes.push(holeIndex);
          }
        }
        return result;
      };
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs
  function triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
    const triangles = (0, import_earcut.default)(points, holes, 2);
    if (!triangles) {
      return;
    }
    for (let i2 = 0; i2 < triangles.length; i2 += 3) {
      indices[indicesOffset++] = triangles[i2] + verticesOffset;
      indices[indicesOffset++] = triangles[i2 + 1] + verticesOffset;
      indices[indicesOffset++] = triangles[i2 + 2] + verticesOffset;
    }
    let index6 = verticesOffset * verticesStride;
    for (let i2 = 0; i2 < points.length; i2 += 2) {
      vertices[index6] = points[i2];
      vertices[index6 + 1] = points[i2 + 1];
      index6 += verticesStride;
    }
  }
  var import_earcut;
  var init_triangulateWithHoles = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs"() {
      import_earcut = __toESM(require_earcut(), 1);
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs
  var emptyArray, buildPolygon;
  var init_buildPolygon = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs"() {
      init_Extensions();
      init_triangulateWithHoles();
      emptyArray = [];
      buildPolygon = {
        extension: {
          type: ExtensionType.ShapeBuilder,
          name: "polygon"
        },
        build(shape2, points) {
          for (let i2 = 0; i2 < shape2.points.length; i2++) {
            points[i2] = shape2.points[i2];
          }
          return points;
        },
        triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
          triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs
  var buildRectangle;
  var init_buildRectangle = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs"() {
      init_Extensions();
      buildRectangle = {
        extension: {
          type: ExtensionType.ShapeBuilder,
          name: "rectangle"
        },
        build(shape2, points) {
          const rectData = shape2;
          const x2 = rectData.x;
          const y2 = rectData.y;
          const width8 = rectData.width;
          const height8 = rectData.height;
          if (!(width8 >= 0 && height8 >= 0)) {
            return points;
          }
          points[0] = x2;
          points[1] = y2;
          points[2] = x2 + width8;
          points[3] = y2;
          points[4] = x2 + width8;
          points[5] = y2 + height8;
          points[6] = x2;
          points[7] = y2 + height8;
          return points;
        },
        triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
          let count2 = 0;
          verticesOffset *= verticesStride;
          vertices[verticesOffset + count2] = points[0];
          vertices[verticesOffset + count2 + 1] = points[1];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[2];
          vertices[verticesOffset + count2 + 1] = points[3];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[6];
          vertices[verticesOffset + count2 + 1] = points[7];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[4];
          vertices[verticesOffset + count2 + 1] = points[5];
          count2 += verticesStride;
          const verticesIndex = verticesOffset / verticesStride;
          indices[indicesOffset++] = verticesIndex;
          indices[indicesOffset++] = verticesIndex + 1;
          indices[indicesOffset++] = verticesIndex + 2;
          indices[indicesOffset++] = verticesIndex + 1;
          indices[indicesOffset++] = verticesIndex + 3;
          indices[indicesOffset++] = verticesIndex + 2;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs
  var buildTriangle;
  var init_buildTriangle = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs"() {
      init_Extensions();
      buildTriangle = {
        extension: {
          type: ExtensionType.ShapeBuilder,
          name: "triangle"
        },
        build(shape2, points) {
          points[0] = shape2.x;
          points[1] = shape2.y;
          points[2] = shape2.x2;
          points[3] = shape2.y2;
          points[4] = shape2.x3;
          points[5] = shape2.y3;
          return points;
        },
        triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
          let count2 = 0;
          verticesOffset *= verticesStride;
          vertices[verticesOffset + count2] = points[0];
          vertices[verticesOffset + count2 + 1] = points[1];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[2];
          vertices[verticesOffset + count2 + 1] = points[3];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[4];
          vertices[verticesOffset + count2 + 1] = points[5];
          const verticesIndex = verticesOffset / verticesStride;
          indices[indicesOffset++] = verticesIndex;
          indices[indicesOffset++] = verticesIndex + 1;
          indices[indicesOffset++] = verticesIndex + 2;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs
  function buildContextBatches(context3, gpuContext) {
    const { geometryData, batches } = gpuContext;
    batches.length = 0;
    geometryData.indices.length = 0;
    geometryData.vertices.length = 0;
    geometryData.uvs.length = 0;
    for (let i2 = 0; i2 < context3.instructions.length; i2++) {
      const instruction = context3.instructions[i2];
      if (instruction.action === "texture") {
        addTextureToGeometryData(instruction.data, batches, geometryData);
      } else if (instruction.action === "fill" || instruction.action === "stroke") {
        const isStroke = instruction.action === "stroke";
        const shapePath = instruction.data.path.shapePath;
        const style3 = instruction.data.style;
        const hole = instruction.data.hole;
        if (isStroke && hole) {
          addShapePathToGeometryData(hole.shapePath, style3, null, true, batches, geometryData);
        }
        addShapePathToGeometryData(shapePath, style3, hole, isStroke, batches, geometryData);
      }
    }
  }
  function addTextureToGeometryData(data, batches, geometryData) {
    const { vertices, uvs, indices } = geometryData;
    const indexOffset = indices.length;
    const vertOffset = vertices.length / 2;
    const points = [];
    const build2 = shapeBuilders.rectangle;
    const rect = tempRect;
    const texture = data.image;
    rect.x = data.dx;
    rect.y = data.dy;
    rect.width = data.dw;
    rect.height = data.dh;
    const matrix = data.transform;
    build2.build(rect, points);
    if (matrix) {
      transformVertices(points, matrix);
    }
    build2.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
    const textureUvs = texture.uvs;
    uvs.push(
      textureUvs.x0,
      textureUvs.y0,
      textureUvs.x1,
      textureUvs.y1,
      textureUvs.x3,
      textureUvs.y3,
      textureUvs.x2,
      textureUvs.y2
    );
    const graphicsBatch = BigPool.get(BatchableGraphics);
    graphicsBatch.indexOffset = indexOffset;
    graphicsBatch.indexSize = indices.length - indexOffset;
    graphicsBatch.attributeOffset = vertOffset;
    graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;
    graphicsBatch.baseColor = data.style;
    graphicsBatch.alpha = data.alpha;
    graphicsBatch.texture = texture;
    graphicsBatch.geometryData = geometryData;
    batches.push(graphicsBatch);
  }
  function addShapePathToGeometryData(shapePath, style3, hole, isStroke, batches, geometryData) {
    const { vertices, uvs, indices } = geometryData;
    const lastIndex = shapePath.shapePrimitives.length - 1;
    shapePath.shapePrimitives.forEach(({ shape: shape2, transform: matrix }, i2) => {
      const indexOffset = indices.length;
      const vertOffset = vertices.length / 2;
      const points = [];
      const build2 = shapeBuilders[shape2.type];
      build2.build(shape2, points);
      if (matrix) {
        transformVertices(points, matrix);
      }
      if (!isStroke) {
        if (hole && lastIndex === i2) {
          if (lastIndex !== 0) {
            console.warn("[Pixi Graphics] only the last shape have be cut out");
          }
          const holeIndices = [];
          const otherPoints = points.slice();
          const holeArrays = getHoleArrays(hole.shapePath);
          holeArrays.forEach((holePoints) => {
            holeIndices.push(otherPoints.length / 2);
            otherPoints.push(...holePoints);
          });
          triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);
        } else {
          build2.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
        }
      } else {
        const close2 = shape2.closePath ?? true;
        const lineStyle = style3;
        buildLine(points, lineStyle, false, close2, vertices, 2, vertOffset, indices, indexOffset);
      }
      const uvsOffset = uvs.length / 2;
      const texture = style3.texture;
      if (texture !== Texture.WHITE) {
        const textureMatrix = style3.matrix;
        if (textureMatrix) {
          if (matrix) {
            textureMatrix.append(matrix.clone().invert());
          }
          buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);
        }
      } else {
        buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);
      }
      const graphicsBatch = BigPool.get(BatchableGraphics);
      graphicsBatch.indexOffset = indexOffset;
      graphicsBatch.indexSize = indices.length - indexOffset;
      graphicsBatch.attributeOffset = vertOffset;
      graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;
      graphicsBatch.baseColor = style3.color;
      graphicsBatch.alpha = style3.alpha;
      graphicsBatch.texture = texture;
      graphicsBatch.geometryData = geometryData;
      batches.push(graphicsBatch);
    });
  }
  function getHoleArrays(shape2) {
    if (!shape2)
      return [];
    const holePrimitives = shape2.shapePrimitives;
    const holeArrays = [];
    for (let k2 = 0; k2 < holePrimitives.length; k2++) {
      const holePrimitive = holePrimitives[k2].shape;
      const holePoints = [];
      const holeBuilder = shapeBuilders[holePrimitive.type];
      holeBuilder.build(holePrimitive, holePoints);
      holeArrays.push(holePoints);
    }
    return holeArrays;
  }
  var shapeBuilders, tempRect;
  var init_buildContextBatches = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs"() {
      init_Extensions();
      init_Rectangle();
      init_buildUvs();
      init_transformVertices();
      init_Texture();
      init_PoolGroup();
      init_BatchableGraphics();
      init_buildCircle();
      init_buildLine();
      init_buildPolygon();
      init_buildRectangle();
      init_buildTriangle();
      init_triangulateWithHoles();
      shapeBuilders = {};
      extensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);
      extensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);
      tempRect = new Rectangle();
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs
  var GpuGraphicsContext, GraphicsContextRenderData, _GraphicsContextSystem, GraphicsContextSystem;
  var init_GraphicsContextSystem = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs"() {
      init_Extensions();
      init_getTextureBatchBindGroup();
      init_DefaultBatcher();
      init_InstructionSet();
      init_deprecation();
      init_PoolGroup();
      init_buildContextBatches();
      GpuGraphicsContext = class {
        constructor() {
          this.batches = [];
          this.geometryData = {
            vertices: [],
            uvs: [],
            indices: []
          };
        }
      };
      GraphicsContextRenderData = class {
        constructor() {
          this.batcher = new DefaultBatcher();
          this.instructions = new InstructionSet();
        }
        init() {
          this.instructions.reset();
        }
        /**
         * @deprecated since version 8.0.0
         * Use `batcher.geometry` instead.
         * @see {Batcher#geometry}
         */
        get geometry() {
          deprecation(v8_3_4, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.");
          return this.batcher.geometry;
        }
      };
      _GraphicsContextSystem = class _GraphicsContextSystem2 {
        constructor(renderer) {
          this._gpuContextHash = {};
          this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);
          renderer.renderableGC.addManagedHash(this, "_gpuContextHash");
          renderer.renderableGC.addManagedHash(this, "_graphicsDataContextHash");
        }
        /**
         * Runner init called, update the default options
         * @ignore
         */
        init(options2) {
          _GraphicsContextSystem2.defaultOptions.bezierSmoothness = options2?.bezierSmoothness ?? _GraphicsContextSystem2.defaultOptions.bezierSmoothness;
        }
        getContextRenderData(context3) {
          return this._graphicsDataContextHash[context3.uid] || this._initContextRenderData(context3);
        }
        // Context management functions
        updateGpuContext(context3) {
          let gpuContext = this._gpuContextHash[context3.uid] || this._initContext(context3);
          if (context3.dirty) {
            if (gpuContext) {
              this._cleanGraphicsContextData(context3);
            } else {
              gpuContext = this._initContext(context3);
            }
            buildContextBatches(context3, gpuContext);
            const batchMode = context3.batchMode;
            if (context3.customShader || batchMode === "no-batch") {
              gpuContext.isBatchable = false;
            } else if (batchMode === "auto") {
              gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;
            }
            context3.dirty = false;
          }
          return gpuContext;
        }
        getGpuContext(context3) {
          return this._gpuContextHash[context3.uid] || this._initContext(context3);
        }
        _initContextRenderData(context3) {
          const graphicsData = BigPool.get(GraphicsContextRenderData);
          const { batches, geometryData } = this._gpuContextHash[context3.uid];
          const vertexSize = geometryData.vertices.length;
          const indexSize = geometryData.indices.length;
          for (let i2 = 0; i2 < batches.length; i2++) {
            batches[i2].applyTransform = false;
          }
          const batcher = graphicsData.batcher;
          batcher.ensureAttributeBuffer(vertexSize);
          batcher.ensureIndexBuffer(indexSize);
          batcher.begin();
          for (let i2 = 0; i2 < batches.length; i2++) {
            const batch = batches[i2];
            batcher.add(batch);
          }
          batcher.finish(graphicsData.instructions);
          const geometry = batcher.geometry;
          geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);
          geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);
          const drawBatches = batcher.batches;
          for (let i2 = 0; i2 < drawBatches.length; i2++) {
            const batch = drawBatches[i2];
            batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count);
          }
          this._graphicsDataContextHash[context3.uid] = graphicsData;
          return graphicsData;
        }
        _initContext(context3) {
          const gpuContext = new GpuGraphicsContext();
          gpuContext.context = context3;
          this._gpuContextHash[context3.uid] = gpuContext;
          context3.on("destroy", this.onGraphicsContextDestroy, this);
          return this._gpuContextHash[context3.uid];
        }
        onGraphicsContextDestroy(context3) {
          this._cleanGraphicsContextData(context3);
          context3.off("destroy", this.onGraphicsContextDestroy, this);
          this._gpuContextHash[context3.uid] = null;
        }
        _cleanGraphicsContextData(context3) {
          const gpuContext = this._gpuContextHash[context3.uid];
          if (!gpuContext.isBatchable) {
            if (this._graphicsDataContextHash[context3.uid]) {
              BigPool.return(this.getContextRenderData(context3));
              this._graphicsDataContextHash[context3.uid] = null;
            }
          }
          if (gpuContext.batches) {
            gpuContext.batches.forEach((batch) => {
              BigPool.return(batch);
            });
          }
        }
        destroy() {
          for (const i2 in this._gpuContextHash) {
            if (this._gpuContextHash[i2]) {
              this.onGraphicsContextDestroy(this._gpuContextHash[i2].context);
            }
          }
        }
      };
      _GraphicsContextSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "graphicsContext"
      };
      _GraphicsContextSystem.defaultOptions = {
        /**
         * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)
         * @default 0.5
         */
        bezierSmoothness: 0.5
      };
      GraphicsContextSystem = _GraphicsContextSystem;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs
  var blendModeIds, BLEND, OFFSET, CULLING, DEPTH_TEST, WINDING, DEPTH_MASK, _State, State;
  var init_State = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs"() {
      "use strict";
      blendModeIds = {
        normal: 0,
        add: 1,
        multiply: 2,
        screen: 3,
        overlay: 4,
        erase: 5,
        "normal-npm": 6,
        "add-npm": 7,
        "screen-npm": 8,
        min: 9,
        max: 10
      };
      BLEND = 0;
      OFFSET = 1;
      CULLING = 2;
      DEPTH_TEST = 3;
      WINDING = 4;
      DEPTH_MASK = 5;
      _State = class _State2 {
        constructor() {
          this.data = 0;
          this.blendMode = "normal";
          this.polygonOffset = 0;
          this.blend = true;
          this.depthMask = true;
        }
        /**
         * Activates blending of the computed fragment color values.
         * @default true
         */
        get blend() {
          return !!(this.data & 1 << BLEND);
        }
        set blend(value12) {
          if (!!(this.data & 1 << BLEND) !== value12) {
            this.data ^= 1 << BLEND;
          }
        }
        /**
         * Activates adding an offset to depth values of polygon's fragments
         * @default false
         */
        get offsets() {
          return !!(this.data & 1 << OFFSET);
        }
        set offsets(value12) {
          if (!!(this.data & 1 << OFFSET) !== value12) {
            this.data ^= 1 << OFFSET;
          }
        }
        /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */
        set cullMode(value12) {
          if (value12 === "none") {
            this.culling = false;
            return;
          }
          this.culling = true;
          this.clockwiseFrontFace = value12 === "front";
        }
        get cullMode() {
          if (!this.culling) {
            return "none";
          }
          return this.clockwiseFrontFace ? "front" : "back";
        }
        /**
         * Activates culling of polygons.
         * @default false
         */
        get culling() {
          return !!(this.data & 1 << CULLING);
        }
        set culling(value12) {
          if (!!(this.data & 1 << CULLING) !== value12) {
            this.data ^= 1 << CULLING;
          }
        }
        /**
         * Activates depth comparisons and updates to the depth buffer.
         * @default false
         */
        get depthTest() {
          return !!(this.data & 1 << DEPTH_TEST);
        }
        set depthTest(value12) {
          if (!!(this.data & 1 << DEPTH_TEST) !== value12) {
            this.data ^= 1 << DEPTH_TEST;
          }
        }
        /**
         * Enables or disables writing to the depth buffer.
         * @default true
         */
        get depthMask() {
          return !!(this.data & 1 << DEPTH_MASK);
        }
        set depthMask(value12) {
          if (!!(this.data & 1 << DEPTH_MASK) !== value12) {
            this.data ^= 1 << DEPTH_MASK;
          }
        }
        /**
         * Specifies whether or not front or back-facing polygons can be culled.
         * @default false
         */
        get clockwiseFrontFace() {
          return !!(this.data & 1 << WINDING);
        }
        set clockwiseFrontFace(value12) {
          if (!!(this.data & 1 << WINDING) !== value12) {
            this.data ^= 1 << WINDING;
          }
        }
        /**
         * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.
         * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
         * @default 'normal'
         */
        get blendMode() {
          return this._blendMode;
        }
        set blendMode(value12) {
          this.blend = value12 !== "none";
          this._blendMode = value12;
          this._blendModeId = blendModeIds[value12] || 0;
        }
        /**
         * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
         * @default 0
         */
        get polygonOffset() {
          return this._polygonOffset;
        }
        set polygonOffset(value12) {
          this.offsets = !!value12;
          this._polygonOffset = value12;
        }
        toString() {
          return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
        }
        /**
         * A quickly getting an instance of a State that is configured for 2d rendering.
         * @returns a new State with values set for 2d rendering
         */
        static for2d() {
          const state4 = new _State2();
          state4.depthTest = false;
          state4.blend = true;
          return state4;
        }
      };
      _State.default2d = _State.for2d();
      State = _State;
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs
  function color32BitToUniform(abgr, out2, offset) {
    const alpha = (abgr >> 24 & 255) / 255;
    out2[offset++] = (abgr & 255) / 255 * alpha;
    out2[offset++] = (abgr >> 8 & 255) / 255 * alpha;
    out2[offset++] = (abgr >> 16 & 255) / 255 * alpha;
    out2[offset++] = alpha;
  }
  var init_colorToUniform = __esm({
    "node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs
  var GraphicsPipe;
  var init_GraphicsPipe = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs"() {
      init_Extensions();
      init_State();
      init_PoolGroup();
      init_colorToUniform();
      init_BatchableGraphics();
      GraphicsPipe = class {
        constructor(renderer, adaptor) {
          this.state = State.for2d();
          this._graphicsBatchesHash = /* @__PURE__ */ Object.create(null);
          this._destroyRenderableBound = this.destroyRenderable.bind(this);
          this.renderer = renderer;
          this._adaptor = adaptor;
          this._adaptor.init();
          this.renderer.renderableGC.addManagedHash(this, "_graphicsBatchesHash");
        }
        validateRenderable(graphics) {
          const context3 = graphics.context;
          const wasBatched = !!this._graphicsBatchesHash[graphics.uid];
          const gpuContext = this.renderer.graphicsContext.updateGpuContext(context3);
          if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {
            return true;
          }
          return false;
        }
        addRenderable(graphics, instructionSet) {
          const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
          if (graphics.didViewUpdate) {
            this._rebuild(graphics);
          }
          if (gpuContext.isBatchable) {
            this._addToBatcher(graphics, instructionSet);
          } else {
            this.renderer.renderPipes.batch.break(instructionSet);
            instructionSet.add(graphics);
          }
        }
        updateRenderable(graphics) {
          const batches = this._graphicsBatchesHash[graphics.uid];
          if (batches) {
            for (let i2 = 0; i2 < batches.length; i2++) {
              const batch = batches[i2];
              batch._batcher.updateElement(batch);
            }
          }
        }
        destroyRenderable(graphics) {
          if (this._graphicsBatchesHash[graphics.uid]) {
            this._removeBatchForRenderable(graphics.uid);
          }
          graphics.off("destroyed", this._destroyRenderableBound);
        }
        execute(graphics) {
          if (!graphics.isRenderable)
            return;
          const renderer = this.renderer;
          const context3 = graphics.context;
          const contextSystem = renderer.graphicsContext;
          if (!contextSystem.getGpuContext(context3).batches.length) {
            return;
          }
          const shader = context3.customShader || this._adaptor.shader;
          this.state.blendMode = graphics.groupBlendMode;
          const localUniforms = shader.resources.localUniforms.uniforms;
          localUniforms.uTransformMatrix = graphics.groupTransform;
          localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;
          color32BitToUniform(
            graphics.groupColorAlpha,
            localUniforms.uColor,
            0
          );
          this._adaptor.execute(this, graphics);
        }
        _rebuild(graphics) {
          const wasBatched = !!this._graphicsBatchesHash[graphics.uid];
          const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
          if (wasBatched) {
            this._removeBatchForRenderable(graphics.uid);
          }
          if (gpuContext.isBatchable) {
            this._initBatchesForRenderable(graphics);
          }
          graphics.batched = gpuContext.isBatchable;
        }
        _addToBatcher(graphics, instructionSet) {
          const batchPipe = this.renderer.renderPipes.batch;
          const batches = this._getBatchesForRenderable(graphics);
          for (let i2 = 0; i2 < batches.length; i2++) {
            const batch = batches[i2];
            batchPipe.addToBatch(batch, instructionSet);
          }
        }
        _getBatchesForRenderable(graphics) {
          return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);
        }
        _initBatchesForRenderable(graphics) {
          const context3 = graphics.context;
          const gpuContext = this.renderer.graphicsContext.getGpuContext(context3);
          const roundPixels = this.renderer._roundPixels | graphics._roundPixels;
          const batches = gpuContext.batches.map((batch) => {
            const batchClone = BigPool.get(BatchableGraphics);
            batch.copyTo(batchClone);
            batchClone.renderable = graphics;
            batchClone.roundPixels = roundPixels;
            return batchClone;
          });
          if (this._graphicsBatchesHash[graphics.uid] === void 0) {
            graphics.on("destroyed", this._destroyRenderableBound);
          }
          this._graphicsBatchesHash[graphics.uid] = batches;
          return batches;
        }
        _removeBatchForRenderable(graphicsUid) {
          this._graphicsBatchesHash[graphicsUid].forEach((batch) => {
            BigPool.return(batch);
          });
          this._graphicsBatchesHash[graphicsUid] = null;
        }
        destroy() {
          this.renderer = null;
          this._adaptor.destroy();
          this._adaptor = null;
          this.state = null;
          for (const i2 in this._graphicsBatchesHash) {
            this._removeBatchForRenderable(i2);
          }
          this._graphicsBatchesHash = null;
        }
      };
      GraphicsPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "graphics"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/init.mjs
  var init_init6 = __esm({
    "node_modules/pixi.js/lib/scene/graphics/init.mjs"() {
      init_Extensions();
      init_GraphicsContextSystem();
      init_GraphicsPipe();
      extensions.add(GraphicsPipe);
      extensions.add(GraphicsContextSystem);
    }
  });

  // node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs
  var BatchableMesh;
  var init_BatchableMesh = __esm({
    "node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs"() {
      "use strict";
      BatchableMesh = class {
        constructor() {
          this.batcherName = "default";
          this.packAsQuad = false;
          this.indexOffset = 0;
          this.attributeOffset = 0;
          this.roundPixels = 0;
          this._batcher = null;
          this._batch = null;
          this._uvUpdateId = -1;
          this._textureMatrixUpdateId = -1;
        }
        get blendMode() {
          return this.renderable.groupBlendMode;
        }
        reset() {
          this.renderable = null;
          this.texture = null;
          this._batcher = null;
          this._batch = null;
          this.geometry = null;
          this._uvUpdateId = -1;
          this._textureMatrixUpdateId = -1;
        }
        get uvs() {
          const geometry = this.geometry;
          const uvBuffer = geometry.getBuffer("aUV");
          const uvs = uvBuffer.data;
          let transformedUvs = uvs;
          const textureMatrix = this.texture.textureMatrix;
          if (!textureMatrix.isSimple) {
            transformedUvs = this._transformedUvs;
            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {
              if (!transformedUvs || transformedUvs.length < uvs.length) {
                transformedUvs = this._transformedUvs = new Float32Array(uvs.length);
              }
              this._textureMatrixUpdateId = textureMatrix._updateID;
              this._uvUpdateId = uvBuffer._updateID;
              textureMatrix.multiplyUvs(uvs, transformedUvs);
            }
          }
          return transformedUvs;
        }
        get positions() {
          return this.geometry.positions;
        }
        get indices() {
          return this.geometry.indices;
        }
        get color() {
          return this.renderable.groupColorAlpha;
        }
        get groupTransform() {
          return this.renderable.groupTransform;
        }
        get attributeSize() {
          return this.geometry.positions.length / 2;
        }
        get indexSize() {
          return this.geometry.indices.length;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs
  var MeshPipe;
  var init_MeshPipe = __esm({
    "node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs"() {
      init_Extensions();
      init_Matrix();
      init_BindGroup();
      init_UniformGroup();
      init_getAdjustedBlendModeBlend();
      init_PoolGroup();
      init_colorToUniform();
      init_BatchableMesh();
      MeshPipe = class {
        constructor(renderer, adaptor) {
          this.localUniforms = new UniformGroup({
            uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uRound: { value: 0, type: "f32" }
          });
          this.localUniformsBindGroup = new BindGroup({
            0: this.localUniforms
          });
          this._meshDataHash = /* @__PURE__ */ Object.create(null);
          this._gpuBatchableMeshHash = /* @__PURE__ */ Object.create(null);
          this._destroyRenderableBound = this.destroyRenderable.bind(this);
          this.renderer = renderer;
          this._adaptor = adaptor;
          this._adaptor.init();
          renderer.renderableGC.addManagedHash(this, "_gpuBatchableMeshHash");
          renderer.renderableGC.addManagedHash(this, "_meshDataHash");
        }
        validateRenderable(mesh) {
          const meshData = this._getMeshData(mesh);
          const wasBatched = meshData.batched;
          const isBatched = mesh.batched;
          meshData.batched = isBatched;
          if (wasBatched !== isBatched) {
            return true;
          } else if (isBatched) {
            const geometry = mesh._geometry;
            if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {
              meshData.indexSize = geometry.indices.length;
              meshData.vertexSize = geometry.positions.length;
              return true;
            }
            const batchableMesh = this._getBatchableMesh(mesh);
            const texture = mesh.texture;
            if (batchableMesh.texture._source !== texture._source) {
              if (batchableMesh.texture._source !== texture._source) {
                return !batchableMesh._batcher.checkAndUpdateTexture(batchableMesh, texture);
              }
            }
          }
          return false;
        }
        addRenderable(mesh, instructionSet) {
          const batcher = this.renderer.renderPipes.batch;
          const { batched } = this._getMeshData(mesh);
          if (batched) {
            const gpuBatchableMesh = this._getBatchableMesh(mesh);
            gpuBatchableMesh.texture = mesh._texture;
            gpuBatchableMesh.geometry = mesh._geometry;
            batcher.addToBatch(gpuBatchableMesh, instructionSet);
          } else {
            batcher.break(instructionSet);
            instructionSet.add(mesh);
          }
        }
        updateRenderable(mesh) {
          if (mesh.batched) {
            const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];
            gpuBatchableMesh.texture = mesh._texture;
            gpuBatchableMesh.geometry = mesh._geometry;
            gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);
          }
        }
        destroyRenderable(mesh) {
          this._meshDataHash[mesh.uid] = null;
          const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];
          if (gpuMesh) {
            BigPool.return(gpuMesh);
            this._gpuBatchableMeshHash[mesh.uid] = null;
          }
          mesh.off("destroyed", this._destroyRenderableBound);
        }
        execute(mesh) {
          if (!mesh.isRenderable)
            return;
          mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);
          const localUniforms = this.localUniforms;
          localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;
          localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;
          localUniforms.update();
          color32BitToUniform(
            mesh.groupColorAlpha,
            localUniforms.uniforms.uColor,
            0
          );
          this._adaptor.execute(this, mesh);
        }
        _getMeshData(mesh) {
          return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);
        }
        _initMeshData(mesh) {
          this._meshDataHash[mesh.uid] = {
            batched: mesh.batched,
            indexSize: mesh._geometry.indices?.length,
            vertexSize: mesh._geometry.positions?.length
          };
          mesh.on("destroyed", this._destroyRenderableBound);
          return this._meshDataHash[mesh.uid];
        }
        _getBatchableMesh(mesh) {
          return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);
        }
        _initBatchableMesh(mesh) {
          const gpuMesh = BigPool.get(BatchableMesh);
          gpuMesh.renderable = mesh;
          gpuMesh.texture = mesh._texture;
          gpuMesh.transform = mesh.groupTransform;
          gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;
          this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;
          return gpuMesh;
        }
        destroy() {
          for (const i2 in this._gpuBatchableMeshHash) {
            if (this._gpuBatchableMeshHash[i2]) {
              BigPool.return(this._gpuBatchableMeshHash[i2]);
            }
          }
          this._gpuBatchableMeshHash = null;
          this._meshDataHash = null;
          this.localUniforms = null;
          this.localUniformsBindGroup = null;
          this._adaptor.destroy();
          this._adaptor = null;
          this.renderer = null;
        }
      };
      MeshPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "mesh"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/mesh/init.mjs
  var init_init7 = __esm({
    "node_modules/pixi.js/lib/scene/mesh/init.mjs"() {
      init_Extensions();
      init_MeshPipe();
      extensions.add(MeshPipe);
    }
  });

  // node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.mjs
  var GlParticleContainerAdaptor;
  var init_GlParticleContainerAdaptor = __esm({
    "node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.mjs"() {
      "use strict";
      GlParticleContainerAdaptor = class {
        execute(particleContainerPop, container) {
          const state4 = particleContainerPop.state;
          const renderer = particleContainerPop.renderer;
          const shader = container.shader || particleContainerPop.defaultShader;
          shader.resources.uTexture = container.texture._source;
          shader.resources.uniforms = particleContainerPop.localUniforms;
          const gl = renderer.gl;
          const buffer = particleContainerPop.getBuffers(container);
          renderer.shader.bind(shader);
          renderer.state.set(state4);
          renderer.geometry.bind(buffer.geometry, shader.glProgram);
          const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;
          const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
          gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.mjs
  function createIndicesForQuads(size5, outBuffer = null) {
    const totalIndices = size5 * 6;
    if (totalIndices > 65535) {
      outBuffer = outBuffer || new Uint32Array(totalIndices);
    } else {
      outBuffer = outBuffer || new Uint16Array(totalIndices);
    }
    if (outBuffer.length !== totalIndices) {
      throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);
    }
    for (let i2 = 0, j2 = 0; i2 < totalIndices; i2 += 6, j2 += 4) {
      outBuffer[i2 + 0] = j2 + 0;
      outBuffer[i2 + 1] = j2 + 1;
      outBuffer[i2 + 2] = j2 + 2;
      outBuffer[i2 + 3] = j2 + 0;
      outBuffer[i2 + 4] = j2 + 2;
      outBuffer[i2 + 5] = j2 + 3;
    }
    return outBuffer;
  }
  var init_createIndicesForQuads = __esm({
    "node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs
  function generateParticleUpdateFunction(properties) {
    return {
      dynamicUpdate: generateUpdateFunction(properties, true),
      staticUpdate: generateUpdateFunction(properties, false)
    };
  }
  function generateUpdateFunction(properties, dynamic) {
    const funcFragments = [];
    funcFragments.push(`
      
        var index = 0;

        for (let i = 0; i < ps.length; ++i)
        {
            const p = ps[i];

            `);
    let offset = 0;
    for (const i2 in properties) {
      const property = properties[i2];
      if (dynamic !== property.dynamic)
        continue;
      funcFragments.push(`offset = index + ${offset}`);
      funcFragments.push(property.code);
      const attributeInfo = getAttributeInfoFromFormat(property.format);
      offset += attributeInfo.stride / 4;
    }
    funcFragments.push(`
            index += stride * 4;
        }
    `);
    funcFragments.unshift(`
        var stride = ${offset};
    `);
    const functionSource = funcFragments.join("\n");
    return new Function("ps", "f32v", "u32v", functionSource);
  }
  var init_generateParticleUpdateFunction = __esm({
    "node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs"() {
      init_getAttributeInfoFromFormat();
    }
  });

  // node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.mjs
  function getParticleSyncKey(properties) {
    const keyGen = [];
    for (const key in properties) {
      const property = properties[key];
      keyGen.push(key, property.code, property.dynamic ? "d" : "s");
    }
    return keyGen.join("_");
  }
  var ParticleBuffer;
  var init_ParticleBuffer = __esm({
    "node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.mjs"() {
      init_Buffer();
      init_const4();
      init_Geometry();
      init_getAttributeInfoFromFormat();
      init_ViewableBuffer();
      init_createIndicesForQuads();
      init_generateParticleUpdateFunction();
      ParticleBuffer = class {
        constructor(options2) {
          this._size = 0;
          this._generateParticleUpdateCache = {};
          const size5 = this._size = options2.size ?? 1e3;
          const properties = options2.properties;
          let staticVertexSize = 0;
          let dynamicVertexSize = 0;
          for (const i2 in properties) {
            const property = properties[i2];
            const attributeInfo = getAttributeInfoFromFormat(property.format);
            if (property.dynamic) {
              dynamicVertexSize += attributeInfo.stride;
            } else {
              staticVertexSize += attributeInfo.stride;
            }
          }
          this._dynamicStride = dynamicVertexSize / 4;
          this._staticStride = staticVertexSize / 4;
          this.staticAttributeBuffer = new ViewableBuffer(size5 * 4 * staticVertexSize);
          this.dynamicAttributeBuffer = new ViewableBuffer(size5 * 4 * dynamicVertexSize);
          this.indexBuffer = createIndicesForQuads(size5);
          const geometry = new Geometry();
          let dynamicOffset = 0;
          let staticOffset = 0;
          this._staticBuffer = new Buffer2({
            data: new Float32Array(1),
            label: "static-particle-buffer",
            shrinkToFit: false,
            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
          });
          this._dynamicBuffer = new Buffer2({
            data: new Float32Array(1),
            label: "dynamic-particle-buffer",
            shrinkToFit: false,
            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
          });
          for (const i2 in properties) {
            const property = properties[i2];
            const attributeInfo = getAttributeInfoFromFormat(property.format);
            if (property.dynamic) {
              geometry.addAttribute(property.attributeName, {
                buffer: this._dynamicBuffer,
                stride: this._dynamicStride * 4,
                offset: dynamicOffset * 4,
                format: property.format
              });
              dynamicOffset += attributeInfo.size;
            } else {
              geometry.addAttribute(property.attributeName, {
                buffer: this._staticBuffer,
                stride: this._staticStride * 4,
                offset: staticOffset * 4,
                format: property.format
              });
              staticOffset += attributeInfo.size;
            }
          }
          geometry.addIndex(this.indexBuffer);
          const uploadFunction = this.getParticleUpdate(properties);
          this._dynamicUpload = uploadFunction.dynamicUpdate;
          this._staticUpload = uploadFunction.staticUpdate;
          this.geometry = geometry;
        }
        getParticleUpdate(properties) {
          const key = getParticleSyncKey(properties);
          if (this._generateParticleUpdateCache[key]) {
            return this._generateParticleUpdateCache[key];
          }
          this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);
          return this._generateParticleUpdateCache[key];
        }
        generateParticleUpdate(properties) {
          return generateParticleUpdateFunction(properties);
        }
        update(particles, uploadStatic) {
          if (particles.length > this._size) {
            uploadStatic = true;
            this._size = Math.max(particles.length, this._size * 1.5 | 0);
            this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);
            this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);
            this.indexBuffer = createIndicesForQuads(this._size);
            this.geometry.indexBuffer.setDataWithSize(
              this.indexBuffer,
              this.indexBuffer.byteLength,
              true
            );
          }
          const dynamicAttributeBuffer = this.dynamicAttributeBuffer;
          this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);
          this._dynamicBuffer.setDataWithSize(
            this.dynamicAttributeBuffer.float32View,
            particles.length * this._dynamicStride * 4,
            true
          );
          if (uploadStatic) {
            const staticAttributeBuffer = this.staticAttributeBuffer;
            this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);
            this._staticBuffer.setDataWithSize(
              staticAttributeBuffer.float32View,
              particles.length * this._staticStride * 4,
              true
            );
          }
        }
        destroy() {
          this._staticBuffer.destroy();
          this._dynamicBuffer.destroy();
          this.geometry.destroy();
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.mjs
  var fragment;
  var init_particles_frag = __esm({
    "node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.mjs"() {
      fragment = "varying vec2 vUV;\nvarying vec4 vColor;\n\nuniform sampler2D uTexture;\n\nvoid main(void){\n    vec4 color = texture2D(uTexture, vUV) * vColor;\n    gl_FragColor = color;\n}";
    }
  });

  // node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.mjs
  var vertex;
  var init_particles_vert = __esm({
    "node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.mjs"() {
      vertex = "attribute vec2 aVertex;\nattribute vec2 aUV;\nattribute vec4 aColor;\n\nattribute vec2 aPosition;\nattribute float aRotation;\n\nuniform mat3 uTranslationMatrix;\nuniform float uRound;\nuniform vec2 uResolution;\nuniform vec4 uColor;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\n\nvec2 roundPixels(vec2 position, vec2 targetSize)\n{       \n    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\nvoid main(void){\n    float cosRotation = cos(aRotation);\n    float sinRotation = sin(aRotation);\n    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;\n    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;\n\n    vec2 v = vec2(x, y);\n    v = v + aPosition;\n\n    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    if(uRound == 1.0)\n    {\n        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n    }\n\n    vUV = aUV;\n    vColor = aColor * uColor;\n}\n";
    }
  });

  // node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.mjs
  var wgsl;
  var init_particles_wgsl = __esm({
    "node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.mjs"() {
      wgsl = "\nstruct ParticleUniforms {\n  uProjectionMatrix:mat3x3<f32>,\n  uResolution:vec2<f32>,\n  uRoundPixels:f32,\n};\n\n@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;\n\n@group(1) @binding(0) var uTexture: texture_2d<f32>;\n@group(1) @binding(1) var uSampler : sampler;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) color : vec4<f32>,\n  };\n@vertex\nfn mainVertex(\n  @location(0) aVertex: vec2<f32>,\n  @location(1) aPosition: vec2<f32>,\n  @location(2) aUV: vec2<f32>,\n  @location(3) aColor: vec4<f32>,\n  @location(4) aRotation: f32,\n) -> VSOutput {\n  \n   let v = vec2(\n       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),\n       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)\n   ) + aPosition;\n\n   let position = vec4((uniforms.uProjectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n  return VSOutput(\n   position,\n   aUV,\n   aColor,\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) color: vec4<f32>,\n  @builtin(position) position: vec4<f32>,\n) -> @location(0) vec4<f32> {\n\n    var sample = textureSample(uTexture, uSampler, uv) * color;\n   \n    return sample;\n}";
    }
  });

  // node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.mjs
  var ParticleShader;
  var init_ParticleShader = __esm({
    "node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.mjs"() {
      init_Color();
      init_Matrix();
      init_GlProgram();
      init_GpuProgram();
      init_Shader();
      init_Texture();
      init_TextureStyle();
      init_particles_frag();
      init_particles_vert();
      init_particles_wgsl();
      ParticleShader = class extends Shader {
        constructor() {
          const glProgram3 = GlProgram.from({
            vertex,
            fragment
          });
          const gpuProgram3 = GpuProgram.from({
            fragment: {
              source: wgsl,
              entryPoint: "mainFragment"
            },
            vertex: {
              source: wgsl,
              entryPoint: "mainVertex"
            }
          });
          super({
            glProgram: glProgram3,
            gpuProgram: gpuProgram3,
            resources: {
              // this will be replaced with the texture from the particle container
              uTexture: Texture.WHITE.source,
              // this will be replaced with the texture style from the particle container
              uSampler: new TextureStyle({}),
              // this will be replaced with the local uniforms from the particle container
              uniforms: {
                uTranslationMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
                uColor: { value: new Color(16777215), type: "vec4<f32>" },
                uRound: { value: 1, type: "f32" },
                uResolution: { value: [0, 0], type: "vec2<f32>" }
              }
            }
          });
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.mjs
  var ParticleContainerPipe;
  var init_ParticleContainerPipe = __esm({
    "node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.mjs"() {
      init_Matrix();
      init_UniformGroup();
      init_getAdjustedBlendModeBlend();
      init_State();
      init_colorToUniform();
      init_ParticleBuffer();
      init_ParticleShader();
      ParticleContainerPipe = class {
        /**
         * @param renderer - The renderer this sprite batch works for.
         * @param adaptor
         */
        constructor(renderer, adaptor) {
          this.state = State.for2d();
          this._gpuBufferHash = /* @__PURE__ */ Object.create(null);
          this._destroyRenderableBound = this.destroyRenderable.bind(this);
          this.localUniforms = new UniformGroup({
            uTranslationMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uColor: { value: new Float32Array(4), type: "vec4<f32>" },
            uRound: { value: 1, type: "f32" },
            uResolution: { value: [0, 0], type: "vec2<f32>" }
          });
          this.renderer = renderer;
          this.adaptor = adaptor;
          this.defaultShader = new ParticleShader();
          this.state = State.for2d();
        }
        validateRenderable(_renderable) {
          return false;
        }
        addRenderable(renderable, instructionSet) {
          this.renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add(renderable);
        }
        getBuffers(renderable) {
          return this._gpuBufferHash[renderable.uid] || this._initBuffer(renderable);
        }
        _initBuffer(renderable) {
          this._gpuBufferHash[renderable.uid] = new ParticleBuffer({
            size: renderable.particleChildren.length,
            properties: renderable._properties
          });
          renderable.on("destroyed", this._destroyRenderableBound);
          return this._gpuBufferHash[renderable.uid];
        }
        updateRenderable(_renderable) {
        }
        destroyRenderable(renderable) {
          const buffer = this._gpuBufferHash[renderable.uid];
          buffer.destroy();
          this._gpuBufferHash[renderable.uid] = null;
          renderable.off("destroyed", this._destroyRenderableBound);
        }
        execute(container) {
          const children2 = container.particleChildren;
          if (children2.length === 0) {
            return;
          }
          const renderer = this.renderer;
          const buffer = this.getBuffers(container);
          container.texture || (container.texture = children2[0].texture);
          const state4 = this.state;
          buffer.update(children2, container._childrenDirty);
          container._childrenDirty = false;
          state4.blendMode = getAdjustedBlendModeBlend(container.blendMode, container.texture._source);
          const uniforms = this.localUniforms.uniforms;
          const transformationMatrix = uniforms.uTranslationMatrix;
          container.worldTransform.copyTo(transformationMatrix);
          transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);
          uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;
          uniforms.uRound = renderer._roundPixels | container._roundPixels;
          color32BitToUniform(
            container.groupColorAlpha,
            uniforms.uColor,
            0
          );
          this.adaptor.execute(this, container);
        }
        /** Destroys the ParticleRenderer. */
        destroy() {
          if (this.defaultShader) {
            this.defaultShader.destroy();
            this.defaultShader = null;
          }
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.mjs
  var GlParticleContainerPipe;
  var init_GlParticleContainerPipe = __esm({
    "node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.mjs"() {
      init_Extensions();
      init_GlParticleContainerAdaptor();
      init_ParticleContainerPipe();
      GlParticleContainerPipe = class extends ParticleContainerPipe {
        constructor(renderer) {
          super(renderer, new GlParticleContainerAdaptor());
        }
      };
      GlParticleContainerPipe.extension = {
        type: [
          ExtensionType.WebGLPipes
        ],
        name: "particle"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs
  var GpuParticleContainerAdaptor;
  var init_GpuParticleContainerAdaptor = __esm({
    "node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs"() {
      "use strict";
      GpuParticleContainerAdaptor = class {
        execute(particleContainerPop, container) {
          const renderer = particleContainerPop.renderer;
          const shader = container.shader || particleContainerPop.defaultShader;
          shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPop.localUniforms, true);
          shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);
          const state4 = particleContainerPop.state;
          const buffer = particleContainerPop.getBuffers(container);
          renderer.encoder.draw({
            geometry: buffer.geometry,
            shader: container.shader || particleContainerPop.defaultShader,
            state: state4,
            size: container.particleChildren.length * 6
          });
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.mjs
  var GpuParticleContainerPipe;
  var init_GpuParticleContainerPipe = __esm({
    "node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.mjs"() {
      init_Extensions();
      init_GpuParticleContainerAdaptor();
      init_ParticleContainerPipe();
      GpuParticleContainerPipe = class extends ParticleContainerPipe {
        constructor(renderer) {
          super(renderer, new GpuParticleContainerAdaptor());
        }
      };
      GpuParticleContainerPipe.extension = {
        type: [
          ExtensionType.WebGPUPipes
        ],
        name: "particle"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/particle-container/init.mjs
  var init_init8 = __esm({
    "node_modules/pixi.js/lib/scene/particle-container/init.mjs"() {
      init_Extensions();
      init_GlParticleContainerPipe();
      init_GpuParticleContainerPipe();
      extensions.add(GlParticleContainerPipe);
      extensions.add(GpuParticleContainerPipe);
    }
  });

  // node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs
  var BatchableSprite;
  var init_BatchableSprite = __esm({
    "node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs"() {
      "use strict";
      BatchableSprite = class {
        constructor() {
          this.batcherName = "default";
          this.attributeSize = 4;
          this.indexSize = 6;
          this.packAsQuad = true;
          this.roundPixels = 0;
          this._attributeStart = 0;
          this._batcher = null;
          this._batch = null;
        }
        get blendMode() {
          return this.renderable.groupBlendMode;
        }
        get color() {
          return this.renderable.groupColorAlpha;
        }
        reset() {
          this.renderable = null;
          this.texture = null;
          this._batcher = null;
          this._batch = null;
          this.bounds = null;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs
  var CanvasTextPipe;
  var init_CanvasTextPipe = __esm({
    "node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs"() {
      init_Extensions();
      init_updateQuadBounds();
      init_PoolGroup();
      init_BatchableSprite();
      CanvasTextPipe = class {
        constructor(renderer) {
          this._gpuText = /* @__PURE__ */ Object.create(null);
          this._destroyRenderableBound = this.destroyRenderable.bind(this);
          this._renderer = renderer;
          this._renderer.runners.resolutionChange.add(this);
          this._renderer.renderableGC.addManagedHash(this, "_gpuText");
        }
        resolutionChange() {
          for (const i2 in this._gpuText) {
            const gpuText = this._gpuText[i2];
            if (!gpuText)
              continue;
            const text6 = gpuText.batchableSprite.renderable;
            if (text6._autoResolution) {
              text6._resolution = this._renderer.resolution;
              text6.onViewUpdate();
            }
          }
        }
        validateRenderable(text6) {
          const gpuText = this._getGpuText(text6);
          const newKey = text6._getKey();
          if (gpuText.currentKey !== newKey) {
            return true;
          }
          return false;
        }
        addRenderable(text6, instructionSet) {
          const gpuText = this._getGpuText(text6);
          const batchableSprite = gpuText.batchableSprite;
          if (text6._didTextUpdate) {
            this._updateText(text6);
          }
          this._renderer.renderPipes.batch.addToBatch(batchableSprite, instructionSet);
        }
        updateRenderable(text6) {
          const gpuText = this._getGpuText(text6);
          const batchableSprite = gpuText.batchableSprite;
          if (text6._didTextUpdate) {
            this._updateText(text6);
          }
          batchableSprite._batcher.updateElement(batchableSprite);
        }
        destroyRenderable(text6) {
          text6.off("destroyed", this._destroyRenderableBound);
          this._destroyRenderableById(text6.uid);
        }
        _destroyRenderableById(textUid) {
          const gpuText = this._gpuText[textUid];
          this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);
          BigPool.return(gpuText.batchableSprite);
          this._gpuText[textUid] = null;
        }
        _updateText(text6) {
          const newKey = text6._getKey();
          const gpuText = this._getGpuText(text6);
          const batchableSprite = gpuText.batchableSprite;
          if (gpuText.currentKey !== newKey) {
            this._updateGpuText(text6);
          }
          text6._didTextUpdate = false;
          const padding = text6._style.padding;
          updateQuadBounds(batchableSprite.bounds, text6._anchor, batchableSprite.texture, padding);
        }
        _updateGpuText(text6) {
          const gpuText = this._getGpuText(text6);
          const batchableSprite = gpuText.batchableSprite;
          if (gpuText.texture) {
            this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);
          }
          gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getManagedTexture(text6);
          gpuText.currentKey = text6._getKey();
          batchableSprite.texture = gpuText.texture;
        }
        _getGpuText(text6) {
          return this._gpuText[text6.uid] || this.initGpuText(text6);
        }
        initGpuText(text6) {
          const gpuTextData = {
            texture: null,
            currentKey: "--",
            batchableSprite: BigPool.get(BatchableSprite)
          };
          gpuTextData.batchableSprite.renderable = text6;
          gpuTextData.batchableSprite.transform = text6.groupTransform;
          gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
          gpuTextData.batchableSprite.roundPixels = this._renderer._roundPixels | text6._roundPixels;
          this._gpuText[text6.uid] = gpuTextData;
          text6._resolution = text6._autoResolution ? this._renderer.resolution : text6.resolution;
          this._updateText(text6);
          text6.on("destroyed", this._destroyRenderableBound);
          return gpuTextData;
        }
        destroy() {
          for (const i2 in this._gpuText) {
            this._destroyRenderableById(i2);
          }
          this._gpuText = null;
          this._renderer = null;
        }
      };
      CanvasTextPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "text"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs
  var CanvasPoolClass, CanvasPool;
  var init_CanvasPool = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs"() {
      init_adapter();
      init_pow2();
      CanvasPoolClass = class {
        constructor(canvasOptions) {
          this._canvasPool = /* @__PURE__ */ Object.create(null);
          this.canvasOptions = canvasOptions || {};
          this.enableFullScreen = false;
        }
        /**
         * Creates texture with params that were specified in pool constructor.
         * @param pixelWidth - Width of texture in pixels.
         * @param pixelHeight - Height of texture in pixels.
         */
        _createCanvasAndContext(pixelWidth, pixelHeight) {
          const canvas2 = DOMAdapter.get().createCanvas();
          canvas2.width = pixelWidth;
          canvas2.height = pixelHeight;
          const context3 = canvas2.getContext("2d");
          return { canvas: canvas2, context: context3 };
        }
        /**
         * Gets a Power-of-Two render texture or fullScreen texture
         * @param minWidth - The minimum width of the render texture.
         * @param minHeight - The minimum height of the render texture.
         * @param resolution - The resolution of the render texture.
         * @returns The new render texture.
         */
        getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {
          minWidth = Math.ceil(minWidth * resolution - 1e-6);
          minHeight = Math.ceil(minHeight * resolution - 1e-6);
          minWidth = nextPow2(minWidth);
          minHeight = nextPow2(minHeight);
          const key = (minWidth << 17) + (minHeight << 1);
          if (!this._canvasPool[key]) {
            this._canvasPool[key] = [];
          }
          let canvasAndContext = this._canvasPool[key].pop();
          if (!canvasAndContext) {
            canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);
          }
          return canvasAndContext;
        }
        /**
         * Place a render texture back into the pool.
         * @param canvasAndContext
         */
        returnCanvasAndContext(canvasAndContext) {
          const canvas2 = canvasAndContext.canvas;
          const { width: width8, height: height8 } = canvas2;
          const key = (width8 << 17) + (height8 << 1);
          canvasAndContext.context.clearRect(0, 0, width8, height8);
          this._canvasPool[key].push(canvasAndContext);
        }
        clear() {
          this._canvasPool = {};
        }
      };
      CanvasPool = new CanvasPoolClass();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs
  var count, TexturePoolClass, TexturePool;
  var init_TexturePool = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs"() {
      init_pow2();
      init_TextureSource();
      init_Texture();
      count = 0;
      TexturePoolClass = class {
        /**
         * @param textureOptions - options that will be passed to BaseRenderTexture constructor
         * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.
         */
        constructor(textureOptions) {
          this._poolKeyHash = /* @__PURE__ */ Object.create(null);
          this._texturePool = {};
          this.textureOptions = textureOptions || {};
          this.enableFullScreen = false;
        }
        /**
         * Creates texture with params that were specified in pool constructor.
         * @param pixelWidth - Width of texture in pixels.
         * @param pixelHeight - Height of texture in pixels.
         * @param antialias
         */
        createTexture(pixelWidth, pixelHeight, antialias) {
          const textureSource = new TextureSource({
            ...this.textureOptions,
            width: pixelWidth,
            height: pixelHeight,
            resolution: 1,
            antialias,
            autoGarbageCollect: true
          });
          return new Texture({
            source: textureSource,
            label: `texturePool_${count++}`
          });
        }
        /**
         * Gets a Power-of-Two render texture or fullScreen texture
         * @param frameWidth - The minimum width of the render texture.
         * @param frameHeight - The minimum height of the render texture.
         * @param resolution - The resolution of the render texture.
         * @param antialias
         * @returns The new render texture.
         */
        getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {
          let po2Width = Math.ceil(frameWidth * resolution - 1e-6);
          let po2Height = Math.ceil(frameHeight * resolution - 1e-6);
          po2Width = nextPow2(po2Width);
          po2Height = nextPow2(po2Height);
          const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);
          if (!this._texturePool[key]) {
            this._texturePool[key] = [];
          }
          let texture = this._texturePool[key].pop();
          if (!texture) {
            texture = this.createTexture(po2Width, po2Height, antialias);
          }
          texture.source._resolution = resolution;
          texture.source.width = po2Width / resolution;
          texture.source.height = po2Height / resolution;
          texture.source.pixelWidth = po2Width;
          texture.source.pixelHeight = po2Height;
          texture.frame.x = 0;
          texture.frame.y = 0;
          texture.frame.width = frameWidth;
          texture.frame.height = frameHeight;
          texture.updateUvs();
          this._poolKeyHash[texture.uid] = key;
          return texture;
        }
        /**
         * Gets extra texture of the same size as input renderTexture
         * @param texture - The texture to check what size it is.
         * @param antialias - Whether to use antialias.
         * @returns A texture that is a power of two
         */
        getSameSizeTexture(texture, antialias = false) {
          const source3 = texture.source;
          return this.getOptimalTexture(texture.width, texture.height, source3._resolution, antialias);
        }
        /**
         * Place a render texture back into the pool.
         * @param renderTexture - The renderTexture to free
         */
        returnTexture(renderTexture) {
          const key = this._poolKeyHash[renderTexture.uid];
          this._texturePool[key].push(renderTexture);
        }
        /**
         * Clears the pool.
         * @param destroyTextures - Destroy all stored textures.
         */
        clear(destroyTextures) {
          destroyTextures = destroyTextures !== false;
          if (destroyTextures) {
            for (const i2 in this._texturePool) {
              const textures = this._texturePool[i2];
              if (textures) {
                for (let j2 = 0; j2 < textures.length; j2++) {
                  textures[j2].destroy(true);
                }
              }
            }
          }
          this._texturePool = {};
        }
      };
      TexturePool = new TexturePoolClass();
    }
  });

  // node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs
  function checkRow(data, width8, y2) {
    for (let x2 = 0, index6 = 4 * y2 * width8; x2 < width8; ++x2, index6 += 4) {
      if (data[index6 + 3] !== 0)
        return false;
    }
    return true;
  }
  function checkColumn(data, width8, x2, top4, bottom3) {
    const stride = 4 * width8;
    for (let y2 = top4, index6 = top4 * stride + 4 * x2; y2 <= bottom3; ++y2, index6 += stride) {
      if (data[index6 + 3] !== 0)
        return false;
    }
    return true;
  }
  function getCanvasBoundingBox(canvas2, resolution = 1) {
    const { width: width8, height: height8 } = canvas2;
    const context3 = canvas2.getContext("2d", {
      willReadFrequently: true
    });
    if (context3 === null) {
      throw new TypeError("Failed to get canvas 2D context");
    }
    const imageData = context3.getImageData(0, 0, width8, height8);
    const data = imageData.data;
    let left = 0;
    let top4 = 0;
    let right = width8 - 1;
    let bottom3 = height8 - 1;
    while (top4 < height8 && checkRow(data, width8, top4))
      ++top4;
    if (top4 === height8)
      return Rectangle.EMPTY;
    while (checkRow(data, width8, bottom3))
      --bottom3;
    while (checkColumn(data, width8, left, top4, bottom3))
      ++left;
    while (checkColumn(data, width8, right, top4, bottom3))
      --right;
    ++right;
    ++bottom3;
    return new Rectangle(left / resolution, top4 / resolution, (right - left) / resolution, (bottom3 - top4) / resolution);
  }
  var init_getCanvasBoundingBox = __esm({
    "node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs"() {
      init_Rectangle();
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs
  var _FillGradient, FillGradient;
  var init_FillGradient = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs"() {
      init_Color();
      init_adapter();
      init_Matrix();
      init_ImageSource();
      init_Texture();
      init_uid();
      _FillGradient = class _FillGradient2 {
        constructor(x0, y0, x1, y1) {
          this.uid = uid("fillGradient");
          this.type = "linear";
          this.gradientStops = [];
          this._styleKey = null;
          this.x0 = x0;
          this.y0 = y0;
          this.x1 = x1;
          this.y1 = y1;
        }
        addColorStop(offset, color) {
          this.gradientStops.push({ offset, color: Color.shared.setValue(color).toHexa() });
          this._styleKey = null;
          return this;
        }
        // TODO move to the system!
        buildLinearGradient() {
          const defaultSize = _FillGradient2.defaultTextureSize;
          const { gradientStops } = this;
          const canvas2 = DOMAdapter.get().createCanvas();
          canvas2.width = defaultSize;
          canvas2.height = defaultSize;
          const ctx = canvas2.getContext("2d");
          const gradient = ctx.createLinearGradient(0, 0, _FillGradient2.defaultTextureSize, 1);
          for (let i2 = 0; i2 < gradientStops.length; i2++) {
            const stop = gradientStops[i2];
            gradient.addColorStop(stop.offset, stop.color);
          }
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, defaultSize, defaultSize);
          this.texture = new Texture({
            source: new ImageSource({
              resource: canvas2,
              addressModeU: "clamp-to-edge",
              addressModeV: "repeat"
            })
          });
          const { x0, y0, x1, y1 } = this;
          const m2 = new Matrix();
          const dx = x1 - x0;
          const dy = y1 - y0;
          const dist2 = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx);
          m2.translate(-x0, -y0);
          m2.scale(1 / defaultSize, 1 / defaultSize);
          m2.rotate(-angle);
          m2.scale(256 / dist2, 1);
          this.transform = m2;
          this._styleKey = null;
        }
        get styleKey() {
          if (this._styleKey) {
            return this._styleKey;
          }
          const stops = this.gradientStops.map((stop) => `${stop.offset}-${stop.color}`).join("-");
          const texture = this.texture.uid;
          const transform2 = this.transform.toArray().join("-");
          return `fill-gradient-${this.uid}-${stops}-${texture}-${transform2}-${this.x0}-${this.y0}-${this.x1}-${this.y1}`;
        }
      };
      _FillGradient.defaultTextureSize = 256;
      FillGradient = _FillGradient;
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs
  var repetitionMap, FillPattern;
  var init_FillPattern = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs"() {
      init_Matrix();
      init_uid();
      repetitionMap = {
        repeat: {
          addressModeU: "repeat",
          addressModeV: "repeat"
        },
        "repeat-x": {
          addressModeU: "repeat",
          addressModeV: "clamp-to-edge"
        },
        "repeat-y": {
          addressModeU: "clamp-to-edge",
          addressModeV: "repeat"
        },
        "no-repeat": {
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        }
      };
      FillPattern = class {
        constructor(texture, repetition) {
          this.uid = uid("fillPattern");
          this.transform = new Matrix();
          this._styleKey = null;
          this.texture = texture;
          this.transform.scale(
            1 / texture.frame.width,
            1 / texture.frame.height
          );
          if (repetition) {
            texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;
            texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;
          }
        }
        setTransform(transform2) {
          const texture = this.texture;
          this.transform.copyFrom(transform2);
          this.transform.invert();
          this.transform.scale(
            1 / texture.frame.width,
            1 / texture.frame.height
          );
          this._styleKey = null;
        }
        get styleKey() {
          if (this._styleKey)
            return this._styleKey;
          this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`;
          return this._styleKey;
        }
      };
    }
  });

  // node_modules/parse-svg-path/index.js
  var require_parse_svg_path = __commonJS({
    "node_modules/parse-svg-path/index.js"(exports, module) {
      module.exports = parse9;
      var length9 = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
      var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
      function parse9(path2) {
        var data = [];
        path2.replace(segment, function(_, command2, args) {
          var type = command2.toLowerCase();
          args = parseValues(args);
          if (type == "m" && args.length > 2) {
            data.push([command2].concat(args.splice(0, 2)));
            type = "l";
            command2 = command2 == "m" ? "l" : "L";
          }
          while (true) {
            if (args.length == length9[type]) {
              args.unshift(command2);
              return data.push(args);
            }
            if (args.length < length9[type]) throw new Error("malformed path data");
            data.push([command2].concat(args.splice(0, length9[type])));
          }
        });
        return data;
      }
      var number2 = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
      function parseValues(args) {
        var numbers = args.match(number2);
        return numbers ? numbers.map(Number) : [];
      }
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs
  function SVGToGraphicsPath(svgPath, path2) {
    const commands = (0, import_parse_svg_path.default)(svgPath);
    const subpaths = [];
    let currentSubPath = null;
    let lastX = 0;
    let lastY = 0;
    for (let i2 = 0; i2 < commands.length; i2++) {
      const command2 = commands[i2];
      const type = command2[0];
      const data = command2;
      switch (type) {
        case "M":
          lastX = data[1];
          lastY = data[2];
          path2.moveTo(lastX, lastY);
          break;
        case "m":
          lastX += data[1];
          lastY += data[2];
          path2.moveTo(lastX, lastY);
          break;
        case "H":
          lastX = data[1];
          path2.lineTo(lastX, lastY);
          break;
        case "h":
          lastX += data[1];
          path2.lineTo(lastX, lastY);
          break;
        case "V":
          lastY = data[1];
          path2.lineTo(lastX, lastY);
          break;
        case "v":
          lastY += data[1];
          path2.lineTo(lastX, lastY);
          break;
        case "L":
          lastX = data[1];
          lastY = data[2];
          path2.lineTo(lastX, lastY);
          break;
        case "l":
          lastX += data[1];
          lastY += data[2];
          path2.lineTo(lastX, lastY);
          break;
        case "C":
          lastX = data[5];
          lastY = data[6];
          path2.bezierCurveTo(
            data[1],
            data[2],
            data[3],
            data[4],
            lastX,
            lastY
          );
          break;
        case "c":
          path2.bezierCurveTo(
            lastX + data[1],
            lastY + data[2],
            lastX + data[3],
            lastY + data[4],
            lastX + data[5],
            lastY + data[6]
          );
          lastX += data[5];
          lastY += data[6];
          break;
        case "S":
          lastX = data[3];
          lastY = data[4];
          path2.bezierCurveToShort(
            data[1],
            data[2],
            lastX,
            lastY
          );
          break;
        case "s":
          path2.bezierCurveToShort(
            lastX + data[1],
            lastY + data[2],
            lastX + data[3],
            lastY + data[4]
          );
          lastX += data[3];
          lastY += data[4];
          break;
        case "Q":
          lastX = data[3];
          lastY = data[4];
          path2.quadraticCurveTo(
            data[1],
            data[2],
            lastX,
            lastY
          );
          break;
        case "q":
          path2.quadraticCurveTo(
            lastX + data[1],
            lastY + data[2],
            lastX + data[3],
            lastY + data[4]
          );
          lastX += data[3];
          lastY += data[4];
          break;
        case "T":
          lastX = data[1];
          lastY = data[2];
          path2.quadraticCurveToShort(
            lastX,
            lastY
          );
          break;
        case "t":
          lastX += data[1];
          lastY += data[2];
          path2.quadraticCurveToShort(
            lastX,
            lastY
          );
          break;
        case "A":
          lastX = data[6];
          lastY = data[7];
          path2.arcToSvg(
            data[1],
            data[2],
            data[3],
            data[4],
            data[5],
            lastX,
            lastY
          );
          break;
        case "a":
          lastX += data[6];
          lastY += data[7];
          path2.arcToSvg(
            data[1],
            data[2],
            data[3],
            data[4],
            data[5],
            lastX,
            lastY
          );
          break;
        case "Z":
        case "z":
          path2.closePath();
          if (subpaths.length > 0) {
            currentSubPath = subpaths.pop();
            if (currentSubPath) {
              lastX = currentSubPath.startX;
              lastY = currentSubPath.startY;
            } else {
              lastX = 0;
              lastY = 0;
            }
          }
          currentSubPath = null;
          break;
        default:
          warn2(`Unknown SVG path command: ${type}`);
      }
      if (type !== "Z" && type !== "z") {
        if (currentSubPath === null) {
          currentSubPath = { startX: lastX, startY: lastY };
          subpaths.push(currentSubPath);
        }
      }
    }
    return path2;
  }
  var import_parse_svg_path;
  var init_SVGToGraphicsPath = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs"() {
      import_parse_svg_path = __toESM(require_parse_svg_path(), 1);
      init_warn();
    }
  });

  // node_modules/pixi.js/lib/maths/shapes/Circle.mjs
  var Circle;
  var init_Circle = __esm({
    "node_modules/pixi.js/lib/maths/shapes/Circle.mjs"() {
      init_Rectangle();
      Circle = class _Circle {
        /**
         * @param x - The X coordinate of the center of this circle
         * @param y - The Y coordinate of the center of this circle
         * @param radius - The radius of the circle
         */
        constructor(x2 = 0, y2 = 0, radius = 0) {
          this.type = "circle";
          this.x = x2;
          this.y = y2;
          this.radius = radius;
        }
        /**
         * Creates a clone of this Circle instance
         * @returns A copy of the Circle
         */
        clone() {
          return new _Circle(this.x, this.y, this.radius);
        }
        /**
         * Checks whether the x and y coordinates given are contained within this circle
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @returns Whether the x/y coordinates are within this Circle
         */
        contains(x2, y2) {
          if (this.radius <= 0)
            return false;
          const r2 = this.radius * this.radius;
          let dx = this.x - x2;
          let dy = this.y - y2;
          dx *= dx;
          dy *= dy;
          return dx + dy <= r2;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this circle including the stroke.
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @param width - The width of the line to check
         * @returns Whether the x/y coordinates are within this Circle
         */
        strokeContains(x2, y2, width8) {
          if (this.radius === 0)
            return false;
          const dx = this.x - x2;
          const dy = this.y - y2;
          const r2 = this.radius;
          const w2 = width8 / 2;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < r2 + w2 && distance > r2 - w2;
        }
        /**
         * Returns the framing rectangle of the circle as a Rectangle object
         * @param out
         * @returns The framing rectangle
         */
        getBounds(out2) {
          out2 = out2 || new Rectangle();
          out2.x = this.x - this.radius;
          out2.y = this.y - this.radius;
          out2.width = this.radius * 2;
          out2.height = this.radius * 2;
          return out2;
        }
        /**
         * Copies another circle to this one.
         * @param circle - The circle to copy from.
         * @returns Returns itself.
         */
        copyFrom(circle) {
          this.x = circle.x;
          this.y = circle.y;
          this.radius = circle.radius;
          return this;
        }
        /**
         * Copies this circle to another one.
         * @param circle - The circle to copy to.
         * @returns Returns given parameter.
         */
        copyTo(circle) {
          circle.copyFrom(this);
          return circle;
        }
        toString() {
          return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs
  var Ellipse;
  var init_Ellipse = __esm({
    "node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs"() {
      init_Rectangle();
      Ellipse = class _Ellipse {
        /**
         * @param x - The X coordinate of the center of this ellipse
         * @param y - The Y coordinate of the center of this ellipse
         * @param halfWidth - The half width of this ellipse
         * @param halfHeight - The half height of this ellipse
         */
        constructor(x2 = 0, y2 = 0, halfWidth = 0, halfHeight = 0) {
          this.type = "ellipse";
          this.x = x2;
          this.y = y2;
          this.halfWidth = halfWidth;
          this.halfHeight = halfHeight;
        }
        /**
         * Creates a clone of this Ellipse instance
         * @returns {Ellipse} A copy of the ellipse
         */
        clone() {
          return new _Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);
        }
        /**
         * Checks whether the x and y coordinates given are contained within this ellipse
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @returns Whether the x/y coords are within this ellipse
         */
        contains(x2, y2) {
          if (this.halfWidth <= 0 || this.halfHeight <= 0) {
            return false;
          }
          let normx = (x2 - this.x) / this.halfWidth;
          let normy = (y2 - this.y) / this.halfHeight;
          normx *= normx;
          normy *= normy;
          return normx + normy <= 1;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this ellipse including stroke
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @param width
         * @returns Whether the x/y coords are within this ellipse
         */
        strokeContains(x2, y2, width8) {
          const { halfWidth, halfHeight } = this;
          if (halfWidth <= 0 || halfHeight <= 0) {
            return false;
          }
          const halfStrokeWidth = width8 / 2;
          const innerA = halfWidth - halfStrokeWidth;
          const innerB = halfHeight - halfStrokeWidth;
          const outerA = halfWidth + halfStrokeWidth;
          const outerB = halfHeight + halfStrokeWidth;
          const normalizedX = x2 - this.x;
          const normalizedY = y2 - this.y;
          const innerEllipse = normalizedX * normalizedX / (innerA * innerA) + normalizedY * normalizedY / (innerB * innerB);
          const outerEllipse = normalizedX * normalizedX / (outerA * outerA) + normalizedY * normalizedY / (outerB * outerB);
          return innerEllipse > 1 && outerEllipse <= 1;
        }
        /**
         * Returns the framing rectangle of the ellipse as a Rectangle object
         * @param out
         * @returns The framing rectangle
         */
        getBounds(out2) {
          out2 = out2 || new Rectangle();
          out2.x = this.x - this.halfWidth;
          out2.y = this.y - this.halfHeight;
          out2.width = this.halfWidth * 2;
          out2.height = this.halfHeight * 2;
          return out2;
        }
        /**
         * Copies another ellipse to this one.
         * @param ellipse - The ellipse to copy from.
         * @returns Returns itself.
         */
        copyFrom(ellipse) {
          this.x = ellipse.x;
          this.y = ellipse.y;
          this.halfWidth = ellipse.halfWidth;
          this.halfHeight = ellipse.halfHeight;
          return this;
        }
        /**
         * Copies this ellipse to another one.
         * @param ellipse - The ellipse to copy to.
         * @returns Returns given parameter.
         */
        copyTo(ellipse) {
          ellipse.copyFrom(this);
          return ellipse;
        }
        toString() {
          return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs
  function squaredDistanceToLineSegment(x2, y2, x1, y1, x22, y22) {
    const a2 = x2 - x1;
    const b2 = y2 - y1;
    const c2 = x22 - x1;
    const d2 = y22 - y1;
    const dot2 = a2 * c2 + b2 * d2;
    const lenSq = c2 * c2 + d2 * d2;
    let param = -1;
    if (lenSq !== 0) {
      param = dot2 / lenSq;
    }
    let xx;
    let yy;
    if (param < 0) {
      xx = x1;
      yy = y1;
    } else if (param > 1) {
      xx = x22;
      yy = y22;
    } else {
      xx = x1 + param * c2;
      yy = y1 + param * d2;
    }
    const dx = x2 - xx;
    const dy = y2 - yy;
    return dx * dx + dy * dy;
  }
  var init_squaredDistanceToLineSegment = __esm({
    "node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/maths/shapes/Polygon.mjs
  var Polygon;
  var init_Polygon = __esm({
    "node_modules/pixi.js/lib/maths/shapes/Polygon.mjs"() {
      init_squaredDistanceToLineSegment();
      init_Rectangle();
      Polygon = class _Polygon {
        /**
         * @param points - This can be an array of Points
         *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
         *  the arguments passed can be all the points of the polygon e.g.
         *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
         *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
         */
        constructor(...points) {
          this.type = "polygon";
          let flat = Array.isArray(points[0]) ? points[0] : points;
          if (typeof flat[0] !== "number") {
            const p2 = [];
            for (let i2 = 0, il = flat.length; i2 < il; i2++) {
              p2.push(flat[i2].x, flat[i2].y);
            }
            flat = p2;
          }
          this.points = flat;
          this.closePath = true;
        }
        /**
         * Creates a clone of this polygon.
         * @returns - A copy of the polygon.
         */
        clone() {
          const points = this.points.slice();
          const polygon = new _Polygon(points);
          polygon.closePath = this.closePath;
          return polygon;
        }
        /**
         * Checks whether the x and y coordinates passed to this function are contained within this polygon.
         * @param x - The X coordinate of the point to test.
         * @param y - The Y coordinate of the point to test.
         * @returns - Whether the x/y coordinates are within this polygon.
         */
        contains(x2, y2) {
          let inside2 = false;
          const length9 = this.points.length / 2;
          for (let i2 = 0, j2 = length9 - 1; i2 < length9; j2 = i2++) {
            const xi = this.points[i2 * 2];
            const yi = this.points[i2 * 2 + 1];
            const xj = this.points[j2 * 2];
            const yj = this.points[j2 * 2 + 1];
            const intersect2 = yi > y2 !== yj > y2 && x2 < (xj - xi) * ((y2 - yi) / (yj - yi)) + xi;
            if (intersect2) {
              inside2 = !inside2;
            }
          }
          return inside2;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this polygon including the stroke.
         * @param x - The X coordinate of the point to test
         * @param y - The Y coordinate of the point to test
         * @param strokeWidth - The width of the line to check
         * @returns Whether the x/y coordinates are within this polygon
         */
        strokeContains(x2, y2, strokeWidth) {
          const halfStrokeWidth = strokeWidth / 2;
          const halfStrokeWidthSqrd = halfStrokeWidth * halfStrokeWidth;
          const { points } = this;
          const iterationLength = points.length - (this.closePath ? 0 : 2);
          for (let i2 = 0; i2 < iterationLength; i2 += 2) {
            const x1 = points[i2];
            const y1 = points[i2 + 1];
            const x22 = points[(i2 + 2) % points.length];
            const y22 = points[(i2 + 3) % points.length];
            const distanceSqrd = squaredDistanceToLineSegment(x2, y2, x1, y1, x22, y22);
            if (distanceSqrd <= halfStrokeWidthSqrd) {
              return true;
            }
          }
          return false;
        }
        /**
         * Returns the framing rectangle of the polygon as a Rectangle object
         * @param out - optional rectangle to store the result
         * @returns The framing rectangle
         */
        getBounds(out2) {
          out2 = out2 || new Rectangle();
          const points = this.points;
          let minX = Infinity;
          let maxX = -Infinity;
          let minY = Infinity;
          let maxY = -Infinity;
          for (let i2 = 0, n2 = points.length; i2 < n2; i2 += 2) {
            const x2 = points[i2];
            const y2 = points[i2 + 1];
            minX = x2 < minX ? x2 : minX;
            maxX = x2 > maxX ? x2 : maxX;
            minY = y2 < minY ? y2 : minY;
            maxY = y2 > maxY ? y2 : maxY;
          }
          out2.x = minX;
          out2.width = maxX - minX;
          out2.y = minY;
          out2.height = maxY - minY;
          return out2;
        }
        /**
         * Copies another polygon to this one.
         * @param polygon - The polygon to copy from.
         * @returns Returns itself.
         */
        copyFrom(polygon) {
          this.points = polygon.points.slice();
          this.closePath = polygon.closePath;
          return this;
        }
        /**
         * Copies this polygon to another one.
         * @param polygon - The polygon to copy to.
         * @returns Returns given parameter.
         */
        copyTo(polygon) {
          polygon.copyFrom(this);
          return polygon;
        }
        toString() {
          return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
        }
        /**
         * Get the last X coordinate of the polygon
         * @readonly
         */
        get lastX() {
          return this.points[this.points.length - 2];
        }
        /**
         * Get the last Y coordinate of the polygon
         * @readonly
         */
        get lastY() {
          return this.points[this.points.length - 1];
        }
        /**
         * Get the first X coordinate of the polygon
         * @readonly
         */
        get x() {
          return this.points[this.points.length - 2];
        }
        /**
         * Get the first Y coordinate of the polygon
         * @readonly
         */
        get y() {
          return this.points[this.points.length - 1];
        }
      };
    }
  });

  // node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs
  var isCornerWithinStroke, RoundedRectangle;
  var init_RoundedRectangle = __esm({
    "node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs"() {
      init_Rectangle();
      isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, halfStrokeWidth) => {
        const dx = pX - cornerX;
        const dy = pY - cornerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance >= radius - halfStrokeWidth && distance <= radius + halfStrokeWidth;
      };
      RoundedRectangle = class _RoundedRectangle {
        /**
         * @param x - The X coordinate of the upper-left corner of the rounded rectangle
         * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
         * @param width - The overall width of this rounded rectangle
         * @param height - The overall height of this rounded rectangle
         * @param radius - Controls the radius of the rounded corners
         */
        constructor(x2 = 0, y2 = 0, width8 = 0, height8 = 0, radius = 20) {
          this.type = "roundedRectangle";
          this.x = x2;
          this.y = y2;
          this.width = width8;
          this.height = height8;
          this.radius = radius;
        }
        /**
         * Returns the framing rectangle of the rounded rectangle as a Rectangle object
         * @param out - optional rectangle to store the result
         * @returns The framing rectangle
         */
        getBounds(out2) {
          out2 = out2 || new Rectangle();
          out2.x = this.x;
          out2.y = this.y;
          out2.width = this.width;
          out2.height = this.height;
          return out2;
        }
        /**
         * Creates a clone of this Rounded Rectangle.
         * @returns - A copy of the rounded rectangle.
         */
        clone() {
          return new _RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
        }
        /**
         * Copies another rectangle to this one.
         * @param rectangle - The rectangle to copy from.
         * @returns Returns itself.
         */
        copyFrom(rectangle) {
          this.x = rectangle.x;
          this.y = rectangle.y;
          this.width = rectangle.width;
          this.height = rectangle.height;
          return this;
        }
        /**
         * Copies this rectangle to another one.
         * @param rectangle - The rectangle to copy to.
         * @returns Returns given parameter.
         */
        copyTo(rectangle) {
          rectangle.copyFrom(this);
          return rectangle;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
         * @param x - The X coordinate of the point to test.
         * @param y - The Y coordinate of the point to test.
         * @returns - Whether the x/y coordinates are within this Rounded Rectangle.
         */
        contains(x2, y2) {
          if (this.width <= 0 || this.height <= 0) {
            return false;
          }
          if (x2 >= this.x && x2 <= this.x + this.width) {
            if (y2 >= this.y && y2 <= this.y + this.height) {
              const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
              if (y2 >= this.y + radius && y2 <= this.y + this.height - radius || x2 >= this.x + radius && x2 <= this.x + this.width - radius) {
                return true;
              }
              let dx = x2 - (this.x + radius);
              let dy = y2 - (this.y + radius);
              const radius2 = radius * radius;
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
              dx = x2 - (this.x + this.width - radius);
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
              dy = y2 - (this.y + this.height - radius);
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
              dx = x2 - (this.x + radius);
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
            }
          }
          return false;
        }
        /**
         * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
         * @param pX - The X coordinate of the point to test
         * @param pY - The Y coordinate of the point to test
         * @param strokeWidth - The width of the line to check
         * @returns Whether the x/y coordinates are within this rectangle
         */
        strokeContains(pX, pY, strokeWidth) {
          const { x: x2, y: y2, width: width8, height: height8, radius } = this;
          const halfStrokeWidth = strokeWidth / 2;
          const innerX = x2 + radius;
          const innerY = y2 + radius;
          const innerWidth2 = width8 - radius * 2;
          const innerHeight3 = height8 - radius * 2;
          const rightBound = x2 + width8;
          const bottomBound = y2 + height8;
          if ((pX >= x2 - halfStrokeWidth && pX <= x2 + halfStrokeWidth || pX >= rightBound - halfStrokeWidth && pX <= rightBound + halfStrokeWidth) && pY >= innerY && pY <= innerY + innerHeight3) {
            return true;
          }
          if ((pY >= y2 - halfStrokeWidth && pY <= y2 + halfStrokeWidth || pY >= bottomBound - halfStrokeWidth && pY <= bottomBound + halfStrokeWidth) && pX >= innerX && pX <= innerX + innerWidth2) {
            return true;
          }
          return (
            // Top-left
            pX < innerX && pY < innerY && isCornerWithinStroke(pX, pY, innerX, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY < innerY && isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, halfStrokeWidth) || pX < innerX && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, halfStrokeWidth)
          );
        }
        toString() {
          return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs
  function buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {
    const scale = 1;
    const smoothing = Math.min(
      0.99,
      // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
      Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)
    );
    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;
    distanceTolerance *= distanceTolerance;
    begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);
    return points;
  }
  function begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {
    recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);
    points.push(eX, eY);
  }
  function recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
    if (level > RECURSION_LIMIT) {
      return;
    }
    const pi = Math.PI;
    const x12 = (x1 + x2) / 2;
    const y12 = (y1 + y2) / 2;
    const x23 = (x2 + x3) / 2;
    const y23 = (y2 + y3) / 2;
    const x34 = (x3 + x4) / 2;
    const y34 = (y3 + y4) / 2;
    const x123 = (x12 + x23) / 2;
    const y123 = (y12 + y23) / 2;
    const x234 = (x23 + x34) / 2;
    const y234 = (y23 + y34) / 2;
    const x1234 = (x123 + x234) / 2;
    const y1234 = (y123 + y234) / 2;
    if (level > 0) {
      let dx = x4 - x1;
      let dy = y4 - y1;
      const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);
      const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);
      let da1;
      let da2;
      if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {
        if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {
          if (mAngleTolerance < curveAngleToleranceEpsilon) {
            points.push(x1234, y1234);
            return;
          }
          const a23 = Math.atan2(y3 - y2, x3 - x2);
          da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));
          da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);
          if (da1 >= pi)
            da1 = 2 * pi - da1;
          if (da2 >= pi)
            da2 = 2 * pi - da2;
          if (da1 + da2 < mAngleTolerance) {
            points.push(x1234, y1234);
            return;
          }
          if (mCuspLimit !== 0) {
            if (da1 > mCuspLimit) {
              points.push(x2, y2);
              return;
            }
            if (da2 > mCuspLimit) {
              points.push(x3, y3);
              return;
            }
          }
        }
      } else if (d2 > FLT_EPSILON) {
        if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
          if (mAngleTolerance < curveAngleToleranceEpsilon) {
            points.push(x1234, y1234);
            return;
          }
          da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
          if (da1 >= pi)
            da1 = 2 * pi - da1;
          if (da1 < mAngleTolerance) {
            points.push(x2, y2);
            points.push(x3, y3);
            return;
          }
          if (mCuspLimit !== 0) {
            if (da1 > mCuspLimit) {
              points.push(x2, y2);
              return;
            }
          }
        }
      } else if (d3 > FLT_EPSILON) {
        if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {
          if (mAngleTolerance < curveAngleToleranceEpsilon) {
            points.push(x1234, y1234);
            return;
          }
          da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));
          if (da1 >= pi)
            da1 = 2 * pi - da1;
          if (da1 < mAngleTolerance) {
            points.push(x2, y2);
            points.push(x3, y3);
            return;
          }
          if (mCuspLimit !== 0) {
            if (da1 > mCuspLimit) {
              points.push(x3, y3);
              return;
            }
          }
        }
      } else {
        dx = x1234 - (x1 + x4) / 2;
        dy = y1234 - (y1 + y4) / 2;
        if (dx * dx + dy * dy <= distanceTolerance) {
          points.push(x1234, y1234);
          return;
        }
      }
    }
    recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);
    recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);
  }
  var RECURSION_LIMIT, FLT_EPSILON, PATH_DISTANCE_EPSILON, curveAngleToleranceEpsilon, mAngleTolerance, mCuspLimit;
  var init_buildAdaptiveBezier = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs"() {
      init_GraphicsContextSystem();
      RECURSION_LIMIT = 8;
      FLT_EPSILON = 11920929e-14;
      PATH_DISTANCE_EPSILON = 1;
      curveAngleToleranceEpsilon = 0.01;
      mAngleTolerance = 0;
      mCuspLimit = 0;
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs
  function buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {
    const scale = 1;
    const smoothing = Math.min(
      0.99,
      // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
      Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)
    );
    let distanceTolerance = (PATH_DISTANCE_EPSILON2 - smoothing) / scale;
    distanceTolerance *= distanceTolerance;
    begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);
    return points;
  }
  function begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {
    recursive2(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);
    points.push(eX, eY);
  }
  function recursive2(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {
    if (level > RECURSION_LIMIT2) {
      return;
    }
    const pi = Math.PI;
    const x12 = (x1 + x2) / 2;
    const y12 = (y1 + y2) / 2;
    const x23 = (x2 + x3) / 2;
    const y23 = (y2 + y3) / 2;
    const x123 = (x12 + x23) / 2;
    const y123 = (y12 + y23) / 2;
    let dx = x3 - x1;
    let dy = y3 - y1;
    const d2 = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);
    if (d2 > FLT_EPSILON2) {
      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance2 < curveAngleToleranceEpsilon2) {
          points.push(x123, y123);
          return;
        }
        let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
        if (da >= pi)
          da = 2 * pi - da;
        if (da < mAngleTolerance2) {
          points.push(x123, y123);
          return;
        }
      }
    } else {
      dx = x123 - (x1 + x3) / 2;
      dy = y123 - (y1 + y3) / 2;
      if (dx * dx + dy * dy <= distanceTolerance) {
        points.push(x123, y123);
        return;
      }
    }
    recursive2(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);
    recursive2(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);
  }
  var RECURSION_LIMIT2, FLT_EPSILON2, PATH_DISTANCE_EPSILON2, curveAngleToleranceEpsilon2, mAngleTolerance2;
  var init_buildAdaptiveQuadratic = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs"() {
      init_GraphicsContextSystem();
      RECURSION_LIMIT2 = 8;
      FLT_EPSILON2 = 11920929e-14;
      PATH_DISTANCE_EPSILON2 = 1;
      curveAngleToleranceEpsilon2 = 0.01;
      mAngleTolerance2 = 0;
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs
  function buildArc(points, x2, y2, radius, start3, end, clockwise, steps) {
    let dist2 = Math.abs(start3 - end);
    if (!clockwise && start3 > end) {
      dist2 = 2 * Math.PI - dist2;
    } else if (clockwise && end > start3) {
      dist2 = 2 * Math.PI - dist2;
    }
    steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist2 / Math.PI)));
    steps = Math.max(steps, 3);
    let f2 = dist2 / steps;
    let t3 = start3;
    f2 *= clockwise ? -1 : 1;
    for (let i2 = 0; i2 < steps + 1; i2++) {
      const cs = Math.cos(t3);
      const sn = Math.sin(t3);
      const nx = x2 + cs * radius;
      const ny = y2 + sn * radius;
      points.push(nx, ny);
      t3 += f2;
    }
  }
  var init_buildArc = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs
  function buildArcTo(points, x1, y1, x2, y2, radius) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    const a1 = fromY - y1;
    const b1 = fromX - x1;
    const a2 = y2 - y1;
    const b2 = x2 - x1;
    const mm = Math.abs(a1 * b2 - b1 * a2);
    if (mm < 1e-8 || radius === 0) {
      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
        points.push(x1, y1);
      }
      return;
    }
    const dd = a1 * a1 + b1 * b1;
    const cc = a2 * a2 + b2 * b2;
    const tt2 = a1 * a2 + b1 * b2;
    const k1 = radius * Math.sqrt(dd) / mm;
    const k2 = radius * Math.sqrt(cc) / mm;
    const j1 = k1 * tt2 / dd;
    const j2 = k2 * tt2 / cc;
    const cx = k1 * b2 + k2 * b1;
    const cy = k1 * a2 + k2 * a1;
    const px = b1 * (k2 + j1);
    const py = a1 * (k2 + j1);
    const qx = b2 * (k1 + j2);
    const qy = a2 * (k1 + j2);
    const startAngle = Math.atan2(py - cy, px - cx);
    const endAngle = Math.atan2(qy - cy, qx - cx);
    buildArc(
      points,
      cx + x1,
      cy + y1,
      radius,
      startAngle,
      endAngle,
      b1 * a2 > b2 * a1
    );
  }
  var init_buildArcTo = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs"() {
      init_buildArc();
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs
  function approxUnitArc(ang1, ang2) {
    const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
    const a2 = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;
    const x1 = Math.cos(ang1);
    const y1 = Math.sin(ang1);
    const x2 = Math.cos(ang1 + ang2);
    const y2 = Math.sin(ang1 + ang2);
    return [
      {
        x: x1 - y1 * a2,
        y: y1 + x1 * a2
      },
      {
        x: x2 + y2 * a2,
        y: y2 - x2 * a2
      },
      {
        x: x2,
        y: y2
      }
    ];
  }
  function buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {
    if (rx === 0 || ry === 0) {
      return;
    }
    const sinPhi = Math.sin(xAxisRotation * TAU / 360);
    const cosPhi = Math.cos(xAxisRotation * TAU / 360);
    const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;
    const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;
    if (pxp === 0 && pyp === 0) {
      return;
    }
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }
    getArcCenter(
      px,
      py,
      cx,
      cy,
      rx,
      ry,
      largeArcFlag,
      sweepFlag,
      sinPhi,
      cosPhi,
      pxp,
      pyp,
      out
    );
    let { ang1, ang2 } = out;
    const { centerX, centerY } = out;
    let ratio = Math.abs(ang2) / (TAU / 4);
    if (Math.abs(1 - ratio) < 1e-7) {
      ratio = 1;
    }
    const segments = Math.max(Math.ceil(ratio), 1);
    ang2 /= segments;
    let lastX = points[points.length - 2];
    let lastY = points[points.length - 1];
    const outCurvePoint = { x: 0, y: 0 };
    for (let i2 = 0; i2 < segments; i2++) {
      const curve = approxUnitArc(ang1, ang2);
      const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
      const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
      const { x: x3, y: y3 } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
      buildAdaptiveBezier(
        points,
        lastX,
        lastY,
        x1,
        y1,
        x2,
        y2,
        x3,
        y3
      );
      lastX = x3;
      lastY = y3;
      ang1 += ang2;
    }
  }
  var TAU, out, mapToEllipse, vectorAngle, getArcCenter;
  var init_buildArcToSvg = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs"() {
      init_buildAdaptiveBezier();
      TAU = Math.PI * 2;
      out = {
        centerX: 0,
        centerY: 0,
        ang1: 0,
        ang2: 0
      };
      mapToEllipse = ({ x: x2, y: y2 }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {
        x2 *= rx;
        y2 *= ry;
        const xp = cosPhi * x2 - sinPhi * y2;
        const yp = sinPhi * x2 + cosPhi * y2;
        out2.x = xp + centerX;
        out2.y = yp + centerY;
        return out2;
      };
      vectorAngle = (ux2, uy2, vx2, vy2) => {
        const sign2 = ux2 * vy2 - uy2 * vx2 < 0 ? -1 : 1;
        let dot2 = ux2 * vx2 + uy2 * vy2;
        if (dot2 > 1) {
          dot2 = 1;
        }
        if (dot2 < -1) {
          dot2 = -1;
        }
        return sign2 * Math.acos(dot2);
      };
      getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {
        const rxSq = Math.pow(rx, 2);
        const rySq = Math.pow(ry, 2);
        const pxpSq = Math.pow(pxp, 2);
        const pypSq = Math.pow(pyp, 2);
        let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;
        if (radicant < 0) {
          radicant = 0;
        }
        radicant /= rxSq * pypSq + rySq * pxpSq;
        radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
        const centerXp = radicant * rx / ry * pyp;
        const centerYp = radicant * -ry / rx * pxp;
        const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;
        const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;
        const vx1 = (pxp - centerXp) / rx;
        const vy1 = (pyp - centerYp) / ry;
        const vx2 = (-pxp - centerXp) / rx;
        const vy2 = (-pyp - centerYp) / ry;
        const ang1 = vectorAngle(1, 0, vx1, vy1);
        let ang2 = vectorAngle(vx1, vy1, vx2, vy2);
        if (sweepFlag === 0 && ang2 > 0) {
          ang2 -= TAU;
        }
        if (sweepFlag === 1 && ang2 < 0) {
          ang2 += TAU;
        }
        out2.centerX = centerX;
        out2.centerY = centerY;
        out2.ang1 = ang1;
        out2.ang2 = ang2;
      };
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs
  function roundedShapeArc(g2, points, radius) {
    const vecFrom = (p2, pp) => {
      const x2 = pp.x - p2.x;
      const y2 = pp.y - p2.y;
      const len = Math.sqrt(x2 * x2 + y2 * y2);
      const nx = x2 / len;
      const ny = y2 / len;
      return { len, nx, ny };
    };
    const sharpCorner = (i2, p2) => {
      if (i2 === 0) {
        g2.moveTo(p2.x, p2.y);
      } else {
        g2.lineTo(p2.x, p2.y);
      }
    };
    let p1 = points[points.length - 1];
    for (let i2 = 0; i2 < points.length; i2++) {
      const p2 = points[i2 % points.length];
      const pRadius = p2.radius ?? radius;
      if (pRadius <= 0) {
        sharpCorner(i2, p2);
        p1 = p2;
        continue;
      }
      const p3 = points[(i2 + 1) % points.length];
      const v1 = vecFrom(p2, p1);
      const v2 = vecFrom(p2, p3);
      if (v1.len < 1e-4 || v2.len < 1e-4) {
        sharpCorner(i2, p2);
        p1 = p2;
        continue;
      }
      let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);
      let radDirection = 1;
      let drawDirection = false;
      if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {
        if (angle < 0) {
          angle = Math.PI + angle;
        } else {
          angle = Math.PI - angle;
          radDirection = -1;
          drawDirection = true;
        }
      } else if (angle > 0) {
        radDirection = -1;
        drawDirection = true;
      }
      const halfAngle = angle / 2;
      let cRadius;
      let lenOut = Math.abs(
        Math.cos(halfAngle) * pRadius / Math.sin(halfAngle)
      );
      if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {
        lenOut = Math.min(v1.len / 2, v2.len / 2);
        cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
      } else {
        cRadius = pRadius;
      }
      const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;
      const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;
      const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;
      const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;
      if (i2 === 0) {
        g2.moveTo(
          cX + Math.cos(startAngle) * cRadius,
          cY + Math.sin(startAngle) * cRadius
        );
      }
      g2.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);
      p1 = p2;
    }
  }
  function roundedShapeQuadraticCurve(g2, points, radius, smoothness) {
    const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
    const pointLerp = (p1, p2, t3) => ({
      x: p1.x + (p2.x - p1.x) * t3,
      y: p1.y + (p2.y - p1.y) * t3
    });
    const numPoints = points.length;
    for (let i2 = 0; i2 < numPoints; i2++) {
      const thisPoint = points[(i2 + 1) % numPoints];
      const pRadius = thisPoint.radius ?? radius;
      if (pRadius <= 0) {
        if (i2 === 0) {
          g2.moveTo(thisPoint.x, thisPoint.y);
        } else {
          g2.lineTo(thisPoint.x, thisPoint.y);
        }
        continue;
      }
      const lastPoint = points[i2];
      const nextPoint = points[(i2 + 2) % numPoints];
      const lastEdgeLength = distance(lastPoint, thisPoint);
      let start3;
      if (lastEdgeLength < 1e-4) {
        start3 = thisPoint;
      } else {
        const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);
        start3 = pointLerp(
          thisPoint,
          lastPoint,
          lastOffsetDistance / lastEdgeLength
        );
      }
      const nextEdgeLength = distance(nextPoint, thisPoint);
      let end;
      if (nextEdgeLength < 1e-4) {
        end = thisPoint;
      } else {
        const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);
        end = pointLerp(
          thisPoint,
          nextPoint,
          nextOffsetDistance / nextEdgeLength
        );
      }
      if (i2 === 0) {
        g2.moveTo(start3.x, start3.y);
      } else {
        g2.lineTo(start3.x, start3.y);
      }
      g2.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);
    }
  }
  var init_roundShape = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs
  var tempRectangle, ShapePath;
  var init_ShapePath = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs"() {
      init_Circle();
      init_Ellipse();
      init_Polygon();
      init_Rectangle();
      init_RoundedRectangle();
      init_Bounds();
      init_buildAdaptiveBezier();
      init_buildAdaptiveQuadratic();
      init_buildArc();
      init_buildArcTo();
      init_buildArcToSvg();
      init_roundShape();
      tempRectangle = new Rectangle();
      ShapePath = class {
        constructor(graphicsPath2D) {
          this.shapePrimitives = [];
          this._currentPoly = null;
          this._bounds = new Bounds();
          this._graphicsPath2D = graphicsPath2D;
        }
        /**
         * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
         * @param x - The x-coordinate for the starting point.
         * @param y - The y-coordinate for the starting point.
         * @returns The instance of the current object for chaining.
         */
        moveTo(x2, y2) {
          this.startPoly(x2, y2);
          return this;
        }
        /**
         * Connects the current point to a new point with a straight line. This method updates the current path.
         * @param x - The x-coordinate of the new point to connect to.
         * @param y - The y-coordinate of the new point to connect to.
         * @returns The instance of the current object for chaining.
         */
        lineTo(x2, y2) {
          this._ensurePoly();
          const points = this._currentPoly.points;
          const fromX = points[points.length - 2];
          const fromY = points[points.length - 1];
          if (fromX !== x2 || fromY !== y2) {
            points.push(x2, y2);
          }
          return this;
        }
        /**
         * Adds an arc to the path. The arc is centered at (x, y)
         *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.
         * @param x - The x-coordinate of the arc's center.
         * @param y - The y-coordinate of the arc's center.
         * @param radius - The radius of the arc.
         * @param startAngle - The starting angle of the arc, in radians.
         * @param endAngle - The ending angle of the arc, in radians.
         * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.
         * @returns The instance of the current object for chaining.
         */
        arc(x2, y2, radius, startAngle, endAngle, counterclockwise) {
          this._ensurePoly(false);
          const points = this._currentPoly.points;
          buildArc(points, x2, y2, radius, startAngle, endAngle, counterclockwise);
          return this;
        }
        /**
         * Adds an arc to the path with the arc tangent to the line joining two specified points.
         * The arc radius is specified by `radius`.
         * @param x1 - The x-coordinate of the first point.
         * @param y1 - The y-coordinate of the first point.
         * @param x2 - The x-coordinate of the second point.
         * @param y2 - The y-coordinate of the second point.
         * @param radius - The radius of the arc.
         * @returns The instance of the current object for chaining.
         */
        arcTo(x1, y1, x2, y2, radius) {
          this._ensurePoly();
          const points = this._currentPoly.points;
          buildArcTo(points, x1, y1, x2, y2, radius);
          return this;
        }
        /**
         * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
         * @param rx - The x-radius of the ellipse.
         * @param ry - The y-radius of the ellipse.
         * @param xAxisRotation - The rotation of the ellipse's x-axis relative
         * to the x-axis of the coordinate system, in degrees.
         * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
         * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
         * @param x - The x-coordinate of the arc's end point.
         * @param y - The y-coordinate of the arc's end point.
         * @returns The instance of the current object for chaining.
         */
        arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
          const points = this._currentPoly.points;
          buildArcToSvg(
            points,
            this._currentPoly.lastX,
            this._currentPoly.lastY,
            x2,
            y2,
            rx,
            ry,
            xAxisRotation,
            largeArcFlag,
            sweepFlag
          );
          return this;
        }
        /**
         * Adds a cubic Bezier curve to the path.
         * It requires three points: the first two are control points and the third one is the end point.
         * The starting point is the last point in the current path.
         * @param cp1x - The x-coordinate of the first control point.
         * @param cp1y - The y-coordinate of the first control point.
         * @param cp2x - The x-coordinate of the second control point.
         * @param cp2y - The y-coordinate of the second control point.
         * @param x - The x-coordinate of the end point.
         * @param y - The y-coordinate of the end point.
         * @param smoothness - Optional parameter to adjust the smoothness of the curve.
         * @returns The instance of the current object for chaining.
         */
        bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness) {
          this._ensurePoly();
          const currentPoly = this._currentPoly;
          buildAdaptiveBezier(
            this._currentPoly.points,
            currentPoly.lastX,
            currentPoly.lastY,
            cp1x,
            cp1y,
            cp2x,
            cp2y,
            x2,
            y2,
            smoothness
          );
          return this;
        }
        /**
         * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
         * The starting point is the last point in the current path.
         * @param cp1x - The x-coordinate of the control point.
         * @param cp1y - The y-coordinate of the control point.
         * @param x - The x-coordinate of the end point.
         * @param y - The y-coordinate of the end point.
         * @param smoothing - Optional parameter to adjust the smoothness of the curve.
         * @returns The instance of the current object for chaining.
         */
        quadraticCurveTo(cp1x, cp1y, x2, y2, smoothing) {
          this._ensurePoly();
          const currentPoly = this._currentPoly;
          buildAdaptiveQuadratic(
            this._currentPoly.points,
            currentPoly.lastX,
            currentPoly.lastY,
            cp1x,
            cp1y,
            x2,
            y2,
            smoothing
          );
          return this;
        }
        /**
         * Closes the current path by drawing a straight line back to the start.
         * If the shape is already closed or there are no points in the path, this method does nothing.
         * @returns The instance of the current object for chaining.
         */
        closePath() {
          this.endPoly(true);
          return this;
        }
        /**
         * Adds another path to the current path. This method allows for the combination of multiple paths into one.
         * @param path - The `GraphicsPath` object representing the path to add.
         * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.
         * @returns The instance of the current object for chaining.
         */
        addPath(path2, transform2) {
          this.endPoly();
          if (transform2 && !transform2.isIdentity()) {
            path2 = path2.clone(true);
            path2.transform(transform2);
          }
          for (let i2 = 0; i2 < path2.instructions.length; i2++) {
            const instruction = path2.instructions[i2];
            this[instruction.action](...instruction.data);
          }
          return this;
        }
        /**
         * Finalizes the drawing of the current path. Optionally, it can close the path.
         * @param closePath - A boolean indicating whether to close the path after finishing. False by default.
         */
        finish(closePath = false) {
          this.endPoly(closePath);
        }
        /**
         * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
         * @param x - The x-coordinate of the top-left corner of the rectangle.
         * @param y - The y-coordinate of the top-left corner of the rectangle.
         * @param w - The width of the rectangle.
         * @param h - The height of the rectangle.
         * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
         * @returns The instance of the current object for chaining.
         */
        rect(x2, y2, w2, h2, transform2) {
          this.drawShape(new Rectangle(x2, y2, w2, h2), transform2);
          return this;
        }
        /**
         * Draws a circle shape. This method adds a new circle path to the current drawing.
         * @param x - The x-coordinate of the center of the circle.
         * @param y - The y-coordinate of the center of the circle.
         * @param radius - The radius of the circle.
         * @param transform - An optional `Matrix` object to apply a transformation to the circle.
         * @returns The instance of the current object for chaining.
         */
        circle(x2, y2, radius, transform2) {
          this.drawShape(new Circle(x2, y2, radius), transform2);
          return this;
        }
        /**
         * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.
         * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
         * representing the x and y coordinates of the polygon's vertices, in sequence.
         * @param close - A boolean indicating whether to close the polygon path. True by default.
         * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
         * @returns The instance of the current object for chaining.
         */
        poly(points, close2, transform2) {
          const polygon = new Polygon(points);
          polygon.closePath = close2;
          this.drawShape(polygon, transform2);
          return this;
        }
        /**
         * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
         * @param x - The x-coordinate of the center of the polygon.
         * @param y - The y-coordinate of the center of the polygon.
         * @param radius - The radius of the circumscribed circle of the polygon.
         * @param sides - The number of sides of the polygon. Must be 3 or more.
         * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
         * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
         * @returns The instance of the current object for chaining.
         */
        regularPoly(x2, y2, radius, sides, rotation = 0, transform2) {
          sides = Math.max(sides | 0, 3);
          const startAngle = -1 * Math.PI / 2 + rotation;
          const delta = Math.PI * 2 / sides;
          const polygon = [];
          for (let i2 = 0; i2 < sides; i2++) {
            const angle = i2 * delta + startAngle;
            polygon.push(
              x2 + radius * Math.cos(angle),
              y2 + radius * Math.sin(angle)
            );
          }
          this.poly(polygon, true, transform2);
          return this;
        }
        /**
         * Draws a polygon with rounded corners.
         * Similar to `regularPoly` but with the ability to round the corners of the polygon.
         * @param x - The x-coordinate of the center of the polygon.
         * @param y - The y-coordinate of the center of the polygon.
         * @param radius - The radius of the circumscribed circle of the polygon.
         * @param sides - The number of sides of the polygon. Must be 3 or more.
         * @param corner - The radius of the rounding of the corners.
         * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
         * @param smoothness - Optional parameter to adjust the smoothness of the rounding.
         * @returns The instance of the current object for chaining.
         */
        roundPoly(x2, y2, radius, sides, corner, rotation = 0, smoothness) {
          sides = Math.max(sides | 0, 3);
          if (corner <= 0) {
            return this.regularPoly(x2, y2, radius, sides, rotation);
          }
          const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;
          corner = Math.min(corner, sideLength);
          const startAngle = -1 * Math.PI / 2 + rotation;
          const delta = Math.PI * 2 / sides;
          const internalAngle = (sides - 2) * Math.PI / sides / 2;
          for (let i2 = 0; i2 < sides; i2++) {
            const angle = i2 * delta + startAngle;
            const x0 = x2 + radius * Math.cos(angle);
            const y0 = y2 + radius * Math.sin(angle);
            const a1 = angle + Math.PI + internalAngle;
            const a2 = angle - Math.PI - internalAngle;
            const x1 = x0 + corner * Math.cos(a1);
            const y1 = y0 + corner * Math.sin(a1);
            const x3 = x0 + corner * Math.cos(a2);
            const y3 = y0 + corner * Math.sin(a2);
            if (i2 === 0) {
              this.moveTo(x1, y1);
            } else {
              this.lineTo(x1, y1);
            }
            this.quadraticCurveTo(x0, y0, x3, y3, smoothness);
          }
          return this.closePath();
        }
        /**
         * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
         * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
         * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
         * A minimum of 3 points is required.
         * @param radius - The default radius for the corners.
         * This radius is applied to all corners unless overridden in `points`.
         * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
         *  method instead of an arc method. Defaults to false.
         * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
         * Higher values make the curve smoother.
         * @returns The instance of the current object for chaining.
         */
        roundShape(points, radius, useQuadratic = false, smoothness) {
          if (points.length < 3) {
            return this;
          }
          if (useQuadratic) {
            roundedShapeQuadraticCurve(this, points, radius, smoothness);
          } else {
            roundedShapeArc(this, points, radius);
          }
          return this.closePath();
        }
        /**
         * Draw Rectangle with fillet corners. This is much like rounded rectangle
         * however it support negative numbers as well for the corner radius.
         * @param x - Upper left corner of rect
         * @param y - Upper right corner of rect
         * @param width - Width of rect
         * @param height - Height of rect
         * @param fillet - accept negative or positive values
         */
        filletRect(x2, y2, width8, height8, fillet) {
          if (fillet === 0) {
            return this.rect(x2, y2, width8, height8);
          }
          const maxFillet = Math.min(width8, height8) / 2;
          const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));
          const right = x2 + width8;
          const bottom3 = y2 + height8;
          const dir2 = inset < 0 ? -inset : 0;
          const size5 = Math.abs(inset);
          return this.moveTo(x2, y2 + size5).arcTo(x2 + dir2, y2 + dir2, x2 + size5, y2, size5).lineTo(right - size5, y2).arcTo(right - dir2, y2 + dir2, right, y2 + size5, size5).lineTo(right, bottom3 - size5).arcTo(right - dir2, bottom3 - dir2, x2 + width8 - size5, bottom3, size5).lineTo(x2 + size5, bottom3).arcTo(x2 + dir2, bottom3 - dir2, x2, bottom3 - size5, size5).closePath();
        }
        /**
         * Draw Rectangle with chamfer corners. These are angled corners.
         * @param x - Upper left corner of rect
         * @param y - Upper right corner of rect
         * @param width - Width of rect
         * @param height - Height of rect
         * @param chamfer - non-zero real number, size of corner cutout
         * @param transform
         */
        chamferRect(x2, y2, width8, height8, chamfer, transform2) {
          if (chamfer <= 0) {
            return this.rect(x2, y2, width8, height8);
          }
          const inset = Math.min(chamfer, Math.min(width8, height8) / 2);
          const right = x2 + width8;
          const bottom3 = y2 + height8;
          const points = [
            x2 + inset,
            y2,
            right - inset,
            y2,
            right,
            y2 + inset,
            right,
            bottom3 - inset,
            right - inset,
            bottom3,
            x2 + inset,
            bottom3,
            x2,
            bottom3 - inset,
            x2,
            y2 + inset
          ];
          for (let i2 = points.length - 1; i2 >= 2; i2 -= 2) {
            if (points[i2] === points[i2 - 2] && points[i2 - 1] === points[i2 - 3]) {
              points.splice(i2 - 1, 2);
            }
          }
          return this.poly(points, true, transform2);
        }
        /**
         * Draws an ellipse at the specified location and with the given x and y radii.
         * An optional transformation can be applied, allowing for rotation, scaling, and translation.
         * @param x - The x-coordinate of the center of the ellipse.
         * @param y - The y-coordinate of the center of the ellipse.
         * @param radiusX - The horizontal radius of the ellipse.
         * @param radiusY - The vertical radius of the ellipse.
         * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.
         * @returns The instance of the current object for chaining.
         */
        ellipse(x2, y2, radiusX, radiusY, transform2) {
          this.drawShape(new Ellipse(x2, y2, radiusX, radiusY), transform2);
          return this;
        }
        /**
         * Draws a rectangle with rounded corners.
         * The corner radius can be specified to determine how rounded the corners should be.
         * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
         * @param x - The x-coordinate of the top-left corner of the rectangle.
         * @param y - The y-coordinate of the top-left corner of the rectangle.
         * @param w - The width of the rectangle.
         * @param h - The height of the rectangle.
         * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
         * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
         * @returns The instance of the current object for chaining.
         */
        roundRect(x2, y2, w2, h2, radius, transform2) {
          this.drawShape(new RoundedRectangle(x2, y2, w2, h2, radius), transform2);
          return this;
        }
        /**
         * Draws a given shape on the canvas.
         * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.
         * An optional transformation matrix can be applied to the shape, allowing for complex transformations.
         * @param shape - The shape to draw, defined as a `ShapePrimitive` object.
         * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,
         * scaling, and translations.
         * @returns The instance of the current object for chaining.
         */
        drawShape(shape2, matrix) {
          this.endPoly();
          this.shapePrimitives.push({ shape: shape2, transform: matrix });
          return this;
        }
        /**
         * Starts a new polygon path from the specified starting point.
         * This method initializes a new polygon or ends the current one if it exists.
         * @param x - The x-coordinate of the starting point of the new polygon.
         * @param y - The y-coordinate of the starting point of the new polygon.
         * @returns The instance of the current object for chaining.
         */
        startPoly(x2, y2) {
          let currentPoly = this._currentPoly;
          if (currentPoly) {
            this.endPoly();
          }
          currentPoly = new Polygon();
          currentPoly.points.push(x2, y2);
          this._currentPoly = currentPoly;
          return this;
        }
        /**
         * Ends the current polygon path. If `closePath` is set to true,
         * the path is closed by connecting the last point to the first one.
         * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.
         * @param closePath - A boolean indicating whether to close the polygon by connecting the last point
         *  back to the starting point. False by default.
         * @returns The instance of the current object for chaining.
         */
        endPoly(closePath = false) {
          const shape2 = this._currentPoly;
          if (shape2 && shape2.points.length > 2) {
            shape2.closePath = closePath;
            this.shapePrimitives.push({ shape: shape2 });
          }
          this._currentPoly = null;
          return this;
        }
        _ensurePoly(start3 = true) {
          if (this._currentPoly)
            return;
          this._currentPoly = new Polygon();
          if (start3) {
            const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];
            if (lastShape) {
              let lx = lastShape.shape.x;
              let ly = lastShape.shape.y;
              if (lastShape.transform && !lastShape.transform.isIdentity()) {
                const t3 = lastShape.transform;
                const tempX = lx;
                lx = t3.a * lx + t3.c * ly + t3.tx;
                ly = t3.b * tempX + t3.d * ly + t3.ty;
              }
              this._currentPoly.points.push(lx, ly);
            } else {
              this._currentPoly.points.push(0, 0);
            }
          }
        }
        /** Builds the path. */
        buildPath() {
          const path2 = this._graphicsPath2D;
          this.shapePrimitives.length = 0;
          this._currentPoly = null;
          for (let i2 = 0; i2 < path2.instructions.length; i2++) {
            const instruction = path2.instructions[i2];
            this[instruction.action](...instruction.data);
          }
          this.finish();
        }
        /** Gets the bounds of the path. */
        get bounds() {
          const bounds = this._bounds;
          bounds.clear();
          const shapePrimitives = this.shapePrimitives;
          for (let i2 = 0; i2 < shapePrimitives.length; i2++) {
            const shapePrimitive = shapePrimitives[i2];
            const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);
            if (shapePrimitive.transform) {
              bounds.addRect(boundsRect, shapePrimitive.transform);
            } else {
              bounds.addRect(boundsRect);
            }
          }
          return bounds;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs
  function adjustTransform(currentMatrix, transform2) {
    if (currentMatrix) {
      return currentMatrix.prepend(transform2);
    }
    return transform2.clone();
  }
  var GraphicsPath;
  var init_GraphicsPath = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs"() {
      init_Point();
      init_uid();
      init_warn();
      init_SVGToGraphicsPath();
      init_ShapePath();
      GraphicsPath = class _GraphicsPath {
        /**
         * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.
         * @param instructions - An SVG path string or an array of `PathInstruction` objects.
         */
        constructor(instructions) {
          this.instructions = [];
          this.uid = uid("graphicsPath");
          this._dirty = true;
          if (typeof instructions === "string") {
            SVGToGraphicsPath(instructions, this);
          } else {
            this.instructions = instructions?.slice() ?? [];
          }
        }
        /**
         * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.
         * @returns The `ShapePath` instance associated with this `GraphicsPath`.
         */
        get shapePath() {
          if (!this._shapePath) {
            this._shapePath = new ShapePath(this);
          }
          if (this._dirty) {
            this._dirty = false;
            this._shapePath.buildPath();
          }
          return this._shapePath;
        }
        /**
         * Adds another `GraphicsPath` to this path, optionally applying a transformation.
         * @param path - The `GraphicsPath` to add.
         * @param transform - An optional transformation to apply to the added path.
         * @returns The instance of the current object for chaining.
         */
        addPath(path2, transform2) {
          path2 = path2.clone();
          this.instructions.push({ action: "addPath", data: [path2, transform2] });
          this._dirty = true;
          return this;
        }
        arc(...args) {
          this.instructions.push({ action: "arc", data: args });
          this._dirty = true;
          return this;
        }
        arcTo(...args) {
          this.instructions.push({ action: "arcTo", data: args });
          this._dirty = true;
          return this;
        }
        arcToSvg(...args) {
          this.instructions.push({ action: "arcToSvg", data: args });
          this._dirty = true;
          return this;
        }
        bezierCurveTo(...args) {
          this.instructions.push({ action: "bezierCurveTo", data: args });
          this._dirty = true;
          return this;
        }
        /**
         * Adds a cubic Bezier curve to the path.
         * It requires two points: the second control point and the end point. The first control point is assumed to be
         * The starting point is the last point in the current path.
         * @param cp2x - The x-coordinate of the second control point.
         * @param cp2y - The y-coordinate of the second control point.
         * @param x - The x-coordinate of the end point.
         * @param y - The y-coordinate of the end point.
         * @param smoothness - Optional parameter to adjust the smoothness of the curve.
         * @returns The instance of the current object for chaining.
         */
        bezierCurveToShort(cp2x, cp2y, x2, y2, smoothness) {
          const last4 = this.instructions[this.instructions.length - 1];
          const lastPoint = this.getLastPoint(Point.shared);
          let cp1x = 0;
          let cp1y = 0;
          if (!last4 || last4.action !== "bezierCurveTo") {
            cp1x = lastPoint.x;
            cp1y = lastPoint.y;
          } else {
            cp1x = last4.data[2];
            cp1y = last4.data[3];
            const currentX = lastPoint.x;
            const currentY = lastPoint.y;
            cp1x = currentX + (currentX - cp1x);
            cp1y = currentY + (currentY - cp1y);
          }
          this.instructions.push({ action: "bezierCurveTo", data: [cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness] });
          this._dirty = true;
          return this;
        }
        /**
         * Closes the current path by drawing a straight line back to the start.
         * If the shape is already closed or there are no points in the path, this method does nothing.
         * @returns The instance of the current object for chaining.
         */
        closePath() {
          this.instructions.push({ action: "closePath", data: [] });
          this._dirty = true;
          return this;
        }
        ellipse(...args) {
          this.instructions.push({ action: "ellipse", data: args });
          this._dirty = true;
          return this;
        }
        lineTo(...args) {
          this.instructions.push({ action: "lineTo", data: args });
          this._dirty = true;
          return this;
        }
        moveTo(...args) {
          this.instructions.push({ action: "moveTo", data: args });
          return this;
        }
        quadraticCurveTo(...args) {
          this.instructions.push({ action: "quadraticCurveTo", data: args });
          this._dirty = true;
          return this;
        }
        /**
         * Adds a quadratic curve to the path. It uses the previous point as the control point.
         * @param x - The x-coordinate of the end point.
         * @param y - The y-coordinate of the end point.
         * @param smoothness - Optional parameter to adjust the smoothness of the curve.
         * @returns The instance of the current object for chaining.
         */
        quadraticCurveToShort(x2, y2, smoothness) {
          const last4 = this.instructions[this.instructions.length - 1];
          const lastPoint = this.getLastPoint(Point.shared);
          let cpx1 = 0;
          let cpy1 = 0;
          if (!last4 || last4.action !== "quadraticCurveTo") {
            cpx1 = lastPoint.x;
            cpy1 = lastPoint.y;
          } else {
            cpx1 = last4.data[0];
            cpy1 = last4.data[1];
            const currentX = lastPoint.x;
            const currentY = lastPoint.y;
            cpx1 = currentX + (currentX - cpx1);
            cpy1 = currentY + (currentY - cpy1);
          }
          this.instructions.push({ action: "quadraticCurveTo", data: [cpx1, cpy1, x2, y2, smoothness] });
          this._dirty = true;
          return this;
        }
        /**
         * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
         * @param x - The x-coordinate of the top-left corner of the rectangle.
         * @param y - The y-coordinate of the top-left corner of the rectangle.
         * @param w - The width of the rectangle.
         * @param h - The height of the rectangle.
         * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
         * @returns The instance of the current object for chaining.
         */
        rect(x2, y2, w2, h2, transform2) {
          this.instructions.push({ action: "rect", data: [x2, y2, w2, h2, transform2] });
          this._dirty = true;
          return this;
        }
        /**
         * Draws a circle shape. This method adds a new circle path to the current drawing.
         * @param x - The x-coordinate of the center of the circle.
         * @param y - The y-coordinate of the center of the circle.
         * @param radius - The radius of the circle.
         * @param transform - An optional `Matrix` object to apply a transformation to the circle.
         * @returns The instance of the current object for chaining.
         */
        circle(x2, y2, radius, transform2) {
          this.instructions.push({ action: "circle", data: [x2, y2, radius, transform2] });
          this._dirty = true;
          return this;
        }
        roundRect(...args) {
          this.instructions.push({ action: "roundRect", data: args });
          this._dirty = true;
          return this;
        }
        poly(...args) {
          this.instructions.push({ action: "poly", data: args });
          this._dirty = true;
          return this;
        }
        regularPoly(...args) {
          this.instructions.push({ action: "regularPoly", data: args });
          this._dirty = true;
          return this;
        }
        roundPoly(...args) {
          this.instructions.push({ action: "roundPoly", data: args });
          this._dirty = true;
          return this;
        }
        roundShape(...args) {
          this.instructions.push({ action: "roundShape", data: args });
          this._dirty = true;
          return this;
        }
        filletRect(...args) {
          this.instructions.push({ action: "filletRect", data: args });
          this._dirty = true;
          return this;
        }
        chamferRect(...args) {
          this.instructions.push({ action: "chamferRect", data: args });
          this._dirty = true;
          return this;
        }
        /**
         * Draws a star shape centered at a specified location. This method allows for the creation
         *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
         * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
         * An optional transformation can be applied to scale, rotate, or translate the star as needed.
         * @param x - The x-coordinate of the center of the star.
         * @param y - The y-coordinate of the center of the star.
         * @param points - The number of points of the star.
         * @param radius - The outer radius of the star (distance from the center to the outer points).
         * @param innerRadius - Optional. The inner radius of the star
         * (distance from the center to the inner points between the outer points).
         * If not provided, defaults to half of the `radius`.
         * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
         * Defaults to 0, meaning one point is directly upward.
         * @param transform - An optional `Matrix` object to apply a transformation to the star.
         * This can include rotations, scaling, and translations.
         * @returns The instance of the current object for chaining further drawing commands.
         */
        // eslint-disable-next-line max-len
        star(x2, y2, points, radius, innerRadius, rotation, transform2) {
          innerRadius = innerRadius || radius / 2;
          const startAngle = -1 * Math.PI / 2 + rotation;
          const len = points * 2;
          const delta = Math.PI * 2 / len;
          const polygon = [];
          for (let i2 = 0; i2 < len; i2++) {
            const r2 = i2 % 2 ? innerRadius : radius;
            const angle = i2 * delta + startAngle;
            polygon.push(
              x2 + r2 * Math.cos(angle),
              y2 + r2 * Math.sin(angle)
            );
          }
          this.poly(polygon, true, transform2);
          return this;
        }
        /**
         * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.
         * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and
         * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`
         * do not affect the original `GraphicsPath` and vice versa.
         * @param deep - A boolean flag indicating whether the clone should be deep.
         * @returns A new `GraphicsPath` instance that is a clone of the current instance.
         */
        clone(deep = false) {
          const newGraphicsPath2D = new _GraphicsPath();
          if (!deep) {
            newGraphicsPath2D.instructions = this.instructions.slice();
          } else {
            for (let i2 = 0; i2 < this.instructions.length; i2++) {
              const instruction = this.instructions[i2];
              newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });
            }
          }
          return newGraphicsPath2D;
        }
        clear() {
          this.instructions.length = 0;
          this._dirty = true;
          return this;
        }
        /**
         * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.
         * This method enables the modification of the path's geometry according to the provided
         * transformation matrix, which can include translations, rotations, scaling, and skewing.
         *
         * Each drawing instruction in the path is updated to reflect the transformation,
         * ensuring the visual representation of the path is consistent with the applied matrix.
         *
         * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,
         * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,
         * allowing for fine-grained control over the path's appearance.
         * @param matrix - A `Matrix` object representing the transformation to apply.
         * @returns The instance of the current object for chaining further operations.
         */
        transform(matrix) {
          if (matrix.isIdentity())
            return this;
          const a2 = matrix.a;
          const b2 = matrix.b;
          const c2 = matrix.c;
          const d2 = matrix.d;
          const tx = matrix.tx;
          const ty = matrix.ty;
          let x2 = 0;
          let y2 = 0;
          let cpx1 = 0;
          let cpy1 = 0;
          let cpx2 = 0;
          let cpy2 = 0;
          let rx = 0;
          let ry = 0;
          for (let i2 = 0; i2 < this.instructions.length; i2++) {
            const instruction = this.instructions[i2];
            const data = instruction.data;
            switch (instruction.action) {
              case "moveTo":
              case "lineTo":
                x2 = data[0];
                y2 = data[1];
                data[0] = a2 * x2 + c2 * y2 + tx;
                data[1] = b2 * x2 + d2 * y2 + ty;
                break;
              case "bezierCurveTo":
                cpx1 = data[0];
                cpy1 = data[1];
                cpx2 = data[2];
                cpy2 = data[3];
                x2 = data[4];
                y2 = data[5];
                data[0] = a2 * cpx1 + c2 * cpy1 + tx;
                data[1] = b2 * cpx1 + d2 * cpy1 + ty;
                data[2] = a2 * cpx2 + c2 * cpy2 + tx;
                data[3] = b2 * cpx2 + d2 * cpy2 + ty;
                data[4] = a2 * x2 + c2 * y2 + tx;
                data[5] = b2 * x2 + d2 * y2 + ty;
                break;
              case "quadraticCurveTo":
                cpx1 = data[0];
                cpy1 = data[1];
                x2 = data[2];
                y2 = data[3];
                data[0] = a2 * cpx1 + c2 * cpy1 + tx;
                data[1] = b2 * cpx1 + d2 * cpy1 + ty;
                data[2] = a2 * x2 + c2 * y2 + tx;
                data[3] = b2 * x2 + d2 * y2 + ty;
                break;
              case "arcToSvg":
                x2 = data[5];
                y2 = data[6];
                rx = data[0];
                ry = data[1];
                data[0] = a2 * rx + c2 * ry;
                data[1] = b2 * rx + d2 * ry;
                data[5] = a2 * x2 + c2 * y2 + tx;
                data[6] = b2 * x2 + d2 * y2 + ty;
                break;
              case "circle":
                data[4] = adjustTransform(data[3], matrix);
                break;
              case "rect":
                data[4] = adjustTransform(data[4], matrix);
                break;
              case "ellipse":
                data[8] = adjustTransform(data[8], matrix);
                break;
              case "roundRect":
                data[5] = adjustTransform(data[5], matrix);
                break;
              case "addPath":
                data[0].transform(matrix);
                break;
              case "poly":
                data[2] = adjustTransform(data[2], matrix);
                break;
              default:
                warn2("unknown transform action", instruction.action);
                break;
            }
          }
          this._dirty = true;
          return this;
        }
        get bounds() {
          return this.shapePath.bounds;
        }
        /**
         * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.
         * This method is useful for operations that depend on the path's current endpoint,
         * such as connecting subsequent shapes or paths. It supports various drawing instructions,
         * ensuring the last point's position is accurately determined regardless of the path's complexity.
         *
         * If the last instruction is a `closePath`, the method iterates backward through the instructions
         *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,
         * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves
         * the last point from the nested path.
         * @param out - A `Point` object where the last point's coordinates will be stored.
         * This object is modified directly to contain the result.
         * @returns The `Point` object containing the last point's coordinates.
         */
        getLastPoint(out2) {
          let index6 = this.instructions.length - 1;
          let lastInstruction = this.instructions[index6];
          if (!lastInstruction) {
            out2.x = 0;
            out2.y = 0;
            return out2;
          }
          while (lastInstruction.action === "closePath") {
            index6--;
            if (index6 < 0) {
              out2.x = 0;
              out2.y = 0;
              return out2;
            }
            lastInstruction = this.instructions[index6];
          }
          switch (lastInstruction.action) {
            case "moveTo":
            case "lineTo":
              out2.x = lastInstruction.data[0];
              out2.y = lastInstruction.data[1];
              break;
            case "quadraticCurveTo":
              out2.x = lastInstruction.data[2];
              out2.y = lastInstruction.data[3];
              break;
            case "bezierCurveTo":
              out2.x = lastInstruction.data[4];
              out2.y = lastInstruction.data[5];
              break;
            case "arc":
            case "arcToSvg":
              out2.x = lastInstruction.data[5];
              out2.y = lastInstruction.data[6];
              break;
            case "addPath":
              lastInstruction.data[0].getLastPoint(out2);
              break;
          }
          return out2;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs
  function SVGParser(svg2, graphicsContext) {
    if (typeof svg2 === "string") {
      const div5 = document.createElement("div");
      div5.innerHTML = svg2.trim();
      svg2 = div5.querySelector("svg");
    }
    const session = {
      context: graphicsContext,
      path: new GraphicsPath()
    };
    renderChildren(svg2, session, null, null);
    return graphicsContext;
  }
  function renderChildren(svg2, session, fillStyle, strokeStyle) {
    const children2 = svg2.children;
    const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg2);
    if (f1 && fillStyle) {
      fillStyle = { ...fillStyle, ...f1 };
    } else if (f1) {
      fillStyle = f1;
    }
    if (s1 && strokeStyle) {
      strokeStyle = { ...strokeStyle, ...s1 };
    } else if (s1) {
      strokeStyle = s1;
    }
    session.context.fillStyle = fillStyle;
    session.context.strokeStyle = strokeStyle;
    let x2;
    let y2;
    let x1;
    let y1;
    let x22;
    let y22;
    let cx;
    let cy;
    let r2;
    let rx;
    let ry;
    let points;
    let pointsString;
    let d2;
    let graphicsPath;
    let width8;
    let height8;
    switch (svg2.nodeName.toLowerCase()) {
      case "path":
        d2 = svg2.getAttribute("d");
        graphicsPath = new GraphicsPath(d2);
        session.context.path(graphicsPath);
        if (fillStyle)
          session.context.fill();
        if (strokeStyle)
          session.context.stroke();
        break;
      case "circle":
        cx = parseFloatAttribute(svg2, "cx", 0);
        cy = parseFloatAttribute(svg2, "cy", 0);
        r2 = parseFloatAttribute(svg2, "r", 0);
        session.context.ellipse(cx, cy, r2, r2);
        if (fillStyle)
          session.context.fill();
        if (strokeStyle)
          session.context.stroke();
        break;
      case "rect":
        x2 = parseFloatAttribute(svg2, "x", 0);
        y2 = parseFloatAttribute(svg2, "y", 0);
        width8 = parseFloatAttribute(svg2, "width", 0);
        height8 = parseFloatAttribute(svg2, "height", 0);
        rx = parseFloatAttribute(svg2, "rx", 0);
        ry = parseFloatAttribute(svg2, "ry", 0);
        if (rx || ry) {
          session.context.roundRect(x2, y2, width8, height8, rx || ry);
        } else {
          session.context.rect(x2, y2, width8, height8);
        }
        if (fillStyle)
          session.context.fill();
        if (strokeStyle)
          session.context.stroke();
        break;
      case "ellipse":
        cx = parseFloatAttribute(svg2, "cx", 0);
        cy = parseFloatAttribute(svg2, "cy", 0);
        rx = parseFloatAttribute(svg2, "rx", 0);
        ry = parseFloatAttribute(svg2, "ry", 0);
        session.context.beginPath();
        session.context.ellipse(cx, cy, rx, ry);
        if (fillStyle)
          session.context.fill();
        if (strokeStyle)
          session.context.stroke();
        break;
      case "line":
        x1 = parseFloatAttribute(svg2, "x1", 0);
        y1 = parseFloatAttribute(svg2, "y1", 0);
        x22 = parseFloatAttribute(svg2, "x2", 0);
        y22 = parseFloatAttribute(svg2, "y2", 0);
        session.context.beginPath();
        session.context.moveTo(x1, y1);
        session.context.lineTo(x22, y22);
        if (strokeStyle)
          session.context.stroke();
        break;
      case "polygon":
        pointsString = svg2.getAttribute("points");
        points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
        session.context.poly(points, true);
        if (fillStyle)
          session.context.fill();
        if (strokeStyle)
          session.context.stroke();
        break;
      case "polyline":
        pointsString = svg2.getAttribute("points");
        points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
        session.context.poly(points, false);
        if (strokeStyle)
          session.context.stroke();
        break;
      case "g":
      case "svg":
        break;
      default: {
        console.info(`[SVG parser] <${svg2.nodeName}> elements unsupported`);
        break;
      }
    }
    for (let i2 = 0; i2 < children2.length; i2++) {
      renderChildren(children2[i2], session, fillStyle, strokeStyle);
    }
  }
  function parseFloatAttribute(svg2, id5, defaultValue5) {
    const value12 = svg2.getAttribute(id5);
    return value12 ? Number(value12) : defaultValue5;
  }
  function parseStyle(svg2) {
    const style3 = svg2.getAttribute("style");
    const strokeStyle = {};
    const fillStyle = {};
    let useFill = false;
    let useStroke = false;
    if (style3) {
      const styleParts = style3.split(";");
      for (let i2 = 0; i2 < styleParts.length; i2++) {
        const stylePart = styleParts[i2];
        const [key, value12] = stylePart.split(":");
        switch (key) {
          case "stroke":
            if (value12 !== "none") {
              strokeStyle.color = Color.shared.setValue(value12).toNumber();
              useStroke = true;
            }
            break;
          case "stroke-width":
            strokeStyle.width = Number(value12);
            break;
          case "fill":
            if (value12 !== "none") {
              useFill = true;
              fillStyle.color = Color.shared.setValue(value12).toNumber();
            }
            break;
          case "fill-opacity":
            fillStyle.alpha = Number(value12);
            break;
          case "stroke-opacity":
            strokeStyle.alpha = Number(value12);
            break;
          case "opacity":
            fillStyle.alpha = Number(value12);
            strokeStyle.alpha = Number(value12);
            break;
        }
      }
    } else {
      const stroke = svg2.getAttribute("stroke");
      if (stroke && stroke !== "none") {
        useStroke = true;
        strokeStyle.color = Color.shared.setValue(stroke).toNumber();
        strokeStyle.width = parseFloatAttribute(svg2, "stroke-width", 1);
      }
      const fill2 = svg2.getAttribute("fill");
      if (fill2 && fill2 !== "none") {
        useFill = true;
        fillStyle.color = Color.shared.setValue(fill2).toNumber();
      }
    }
    return {
      strokeStyle: useStroke ? strokeStyle : null,
      fillStyle: useFill ? fillStyle : null
    };
  }
  var init_SVGParser = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs"() {
      init_Color();
      init_GraphicsPath();
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs
  function isColorLike(value12) {
    return Color.isColorLike(value12);
  }
  function isFillPattern(value12) {
    return value12 instanceof FillPattern;
  }
  function isFillGradient(value12) {
    return value12 instanceof FillGradient;
  }
  function handleColorLike(fill2, value12, defaultStyle) {
    const temp = Color.shared.setValue(value12 ?? 0);
    fill2.color = temp.toNumber();
    fill2.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;
    fill2.texture = Texture.WHITE;
    return { ...defaultStyle, ...fill2 };
  }
  function handleFillPattern(fill2, value12, defaultStyle) {
    fill2.fill = value12;
    fill2.color = 16777215;
    fill2.texture = value12.texture;
    fill2.matrix = value12.transform;
    return { ...defaultStyle, ...fill2 };
  }
  function handleFillGradient(fill2, value12, defaultStyle) {
    value12.buildLinearGradient();
    fill2.fill = value12;
    fill2.color = 16777215;
    fill2.texture = value12.texture;
    fill2.matrix = value12.transform;
    return { ...defaultStyle, ...fill2 };
  }
  function handleFillObject(value12, defaultStyle) {
    const style3 = { ...defaultStyle, ...value12 };
    if (style3.texture) {
      if (style3.texture !== Texture.WHITE) {
        const m2 = style3.matrix?.invert() || new Matrix();
        m2.translate(style3.texture.frame.x, style3.texture.frame.y);
        m2.scale(1 / style3.texture.source.width, 1 / style3.texture.source.height);
        style3.matrix = m2;
      }
      const sourceStyle = style3.texture.source.style;
      if (sourceStyle.addressMode === "clamp-to-edge") {
        sourceStyle.addressMode = "repeat";
        sourceStyle.update();
      }
    }
    const color = Color.shared.setValue(style3.color);
    style3.alpha *= color.alpha;
    style3.color = color.toNumber();
    style3.matrix = style3.matrix ? style3.matrix.clone() : null;
    return style3;
  }
  function toFillStyle(value12, defaultStyle) {
    if (value12 === void 0 || value12 === null) {
      return null;
    }
    const fill2 = {};
    const objectStyle = value12;
    if (isColorLike(value12)) {
      return handleColorLike(fill2, value12, defaultStyle);
    } else if (isFillPattern(value12)) {
      return handleFillPattern(fill2, value12, defaultStyle);
    } else if (isFillGradient(value12)) {
      return handleFillGradient(fill2, value12, defaultStyle);
    } else if (objectStyle.fill && isFillPattern(objectStyle.fill)) {
      return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);
    } else if (objectStyle.fill && isFillGradient(objectStyle.fill)) {
      return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);
    }
    return handleFillObject(objectStyle, defaultStyle);
  }
  function toStrokeStyle(value12, defaultStyle) {
    const { width: width8, alignment, miterLimit, cap, join: join2, ...rest } = defaultStyle;
    const fill2 = toFillStyle(value12, rest);
    if (!fill2) {
      return null;
    }
    return {
      width: width8,
      alignment,
      miterLimit,
      cap,
      join: join2,
      ...fill2
    };
  }
  var init_convertFillInputToFillStyle = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs"() {
      init_Color();
      init_Matrix();
      init_Texture();
      init_FillGradient();
      init_FillPattern();
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs
  var tmpPoint, tempMatrix3, _GraphicsContext, GraphicsContext;
  var init_GraphicsContext = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs"() {
      init_eventemitter3();
      init_Color();
      init_Matrix();
      init_Point();
      init_Texture();
      init_uid();
      init_deprecation();
      init_Bounds();
      init_GraphicsPath();
      init_SVGParser();
      init_convertFillInputToFillStyle();
      tmpPoint = new Point();
      tempMatrix3 = new Matrix();
      _GraphicsContext = class _GraphicsContext2 extends eventemitter3_default {
        constructor() {
          super(...arguments);
          this.uid = uid("graphicsContext");
          this.dirty = true;
          this.batchMode = "auto";
          this.instructions = [];
          this._activePath = new GraphicsPath();
          this._transform = new Matrix();
          this._fillStyle = { ..._GraphicsContext2.defaultFillStyle };
          this._strokeStyle = { ..._GraphicsContext2.defaultStrokeStyle };
          this._stateStack = [];
          this._tick = 0;
          this._bounds = new Bounds();
          this._boundsDirty = true;
        }
        /**
         * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,
         * including the current drawing state, transformations, styles, and instructions.
         * @returns A new GraphicsContext instance with the same properties and state as this one.
         */
        clone() {
          const clone = new _GraphicsContext2();
          clone.batchMode = this.batchMode;
          clone.instructions = this.instructions.slice();
          clone._activePath = this._activePath.clone();
          clone._transform = this._transform.clone();
          clone._fillStyle = { ...this._fillStyle };
          clone._strokeStyle = { ...this._strokeStyle };
          clone._stateStack = this._stateStack.slice();
          clone._bounds = this._bounds.clone();
          clone._boundsDirty = true;
          return clone;
        }
        /**
         * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.
         */
        get fillStyle() {
          return this._fillStyle;
        }
        set fillStyle(value12) {
          this._fillStyle = toFillStyle(value12, _GraphicsContext2.defaultFillStyle);
        }
        /**
         * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
         */
        get strokeStyle() {
          return this._strokeStyle;
        }
        set strokeStyle(value12) {
          this._strokeStyle = toStrokeStyle(value12, _GraphicsContext2.defaultStrokeStyle);
        }
        /**
         * Sets the current fill style of the graphics context. The fill style can be a color, gradient,
         * pattern, or a more complex style defined by a FillStyle object.
         * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,
         *                or a FillStyle or ConvertedFillStyle object.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        setFillStyle(style3) {
          this._fillStyle = toFillStyle(style3, _GraphicsContext2.defaultFillStyle);
          return this;
        }
        /**
         * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can
         * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
         * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,
         *                or a StrokeStyle or ConvertedStrokeStyle object.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        setStrokeStyle(style3) {
          this._strokeStyle = toFillStyle(style3, _GraphicsContext2.defaultStrokeStyle);
          return this;
        }
        texture(texture, tint, dx, dy, dw, dh) {
          this.instructions.push({
            action: "texture",
            data: {
              image: texture,
              dx: dx || 0,
              dy: dy || 0,
              dw: dw || texture.frame.width,
              dh: dh || texture.frame.height,
              transform: this._transform.clone(),
              alpha: this._fillStyle.alpha,
              style: tint ? Color.shared.setValue(tint).toNumber() : 16777215
            }
          });
          this.onUpdate();
          return this;
        }
        /**
         * Resets the current path. Any previous path and its commands are discarded and a new path is
         * started. This is typically called before beginning a new shape or series of drawing commands.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        beginPath() {
          this._activePath = new GraphicsPath();
          return this;
        }
        fill(style3, alpha) {
          let path2;
          const lastInstruction = this.instructions[this.instructions.length - 1];
          if (this._tick === 0 && lastInstruction && lastInstruction.action === "stroke") {
            path2 = lastInstruction.data.path;
          } else {
            path2 = this._activePath.clone();
          }
          if (!path2)
            return this;
          if (style3 != null) {
            if (alpha !== void 0 && typeof style3 === "number") {
              deprecation(v8_0_0, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead");
              style3 = { color: style3, alpha };
            }
            this._fillStyle = toFillStyle(style3, _GraphicsContext2.defaultFillStyle);
          }
          this.instructions.push({
            action: "fill",
            // TODO copy fill style!
            data: { style: this.fillStyle, path: path2 }
          });
          this.onUpdate();
          this._initNextPathLocation();
          this._tick = 0;
          return this;
        }
        _initNextPathLocation() {
          const { x: x2, y: y2 } = this._activePath.getLastPoint(Point.shared);
          this._activePath.clear();
          this._activePath.moveTo(x2, y2);
        }
        /**
         * Strokes the current path with the current stroke style. This method can take an optional
         * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.
         * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        stroke(style3) {
          let path2;
          const lastInstruction = this.instructions[this.instructions.length - 1];
          if (this._tick === 0 && lastInstruction && lastInstruction.action === "fill") {
            path2 = lastInstruction.data.path;
          } else {
            path2 = this._activePath.clone();
          }
          if (!path2)
            return this;
          if (style3 != null) {
            this._strokeStyle = toStrokeStyle(style3, _GraphicsContext2.defaultStrokeStyle);
          }
          this.instructions.push({
            action: "stroke",
            // TODO copy fill style!
            data: { style: this.strokeStyle, path: path2 }
          });
          this.onUpdate();
          this._initNextPathLocation();
          this._tick = 0;
          return this;
        }
        /**
         * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
         * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will
         * fail to cut correctly!
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        cut() {
          for (let i2 = 0; i2 < 2; i2++) {
            const lastInstruction = this.instructions[this.instructions.length - 1 - i2];
            const holePath = this._activePath.clone();
            if (lastInstruction) {
              if (lastInstruction.action === "stroke" || lastInstruction.action === "fill") {
                if (lastInstruction.data.hole) {
                  lastInstruction.data.hole.addPath(holePath);
                } else {
                  lastInstruction.data.hole = holePath;
                  break;
                }
              }
            }
          }
          this._initNextPathLocation();
          return this;
        }
        /**
         * Adds an arc to the current path, which is centered at (x, y) with the specified radius,
         * starting and ending angles, and direction.
         * @param x - The x-coordinate of the arc's center.
         * @param y - The y-coordinate of the arc's center.
         * @param radius - The arc's radius.
         * @param startAngle - The starting angle, in radians.
         * @param endAngle - The ending angle, in radians.
         * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        arc(x2, y2, radius, startAngle, endAngle, counterclockwise) {
          this._tick++;
          const t3 = this._transform;
          this._activePath.arc(
            t3.a * x2 + t3.c * y2 + t3.tx,
            t3.b * x2 + t3.d * y2 + t3.ty,
            radius,
            startAngle,
            endAngle,
            counterclockwise
          );
          return this;
        }
        /**
         * Adds an arc to the current path with the given control points and radius, connected to the previous point
         * by a straight line if necessary.
         * @param x1 - The x-coordinate of the first control point.
         * @param y1 - The y-coordinate of the first control point.
         * @param x2 - The x-coordinate of the second control point.
         * @param y2 - The y-coordinate of the second control point.
         * @param radius - The arc's radius.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        arcTo(x1, y1, x2, y2, radius) {
          this._tick++;
          const t3 = this._transform;
          this._activePath.arcTo(
            t3.a * x1 + t3.c * y1 + t3.tx,
            t3.b * x1 + t3.d * y1 + t3.ty,
            t3.a * x2 + t3.c * y2 + t3.tx,
            t3.b * x2 + t3.d * y2 + t3.ty,
            radius
          );
          return this;
        }
        /**
         * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
         * @param rx - The x-radius of the ellipse.
         * @param ry - The y-radius of the ellipse.
         * @param xAxisRotation - The rotation of the ellipse's x-axis relative
         * to the x-axis of the coordinate system, in degrees.
         * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
         * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
         * @param x - The x-coordinate of the arc's end point.
         * @param y - The y-coordinate of the arc's end point.
         * @returns The instance of the current object for chaining.
         */
        arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
          this._tick++;
          const t3 = this._transform;
          this._activePath.arcToSvg(
            rx,
            ry,
            xAxisRotation,
            // should we rotate this with transform??
            largeArcFlag,
            sweepFlag,
            t3.a * x2 + t3.c * y2 + t3.tx,
            t3.b * x2 + t3.d * y2 + t3.ty
          );
          return this;
        }
        /**
         * Adds a cubic Bezier curve to the path.
         * It requires three points: the first two are control points and the third one is the end point.
         * The starting point is the last point in the current path.
         * @param cp1x - The x-coordinate of the first control point.
         * @param cp1y - The y-coordinate of the first control point.
         * @param cp2x - The x-coordinate of the second control point.
         * @param cp2y - The y-coordinate of the second control point.
         * @param x - The x-coordinate of the end point.
         * @param y - The y-coordinate of the end point.
         * @param smoothness - Optional parameter to adjust the smoothness of the curve.
         * @returns The instance of the current object for chaining.
         */
        bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness) {
          this._tick++;
          const t3 = this._transform;
          this._activePath.bezierCurveTo(
            t3.a * cp1x + t3.c * cp1y + t3.tx,
            t3.b * cp1x + t3.d * cp1y + t3.ty,
            t3.a * cp2x + t3.c * cp2y + t3.tx,
            t3.b * cp2x + t3.d * cp2y + t3.ty,
            t3.a * x2 + t3.c * y2 + t3.tx,
            t3.b * x2 + t3.d * y2 + t3.ty,
            smoothness
          );
          return this;
        }
        /**
         * Closes the current path by drawing a straight line back to the start.
         * If the shape is already closed or there are no points in the path, this method does nothing.
         * @returns The instance of the current object for chaining.
         */
        closePath() {
          this._tick++;
          this._activePath?.closePath();
          return this;
        }
        /**
         * Draws an ellipse at the specified location and with the given x and y radii.
         * An optional transformation can be applied, allowing for rotation, scaling, and translation.
         * @param x - The x-coordinate of the center of the ellipse.
         * @param y - The y-coordinate of the center of the ellipse.
         * @param radiusX - The horizontal radius of the ellipse.
         * @param radiusY - The vertical radius of the ellipse.
         * @returns The instance of the current object for chaining.
         */
        ellipse(x2, y2, radiusX, radiusY) {
          this._tick++;
          this._activePath.ellipse(x2, y2, radiusX, radiusY, this._transform.clone());
          return this;
        }
        /**
         * Draws a circle shape. This method adds a new circle path to the current drawing.
         * @param x - The x-coordinate of the center of the circle.
         * @param y - The y-coordinate of the center of the circle.
         * @param radius - The radius of the circle.
         * @returns The instance of the current object for chaining.
         */
        circle(x2, y2, radius) {
          this._tick++;
          this._activePath.circle(x2, y2, radius, this._transform.clone());
          return this;
        }
        /**
         * Adds another `GraphicsPath` to this path, optionally applying a transformation.
         * @param path - The `GraphicsPath` to add.
         * @returns The instance of the current object for chaining.
         */
        path(path2) {
          this._tick++;
          this._activePath.addPath(path2, this._transform.clone());
          return this;
        }
        /**
         * Connects the current point to a new point with a straight line. This method updates the current path.
         * @param x - The x-coordinate of the new point to connect to.
         * @param y - The y-coordinate of the new point to connect to.
         * @returns The instance of the current object for chaining.
         */
        lineTo(x2, y2) {
          this._tick++;
          const t3 = this._transform;
          this._activePath.lineTo(
            t3.a * x2 + t3.c * y2 + t3.tx,
            t3.b * x2 + t3.d * y2 + t3.ty
          );
          return this;
        }
        /**
         * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
         * @param x - The x-coordinate for the starting point.
         * @param y - The y-coordinate for the starting point.
         * @returns The instance of the current object for chaining.
         */
        moveTo(x2, y2) {
          this._tick++;
          const t3 = this._transform;
          const instructions = this._activePath.instructions;
          const transformedX = t3.a * x2 + t3.c * y2 + t3.tx;
          const transformedY = t3.b * x2 + t3.d * y2 + t3.ty;
          if (instructions.length === 1 && instructions[0].action === "moveTo") {
            instructions[0].data[0] = transformedX;
            instructions[0].data[1] = transformedY;
            return this;
          }
          this._activePath.moveTo(
            transformedX,
            transformedY
          );
          return this;
        }
        /**
         * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
         * The starting point is the last point in the current path.
         * @param cpx - The x-coordinate of the control point.
         * @param cpy - The y-coordinate of the control point.
         * @param x - The x-coordinate of the end point.
         * @param y - The y-coordinate of the end point.
         * @param smoothness - Optional parameter to adjust the smoothness of the curve.
         * @returns The instance of the current object for chaining.
         */
        quadraticCurveTo(cpx, cpy, x2, y2, smoothness) {
          this._tick++;
          const t3 = this._transform;
          this._activePath.quadraticCurveTo(
            t3.a * cpx + t3.c * cpy + t3.tx,
            t3.b * cpx + t3.d * cpy + t3.ty,
            t3.a * x2 + t3.c * y2 + t3.tx,
            t3.b * x2 + t3.d * y2 + t3.ty,
            smoothness
          );
          return this;
        }
        /**
         * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
         * @param x - The x-coordinate of the top-left corner of the rectangle.
         * @param y - The y-coordinate of the top-left corner of the rectangle.
         * @param w - The width of the rectangle.
         * @param h - The height of the rectangle.
         * @returns The instance of the current object for chaining.
         */
        rect(x2, y2, w2, h2) {
          this._tick++;
          this._activePath.rect(x2, y2, w2, h2, this._transform.clone());
          return this;
        }
        /**
         * Draws a rectangle with rounded corners.
         * The corner radius can be specified to determine how rounded the corners should be.
         * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
         * @param x - The x-coordinate of the top-left corner of the rectangle.
         * @param y - The y-coordinate of the top-left corner of the rectangle.
         * @param w - The width of the rectangle.
         * @param h - The height of the rectangle.
         * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
         * @returns The instance of the current object for chaining.
         */
        roundRect(x2, y2, w2, h2, radius) {
          this._tick++;
          this._activePath.roundRect(x2, y2, w2, h2, radius, this._transform.clone());
          return this;
        }
        /**
         * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,
         * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,
         * rotated, or translated as needed.
         * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
         * representing the x and y coordinates, of the polygon's vertices, in sequence.
         * @param close - A boolean indicating whether to close the polygon path. True by default.
         */
        poly(points, close2) {
          this._tick++;
          this._activePath.poly(points, close2, this._transform.clone());
          return this;
        }
        /**
         * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
         * @param x - The x-coordinate of the center of the polygon.
         * @param y - The y-coordinate of the center of the polygon.
         * @param radius - The radius of the circumscribed circle of the polygon.
         * @param sides - The number of sides of the polygon. Must be 3 or more.
         * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
         * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
         * @returns The instance of the current object for chaining.
         */
        regularPoly(x2, y2, radius, sides, rotation = 0, transform2) {
          this._tick++;
          this._activePath.regularPoly(x2, y2, radius, sides, rotation, transform2);
          return this;
        }
        /**
         * Draws a polygon with rounded corners.
         * Similar to `regularPoly` but with the ability to round the corners of the polygon.
         * @param x - The x-coordinate of the center of the polygon.
         * @param y - The y-coordinate of the center of the polygon.
         * @param radius - The radius of the circumscribed circle of the polygon.
         * @param sides - The number of sides of the polygon. Must be 3 or more.
         * @param corner - The radius of the rounding of the corners.
         * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
         * @returns The instance of the current object for chaining.
         */
        roundPoly(x2, y2, radius, sides, corner, rotation) {
          this._tick++;
          this._activePath.roundPoly(x2, y2, radius, sides, corner, rotation);
          return this;
        }
        /**
         * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
         * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
         * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
         * A minimum of 3 points is required.
         * @param radius - The default radius for the corners.
         * This radius is applied to all corners unless overridden in `points`.
         * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
         *  method instead of an arc method. Defaults to false.
         * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
         * Higher values make the curve smoother.
         * @returns The instance of the current object for chaining.
         */
        roundShape(points, radius, useQuadratic, smoothness) {
          this._tick++;
          this._activePath.roundShape(points, radius, useQuadratic, smoothness);
          return this;
        }
        /**
         * Draw Rectangle with fillet corners. This is much like rounded rectangle
         * however it support negative numbers as well for the corner radius.
         * @param x - Upper left corner of rect
         * @param y - Upper right corner of rect
         * @param width - Width of rect
         * @param height - Height of rect
         * @param fillet - accept negative or positive values
         */
        filletRect(x2, y2, width8, height8, fillet) {
          this._tick++;
          this._activePath.filletRect(x2, y2, width8, height8, fillet);
          return this;
        }
        /**
         * Draw Rectangle with chamfer corners. These are angled corners.
         * @param x - Upper left corner of rect
         * @param y - Upper right corner of rect
         * @param width - Width of rect
         * @param height - Height of rect
         * @param chamfer - non-zero real number, size of corner cutout
         * @param transform
         */
        chamferRect(x2, y2, width8, height8, chamfer, transform2) {
          this._tick++;
          this._activePath.chamferRect(x2, y2, width8, height8, chamfer, transform2);
          return this;
        }
        /**
         * Draws a star shape centered at a specified location. This method allows for the creation
         *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
         * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
         * An optional transformation can be applied to scale, rotate, or translate the star as needed.
         * @param x - The x-coordinate of the center of the star.
         * @param y - The y-coordinate of the center of the star.
         * @param points - The number of points of the star.
         * @param radius - The outer radius of the star (distance from the center to the outer points).
         * @param innerRadius - Optional. The inner radius of the star
         * (distance from the center to the inner points between the outer points).
         * If not provided, defaults to half of the `radius`.
         * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
         * Defaults to 0, meaning one point is directly upward.
         * @returns The instance of the current object for chaining further drawing commands.
         */
        star(x2, y2, points, radius, innerRadius = 0, rotation = 0) {
          this._tick++;
          this._activePath.star(x2, y2, points, radius, innerRadius, rotation, this._transform.clone());
          return this;
        }
        /**
         * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths
         * defined in SVG format to be drawn within the graphics context.
         * @param svg - The SVG string to be parsed and rendered.
         */
        svg(svg2) {
          this._tick++;
          SVGParser(svg2, this);
          return this;
        }
        /**
         * Restores the most recently saved graphics state by popping the top of the graphics state stack.
         * This includes transformations, fill styles, and stroke styles.
         */
        restore() {
          const state4 = this._stateStack.pop();
          if (state4) {
            this._transform = state4.transform;
            this._fillStyle = state4.fillStyle;
            this._strokeStyle = state4.strokeStyle;
          }
          return this;
        }
        /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */
        save() {
          this._stateStack.push({
            transform: this._transform.clone(),
            fillStyle: { ...this._fillStyle },
            strokeStyle: { ...this._strokeStyle }
          });
          return this;
        }
        /**
         * Returns the current transformation matrix of the graphics context.
         * @returns The current transformation matrix.
         */
        getTransform() {
          return this._transform;
        }
        /**
         * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        resetTransform() {
          this._transform.identity();
          return this;
        }
        /**
         * Applies a rotation transformation to the graphics context around the current origin.
         * @param angle - The angle of rotation in radians.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        rotate(angle) {
          this._transform.rotate(angle);
          return this;
        }
        /**
         * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.
         * @param x - The scale factor in the horizontal direction.
         * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        scale(x2, y2 = x2) {
          this._transform.scale(x2, y2);
          return this;
        }
        setTransform(a2, b2, c2, d2, dx, dy) {
          if (a2 instanceof Matrix) {
            this._transform.set(a2.a, a2.b, a2.c, a2.d, a2.tx, a2.ty);
            return this;
          }
          this._transform.set(a2, b2, c2, d2, dx, dy);
          return this;
        }
        transform(a2, b2, c2, d2, dx, dy) {
          if (a2 instanceof Matrix) {
            this._transform.append(a2);
            return this;
          }
          tempMatrix3.set(a2, b2, c2, d2, dx, dy);
          this._transform.append(tempMatrix3);
          return this;
        }
        /**
         * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.
         * @param x - The amount to translate in the horizontal direction.
         * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        translate(x2, y2 = x2) {
          this._transform.translate(x2, y2);
          return this;
        }
        /**
         * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,
         * and optionally resetting transformations to the identity matrix.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        clear() {
          this._activePath.clear();
          this.instructions.length = 0;
          this.resetTransform();
          this.onUpdate();
          return this;
        }
        onUpdate() {
          if (this.dirty)
            return;
          this.emit("update", this, 16);
          this.dirty = true;
          this._boundsDirty = true;
        }
        /** The bounds of the graphic shape. */
        get bounds() {
          if (!this._boundsDirty)
            return this._bounds;
          const bounds = this._bounds;
          bounds.clear();
          for (let i2 = 0; i2 < this.instructions.length; i2++) {
            const instruction = this.instructions[i2];
            const action2 = instruction.action;
            if (action2 === "fill") {
              const data = instruction.data;
              bounds.addBounds(data.path.bounds);
            } else if (action2 === "texture") {
              const data = instruction.data;
              bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);
            }
            if (action2 === "stroke") {
              const data = instruction.data;
              const padding = data.style.width / 2;
              const _bounds = data.path.bounds;
              bounds.addFrame(
                _bounds.minX - padding,
                _bounds.minY - padding,
                _bounds.maxX + padding,
                _bounds.maxY + padding
              );
            }
          }
          return bounds;
        }
        /**
         * Check to see if a point is contained within this geometry.
         * @param point - Point to check if it's contained.
         * @returns {boolean} `true` if the point is contained within geometry.
         */
        containsPoint(point) {
          if (!this.bounds.containsPoint(point.x, point.y))
            return false;
          const instructions = this.instructions;
          let hasHit = false;
          for (let k2 = 0; k2 < instructions.length; k2++) {
            const instruction = instructions[k2];
            const data = instruction.data;
            const path2 = data.path;
            if (!instruction.action || !path2)
              continue;
            const style3 = data.style;
            const shapes = path2.shapePath.shapePrimitives;
            for (let i2 = 0; i2 < shapes.length; i2++) {
              const shape2 = shapes[i2].shape;
              if (!style3 || !shape2)
                continue;
              const transform2 = shapes[i2].transform;
              const transformedPoint = transform2 ? transform2.applyInverse(point, tmpPoint) : point;
              if (instruction.action === "fill") {
                hasHit = shape2.contains(transformedPoint.x, transformedPoint.y);
              } else {
                hasHit = shape2.strokeContains(transformedPoint.x, transformedPoint.y, style3.width);
              }
              const holes = data.hole;
              if (holes) {
                const holeShapes = holes.shapePath?.shapePrimitives;
                if (holeShapes) {
                  for (let j2 = 0; j2 < holeShapes.length; j2++) {
                    if (holeShapes[j2].shape.contains(transformedPoint.x, transformedPoint.y)) {
                      hasHit = false;
                    }
                  }
                }
              }
              if (hasHit) {
                return true;
              }
            }
          }
          return hasHit;
        }
        /**
         * Destroys the GraphicsData object.
         * @param options - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?
         * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?
         */
        destroy(options2 = false) {
          this._stateStack.length = 0;
          this._transform = null;
          this.emit("destroy", this);
          this.removeAllListeners();
          const destroyTexture = typeof options2 === "boolean" ? options2 : options2?.texture;
          if (destroyTexture) {
            const destroyTextureSource = typeof options2 === "boolean" ? options2 : options2?.textureSource;
            if (this._fillStyle.texture) {
              this._fillStyle.texture.destroy(destroyTextureSource);
            }
            if (this._strokeStyle.texture) {
              this._strokeStyle.texture.destroy(destroyTextureSource);
            }
          }
          this._fillStyle = null;
          this._strokeStyle = null;
          this.instructions = null;
          this._activePath = null;
          this._bounds = null;
          this._stateStack = null;
          this.customShader = null;
          this._transform = null;
        }
      };
      _GraphicsContext.defaultFillStyle = {
        /** The color to use for the fill. */
        color: 16777215,
        /** The alpha value to use for the fill. */
        alpha: 1,
        /** The texture to use for the fill. */
        texture: Texture.WHITE,
        /** The matrix to apply. */
        matrix: null,
        /** The fill pattern to use. */
        fill: null
      };
      _GraphicsContext.defaultStrokeStyle = {
        /** The width of the stroke. */
        width: 1,
        /** The color to use for the stroke. */
        color: 16777215,
        /** The alpha value to use for the stroke. */
        alpha: 1,
        /** The alignment of the stroke. */
        alignment: 0.5,
        /** The miter limit to use. */
        miterLimit: 10,
        /** The line cap style to use. */
        cap: "butt",
        /** The line join style to use. */
        join: "miter",
        /** The texture to use for the fill. */
        texture: Texture.WHITE,
        /** The matrix to apply. */
        matrix: null,
        /** The fill pattern to use. */
        fill: null
      };
      GraphicsContext = _GraphicsContext;
    }
  });

  // node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs
  function generateTextStyleKey(style3) {
    const key = [];
    let index6 = 0;
    for (let i2 = 0; i2 < valuesToIterateForKeys.length; i2++) {
      const prop = `_${valuesToIterateForKeys[i2]}`;
      key[index6++] = style3[prop];
    }
    index6 = addFillStyleKey(style3._fill, key, index6);
    index6 = addStokeStyleKey(style3._stroke, key, index6);
    index6 = addDropShadowKey(style3.dropShadow, key, index6);
    return key.join("-");
  }
  function addFillStyleKey(fillStyle, key, index6) {
    if (!fillStyle)
      return index6;
    key[index6++] = fillStyle.color;
    key[index6++] = fillStyle.alpha;
    key[index6++] = fillStyle.fill?.styleKey;
    return index6;
  }
  function addStokeStyleKey(strokeStyle, key, index6) {
    if (!strokeStyle)
      return index6;
    index6 = addFillStyleKey(strokeStyle, key, index6);
    key[index6++] = strokeStyle.width;
    key[index6++] = strokeStyle.alignment;
    key[index6++] = strokeStyle.cap;
    key[index6++] = strokeStyle.join;
    key[index6++] = strokeStyle.miterLimit;
    return index6;
  }
  function addDropShadowKey(dropShadow, key, index6) {
    if (!dropShadow)
      return index6;
    key[index6++] = dropShadow.alpha;
    key[index6++] = dropShadow.angle;
    key[index6++] = dropShadow.blur;
    key[index6++] = dropShadow.distance;
    key[index6++] = Color.shared.setValue(dropShadow.color).toNumber();
    return index6;
  }
  var valuesToIterateForKeys;
  var init_generateTextStyleKey = __esm({
    "node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs"() {
      init_Color();
      valuesToIterateForKeys = [
        "align",
        "breakWords",
        "cssOverrides",
        "fontVariant",
        "fontWeight",
        "leading",
        "letterSpacing",
        "lineHeight",
        "padding",
        "textBaseline",
        "trim",
        "whiteSpace",
        "wordWrap",
        "wordWrapWidth",
        "fontFamily",
        "fontStyle",
        "fontSize"
      ];
    }
  });

  // node_modules/pixi.js/lib/scene/text/TextStyle.mjs
  function convertV7Tov8Style(style3) {
    const oldStyle = style3;
    if (typeof oldStyle.dropShadow === "boolean" && oldStyle.dropShadow) {
      const defaults3 = TextStyle.defaultDropShadow;
      style3.dropShadow = {
        alpha: oldStyle.dropShadowAlpha ?? defaults3.alpha,
        angle: oldStyle.dropShadowAngle ?? defaults3.angle,
        blur: oldStyle.dropShadowBlur ?? defaults3.blur,
        color: oldStyle.dropShadowColor ?? defaults3.color,
        distance: oldStyle.dropShadowDistance ?? defaults3.distance
      };
    }
    if (oldStyle.strokeThickness !== void 0) {
      deprecation(v8_0_0, "strokeThickness is now a part of stroke");
      const color = oldStyle.stroke;
      let obj = {};
      if (Color.isColorLike(color)) {
        obj.color = color;
      } else if (color instanceof FillGradient || color instanceof FillPattern) {
        obj.fill = color;
      } else if (Object.hasOwnProperty.call(color, "color") || Object.hasOwnProperty.call(color, "fill")) {
        obj = color;
      } else {
        throw new Error("Invalid stroke value.");
      }
      style3.stroke = {
        ...obj,
        width: oldStyle.strokeThickness
      };
    }
    if (Array.isArray(oldStyle.fillGradientStops)) {
      deprecation(v8_0_0, "gradient fill is now a fill pattern: `new FillGradient(...)`");
      let fontSize;
      if (style3.fontSize == null) {
        style3.fontSize = TextStyle.defaultTextStyle.fontSize;
      } else if (typeof style3.fontSize === "string") {
        fontSize = parseInt(style3.fontSize, 10);
      } else {
        fontSize = style3.fontSize;
      }
      const gradientFill = new FillGradient(0, 0, 0, fontSize * 1.7);
      const fills = oldStyle.fillGradientStops.map((color) => Color.shared.setValue(color).toNumber());
      fills.forEach((number2, index6) => {
        const ratio = index6 / (fills.length - 1);
        gradientFill.addColorStop(ratio, number2);
      });
      style3.fill = {
        fill: gradientFill
      };
    }
  }
  var _TextStyle, TextStyle;
  var init_TextStyle = __esm({
    "node_modules/pixi.js/lib/scene/text/TextStyle.mjs"() {
      init_eventemitter3();
      init_Color();
      init_deprecation();
      init_FillGradient();
      init_FillPattern();
      init_GraphicsContext();
      init_convertFillInputToFillStyle();
      init_generateTextStyleKey();
      _TextStyle = class _TextStyle2 extends eventemitter3_default {
        constructor(style3 = {}) {
          super();
          convertV7Tov8Style(style3);
          const fullStyle = { ..._TextStyle2.defaultTextStyle, ...style3 };
          for (const key in fullStyle) {
            const thisKey = key;
            this[thisKey] = fullStyle[key];
          }
          this.update();
        }
        /**
         * Alignment for multiline text, does not affect single line text.
         * @member {'left'|'center'|'right'|'justify'}
         */
        get align() {
          return this._align;
        }
        set align(value12) {
          this._align = value12;
          this.update();
        }
        /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */
        get breakWords() {
          return this._breakWords;
        }
        set breakWords(value12) {
          this._breakWords = value12;
          this.update();
        }
        /** Set a drop shadow for the text. */
        get dropShadow() {
          return this._dropShadow;
        }
        set dropShadow(value12) {
          if (value12 !== null && typeof value12 === "object") {
            this._dropShadow = this._createProxy({ ..._TextStyle2.defaultDropShadow, ...value12 });
          } else {
            this._dropShadow = value12 ? this._createProxy({ ..._TextStyle2.defaultDropShadow }) : null;
          }
          this.update();
        }
        /** The font family, can be a single font name, or a list of names where the first is the preferred font. */
        get fontFamily() {
          return this._fontFamily;
        }
        set fontFamily(value12) {
          this._fontFamily = value12;
          this.update();
        }
        /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */
        get fontSize() {
          return this._fontSize;
        }
        set fontSize(value12) {
          if (typeof value12 === "string") {
            this._fontSize = parseInt(value12, 10);
          } else {
            this._fontSize = value12;
          }
          this.update();
        }
        /**
         * The font style.
         * @member {'normal'|'italic'|'oblique'}
         */
        get fontStyle() {
          return this._fontStyle;
        }
        set fontStyle(value12) {
          this._fontStyle = value12.toLowerCase();
          this.update();
        }
        /**
         * The font variant.
         * @member {'normal'|'small-caps'}
         */
        get fontVariant() {
          return this._fontVariant;
        }
        set fontVariant(value12) {
          this._fontVariant = value12;
          this.update();
        }
        /**
         * The font weight.
         * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
         */
        get fontWeight() {
          return this._fontWeight;
        }
        set fontWeight(value12) {
          this._fontWeight = value12;
          this.update();
        }
        /** The space between lines. */
        get leading() {
          return this._leading;
        }
        set leading(value12) {
          this._leading = value12;
          this.update();
        }
        /** The amount of spacing between letters, default is 0. */
        get letterSpacing() {
          return this._letterSpacing;
        }
        set letterSpacing(value12) {
          this._letterSpacing = value12;
          this.update();
        }
        /** The line height, a number that represents the vertical space that a letter uses. */
        get lineHeight() {
          return this._lineHeight;
        }
        set lineHeight(value12) {
          this._lineHeight = value12;
          this.update();
        }
        /**
         * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
         * by adding padding to all sides of the text.
         */
        get padding() {
          return this._padding;
        }
        set padding(value12) {
          this._padding = value12;
          this.update();
        }
        /** Trim transparent borders. This is an expensive operation so only use this if you have to! */
        get trim() {
          return this._trim;
        }
        set trim(value12) {
          this._trim = value12;
          this.update();
        }
        /**
         * The baseline of the text that is rendered.
         * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
         */
        get textBaseline() {
          return this._textBaseline;
        }
        set textBaseline(value12) {
          this._textBaseline = value12;
          this.update();
        }
        /**
         * How newlines and spaces should be handled.
         * Default is 'pre' (preserve, preserve).
         *
         *  value       | New lines     |   Spaces
         *  ---         | ---           |   ---
         * 'normal'     | Collapse      |   Collapse
         * 'pre'        | Preserve      |   Preserve
         * 'pre-line'   | Preserve      |   Collapse
         * @member {'normal'|'pre'|'pre-line'}
         */
        get whiteSpace() {
          return this._whiteSpace;
        }
        set whiteSpace(value12) {
          this._whiteSpace = value12;
          this.update();
        }
        /** Indicates if word wrap should be used. */
        get wordWrap() {
          return this._wordWrap;
        }
        set wordWrap(value12) {
          this._wordWrap = value12;
          this.update();
        }
        /** The width at which text will wrap, it needs wordWrap to be set to true. */
        get wordWrapWidth() {
          return this._wordWrapWidth;
        }
        set wordWrapWidth(value12) {
          this._wordWrapWidth = value12;
          this.update();
        }
        /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */
        get fill() {
          return this._originalFill;
        }
        set fill(value12) {
          if (value12 === this._originalFill)
            return;
          this._originalFill = value12;
          if (this._isFillStyle(value12)) {
            this._originalFill = this._createProxy({ ...GraphicsContext.defaultFillStyle, ...value12 }, () => {
              this._fill = toFillStyle(
                { ...this._originalFill },
                GraphicsContext.defaultFillStyle
              );
            });
          }
          this._fill = toFillStyle(
            value12 === 0 ? "black" : value12,
            GraphicsContext.defaultFillStyle
          );
          this.update();
        }
        /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */
        get stroke() {
          return this._originalStroke;
        }
        set stroke(value12) {
          if (value12 === this._originalStroke)
            return;
          this._originalStroke = value12;
          if (this._isFillStyle(value12)) {
            this._originalStroke = this._createProxy({ ...GraphicsContext.defaultStrokeStyle, ...value12 }, () => {
              this._stroke = toStrokeStyle(
                { ...this._originalStroke },
                GraphicsContext.defaultStrokeStyle
              );
            });
          }
          this._stroke = toStrokeStyle(value12, GraphicsContext.defaultStrokeStyle);
          this.update();
        }
        _generateKey() {
          this._styleKey = generateTextStyleKey(this);
          return this._styleKey;
        }
        update() {
          this._styleKey = null;
          this.emit("update", this);
        }
        /** Resets all properties to the default values */
        reset() {
          const defaultStyle = _TextStyle2.defaultTextStyle;
          for (const key in defaultStyle) {
            this[key] = defaultStyle[key];
          }
        }
        get styleKey() {
          return this._styleKey || this._generateKey();
        }
        /**
         * Creates a new TextStyle object with the same values as this one.
         * @returns New cloned TextStyle object
         */
        clone() {
          return new _TextStyle2({
            align: this.align,
            breakWords: this.breakWords,
            dropShadow: this._dropShadow ? { ...this._dropShadow } : null,
            fill: this._fill,
            fontFamily: this.fontFamily,
            fontSize: this.fontSize,
            fontStyle: this.fontStyle,
            fontVariant: this.fontVariant,
            fontWeight: this.fontWeight,
            leading: this.leading,
            letterSpacing: this.letterSpacing,
            lineHeight: this.lineHeight,
            padding: this.padding,
            stroke: this._stroke,
            textBaseline: this.textBaseline,
            whiteSpace: this.whiteSpace,
            wordWrap: this.wordWrap,
            wordWrapWidth: this.wordWrapWidth
          });
        }
        /**
         * Destroys this text style.
         * @param options - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style
         * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style
         */
        destroy(options2 = false) {
          this.removeAllListeners();
          const destroyTexture = typeof options2 === "boolean" ? options2 : options2?.texture;
          if (destroyTexture) {
            const destroyTextureSource = typeof options2 === "boolean" ? options2 : options2?.textureSource;
            if (this._fill?.texture) {
              this._fill.texture.destroy(destroyTextureSource);
            }
            if (this._originalFill?.texture) {
              this._originalFill.texture.destroy(destroyTextureSource);
            }
            if (this._stroke?.texture) {
              this._stroke.texture.destroy(destroyTextureSource);
            }
            if (this._originalStroke?.texture) {
              this._originalStroke.texture.destroy(destroyTextureSource);
            }
          }
          this._fill = null;
          this._stroke = null;
          this.dropShadow = null;
          this._originalStroke = null;
          this._originalFill = null;
        }
        _createProxy(value12, cb) {
          return new Proxy(value12, {
            set: (target5, property, newValue) => {
              target5[property] = newValue;
              cb?.(property, newValue);
              this.update();
              return true;
            }
          });
        }
        _isFillStyle(value12) {
          return (value12 ?? null) !== null && !(Color.isColorLike(value12) || value12 instanceof FillGradient || value12 instanceof FillPattern);
        }
      };
      _TextStyle.defaultDropShadow = {
        /** Set alpha for the drop shadow */
        alpha: 1,
        /** Set a angle of the drop shadow */
        angle: Math.PI / 6,
        /** Set a shadow blur radius */
        blur: 0,
        /** A fill style to be used on the  e.g., 'red', '#00FF00' */
        color: "black",
        /** Set a distance of the drop shadow */
        distance: 5
      };
      _TextStyle.defaultTextStyle = {
        /**
         * See {@link TextStyle.align}
         * @type {'left'|'center'|'right'|'justify'}
         */
        align: "left",
        /** See {@link TextStyle.breakWords} */
        breakWords: false,
        /** See {@link TextStyle.dropShadow} */
        dropShadow: null,
        /**
         * See {@link TextStyle.fill}
         * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
         */
        fill: "black",
        /**
         * See {@link TextStyle.fontFamily}
         * @type {string|string[]}
         */
        fontFamily: "Arial",
        /**
         * See {@link TextStyle.fontSize}
         * @type {number|string}
         */
        fontSize: 26,
        /**
         * See {@link TextStyle.fontStyle}
         * @type {'normal'|'italic'|'oblique'}
         */
        fontStyle: "normal",
        /**
         * See {@link TextStyle.fontVariant}
         * @type {'normal'|'small-caps'}
         */
        fontVariant: "normal",
        /**
         * See {@link TextStyle.fontWeight}
         * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
         */
        fontWeight: "normal",
        /** See {@link TextStyle.leading} */
        leading: 0,
        /** See {@link TextStyle.letterSpacing} */
        letterSpacing: 0,
        /** See {@link TextStyle.lineHeight} */
        lineHeight: 0,
        /** See {@link TextStyle.padding} */
        padding: 0,
        /**
         * See {@link TextStyle.stroke}
         * @type {string|number}
         */
        stroke: null,
        /**
         * See {@link TextStyle.textBaseline}
         * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
         */
        textBaseline: "alphabetic",
        /** See {@link TextStyle.trim} */
        trim: false,
        /**
         * See {@link TextStyle.whiteSpace}
         * @type {'normal'|'pre'|'pre-line'}
         */
        whiteSpace: "pre",
        /** See {@link TextStyle.wordWrap} */
        wordWrap: false,
        /** See {@link TextStyle.wordWrapWidth} */
        wordWrapWidth: 100
      };
      TextStyle = _TextStyle;
    }
  });

  // node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs
  function getPo2TextureFromSource(image, width8, height8, resolution) {
    const bounds = tempBounds2;
    bounds.minX = 0;
    bounds.minY = 0;
    bounds.maxX = image.width / resolution | 0;
    bounds.maxY = image.height / resolution | 0;
    const texture = TexturePool.getOptimalTexture(
      bounds.width,
      bounds.height,
      resolution,
      false
    );
    texture.source.uploadMethodId = "image";
    texture.source.resource = image;
    texture.source.alphaMode = "premultiply-alpha-on-upload";
    texture.frame.width = width8 / resolution;
    texture.frame.height = height8 / resolution;
    texture.source.emit("update", texture.source);
    texture.updateUvs();
    return texture;
  }
  var tempBounds2;
  var init_getPo2TextureFromSource = __esm({
    "node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs"() {
      init_TexturePool();
      init_Bounds();
      tempBounds2 = new Bounds();
    }
  });

  // node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs
  function fontStringFromTextStyle(style3) {
    const fontSizeString = typeof style3.fontSize === "number" ? `${style3.fontSize}px` : style3.fontSize;
    let fontFamilies = style3.fontFamily;
    if (!Array.isArray(style3.fontFamily)) {
      fontFamilies = style3.fontFamily.split(",");
    }
    for (let i2 = fontFamilies.length - 1; i2 >= 0; i2--) {
      let fontFamily = fontFamilies[i2].trim();
      if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {
        fontFamily = `"${fontFamily}"`;
      }
      fontFamilies[i2] = fontFamily;
    }
    return `${style3.fontStyle} ${style3.fontVariant} ${style3.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
  }
  var genericFontFamilies;
  var init_fontStringFromTextStyle = __esm({
    "node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs"() {
      "use strict";
      genericFontFamilies = [
        "serif",
        "sans-serif",
        "monospace",
        "cursive",
        "fantasy",
        "system-ui"
      ];
    }
  });

  // node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs
  var contextSettings, _CanvasTextMetrics, CanvasTextMetrics;
  var init_CanvasTextMetrics = __esm({
    "node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs"() {
      init_adapter();
      init_fontStringFromTextStyle();
      contextSettings = {
        // TextMetrics requires getImageData readback for measuring fonts.
        willReadFrequently: true
      };
      _CanvasTextMetrics = class _CanvasTextMetrics2 {
        /**
         * Checking that we can use modern canvas 2D API.
         *
         * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.
         * @see TextMetrics.experimentalLetterSpacing
         * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing
         * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441
         */
        static get experimentalLetterSpacingSupported() {
          let result = _CanvasTextMetrics2._experimentalLetterSpacingSupported;
          if (result !== void 0) {
            const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;
            result = _CanvasTextMetrics2._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
          }
          return result;
        }
        /**
         * @param text - the text that was measured
         * @param style - the style that was measured
         * @param width - the measured width of the text
         * @param height - the measured height of the text
         * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style
         * @param lineWidths - an array of the line widths for each line matched to `lines`
         * @param lineHeight - the measured line height for this style
         * @param maxLineWidth - the maximum line width for all measured lines
         * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont
         */
        constructor(text6, style3, width8, height8, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
          this.text = text6;
          this.style = style3;
          this.width = width8;
          this.height = height8;
          this.lines = lines;
          this.lineWidths = lineWidths;
          this.lineHeight = lineHeight;
          this.maxLineWidth = maxLineWidth;
          this.fontProperties = fontProperties;
        }
        /**
         * Measures the supplied string of text and returns a Rectangle.
         * @param text - The text to measure.
         * @param style - The text style to use for measuring
         * @param canvas - optional specification of the canvas to use for measuring.
         * @param wordWrap
         * @returns Measured width and height of the text.
         */
        static measureText(text6 = " ", style3, canvas2 = _CanvasTextMetrics2._canvas, wordWrap = style3.wordWrap) {
          const textKey = `${text6}:${style3.styleKey}`;
          if (_CanvasTextMetrics2._measurementCache[textKey])
            return _CanvasTextMetrics2._measurementCache[textKey];
          const font = fontStringFromTextStyle(style3);
          const fontProperties = _CanvasTextMetrics2.measureFont(font);
          if (fontProperties.fontSize === 0) {
            fontProperties.fontSize = style3.fontSize;
            fontProperties.ascent = style3.fontSize;
          }
          const context3 = _CanvasTextMetrics2.__context;
          context3.font = font;
          const outputText = wordWrap ? _CanvasTextMetrics2._wordWrap(text6, style3, canvas2) : text6;
          const lines = outputText.split(/(?:\r\n|\r|\n)/);
          const lineWidths = new Array(lines.length);
          let maxLineWidth = 0;
          for (let i2 = 0; i2 < lines.length; i2++) {
            const lineWidth = _CanvasTextMetrics2._measureText(lines[i2], style3.letterSpacing, context3);
            lineWidths[i2] = lineWidth;
            maxLineWidth = Math.max(maxLineWidth, lineWidth);
          }
          const strokeWidth = style3._stroke?.width || 0;
          let width8 = maxLineWidth + strokeWidth;
          if (style3.dropShadow) {
            width8 += style3.dropShadow.distance;
          }
          const lineHeight = style3.lineHeight || fontProperties.fontSize;
          let height8 = Math.max(lineHeight, fontProperties.fontSize + strokeWidth) + (lines.length - 1) * (lineHeight + style3.leading);
          if (style3.dropShadow) {
            height8 += style3.dropShadow.distance;
          }
          const measurements = new _CanvasTextMetrics2(
            text6,
            style3,
            width8,
            height8,
            lines,
            lineWidths,
            lineHeight + style3.leading,
            maxLineWidth,
            fontProperties
          );
          return measurements;
        }
        static _measureText(text6, letterSpacing, context3) {
          let useExperimentalLetterSpacing = false;
          if (_CanvasTextMetrics2.experimentalLetterSpacingSupported) {
            if (_CanvasTextMetrics2.experimentalLetterSpacing) {
              context3.letterSpacing = `${letterSpacing}px`;
              context3.textLetterSpacing = `${letterSpacing}px`;
              useExperimentalLetterSpacing = true;
            } else {
              context3.letterSpacing = "0px";
              context3.textLetterSpacing = "0px";
            }
          }
          const metrics = context3.measureText(text6);
          let metricWidth = metrics.width;
          const actualBoundingBoxLeft = -metrics.actualBoundingBoxLeft;
          const actualBoundingBoxRight = metrics.actualBoundingBoxRight;
          let boundsWidth = actualBoundingBoxRight - actualBoundingBoxLeft;
          if (metricWidth > 0) {
            if (useExperimentalLetterSpacing) {
              metricWidth -= letterSpacing;
              boundsWidth -= letterSpacing;
            } else {
              const val = (_CanvasTextMetrics2.graphemeSegmenter(text6).length - 1) * letterSpacing;
              metricWidth += val;
              boundsWidth += val;
            }
          }
          return Math.max(metricWidth, boundsWidth);
        }
        /**
         * Applies newlines to a string to have it optimally fit into the horizontal
         * bounds set by the Text object's wordWrapWidth property.
         * @param text - String to apply word wrapping to
         * @param style - the style to use when wrapping
         * @param canvas - optional specification of the canvas to use for measuring.
         * @returns New string with new lines applied where required
         */
        static _wordWrap(text6, style3, canvas2 = _CanvasTextMetrics2._canvas) {
          const context3 = canvas2.getContext("2d", contextSettings);
          let width8 = 0;
          let line = "";
          let lines = "";
          const cache2 = /* @__PURE__ */ Object.create(null);
          const { letterSpacing, whiteSpace } = style3;
          const collapseSpaces = _CanvasTextMetrics2._collapseSpaces(whiteSpace);
          const collapseNewlines = _CanvasTextMetrics2._collapseNewlines(whiteSpace);
          let canPrependSpaces = !collapseSpaces;
          const wordWrapWidth = style3.wordWrapWidth + letterSpacing;
          const tokens = _CanvasTextMetrics2._tokenize(text6);
          for (let i2 = 0; i2 < tokens.length; i2++) {
            let token = tokens[i2];
            if (_CanvasTextMetrics2._isNewline(token)) {
              if (!collapseNewlines) {
                lines += _CanvasTextMetrics2._addLine(line);
                canPrependSpaces = !collapseSpaces;
                line = "";
                width8 = 0;
                continue;
              }
              token = " ";
            }
            if (collapseSpaces) {
              const currIsBreakingSpace = _CanvasTextMetrics2.isBreakingSpace(token);
              const lastIsBreakingSpace = _CanvasTextMetrics2.isBreakingSpace(line[line.length - 1]);
              if (currIsBreakingSpace && lastIsBreakingSpace) {
                continue;
              }
            }
            const tokenWidth = _CanvasTextMetrics2._getFromCache(token, letterSpacing, cache2, context3);
            if (tokenWidth > wordWrapWidth) {
              if (line !== "") {
                lines += _CanvasTextMetrics2._addLine(line);
                line = "";
                width8 = 0;
              }
              if (_CanvasTextMetrics2.canBreakWords(token, style3.breakWords)) {
                const characters = _CanvasTextMetrics2.wordWrapSplit(token);
                for (let j2 = 0; j2 < characters.length; j2++) {
                  let char2 = characters[j2];
                  let lastChar = char2;
                  let k2 = 1;
                  while (characters[j2 + k2]) {
                    const nextChar2 = characters[j2 + k2];
                    if (!_CanvasTextMetrics2.canBreakChars(lastChar, nextChar2, token, j2, style3.breakWords)) {
                      char2 += nextChar2;
                    } else {
                      break;
                    }
                    lastChar = nextChar2;
                    k2++;
                  }
                  j2 += k2 - 1;
                  const characterWidth = _CanvasTextMetrics2._getFromCache(char2, letterSpacing, cache2, context3);
                  if (characterWidth + width8 > wordWrapWidth) {
                    lines += _CanvasTextMetrics2._addLine(line);
                    canPrependSpaces = false;
                    line = "";
                    width8 = 0;
                  }
                  line += char2;
                  width8 += characterWidth;
                }
              } else {
                if (line.length > 0) {
                  lines += _CanvasTextMetrics2._addLine(line);
                  line = "";
                  width8 = 0;
                }
                const isLastToken = i2 === tokens.length - 1;
                lines += _CanvasTextMetrics2._addLine(token, !isLastToken);
                canPrependSpaces = false;
                line = "";
                width8 = 0;
              }
            } else {
              if (tokenWidth + width8 > wordWrapWidth) {
                canPrependSpaces = false;
                lines += _CanvasTextMetrics2._addLine(line);
                line = "";
                width8 = 0;
              }
              if (line.length > 0 || !_CanvasTextMetrics2.isBreakingSpace(token) || canPrependSpaces) {
                line += token;
                width8 += tokenWidth;
              }
            }
          }
          lines += _CanvasTextMetrics2._addLine(line, false);
          return lines;
        }
        /**
         * Convenience function for logging each line added during the wordWrap method.
         * @param line    - The line of text to add
         * @param newLine - Add new line character to end
         * @returns A formatted line
         */
        static _addLine(line, newLine = true) {
          line = _CanvasTextMetrics2._trimRight(line);
          line = newLine ? `${line}
` : line;
          return line;
        }
        /**
         * Gets & sets the widths of calculated characters in a cache object
         * @param key            - The key
         * @param letterSpacing  - The letter spacing
         * @param cache          - The cache
         * @param context        - The canvas context
         * @returns The from cache.
         */
        static _getFromCache(key, letterSpacing, cache2, context3) {
          let width8 = cache2[key];
          if (typeof width8 !== "number") {
            width8 = _CanvasTextMetrics2._measureText(key, letterSpacing, context3) + letterSpacing;
            cache2[key] = width8;
          }
          return width8;
        }
        /**
         * Determines whether we should collapse breaking spaces.
         * @param whiteSpace - The TextStyle property whiteSpace
         * @returns Should collapse
         */
        static _collapseSpaces(whiteSpace) {
          return whiteSpace === "normal" || whiteSpace === "pre-line";
        }
        /**
         * Determines whether we should collapse newLine chars.
         * @param whiteSpace - The white space
         * @returns should collapse
         */
        static _collapseNewlines(whiteSpace) {
          return whiteSpace === "normal";
        }
        /**
         * Trims breaking whitespaces from string.
         * @param text - The text
         * @returns Trimmed string
         */
        static _trimRight(text6) {
          if (typeof text6 !== "string") {
            return "";
          }
          for (let i2 = text6.length - 1; i2 >= 0; i2--) {
            const char2 = text6[i2];
            if (!_CanvasTextMetrics2.isBreakingSpace(char2)) {
              break;
            }
            text6 = text6.slice(0, -1);
          }
          return text6;
        }
        /**
         * Determines if char is a newline.
         * @param char - The character
         * @returns True if newline, False otherwise.
         */
        static _isNewline(char2) {
          if (typeof char2 !== "string") {
            return false;
          }
          return _CanvasTextMetrics2._newlines.includes(char2.charCodeAt(0));
        }
        /**
         * Determines if char is a breaking whitespace.
         *
         * It allows one to determine whether char should be a breaking whitespace
         * For example certain characters in CJK langs or numbers.
         * It must return a boolean.
         * @param char - The character
         * @param [_nextChar] - The next character
         * @returns True if whitespace, False otherwise.
         */
        static isBreakingSpace(char2, _nextChar) {
          if (typeof char2 !== "string") {
            return false;
          }
          return _CanvasTextMetrics2._breakingSpaces.includes(char2.charCodeAt(0));
        }
        /**
         * Splits a string into words, breaking-spaces and newLine characters
         * @param text - The text
         * @returns A tokenized array
         */
        static _tokenize(text6) {
          const tokens = [];
          let token = "";
          if (typeof text6 !== "string") {
            return tokens;
          }
          for (let i2 = 0; i2 < text6.length; i2++) {
            const char2 = text6[i2];
            const nextChar2 = text6[i2 + 1];
            if (_CanvasTextMetrics2.isBreakingSpace(char2, nextChar2) || _CanvasTextMetrics2._isNewline(char2)) {
              if (token !== "") {
                tokens.push(token);
                token = "";
              }
              tokens.push(char2);
              continue;
            }
            token += char2;
          }
          if (token !== "") {
            tokens.push(token);
          }
          return tokens;
        }
        /**
         * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
         *
         * It allows one to customise which words should break
         * Examples are if the token is CJK or numbers.
         * It must return a boolean.
         * @param _token - The token
         * @param breakWords - The style attr break words
         * @returns Whether to break word or not
         */
        static canBreakWords(_token, breakWords) {
          return breakWords;
        }
        /**
         * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
         *
         * It allows one to determine whether a pair of characters
         * should be broken by newlines
         * For example certain characters in CJK langs or numbers.
         * It must return a boolean.
         * @param _char - The character
         * @param _nextChar - The next character
         * @param _token - The token/word the characters are from
         * @param _index - The index in the token of the char
         * @param _breakWords - The style attr break words
         * @returns whether to break word or not
         */
        static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
          return true;
        }
        /**
         * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
         *
         * It is called when a token (usually a word) has to be split into separate pieces
         * in order to determine the point to break a word.
         * It must return an array of characters.
         * @param token - The token to split
         * @returns The characters of the token
         * @see CanvasTextMetrics.graphemeSegmenter
         */
        static wordWrapSplit(token) {
          return _CanvasTextMetrics2.graphemeSegmenter(token);
        }
        /**
         * Calculates the ascent, descent and fontSize of a given font-style
         * @param font - String representing the style of the font
         * @returns Font properties object
         */
        static measureFont(font) {
          if (_CanvasTextMetrics2._fonts[font]) {
            return _CanvasTextMetrics2._fonts[font];
          }
          const context3 = _CanvasTextMetrics2._context;
          context3.font = font;
          const metrics = context3.measureText(_CanvasTextMetrics2.METRICS_STRING + _CanvasTextMetrics2.BASELINE_SYMBOL);
          const properties = {
            ascent: metrics.actualBoundingBoxAscent,
            descent: metrics.actualBoundingBoxDescent,
            fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
          };
          _CanvasTextMetrics2._fonts[font] = properties;
          return properties;
        }
        /**
         * Clear font metrics in metrics cache.
         * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
         */
        static clearMetrics(font = "") {
          if (font) {
            delete _CanvasTextMetrics2._fonts[font];
          } else {
            _CanvasTextMetrics2._fonts = {};
          }
        }
        /**
         * Cached canvas element for measuring text
         * TODO: this should be private, but isn't because of backward compat, will fix later.
         * @ignore
         */
        static get _canvas() {
          if (!_CanvasTextMetrics2.__canvas) {
            let canvas2;
            try {
              const c2 = new OffscreenCanvas(0, 0);
              const context3 = c2.getContext("2d", contextSettings);
              if (context3?.measureText) {
                _CanvasTextMetrics2.__canvas = c2;
                return c2;
              }
              canvas2 = DOMAdapter.get().createCanvas();
            } catch (ex) {
              canvas2 = DOMAdapter.get().createCanvas();
            }
            canvas2.width = canvas2.height = 10;
            _CanvasTextMetrics2.__canvas = canvas2;
          }
          return _CanvasTextMetrics2.__canvas;
        }
        /**
         * TODO: this should be private, but isn't because of backward compat, will fix later.
         * @ignore
         */
        static get _context() {
          if (!_CanvasTextMetrics2.__context) {
            _CanvasTextMetrics2.__context = _CanvasTextMetrics2._canvas.getContext("2d", contextSettings);
          }
          return _CanvasTextMetrics2.__context;
        }
      };
      _CanvasTextMetrics.METRICS_STRING = "|\xC9q\xC5";
      _CanvasTextMetrics.BASELINE_SYMBOL = "M";
      _CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;
      _CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;
      _CanvasTextMetrics.graphemeSegmenter = (() => {
        if (typeof Intl?.Segmenter === "function") {
          const segmenter2 = new Intl.Segmenter();
          return (s2) => [...segmenter2.segment(s2)].map((x2) => x2.segment);
        }
        return (s2) => [...s2];
      })();
      _CanvasTextMetrics.experimentalLetterSpacing = false;
      _CanvasTextMetrics._fonts = {};
      _CanvasTextMetrics._newlines = [
        10,
        // line feed
        13
        // carriage return
      ];
      _CanvasTextMetrics._breakingSpaces = [
        9,
        // character tabulation
        32,
        // space
        8192,
        // en quad
        8193,
        // em quad
        8194,
        // en space
        8195,
        // em space
        8196,
        // three-per-em space
        8197,
        // four-per-em space
        8198,
        // six-per-em space
        8200,
        // punctuation space
        8201,
        // thin space
        8202,
        // hair space
        8287,
        // medium mathematical space
        12288
        // ideographic space
      ];
      _CanvasTextMetrics._measurementCache = {};
      CanvasTextMetrics = _CanvasTextMetrics;
    }
  });

  // node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs
  function getCanvasFillStyle(fillStyle, context3) {
    if (fillStyle.texture === Texture.WHITE && !fillStyle.fill) {
      return Color.shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha ?? 1).toHexa();
    } else if (!fillStyle.fill) {
      const pattern2 = context3.createPattern(fillStyle.texture.source.resource, "repeat");
      const tempMatrix6 = fillStyle.matrix.copyTo(Matrix.shared);
      tempMatrix6.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);
      pattern2.setTransform(tempMatrix6);
      return pattern2;
    } else if (fillStyle.fill instanceof FillPattern) {
      const fillPattern = fillStyle.fill;
      const pattern2 = context3.createPattern(fillPattern.texture.source.resource, "repeat");
      const tempMatrix6 = fillPattern.transform.copyTo(Matrix.shared);
      tempMatrix6.scale(
        fillPattern.texture.frame.width,
        fillPattern.texture.frame.height
      );
      pattern2.setTransform(tempMatrix6);
      return pattern2;
    } else if (fillStyle.fill instanceof FillGradient) {
      const fillGradient = fillStyle.fill;
      if (fillGradient.type === "linear") {
        const gradient = context3.createLinearGradient(
          fillGradient.x0,
          fillGradient.y0,
          fillGradient.x1,
          fillGradient.y1
        );
        fillGradient.gradientStops.forEach((stop) => {
          gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());
        });
        return gradient;
      }
    }
    warn2("FillStyle not recognised", fillStyle);
    return "red";
  }
  var init_getCanvasFillStyle = __esm({
    "node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs"() {
      init_Color();
      init_Matrix();
      init_Texture();
      init_warn();
      init_FillGradient();
      init_FillPattern();
    }
  });

  // node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs
  var CanvasTextSystem;
  var init_CanvasTextSystem = __esm({
    "node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs"() {
      init_Color();
      init_Extensions();
      init_pow2();
      init_CanvasPool();
      init_TexturePool();
      init_getCanvasBoundingBox();
      init_deprecation();
      init_TextStyle();
      init_getPo2TextureFromSource();
      init_CanvasTextMetrics();
      init_fontStringFromTextStyle();
      init_getCanvasFillStyle();
      CanvasTextSystem = class {
        constructor(_renderer) {
          this._activeTextures = {};
          this._renderer = _renderer;
        }
        getTextureSize(text6, resolution, style3) {
          const measured = CanvasTextMetrics.measureText(text6 || " ", style3);
          let width8 = Math.ceil(Math.ceil(Math.max(1, measured.width) + style3.padding * 2) * resolution);
          let height8 = Math.ceil(Math.ceil(Math.max(1, measured.height) + style3.padding * 2) * resolution);
          width8 = Math.ceil(width8 - 1e-6);
          height8 = Math.ceil(height8 - 1e-6);
          width8 = nextPow2(width8);
          height8 = nextPow2(height8);
          return { width: width8, height: height8 };
        }
        getTexture(options2, resolution, style3, _textKey) {
          if (typeof options2 === "string") {
            deprecation("8.0.0", "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments");
            options2 = {
              text: options2,
              style: style3,
              resolution
            };
          }
          if (!(options2.style instanceof TextStyle)) {
            options2.style = new TextStyle(options2.style);
          }
          const { texture, canvasAndContext } = this.createTextureAndCanvas(
            options2
          );
          this._renderer.texture.initSource(texture._source);
          CanvasPool.returnCanvasAndContext(canvasAndContext);
          return texture;
        }
        createTextureAndCanvas(options2) {
          const { text: text6, style: style3 } = options2;
          const resolution = options2.resolution ?? this._renderer.resolution;
          const measured = CanvasTextMetrics.measureText(text6 || " ", style3);
          const width8 = Math.ceil(Math.ceil(Math.max(1, measured.width) + style3.padding * 2) * resolution);
          const height8 = Math.ceil(Math.ceil(Math.max(1, measured.height) + style3.padding * 2) * resolution);
          const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width8, height8);
          const { canvas: canvas2 } = canvasAndContext;
          this.renderTextToCanvas(text6, style3, resolution, canvasAndContext);
          const texture = getPo2TextureFromSource(canvas2, width8, height8, resolution);
          if (style3.trim) {
            const trimmed = getCanvasBoundingBox(canvas2, resolution);
            texture.frame.copyFrom(trimmed);
            texture.updateUvs();
          }
          return { texture, canvasAndContext };
        }
        getManagedTexture(text6) {
          text6._resolution = text6._autoResolution ? this._renderer.resolution : text6.resolution;
          const textKey = text6._getKey();
          if (this._activeTextures[textKey]) {
            this._increaseReferenceCount(textKey);
            return this._activeTextures[textKey].texture;
          }
          const { texture, canvasAndContext } = this.createTextureAndCanvas(text6);
          this._activeTextures[textKey] = {
            canvasAndContext,
            texture,
            usageCount: 1
          };
          return texture;
        }
        _increaseReferenceCount(textKey) {
          this._activeTextures[textKey].usageCount++;
        }
        decreaseReferenceCount(textKey) {
          const activeTexture = this._activeTextures[textKey];
          activeTexture.usageCount--;
          if (activeTexture.usageCount === 0) {
            CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);
            TexturePool.returnTexture(activeTexture.texture);
            const source3 = activeTexture.texture.source;
            source3.resource = null;
            source3.uploadMethodId = "unknown";
            source3.alphaMode = "no-premultiply-alpha";
            this._activeTextures[textKey] = null;
          }
        }
        getReferenceCount(textKey) {
          return this._activeTextures[textKey].usageCount;
        }
        /**
         * Renders text to its canvas, and updates its texture.
         *
         * By default this is used internally to ensure the texture is correct before rendering,
         * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,
         * and then shared across multiple Sprites.
         * @param text
         * @param style
         * @param resolution
         * @param canvasAndContext
         */
        renderTextToCanvas(text6, style3, resolution, canvasAndContext) {
          const { canvas: canvas2, context: context3 } = canvasAndContext;
          const font = fontStringFromTextStyle(style3);
          const measured = CanvasTextMetrics.measureText(text6 || " ", style3);
          const lines = measured.lines;
          const lineHeight = measured.lineHeight;
          const lineWidths = measured.lineWidths;
          const maxLineWidth = measured.maxLineWidth;
          const fontProperties = measured.fontProperties;
          const height8 = canvas2.height;
          context3.resetTransform();
          context3.scale(resolution, resolution);
          context3.textBaseline = style3.textBaseline;
          if (style3._stroke?.width) {
            const strokeStyle = style3._stroke;
            context3.lineWidth = strokeStyle.width;
            context3.miterLimit = strokeStyle.miterLimit;
            context3.lineJoin = strokeStyle.join;
            context3.lineCap = strokeStyle.cap;
          }
          context3.font = font;
          let linePositionX;
          let linePositionY;
          const passesCount = style3.dropShadow ? 2 : 1;
          for (let i2 = 0; i2 < passesCount; ++i2) {
            const isShadowPass = style3.dropShadow && i2 === 0;
            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height8) + style3.padding * 2) : 0;
            const dsOffsetShadow = dsOffsetText * resolution;
            if (isShadowPass) {
              context3.fillStyle = "black";
              context3.strokeStyle = "black";
              const shadowOptions = style3.dropShadow;
              const dropShadowColor = shadowOptions.color;
              const dropShadowAlpha = shadowOptions.alpha;
              context3.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();
              const dropShadowBlur = shadowOptions.blur * resolution;
              const dropShadowDistance = shadowOptions.distance * resolution;
              context3.shadowBlur = dropShadowBlur;
              context3.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
              context3.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;
            } else {
              context3.fillStyle = style3._fill ? getCanvasFillStyle(style3._fill, context3) : null;
              if (style3._stroke?.width) {
                context3.strokeStyle = getCanvasFillStyle(style3._stroke, context3);
              }
              context3.shadowColor = "black";
            }
            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
            if (lineHeight - fontProperties.fontSize < 0) {
              linePositionYShift = 0;
            }
            const strokeWidth = style3._stroke?.width ?? 0;
            for (let i22 = 0; i22 < lines.length; i22++) {
              linePositionX = strokeWidth / 2;
              linePositionY = strokeWidth / 2 + i22 * lineHeight + fontProperties.ascent + linePositionYShift;
              if (style3.align === "right") {
                linePositionX += maxLineWidth - lineWidths[i22];
              } else if (style3.align === "center") {
                linePositionX += (maxLineWidth - lineWidths[i22]) / 2;
              }
              if (style3._stroke?.width) {
                this._drawLetterSpacing(
                  lines[i22],
                  style3,
                  canvasAndContext,
                  linePositionX + style3.padding,
                  linePositionY + style3.padding - dsOffsetText,
                  true
                );
              }
              if (style3._fill !== void 0) {
                this._drawLetterSpacing(
                  lines[i22],
                  style3,
                  canvasAndContext,
                  linePositionX + style3.padding,
                  linePositionY + style3.padding - dsOffsetText
                );
              }
            }
          }
        }
        /**
         * Render the text with letter-spacing.
         * @param text - The text to draw
         * @param style
         * @param canvasAndContext
         * @param x - Horizontal position to draw the text
         * @param y - Vertical position to draw the text
         * @param isStroke - Is this drawing for the outside stroke of the
         *  text? If not, it's for the inside fill
         */
        _drawLetterSpacing(text6, style3, canvasAndContext, x2, y2, isStroke = false) {
          const { context: context3 } = canvasAndContext;
          const letterSpacing = style3.letterSpacing;
          let useExperimentalLetterSpacing = false;
          if (CanvasTextMetrics.experimentalLetterSpacingSupported) {
            if (CanvasTextMetrics.experimentalLetterSpacing) {
              context3.letterSpacing = `${letterSpacing}px`;
              context3.textLetterSpacing = `${letterSpacing}px`;
              useExperimentalLetterSpacing = true;
            } else {
              context3.letterSpacing = "0px";
              context3.textLetterSpacing = "0px";
            }
          }
          if (letterSpacing === 0 || useExperimentalLetterSpacing) {
            if (isStroke) {
              context3.strokeText(text6, x2, y2);
            } else {
              context3.fillText(text6, x2, y2);
            }
            return;
          }
          let currentPosition = x2;
          const stringArray = CanvasTextMetrics.graphemeSegmenter(text6);
          let previousWidth = context3.measureText(text6).width;
          let currentWidth = 0;
          for (let i2 = 0; i2 < stringArray.length; ++i2) {
            const currentChar = stringArray[i2];
            if (isStroke) {
              context3.strokeText(currentChar, currentPosition, y2);
            } else {
              context3.fillText(currentChar, currentPosition, y2);
            }
            let textStr = "";
            for (let j2 = i2 + 1; j2 < stringArray.length; ++j2) {
              textStr += stringArray[j2];
            }
            currentWidth = context3.measureText(textStr).width;
            currentPosition += previousWidth - currentWidth + letterSpacing;
            previousWidth = currentWidth;
          }
        }
        destroy() {
          this._activeTextures = null;
        }
      };
      CanvasTextSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "canvasText"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/text/init.mjs
  var init_init9 = __esm({
    "node_modules/pixi.js/lib/scene/text/init.mjs"() {
      init_Extensions();
      init_CanvasTextPipe();
      init_CanvasTextSystem();
      extensions.add(CanvasTextSystem);
      extensions.add(CanvasTextPipe);
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs
  var Graphics;
  var init_Graphics = __esm({
    "node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs"() {
      init_deprecation();
      init_ViewContainer();
      init_GraphicsContext();
      Graphics = class _Graphics extends ViewContainer {
        /**
         * @param options - Options for the Graphics.
         */
        constructor(options2) {
          if (options2 instanceof GraphicsContext) {
            options2 = { context: options2 };
          }
          const { context: context3, roundPixels, ...rest } = options2 || {};
          super({
            label: "Graphics",
            ...rest
          });
          this.renderPipeId = "graphics";
          if (!context3) {
            this._context = this._ownedContext = new GraphicsContext();
          } else {
            this._context = context3;
          }
          this._context.on("update", this.onViewUpdate, this);
          this.allowChildren = false;
          this.roundPixels = roundPixels ?? false;
        }
        set context(context3) {
          if (context3 === this._context)
            return;
          this._context.off("update", this.onViewUpdate, this);
          this._context = context3;
          this._context.on("update", this.onViewUpdate, this);
          this.onViewUpdate();
        }
        get context() {
          return this._context;
        }
        /**
         * The local bounds of the graphic.
         * @type {rendering.Bounds}
         */
        get bounds() {
          return this._context.bounds;
        }
        /**
         * Adds the bounds of this object to the bounds object.
         * @param bounds - The output bounds object.
         */
        addBounds(bounds) {
          bounds.addBounds(this._context.bounds);
        }
        /**
         * Checks if the object contains the given point.
         * @param point - The point to check
         */
        containsPoint(point) {
          return this._context.containsPoint(point);
        }
        /**
         * Destroys this graphics renderable and optionally its context.
         * @param options - Options parameter. A boolean will act as if all options
         *
         * If the context was created by this graphics and `destroy(false)` or `destroy()` is called
         * then the context will still be destroyed.
         *
         * If you want to explicitly not destroy this context that this graphics created,
         * then you should pass destroy({ context: false })
         *
         * If the context was passed in as an argument to the constructor then it will not be destroyed
         * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context
         * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context
         * @param {boolean} [options.context=false] - Should destroy the context
         */
        destroy(options2) {
          if (this._ownedContext && !options2) {
            this._ownedContext.destroy(options2);
          } else if (options2 === true || options2?.context === true) {
            this._context.destroy(options2);
          }
          this._ownedContext = null;
          this._context = null;
          super.destroy(options2);
        }
        _callContextMethod(method2, args) {
          this.context[method2](...args);
          return this;
        }
        // --------------------------------------- GraphicsContext methods ---------------------------------------
        /**
         * Sets the current fill style of the graphics context. The fill style can be a color, gradient,
         * pattern, or a more complex style defined by a FillStyle object.
         * @param {FillInput} args - The fill style to apply. This can be a simple color, a gradient or
         * pattern object, or a FillStyle or ConvertedFillStyle object.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        setFillStyle(...args) {
          return this._callContextMethod("setFillStyle", args);
        }
        /**
         * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can
         * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
         * @param {StrokeInput} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,
         * or a StrokeStyle or ConvertedStrokeStyle object.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        setStrokeStyle(...args) {
          return this._callContextMethod("setStrokeStyle", args);
        }
        fill(...args) {
          return this._callContextMethod("fill", args);
        }
        /**
         * Strokes the current path with the current stroke style. This method can take an optional
         * FillStyle parameter to define the stroke's appearance, including its color, width, and other properties.
         * @param {FillStyle} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more
         * complex style object. If omitted, uses the current stroke style.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        stroke(...args) {
          return this._callContextMethod("stroke", args);
        }
        texture(...args) {
          return this._callContextMethod("texture", args);
        }
        /**
         * Resets the current path. Any previous path and its commands are discarded and a new path is
         * started. This is typically called before beginning a new shape or series of drawing commands.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        beginPath() {
          return this._callContextMethod("beginPath", []);
        }
        /**
         * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
         * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will
         * fail to cut correctly!
         */
        cut() {
          return this._callContextMethod("cut", []);
        }
        arc(...args) {
          return this._callContextMethod("arc", args);
        }
        arcTo(...args) {
          return this._callContextMethod("arcTo", args);
        }
        arcToSvg(...args) {
          return this._callContextMethod("arcToSvg", args);
        }
        bezierCurveTo(...args) {
          return this._callContextMethod("bezierCurveTo", args);
        }
        /**
         * Closes the current path by drawing a straight line back to the start.
         * If the shape is already closed or there are no points in the path, this method does nothing.
         * @returns The instance of the current object for chaining.
         */
        closePath() {
          return this._callContextMethod("closePath", []);
        }
        ellipse(...args) {
          return this._callContextMethod("ellipse", args);
        }
        circle(...args) {
          return this._callContextMethod("circle", args);
        }
        path(...args) {
          return this._callContextMethod("path", args);
        }
        lineTo(...args) {
          return this._callContextMethod("lineTo", args);
        }
        moveTo(...args) {
          return this._callContextMethod("moveTo", args);
        }
        quadraticCurveTo(...args) {
          return this._callContextMethod("quadraticCurveTo", args);
        }
        rect(...args) {
          return this._callContextMethod("rect", args);
        }
        roundRect(...args) {
          return this._callContextMethod("roundRect", args);
        }
        poly(...args) {
          return this._callContextMethod("poly", args);
        }
        regularPoly(...args) {
          return this._callContextMethod("regularPoly", args);
        }
        roundPoly(...args) {
          return this._callContextMethod("roundPoly", args);
        }
        roundShape(...args) {
          return this._callContextMethod("roundShape", args);
        }
        filletRect(...args) {
          return this._callContextMethod("filletRect", args);
        }
        chamferRect(...args) {
          return this._callContextMethod("chamferRect", args);
        }
        star(...args) {
          return this._callContextMethod("star", args);
        }
        svg(...args) {
          return this._callContextMethod("svg", args);
        }
        restore(...args) {
          return this._callContextMethod("restore", args);
        }
        /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */
        save() {
          return this._callContextMethod("save", []);
        }
        /**
         * Returns the current transformation matrix of the graphics context.
         * @returns The current transformation matrix.
         */
        getTransform() {
          return this.context.getTransform();
        }
        /**
         * Resets the current transformation matrix to the identity matrix, effectively removing
         * any transformations (rotation, scaling, translation) previously applied.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        resetTransform() {
          return this._callContextMethod("resetTransform", []);
        }
        rotateTransform(...args) {
          return this._callContextMethod("rotate", args);
        }
        scaleTransform(...args) {
          return this._callContextMethod("scale", args);
        }
        setTransform(...args) {
          return this._callContextMethod("setTransform", args);
        }
        transform(...args) {
          return this._callContextMethod("transform", args);
        }
        translateTransform(...args) {
          return this._callContextMethod("translate", args);
        }
        /**
         * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,
         * and optionally resetting transformations to the identity matrix.
         * @returns The instance of the current GraphicsContext for method chaining.
         */
        clear() {
          return this._callContextMethod("clear", []);
        }
        /**
         * The fill style to use.
         * @type {ConvertedFillStyle}
         */
        get fillStyle() {
          return this._context.fillStyle;
        }
        set fillStyle(value12) {
          this._context.fillStyle = value12;
        }
        /**
         * The stroke style to use.
         * @type {ConvertedStrokeStyle}
         */
        get strokeStyle() {
          return this._context.strokeStyle;
        }
        set strokeStyle(value12) {
          this._context.strokeStyle = value12;
        }
        /**
         * Creates a new Graphics object.
         * Note that only the context of the object is cloned, not its transform (position,scale,etc)
         * @param deep - Whether to create a deep clone of the graphics object. If false, the context
         * will be shared between the two objects (default false). If true, the context will be
         * cloned (recommended if you need to modify the context in any way).
         * @returns - A clone of the graphics object
         */
        clone(deep = false) {
          if (deep) {
            return new _Graphics(this._context.clone());
          }
          this._ownedContext = null;
          const clone = new _Graphics(this._context);
          return clone;
        }
        // -------- v7 deprecations ---------
        /**
         * @param width
         * @param color
         * @param alpha
         * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead
         */
        lineStyle(width8, color, alpha) {
          deprecation(v8_0_0, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
          const strokeStyle = {};
          width8 && (strokeStyle.width = width8);
          color && (strokeStyle.color = color);
          alpha && (strokeStyle.alpha = alpha);
          this.context.strokeStyle = strokeStyle;
          return this;
        }
        /**
         * @param color
         * @param alpha
         * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
         */
        beginFill(color, alpha) {
          deprecation(v8_0_0, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
          const fillStyle = {};
          color && (fillStyle.color = color);
          alpha && (fillStyle.alpha = alpha);
          this.context.fillStyle = fillStyle;
          return this;
        }
        /**
         * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
         */
        endFill() {
          deprecation(v8_0_0, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
          this.context.fill();
          const strokeStyle = this.context.strokeStyle;
          if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha) {
            this.context.stroke();
          }
          return this;
        }
        /**
         * @param {...any} args
         * @deprecated since 8.0.0 Use {@link Graphics#circle} instead
         */
        drawCircle(...args) {
          deprecation(v8_0_0, "Graphics#drawCircle has been renamed to Graphics#circle");
          return this._callContextMethod("circle", args);
        }
        /**
         * @param {...any} args
         * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead
         */
        drawEllipse(...args) {
          deprecation(v8_0_0, "Graphics#drawEllipse has been renamed to Graphics#ellipse");
          return this._callContextMethod("ellipse", args);
        }
        /**
         * @param {...any} args
         * @deprecated since 8.0.0 Use {@link Graphics#poly} instead
         */
        drawPolygon(...args) {
          deprecation(v8_0_0, "Graphics#drawPolygon has been renamed to Graphics#poly");
          return this._callContextMethod("poly", args);
        }
        /**
         * @param {...any} args
         * @deprecated since 8.0.0 Use {@link Graphics#rect} instead
         */
        drawRect(...args) {
          deprecation(v8_0_0, "Graphics#drawRect has been renamed to Graphics#rect");
          return this._callContextMethod("rect", args);
        }
        /**
         * @param {...any} args
         * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead
         */
        drawRoundedRect(...args) {
          deprecation(v8_0_0, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect");
          return this._callContextMethod("roundRect", args);
        }
        /**
         * @param {...any} args
         * @deprecated since 8.0.0 Use {@link Graphics#star} instead
         */
        drawStar(...args) {
          deprecation(v8_0_0, "Graphics#drawStar has been renamed to Graphics#star");
          return this._callContextMethod("star", args);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs
  var localUniformMSDFBit, localUniformMSDFBitGl;
  var init_localUniformMSDFBit = __esm({
    "node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs"() {
      "use strict";
      localUniformMSDFBit = {
        name: "local-uniform-msdf-bit",
        vertex: {
          header: (
            /* wgsl */
            `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `
          ),
          main: (
            /* wgsl */
            `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `
          ),
          end: (
            /* wgsl */
            `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
          )
        },
        fragment: {
          header: (
            /* wgsl */
            `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `
          ),
          main: (
            /* wgsl */
            ` 
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `
          )
        }
      };
      localUniformMSDFBitGl = {
        name: "local-uniform-msdf-bit",
        vertex: {
          header: (
            /* glsl */
            `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `
          ),
          main: (
            /* glsl */
            `
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `
          ),
          end: (
            /* glsl */
            `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
          )
        },
        fragment: {
          header: (
            /* glsl */
            `
            uniform float uDistance;
         `
          ),
          main: (
            /* glsl */
            ` 
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `
          )
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs
  var mSDFBit, mSDFBitGl;
  var init_mSDFBit = __esm({
    "node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs"() {
      "use strict";
      mSDFBit = {
        name: "msdf-bit",
        fragment: {
          header: (
            /* wgsl */
            `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {
                
                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));
            
                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;
             
            }
        `
          )
        }
      };
      mSDFBitGl = {
        name: "msdf-bit",
        fragment: {
          header: (
            /* glsl */
            `
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {
                
                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));
               
                // SDF
                median = min(median, msdfColor.a);
            
                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
           
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);  
              
                return coverage;
            }
        `
          )
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs
  var gpuProgram, glProgram, SdfShader;
  var init_SdfShader = __esm({
    "node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs"() {
      init_Matrix();
      init_maxRecommendedTextures();
      init_compileHighShaderToProgram();
      init_colorBit();
      init_generateTextureBatchBit();
      init_roundPixelsBit();
      init_getBatchSamplersUniformGroup();
      init_Shader();
      init_UniformGroup();
      init_localUniformMSDFBit();
      init_mSDFBit();
      SdfShader = class extends Shader {
        constructor() {
          const uniforms = new UniformGroup({
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uDistance: { value: 4, type: "f32" },
            uRound: { value: 0, type: "f32" }
          });
          const maxTextures2 = getMaxTexturesPerBatch();
          gpuProgram ?? (gpuProgram = compileHighShaderGpuProgram({
            name: "sdf-shader",
            bits: [
              colorBit,
              generateTextureBatchBit(maxTextures2),
              localUniformMSDFBit,
              mSDFBit,
              roundPixelsBit
            ]
          }));
          glProgram ?? (glProgram = compileHighShaderGlProgram({
            name: "sdf-shader",
            bits: [
              colorBitGl,
              generateTextureBatchBitGl(maxTextures2),
              localUniformMSDFBitGl,
              mSDFBitGl,
              roundPixelsBitGl
            ]
          }));
          super({
            glProgram,
            gpuProgram,
            resources: {
              localUniforms: uniforms,
              batchSamplers: getBatchSamplersUniformGroup(maxTextures2)
            }
          });
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs
  var AbstractBitmapFont;
  var init_AbstractBitmapFont = __esm({
    "node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs"() {
      init_eventemitter3();
      init_deprecation();
      AbstractBitmapFont = class extends eventemitter3_default {
        constructor() {
          super(...arguments);
          this.chars = /* @__PURE__ */ Object.create(null);
          this.lineHeight = 0;
          this.fontFamily = "";
          this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };
          this.baseLineOffset = 0;
          this.distanceField = { type: "none", range: 0 };
          this.pages = [];
          this.applyFillAsTint = true;
          this.baseMeasurementFontSize = 100;
          this.baseRenderedFontSize = 100;
        }
        /**
         * The name of the font face.
         * @deprecated since 8.0.0 Use `fontFamily` instead.
         */
        get font() {
          deprecation(v8_0_0, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.");
          return this.fontFamily;
        }
        /**
         * The map of base page textures (i.e., sheets of glyphs).
         * @deprecated since 8.0.0 Use `pages` instead.
         */
        get pageTextures() {
          deprecation(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
          return this.pages;
        }
        /**
         * The size of the font face in pixels.
         * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.
         */
        get size() {
          deprecation(v8_0_0, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.");
          return this.fontMetrics.fontSize;
        }
        /**
         * The kind of distance field for this font or "none".
         * @deprecated since 8.0.0 Use `distanceField.type` instead.
         */
        get distanceFieldRange() {
          deprecation(v8_0_0, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.");
          return this.distanceField.range;
        }
        /**
         * The range of the distance field in pixels.
         * @deprecated since 8.0.0 Use `distanceField.range` instead.
         */
        get distanceFieldType() {
          deprecation(v8_0_0, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.");
          return this.distanceField.type;
        }
        destroy(destroyTextures = false) {
          this.emit("destroy", this);
          this.removeAllListeners();
          for (const i2 in this.chars) {
            this.chars[i2].texture?.destroy();
          }
          this.chars = null;
          if (destroyTextures) {
            this.pages.forEach((page) => page.texture.destroy(true));
            this.pages = null;
          }
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs
  function resolveCharacters(chars) {
    if (chars === "") {
      return [];
    }
    if (typeof chars === "string") {
      chars = [chars];
    }
    const result = [];
    for (let i2 = 0, j2 = chars.length; i2 < j2; i2++) {
      const item = chars[i2];
      if (Array.isArray(item)) {
        if (item.length !== 2) {
          throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
        }
        if (item[0].length === 0 || item[1].length === 0) {
          throw new Error("[BitmapFont]: Invalid character delimiter.");
        }
        const startCode = item[0].charCodeAt(0);
        const endCode = item[1].charCodeAt(0);
        if (endCode < startCode) {
          throw new Error("[BitmapFont]: Invalid character range.");
        }
        for (let i22 = startCode, j22 = endCode; i22 <= j22; i22++) {
          result.push(String.fromCharCode(i22));
        }
      } else {
        result.push(...Array.from(item));
      }
    }
    if (result.length === 0) {
      throw new Error("[BitmapFont]: Empty set when resolving characters.");
    }
    return result;
  }
  var init_resolveCharacters = __esm({
    "node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs
  var _DynamicBitmapFont, DynamicBitmapFont;
  var init_DynamicBitmapFont = __esm({
    "node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs"() {
      init_Color();
      init_Rectangle();
      init_CanvasPool();
      init_ImageSource();
      init_Texture();
      init_deprecation();
      init_CanvasTextMetrics();
      init_fontStringFromTextStyle();
      init_getCanvasFillStyle();
      init_TextStyle();
      init_AbstractBitmapFont();
      init_resolveCharacters();
      _DynamicBitmapFont = class _DynamicBitmapFont2 extends AbstractBitmapFont {
        /**
         * @param options - The options for the dynamic bitmap font.
         */
        constructor(options2) {
          super();
          this.resolution = 1;
          this.pages = [];
          this._padding = 0;
          this._measureCache = /* @__PURE__ */ Object.create(null);
          this._currentChars = [];
          this._currentX = 0;
          this._currentY = 0;
          this._currentPageIndex = -1;
          this._skipKerning = false;
          const dynamicOptions = { ..._DynamicBitmapFont2.defaultOptions, ...options2 };
          this._textureSize = dynamicOptions.textureSize;
          this._mipmap = dynamicOptions.mipmap;
          const style3 = dynamicOptions.style.clone();
          if (dynamicOptions.overrideFill) {
            style3._fill.color = 16777215;
            style3._fill.alpha = 1;
            style3._fill.texture = Texture.WHITE;
            style3._fill.fill = null;
          }
          this.applyFillAsTint = dynamicOptions.overrideFill;
          const requestedFontSize = style3.fontSize;
          style3.fontSize = this.baseMeasurementFontSize;
          const font = fontStringFromTextStyle(style3);
          if (dynamicOptions.overrideSize) {
            if (style3._stroke) {
              style3._stroke.width *= this.baseRenderedFontSize / requestedFontSize;
            }
          } else {
            style3.fontSize = this.baseRenderedFontSize = requestedFontSize;
          }
          this._style = style3;
          this._skipKerning = dynamicOptions.skipKerning ?? false;
          this.resolution = dynamicOptions.resolution ?? 1;
          this._padding = dynamicOptions.padding ?? 4;
          this.fontMetrics = CanvasTextMetrics.measureFont(font);
          this.lineHeight = style3.lineHeight || this.fontMetrics.fontSize || style3.fontSize;
        }
        ensureCharacters(chars) {
          const charList = resolveCharacters(chars).filter((char2) => !this._currentChars.includes(char2)).filter((char2, index6, self2) => self2.indexOf(char2) === index6);
          if (!charList.length)
            return;
          this._currentChars = [...this._currentChars, ...charList];
          let pageData;
          if (this._currentPageIndex === -1) {
            pageData = this._nextPage();
          } else {
            pageData = this.pages[this._currentPageIndex];
          }
          let { canvas: canvas2, context: context3 } = pageData.canvasAndContext;
          let textureSource = pageData.texture.source;
          const style3 = this._style;
          let currentX = this._currentX;
          let currentY = this._currentY;
          const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;
          const padding = this._padding * fontScale;
          let maxCharHeight = 0;
          let skipTexture = false;
          for (let i2 = 0; i2 < charList.length; i2++) {
            const char2 = charList[i2];
            const metrics = CanvasTextMetrics.measureText(char2, style3, canvas2, false);
            const textureGlyphWidth = Math.ceil((style3.fontStyle === "italic" ? 2 : 1) * metrics.width);
            metrics.lineHeight = metrics.height;
            const width8 = metrics.width * fontScale;
            const height8 = metrics.height * fontScale;
            const paddedWidth = textureGlyphWidth + padding * 2;
            const paddedHeight = height8 + padding * 2;
            skipTexture = false;
            if (char2 !== "\n" && char2 !== "\r" && char2 !== "	" && char2 !== " ") {
              skipTexture = true;
              maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));
            }
            if (currentX + paddedWidth > this._textureSize) {
              currentY += maxCharHeight;
              maxCharHeight = paddedHeight;
              currentX = 0;
              if (currentY + maxCharHeight > this._textureSize) {
                textureSource.update();
                const pageData2 = this._nextPage();
                canvas2 = pageData2.canvasAndContext.canvas;
                context3 = pageData2.canvasAndContext.context;
                textureSource = pageData2.texture.source;
                currentY = 0;
              }
            }
            const xAdvance = width8 / fontScale - (style3.dropShadow?.distance ?? 0) - (style3._stroke?.width ?? 0);
            this.chars[char2] = {
              id: char2.codePointAt(0),
              xOffset: -this._padding,
              yOffset: -this._padding,
              xAdvance,
              kerning: {}
            };
            if (skipTexture) {
              this._drawGlyph(
                context3,
                metrics,
                currentX + padding,
                currentY + padding,
                fontScale,
                style3
              );
              const px = textureSource.width * fontScale;
              const py = textureSource.height * fontScale;
              const frame = new Rectangle(
                currentX / px * textureSource.width,
                currentY / py * textureSource.height,
                paddedWidth / px * textureSource.width,
                paddedHeight / py * textureSource.height
              );
              this.chars[char2].texture = new Texture({
                source: textureSource,
                frame
              });
              currentX += Math.ceil(paddedWidth);
            }
          }
          textureSource.update();
          this._currentX = currentX;
          this._currentY = currentY;
          this._skipKerning && this._applyKerning(charList, context3);
        }
        /**
         * @deprecated since 8.0.0
         * The map of base page textures (i.e., sheets of glyphs).
         */
        get pageTextures() {
          deprecation(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
          return this.pages;
        }
        _applyKerning(newChars, context3) {
          const measureCache = this._measureCache;
          for (let i2 = 0; i2 < newChars.length; i2++) {
            const first = newChars[i2];
            for (let j2 = 0; j2 < this._currentChars.length; j2++) {
              const second2 = this._currentChars[j2];
              let c1 = measureCache[first];
              if (!c1)
                c1 = measureCache[first] = context3.measureText(first).width;
              let c2 = measureCache[second2];
              if (!c2)
                c2 = measureCache[second2] = context3.measureText(second2).width;
              let total = context3.measureText(first + second2).width;
              let amount = total - (c1 + c2);
              if (amount) {
                this.chars[first].kerning[second2] = amount;
              }
              total = context3.measureText(first + second2).width;
              amount = total - (c1 + c2);
              if (amount) {
                this.chars[second2].kerning[first] = amount;
              }
            }
          }
        }
        _nextPage() {
          this._currentPageIndex++;
          const textureResolution = this.resolution;
          const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(
            this._textureSize,
            this._textureSize,
            textureResolution
          );
          this._setupContext(canvasAndContext.context, this._style, textureResolution);
          const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);
          const texture = new Texture({
            source: new ImageSource({
              resource: canvasAndContext.canvas,
              resolution,
              alphaMode: "premultiply-alpha-on-upload",
              autoGenerateMipmaps: this._mipmap
            })
          });
          const pageData = {
            canvasAndContext,
            texture
          };
          this.pages[this._currentPageIndex] = pageData;
          return pageData;
        }
        // canvas style!
        _setupContext(context3, style3, resolution) {
          style3.fontSize = this.baseRenderedFontSize;
          context3.scale(resolution, resolution);
          context3.font = fontStringFromTextStyle(style3);
          style3.fontSize = this.baseMeasurementFontSize;
          context3.textBaseline = style3.textBaseline;
          const stroke = style3._stroke;
          const strokeThickness = stroke?.width ?? 0;
          if (stroke) {
            context3.lineWidth = strokeThickness;
            context3.lineJoin = stroke.join;
            context3.miterLimit = stroke.miterLimit;
            context3.strokeStyle = getCanvasFillStyle(stroke, context3);
          }
          if (style3._fill) {
            context3.fillStyle = getCanvasFillStyle(style3._fill, context3);
          }
          if (style3.dropShadow) {
            const shadowOptions = style3.dropShadow;
            const rgb = Color.shared.setValue(shadowOptions.color).toArray();
            const dropShadowBlur = shadowOptions.blur * resolution;
            const dropShadowDistance = shadowOptions.distance * resolution;
            context3.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;
            context3.shadowBlur = dropShadowBlur;
            context3.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
            context3.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;
          } else {
            context3.shadowColor = "black";
            context3.shadowBlur = 0;
            context3.shadowOffsetX = 0;
            context3.shadowOffsetY = 0;
          }
        }
        _drawGlyph(context3, metrics, x2, y2, fontScale, style3) {
          const char2 = metrics.text;
          const fontProperties = metrics.fontProperties;
          const stroke = style3._stroke;
          const strokeThickness = (stroke?.width ?? 0) * fontScale;
          const tx = x2 + strokeThickness / 2;
          const ty = y2 - strokeThickness / 2;
          const descent = fontProperties.descent * fontScale;
          const lineHeight = metrics.lineHeight * fontScale;
          if (style3.stroke && strokeThickness) {
            context3.strokeText(char2, tx, ty + lineHeight - descent);
          }
          if (style3._fill) {
            context3.fillText(char2, tx, ty + lineHeight - descent);
          }
        }
        destroy() {
          super.destroy();
          for (let i2 = 0; i2 < this.pages.length; i2++) {
            const { canvasAndContext, texture } = this.pages[i2];
            CanvasPool.returnCanvasAndContext(canvasAndContext);
            texture.destroy(true);
          }
          this.pages = null;
        }
      };
      _DynamicBitmapFont.defaultOptions = {
        textureSize: 512,
        style: new TextStyle(),
        mipmap: true
      };
      DynamicBitmapFont = _DynamicBitmapFont;
    }
  });

  // node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs
  function getBitmapTextLayout(chars, style3, font, trimEnd) {
    const layoutData = {
      width: 0,
      height: 0,
      offsetY: 0,
      scale: style3.fontSize / font.baseMeasurementFontSize,
      lines: [{
        width: 0,
        charPositions: [],
        spaceWidth: 0,
        spacesIndex: [],
        chars: []
      }]
    };
    layoutData.offsetY = font.baseLineOffset;
    let currentLine = layoutData.lines[0];
    let previousChar = null;
    let firstWord = true;
    const currentWord = {
      spaceWord: false,
      width: 0,
      start: 0,
      index: 0,
      // use index to not modify the array as we use it a lot!
      positions: [],
      chars: []
    };
    const nextWord = (word) => {
      const start3 = currentLine.width;
      for (let j2 = 0; j2 < currentWord.index; j2++) {
        const position2 = word.positions[j2];
        currentLine.chars.push(word.chars[j2]);
        currentLine.charPositions.push(position2 + start3);
      }
      currentLine.width += word.width;
      firstWord = false;
      currentWord.width = 0;
      currentWord.index = 0;
      currentWord.chars.length = 0;
    };
    const nextLine = () => {
      let index6 = currentLine.chars.length - 1;
      if (trimEnd) {
        let lastChar = currentLine.chars[index6];
        while (lastChar === " ") {
          currentLine.width -= font.chars[lastChar].xAdvance;
          lastChar = currentLine.chars[--index6];
        }
      }
      layoutData.width = Math.max(layoutData.width, currentLine.width);
      currentLine = {
        width: 0,
        charPositions: [],
        chars: [],
        spaceWidth: 0,
        spacesIndex: []
      };
      firstWord = true;
      layoutData.lines.push(currentLine);
      layoutData.height += font.lineHeight;
    };
    const scale = font.baseMeasurementFontSize / style3.fontSize;
    const adjustedLetterSpacing = style3.letterSpacing * scale;
    const adjustedWordWrapWidth = style3.wordWrapWidth * scale;
    for (let i2 = 0; i2 < chars.length + 1; i2++) {
      let char2;
      const isEnd = i2 === chars.length;
      if (!isEnd) {
        char2 = chars[i2];
      }
      const charData = font.chars[char2] || font.chars[" "];
      const isSpace = /(?:\s)/.test(char2);
      const isWordBreak = isSpace || char2 === "\r" || char2 === "\n" || isEnd;
      if (isWordBreak) {
        const addWordToNextLine = !firstWord && style3.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;
        if (addWordToNextLine) {
          nextLine();
          nextWord(currentWord);
          if (!isEnd) {
            currentLine.charPositions.push(0);
          }
        } else {
          currentWord.start = currentLine.width;
          nextWord(currentWord);
          if (!isEnd) {
            currentLine.charPositions.push(0);
          }
        }
        if (char2 === "\r" || char2 === "\n") {
          if (currentLine.width !== 0) {
            nextLine();
          }
        } else if (!isEnd) {
          const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;
          currentLine.width += spaceWidth;
          currentLine.spaceWidth = spaceWidth;
          currentLine.spacesIndex.push(currentLine.charPositions.length);
          currentLine.chars.push(char2);
        }
      } else {
        const kerning = charData.kerning[previousChar] || 0;
        const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;
        currentWord.positions[currentWord.index++] = currentWord.width + kerning;
        currentWord.chars.push(char2);
        currentWord.width += nextCharWidth;
      }
      previousChar = char2;
    }
    nextLine();
    if (style3.align === "center") {
      alignCenter(layoutData);
    } else if (style3.align === "right") {
      alignRight(layoutData);
    } else if (style3.align === "justify") {
      alignJustify(layoutData);
    }
    return layoutData;
  }
  function alignCenter(measurementData) {
    for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
      const line = measurementData.lines[i2];
      const offset = measurementData.width / 2 - line.width / 2;
      for (let j2 = 0; j2 < line.charPositions.length; j2++) {
        line.charPositions[j2] += offset;
      }
    }
  }
  function alignRight(measurementData) {
    for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
      const line = measurementData.lines[i2];
      const offset = measurementData.width - line.width;
      for (let j2 = 0; j2 < line.charPositions.length; j2++) {
        line.charPositions[j2] += offset;
      }
    }
  }
  function alignJustify(measurementData) {
    const width8 = measurementData.width;
    for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
      const line = measurementData.lines[i2];
      let indy = 0;
      let spaceIndex = line.spacesIndex[indy++];
      let offset = 0;
      const totalSpaces = line.spacesIndex.length;
      const newSpaceWidth = (width8 - line.width) / totalSpaces;
      const spaceWidth = newSpaceWidth;
      for (let j2 = 0; j2 < line.charPositions.length; j2++) {
        if (j2 === spaceIndex) {
          spaceIndex = line.spacesIndex[indy++];
          offset += spaceWidth;
        }
        line.charPositions[j2] += offset;
      }
    }
  }
  var init_getBitmapTextLayout = __esm({
    "node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs
  var fontCount, BitmapFontManagerClass, BitmapFontManager;
  var init_BitmapFontManager = __esm({
    "node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs"() {
      init_Cache();
      init_deprecation();
      init_warn();
      init_TextStyle();
      init_DynamicBitmapFont();
      init_getBitmapTextLayout();
      init_resolveCharacters();
      fontCount = 0;
      BitmapFontManagerClass = class {
        constructor() {
          this.ALPHA = [["a", "z"], ["A", "Z"], " "];
          this.NUMERIC = [["0", "9"]];
          this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
          this.ASCII = [[" ", "~"]];
          this.defaultOptions = {
            chars: this.ALPHANUMERIC,
            resolution: 1,
            padding: 4,
            skipKerning: false
          };
        }
        /**
         * Get a font for the specified text and style.
         * @param text - The text to get the font for
         * @param style - The style to use
         */
        getFont(text6, style3) {
          let fontFamilyKey = `${style3.fontFamily}-bitmap`;
          let overrideFill = true;
          if (style3._fill.fill && !style3._stroke) {
            fontFamilyKey += style3._fill.fill.styleKey;
            overrideFill = false;
          } else if (style3._stroke || style3.dropShadow) {
            let key = style3.styleKey;
            key = key.substring(0, key.lastIndexOf("-"));
            fontFamilyKey = `${key}-bitmap`;
            overrideFill = false;
          }
          if (!Cache.has(fontFamilyKey)) {
            const fnt = new DynamicBitmapFont({
              style: style3,
              overrideFill,
              overrideSize: true,
              ...this.defaultOptions
            });
            fontCount++;
            if (fontCount > 50) {
              warn2("BitmapText", `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``);
            }
            fnt.once("destroy", () => {
              fontCount--;
              Cache.remove(fontFamilyKey);
            });
            Cache.set(
              fontFamilyKey,
              fnt
            );
          }
          const dynamicFont = Cache.get(fontFamilyKey);
          dynamicFont.ensureCharacters?.(text6);
          return dynamicFont;
        }
        /**
         * Get the layout of a text for the specified style.
         * @param text - The text to get the layout for
         * @param style - The style to use
         * @param trimEnd - Whether to ignore whitespaces at the end of each line
         */
        getLayout(text6, style3, trimEnd = true) {
          const bitmapFont = this.getFont(text6, style3);
          return getBitmapTextLayout([...text6], style3, bitmapFont, trimEnd);
        }
        /**
         * Measure the text using the specified style.
         * @param text - The text to measure
         * @param style - The style to use
         * @param trimEnd - Whether to ignore whitespaces at the end of each line
         */
        measureText(text6, style3, trimEnd = true) {
          return this.getLayout(text6, style3, trimEnd);
        }
        // eslint-disable-next-line max-len
        install(...args) {
          let options2 = args[0];
          if (typeof options2 === "string") {
            options2 = {
              name: options2,
              style: args[1],
              chars: args[2]?.chars,
              resolution: args[2]?.resolution,
              padding: args[2]?.padding,
              skipKerning: args[2]?.skipKerning
            };
            deprecation(v8_0_0, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})");
          }
          const name16 = options2?.name;
          if (!name16) {
            throw new Error("[BitmapFontManager] Property `name` is required.");
          }
          options2 = { ...this.defaultOptions, ...options2 };
          const textStyle = options2.style;
          const style3 = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
          const overrideFill = style3._fill.fill !== null && style3._fill.fill !== void 0;
          const font = new DynamicBitmapFont({
            style: style3,
            overrideFill,
            skipKerning: options2.skipKerning,
            padding: options2.padding,
            resolution: options2.resolution,
            overrideSize: false
          });
          const flatChars = resolveCharacters(options2.chars);
          font.ensureCharacters(flatChars.join(""));
          Cache.set(`${name16}-bitmap`, font);
          font.once("destroy", () => Cache.remove(`${name16}-bitmap`));
          return font;
        }
        /**
         * Uninstalls a bitmap font from the cache.
         * @param {string} name - The name of the bitmap font to uninstall.
         */
        uninstall(name16) {
          const cacheKey = `${name16}-bitmap`;
          const font = Cache.get(cacheKey);
          if (font) {
            font.destroy();
          }
        }
      };
      BitmapFontManager = new BitmapFontManagerClass();
    }
  });

  // node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs
  function syncWithProxy(container, proxy) {
    proxy.groupTransform = container.groupTransform;
    proxy.groupColorAlpha = container.groupColorAlpha;
    proxy.groupColor = container.groupColor;
    proxy.groupBlendMode = container.groupBlendMode;
    proxy.globalDisplayStatus = container.globalDisplayStatus;
    proxy.groupTransform = container.groupTransform;
    proxy.localDisplayStatus = container.localDisplayStatus;
    proxy.groupAlpha = container.groupAlpha;
    proxy._roundPixels = container._roundPixels;
  }
  var BitmapTextPipe;
  var init_BitmapTextPipe = __esm({
    "node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs"() {
      init_Cache();
      init_Extensions();
      init_PoolGroup();
      init_Graphics();
      init_SdfShader();
      init_BitmapFontManager();
      init_getBitmapTextLayout();
      BitmapTextPipe = class {
        constructor(renderer) {
          this._gpuBitmapText = {};
          this._destroyRenderableBound = this.destroyRenderable.bind(this);
          this._renderer = renderer;
          this._renderer.renderableGC.addManagedHash(this, "_gpuBitmapText");
        }
        validateRenderable(bitmapText) {
          const graphicsRenderable = this._getGpuBitmapText(bitmapText);
          if (bitmapText._didTextUpdate) {
            bitmapText._didTextUpdate = false;
            this._updateContext(bitmapText, graphicsRenderable);
          }
          return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);
        }
        addRenderable(bitmapText, instructionSet) {
          const graphicsRenderable = this._getGpuBitmapText(bitmapText);
          syncWithProxy(bitmapText, graphicsRenderable);
          if (bitmapText._didTextUpdate) {
            bitmapText._didTextUpdate = false;
            this._updateContext(bitmapText, graphicsRenderable);
          }
          this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);
          if (graphicsRenderable.context.customShader) {
            this._updateDistanceField(bitmapText);
          }
        }
        destroyRenderable(bitmapText) {
          bitmapText.off("destroyed", this._destroyRenderableBound);
          this._destroyRenderableByUid(bitmapText.uid);
        }
        _destroyRenderableByUid(renderableUid) {
          const context3 = this._gpuBitmapText[renderableUid].context;
          if (context3.customShader) {
            BigPool.return(context3.customShader);
            context3.customShader = null;
          }
          BigPool.return(this._gpuBitmapText[renderableUid]);
          this._gpuBitmapText[renderableUid] = null;
        }
        updateRenderable(bitmapText) {
          const graphicsRenderable = this._getGpuBitmapText(bitmapText);
          syncWithProxy(bitmapText, graphicsRenderable);
          this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);
          if (graphicsRenderable.context.customShader) {
            this._updateDistanceField(bitmapText);
          }
        }
        _updateContext(bitmapText, proxyGraphics) {
          const { context: context3 } = proxyGraphics;
          const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);
          context3.clear();
          if (bitmapFont.distanceField.type !== "none") {
            if (!context3.customShader) {
              context3.customShader = BigPool.get(SdfShader);
            }
          }
          const chars = Array.from(bitmapText.text);
          const style3 = bitmapText._style;
          let currentY = bitmapFont.baseLineOffset;
          const bitmapTextLayout = getBitmapTextLayout(chars, style3, bitmapFont, true);
          let index6 = 0;
          const padding = style3.padding;
          const scale = bitmapTextLayout.scale;
          let tx = bitmapTextLayout.width;
          let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;
          if (style3._stroke) {
            tx += style3._stroke.width / scale;
            ty += style3._stroke.width / scale;
          }
          context3.translate(-bitmapText._anchor._x * tx - padding, -bitmapText._anchor._y * ty - padding).scale(scale, scale);
          const tint = bitmapFont.applyFillAsTint ? style3._fill.color : 16777215;
          for (let i2 = 0; i2 < bitmapTextLayout.lines.length; i2++) {
            const line = bitmapTextLayout.lines[i2];
            for (let j2 = 0; j2 < line.charPositions.length; j2++) {
              const char2 = chars[index6++];
              const charData = bitmapFont.chars[char2];
              if (charData?.texture) {
                context3.texture(
                  charData.texture,
                  tint ? tint : "black",
                  Math.round(line.charPositions[j2] + charData.xOffset),
                  Math.round(currentY + charData.yOffset)
                );
              }
            }
            currentY += bitmapFont.lineHeight;
          }
        }
        _getGpuBitmapText(bitmapText) {
          return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);
        }
        initGpuText(bitmapText) {
          const proxyRenderable = BigPool.get(Graphics);
          this._gpuBitmapText[bitmapText.uid] = proxyRenderable;
          this._updateContext(bitmapText, proxyRenderable);
          bitmapText.on("destroyed", this._destroyRenderableBound);
          return this._gpuBitmapText[bitmapText.uid];
        }
        _updateDistanceField(bitmapText) {
          const context3 = this._getGpuBitmapText(bitmapText).context;
          const fontFamily = bitmapText._style.fontFamily;
          const dynamicFont = Cache.get(`${fontFamily}-bitmap`);
          const { a: a2, b: b2, c: c2, d: d2 } = bitmapText.groupTransform;
          const dx = Math.sqrt(a2 * a2 + b2 * b2);
          const dy = Math.sqrt(c2 * c2 + d2 * d2);
          const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
          const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;
          const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);
          context3.customShader.resources.localUniforms.uniforms.uDistance = distance;
        }
        destroy() {
          for (const uid3 in this._gpuBitmapText) {
            this._destroyRenderableByUid(uid3);
          }
          this._gpuBitmapText = null;
          this._renderer = null;
        }
      };
      BitmapTextPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "bitmapText"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/text-bitmap/init.mjs
  var init_init10 = __esm({
    "node_modules/pixi.js/lib/scene/text-bitmap/init.mjs"() {
      init_Extensions();
      init_BitmapTextPipe();
      extensions.add(BitmapTextPipe);
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs
  var HTMLTextPipe;
  var init_HTMLTextPipe = __esm({
    "node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs"() {
      init_Extensions();
      init_Texture();
      init_updateQuadBounds();
      init_PoolGroup();
      init_BatchableSprite();
      HTMLTextPipe = class {
        constructor(renderer) {
          this._gpuText = /* @__PURE__ */ Object.create(null);
          this._destroyRenderableBound = this.destroyRenderable.bind(this);
          this._renderer = renderer;
          this._renderer.runners.resolutionChange.add(this);
          this._renderer.renderableGC.addManagedHash(this, "_gpuText");
        }
        resolutionChange() {
          for (const i2 in this._gpuText) {
            const gpuText = this._gpuText[i2];
            if (!gpuText)
              continue;
            const text6 = gpuText.batchableSprite.renderable;
            if (text6._autoResolution) {
              text6._resolution = this._renderer.resolution;
              text6.onViewUpdate();
            }
          }
        }
        validateRenderable(htmlText) {
          const gpuText = this._getGpuText(htmlText);
          const newKey = htmlText._getKey();
          if (gpuText.textureNeedsUploading) {
            gpuText.textureNeedsUploading = false;
            return true;
          }
          if (gpuText.currentKey !== newKey) {
            return true;
          }
          return false;
        }
        addRenderable(htmlText, instructionSet) {
          const gpuText = this._getGpuText(htmlText);
          const batchableSprite = gpuText.batchableSprite;
          if (htmlText._didTextUpdate) {
            this._updateText(htmlText);
          }
          this._renderer.renderPipes.batch.addToBatch(batchableSprite, instructionSet);
        }
        updateRenderable(htmlText) {
          const gpuText = this._getGpuText(htmlText);
          const batchableSprite = gpuText.batchableSprite;
          if (htmlText._didTextUpdate) {
            this._updateText(htmlText);
          }
          batchableSprite._batcher.updateElement(batchableSprite);
        }
        destroyRenderable(htmlText) {
          htmlText.off("destroyed", this._destroyRenderableBound);
          this._destroyRenderableById(htmlText.uid);
        }
        _destroyRenderableById(htmlTextUid) {
          const gpuText = this._gpuText[htmlTextUid];
          this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);
          BigPool.return(gpuText.batchableSprite);
          this._gpuText[htmlTextUid] = null;
        }
        _updateText(htmlText) {
          const newKey = htmlText._getKey();
          const gpuText = this._getGpuText(htmlText);
          const batchableSprite = gpuText.batchableSprite;
          if (gpuText.currentKey !== newKey) {
            this._updateGpuText(htmlText).catch((e2) => {
              console.error(e2);
            });
          }
          htmlText._didTextUpdate = false;
          const padding = htmlText._style.padding;
          updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);
        }
        async _updateGpuText(htmlText) {
          htmlText._didTextUpdate = false;
          const gpuText = this._getGpuText(htmlText);
          if (gpuText.generatingTexture)
            return;
          const newKey = htmlText._getKey();
          this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);
          gpuText.generatingTexture = true;
          gpuText.currentKey = newKey;
          const resolution = htmlText.resolution ?? this._renderer.resolution;
          const texture = await this._renderer.htmlText.getManagedTexture(
            htmlText.text,
            resolution,
            htmlText._style,
            htmlText._getKey()
          );
          const batchableSprite = gpuText.batchableSprite;
          batchableSprite.texture = gpuText.texture = texture;
          gpuText.generatingTexture = false;
          gpuText.textureNeedsUploading = true;
          htmlText.onViewUpdate();
          const padding = htmlText._style.padding;
          updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);
        }
        _getGpuText(htmlText) {
          return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);
        }
        initGpuText(htmlText) {
          const gpuTextData = {
            texture: Texture.EMPTY,
            currentKey: "--",
            batchableSprite: BigPool.get(BatchableSprite),
            textureNeedsUploading: false,
            generatingTexture: false
          };
          const batchableSprite = gpuTextData.batchableSprite;
          batchableSprite.renderable = htmlText;
          batchableSprite.transform = htmlText.groupTransform;
          batchableSprite.texture = Texture.EMPTY;
          batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
          batchableSprite.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;
          htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;
          this._gpuText[htmlText.uid] = gpuTextData;
          htmlText.on("destroyed", this._destroyRenderableBound);
          return gpuTextData;
        }
        destroy() {
          for (const i2 in this._gpuText) {
            this._destroyRenderableById(i2);
          }
          this._gpuText = null;
          this._renderer = null;
        }
      };
      HTMLTextPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "htmlText"
      };
    }
  });

  // node_modules/pixi.js/lib/utils/browser/isSafari.mjs
  function isSafari() {
    const { userAgent: userAgent2 } = DOMAdapter.get().getNavigator();
    return /^((?!chrome|android).)*safari/i.test(userAgent2);
  }
  var init_isSafari = __esm({
    "node_modules/pixi.js/lib/utils/browser/isSafari.mjs"() {
      init_adapter();
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs
  var nssvg, nsxhtml, HTMLTextRenderData;
  var init_HTMLTextRenderData = __esm({
    "node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs"() {
      "use strict";
      nssvg = "http://www.w3.org/2000/svg";
      nsxhtml = "http://www.w3.org/1999/xhtml";
      HTMLTextRenderData = class {
        constructor() {
          this.svgRoot = document.createElementNS(nssvg, "svg");
          this.foreignObject = document.createElementNS(nssvg, "foreignObject");
          this.domElement = document.createElementNS(nsxhtml, "div");
          this.styleElement = document.createElementNS(nsxhtml, "style");
          this.image = new Image();
          const { foreignObject, svgRoot, styleElement, domElement } = this;
          foreignObject.setAttribute("width", "10000");
          foreignObject.setAttribute("height", "10000");
          foreignObject.style.overflow = "hidden";
          svgRoot.appendChild(foreignObject);
          foreignObject.appendChild(styleElement);
          foreignObject.appendChild(domElement);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.mjs
  function textStyleToCSS(style3) {
    const stroke = style3._stroke;
    const fill2 = style3._fill;
    const cssStyleString = [
      `color: ${Color.shared.setValue(fill2.color).toHex()}`,
      `font-size: ${style3.fontSize}px`,
      `font-family: ${style3.fontFamily}`,
      `font-weight: ${style3.fontWeight}`,
      `font-style: ${style3.fontStyle}`,
      `font-variant: ${style3.fontVariant}`,
      `letter-spacing: ${style3.letterSpacing}px`,
      `text-align: ${style3.align}`,
      `padding: ${style3.padding}px`,
      `white-space: ${style3.whiteSpace === "pre" && style3.wordWrap ? "pre-wrap" : style3.whiteSpace}`,
      ...style3.lineHeight ? [`line-height: ${style3.lineHeight}px`] : [],
      ...style3.wordWrap ? [
        `word-wrap: ${style3.breakWords ? "break-all" : "break-word"}`,
        `max-width: ${style3.wordWrapWidth}px`
      ] : [],
      ...stroke ? [strokeToCSS(stroke)] : [],
      ...style3.dropShadow ? [dropShadowToCSS(style3.dropShadow)] : [],
      ...style3.cssOverrides
    ].join(";");
    const cssStyles = [`div { ${cssStyleString} }`];
    tagStyleToCSS(style3.tagStyles, cssStyles);
    return cssStyles.join(" ");
  }
  function dropShadowToCSS(dropShadowStyle) {
    const color = Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();
    const x2 = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);
    const y2 = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);
    const position2 = `${x2}px ${y2}px`;
    if (dropShadowStyle.blur > 0) {
      return `text-shadow: ${position2} ${dropShadowStyle.blur}px ${color}`;
    }
    return `text-shadow: ${position2} ${color}`;
  }
  function strokeToCSS(stroke) {
    return [
      `-webkit-text-stroke-width: ${stroke.width}px`,
      `-webkit-text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,
      `text-stroke-width: ${stroke.width}px`,
      `text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,
      "paint-order: stroke"
    ].join(";");
  }
  function tagStyleToCSS(tagStyles, out2) {
    for (const i2 in tagStyles) {
      const tagStyle = tagStyles[i2];
      const cssTagStyle = [];
      for (const j2 in tagStyle) {
        if (transform[j2]) {
          cssTagStyle.push(transform[j2](tagStyle[j2]));
        } else if (templates[j2]) {
          cssTagStyle.push(templates[j2].replace("{{VALUE}}", tagStyle[j2]));
        }
      }
      out2.push(`${i2} { ${cssTagStyle.join(";")} }`);
    }
  }
  var templates, transform;
  var init_textStyleToCSS = __esm({
    "node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.mjs"() {
      init_Color();
      templates = {
        fontSize: `font-size: {{VALUE}}px`,
        fontFamily: `font-family: {{VALUE}}`,
        fontWeight: `font-weight: {{VALUE}}`,
        fontStyle: `font-style: {{VALUE}}`,
        fontVariant: `font-variant: {{VALUE}}`,
        letterSpacing: `letter-spacing: {{VALUE}}px`,
        align: `text-align: {{VALUE}}`,
        padding: `padding: {{VALUE}}px`,
        whiteSpace: `white-space: {{VALUE}}`,
        lineHeight: `line-height: {{VALUE}}px`,
        wordWrapWidth: `max-width: {{VALUE}}px`
      };
      transform = {
        fill: (value12) => `color: ${Color.shared.setValue(value12).toHex()}`,
        breakWords: (value12) => `word-wrap: ${value12 ? "break-all" : "break-word"}`,
        stroke: strokeToCSS,
        dropShadow: dropShadowToCSS
      };
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/HtmlTextStyle.mjs
  var HTMLTextStyle;
  var init_HtmlTextStyle = __esm({
    "node_modules/pixi.js/lib/scene/text-html/HtmlTextStyle.mjs"() {
      init_warn();
      init_TextStyle();
      init_generateTextStyleKey();
      init_textStyleToCSS();
      HTMLTextStyle = class _HTMLTextStyle extends TextStyle {
        constructor(options2 = {}) {
          super(options2);
          this._cssOverrides = [];
          this.cssOverrides ?? (this.cssOverrides = options2.cssOverrides);
          this.tagStyles = options2.tagStyles ?? {};
        }
        /** List of style overrides that will be applied to the HTML text. */
        set cssOverrides(value12) {
          this._cssOverrides = value12 instanceof Array ? value12 : [value12];
          this.update();
        }
        get cssOverrides() {
          return this._cssOverrides;
        }
        _generateKey() {
          this._styleKey = generateTextStyleKey(this) + this._cssOverrides.join("-");
          return this._styleKey;
        }
        update() {
          this._cssStyle = null;
          super.update();
        }
        /**
         * Creates a new HTMLTextStyle object with the same values as this one.
         * @returns New cloned HTMLTextStyle object
         */
        clone() {
          return new _HTMLTextStyle({
            align: this.align,
            breakWords: this.breakWords,
            dropShadow: this.dropShadow ? { ...this.dropShadow } : null,
            fill: this._fill,
            fontFamily: this.fontFamily,
            fontSize: this.fontSize,
            fontStyle: this.fontStyle,
            fontVariant: this.fontVariant,
            fontWeight: this.fontWeight,
            letterSpacing: this.letterSpacing,
            lineHeight: this.lineHeight,
            padding: this.padding,
            stroke: this._stroke,
            whiteSpace: this.whiteSpace,
            wordWrap: this.wordWrap,
            wordWrapWidth: this.wordWrapWidth,
            cssOverrides: this.cssOverrides
          });
        }
        get cssStyle() {
          if (!this._cssStyle) {
            this._cssStyle = textStyleToCSS(this);
          }
          return this._cssStyle;
        }
        /**
         * Add a style override, this can be any CSS property
         * it will override any built-in style. This is the
         * property and the value as a string (e.g., `color: red`).
         * This will override any other internal style.
         * @param {string} value - CSS style(s) to add.
         * @example
         * style.addOverride('background-color: red');
         */
        addOverride(...value12) {
          const toAdd = value12.filter((v2) => !this.cssOverrides.includes(v2));
          if (toAdd.length > 0) {
            this.cssOverrides.push(...toAdd);
            this.update();
          }
        }
        /**
         * Remove any overrides that match the value.
         * @param {string} value - CSS style to remove.
         * @example
         * style.removeOverride('background-color: red');
         */
        removeOverride(...value12) {
          const toRemove = value12.filter((v2) => this.cssOverrides.includes(v2));
          if (toRemove.length > 0) {
            this.cssOverrides = this.cssOverrides.filter((v2) => !toRemove.includes(v2));
            this.update();
          }
        }
        set fill(value12) {
          if (typeof value12 !== "string" && typeof value12 !== "number") {
            warn2("[HTMLTextStyle] only color fill is not supported by HTMLText");
          }
          super.fill = value12;
        }
        set stroke(value12) {
          if (value12 && typeof value12 !== "string" && typeof value12 !== "number") {
            warn2("[HTMLTextStyle] only color stroke is not supported by HTMLText");
          }
          super.stroke = value12;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs
  function extractFontFamilies(text6, style3) {
    const fontFamily = style3.fontFamily;
    const fontFamilies = [];
    const dedupe = {};
    const regex2 = /font-family:([^;"\s]+)/g;
    const matches2 = text6.match(regex2);
    function addFontFamily(fontFamily2) {
      if (!dedupe[fontFamily2]) {
        fontFamilies.push(fontFamily2);
        dedupe[fontFamily2] = true;
      }
    }
    if (Array.isArray(fontFamily)) {
      for (let i2 = 0; i2 < fontFamily.length; i2++) {
        addFontFamily(fontFamily[i2]);
      }
    } else {
      addFontFamily(fontFamily);
    }
    if (matches2) {
      matches2.forEach((match2) => {
        const fontFamily2 = match2.split(":")[1].trim();
        addFontFamily(fontFamily2);
      });
    }
    for (const i2 in style3.tagStyles) {
      const fontFamily2 = style3.tagStyles[i2].fontFamily;
      addFontFamily(fontFamily2);
    }
    return fontFamilies;
  }
  var init_extractFontFamilies = __esm({
    "node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs
  async function loadFontAsBase64(url2) {
    const response = await DOMAdapter.get().fetch(url2);
    const blob = await response.blob();
    const reader = new FileReader();
    const dataSrc = await new Promise((resolve, reject) => {
      reader.onloadend = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
    return dataSrc;
  }
  var init_loadFontAsBase64 = __esm({
    "node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs"() {
      init_adapter();
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs
  async function loadFontCSS(style3, url2) {
    const dataSrc = await loadFontAsBase64(url2);
    return `@font-face {
        font-family: "${style3.fontFamily}";
        src: url('${dataSrc}');
        font-weight: ${style3.fontWeight};
        font-style: ${style3.fontStyle};
    }`;
  }
  var init_loadFontCSS = __esm({
    "node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs"() {
      init_loadFontAsBase64();
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs
  async function getFontCss(fontFamilies, style3, defaultOptions) {
    const fontPromises = fontFamilies.filter((fontFamily) => Cache.has(`${fontFamily}-and-url`)).map((fontFamily, i2) => {
      if (!FontStylePromiseCache.has(fontFamily)) {
        const { url: url2 } = Cache.get(`${fontFamily}-and-url`);
        if (i2 === 0) {
          FontStylePromiseCache.set(fontFamily, loadFontCSS({
            fontWeight: style3.fontWeight,
            fontStyle: style3.fontStyle,
            fontFamily
          }, url2));
        } else {
          FontStylePromiseCache.set(fontFamily, loadFontCSS({
            fontWeight: defaultOptions.fontWeight,
            fontStyle: defaultOptions.fontStyle,
            fontFamily
          }, url2));
        }
      }
      return FontStylePromiseCache.get(fontFamily);
    });
    return (await Promise.all(fontPromises)).join("\n");
  }
  var FontStylePromiseCache;
  var init_getFontCss = __esm({
    "node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs"() {
      init_Cache();
      init_loadFontCSS();
      FontStylePromiseCache = /* @__PURE__ */ new Map();
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs
  function getSVGUrl(text6, style3, resolution, fontCSS, htmlTextData) {
    const { domElement, styleElement, svgRoot } = htmlTextData;
    domElement.innerHTML = `<style>${style3.cssStyle}</style><div style='padding:0;'>${text6}</div>`;
    domElement.setAttribute("style", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);
    styleElement.textContent = fontCSS;
    const { width: width8, height: height8 } = htmlTextData.image;
    svgRoot.setAttribute("width", width8.toString());
    svgRoot.setAttribute("height", height8.toString());
    return new XMLSerializer().serializeToString(svgRoot);
  }
  var init_getSVGUrl = __esm({
    "node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs
  function getTemporaryCanvasFromImage(image, resolution) {
    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(
      image.width,
      image.height,
      resolution
    );
    const { context: context3 } = canvasAndContext;
    context3.clearRect(0, 0, image.width, image.height);
    context3.drawImage(image, 0, 0);
    return canvasAndContext;
  }
  var init_getTemporaryCanvasFromImage = __esm({
    "node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs"() {
      init_CanvasPool();
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs
  function loadSVGImage(image, url2, delay2) {
    return new Promise(async (resolve) => {
      if (delay2) {
        await new Promise((resolve2) => setTimeout(resolve2, 100));
      }
      image.onload = () => {
        resolve();
      };
      image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url2)}`;
      image.crossOrigin = "anonymous";
    });
  }
  var init_loadSVGImage = __esm({
    "node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs
  function measureHtmlText(text6, style3, fontStyleCSS, htmlTextRenderData) {
    htmlTextRenderData = htmlTextRenderData || tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());
    const { domElement, styleElement, svgRoot } = htmlTextRenderData;
    domElement.innerHTML = `<style>${style3.cssStyle};</style><div style='padding:0'>${text6}</div>`;
    domElement.setAttribute("style", "transform-origin: top left; display: inline-block");
    if (fontStyleCSS) {
      styleElement.textContent = fontStyleCSS;
    }
    document.body.appendChild(svgRoot);
    const contentBounds = domElement.getBoundingClientRect();
    svgRoot.remove();
    const doublePadding = style3.padding * 2;
    return {
      width: contentBounds.width - doublePadding,
      height: contentBounds.height - doublePadding
    };
  }
  var tempHTMLTextRenderData;
  var init_measureHtmlText = __esm({
    "node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs"() {
      init_HTMLTextRenderData();
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs
  var HTMLTextSystem;
  var init_HTMLTextSystem = __esm({
    "node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs"() {
      init_Extensions();
      init_CanvasPool();
      init_TexturePool();
      init_types2();
      init_isSafari();
      init_warn();
      init_PoolGroup();
      init_getPo2TextureFromSource();
      init_HTMLTextRenderData();
      init_HtmlTextStyle();
      init_extractFontFamilies();
      init_getFontCss();
      init_getSVGUrl();
      init_getTemporaryCanvasFromImage();
      init_loadSVGImage();
      init_measureHtmlText();
      HTMLTextSystem = class {
        constructor(renderer) {
          this._activeTextures = {};
          this._renderer = renderer;
          this._createCanvas = renderer.type === RendererType.WEBGPU;
        }
        getTexture(options2) {
          return this._buildTexturePromise(
            options2.text,
            options2.resolution,
            options2.style
          );
        }
        getManagedTexture(text6, resolution, style3, textKey) {
          if (this._activeTextures[textKey]) {
            this._increaseReferenceCount(textKey);
            return this._activeTextures[textKey].promise;
          }
          const promise2 = this._buildTexturePromise(text6, resolution, style3).then((texture) => {
            this._activeTextures[textKey].texture = texture;
            return texture;
          });
          this._activeTextures[textKey] = {
            texture: null,
            promise: promise2,
            usageCount: 1
          };
          return promise2;
        }
        async _buildTexturePromise(text6, resolution, style3) {
          const htmlTextData = BigPool.get(HTMLTextRenderData);
          const fontFamilies = extractFontFamilies(text6, style3);
          const fontCSS = await getFontCss(
            fontFamilies,
            style3,
            HTMLTextStyle.defaultTextStyle
          );
          const measured = measureHtmlText(text6, style3, fontCSS, htmlTextData);
          const width8 = Math.ceil(Math.ceil(Math.max(1, measured.width) + style3.padding * 2) * resolution);
          const height8 = Math.ceil(Math.ceil(Math.max(1, measured.height) + style3.padding * 2) * resolution);
          const image = htmlTextData.image;
          const uvSafeOffset = 2;
          image.width = (width8 | 0) + uvSafeOffset;
          image.height = (height8 | 0) + uvSafeOffset;
          const svgURL = getSVGUrl(text6, style3, resolution, fontCSS, htmlTextData);
          await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);
          const resource = image;
          let canvasAndContext;
          if (this._createCanvas) {
            canvasAndContext = getTemporaryCanvasFromImage(image, resolution);
          }
          const texture = getPo2TextureFromSource(
            canvasAndContext ? canvasAndContext.canvas : resource,
            image.width - uvSafeOffset,
            image.height - uvSafeOffset,
            resolution
          );
          if (this._createCanvas) {
            this._renderer.texture.initSource(texture.source);
            CanvasPool.returnCanvasAndContext(canvasAndContext);
          }
          BigPool.return(htmlTextData);
          return texture;
        }
        _increaseReferenceCount(textKey) {
          this._activeTextures[textKey].usageCount++;
        }
        decreaseReferenceCount(textKey) {
          const activeTexture = this._activeTextures[textKey];
          if (!activeTexture)
            return;
          activeTexture.usageCount--;
          if (activeTexture.usageCount === 0) {
            if (activeTexture.texture) {
              this._cleanUp(activeTexture);
            } else {
              activeTexture.promise.then((texture) => {
                activeTexture.texture = texture;
                this._cleanUp(activeTexture);
              }).catch(() => {
                warn2("HTMLTextSystem: Failed to clean texture");
              });
            }
            this._activeTextures[textKey] = null;
          }
        }
        _cleanUp(activeTexture) {
          TexturePool.returnTexture(activeTexture.texture);
          activeTexture.texture.source.resource = null;
          activeTexture.texture.source.uploadMethodId = "unknown";
        }
        getReferenceCount(textKey) {
          return this._activeTextures[textKey].usageCount;
        }
        destroy() {
          this._activeTextures = null;
        }
      };
      HTMLTextSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "htmlText"
      };
      HTMLTextSystem.defaultFontOptions = {
        fontFamily: "Arial",
        fontStyle: "normal",
        fontWeight: "normal"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/text-html/init.mjs
  var init_init11 = __esm({
    "node_modules/pixi.js/lib/scene/text-html/init.mjs"() {
      init_Extensions();
      init_HTMLTextPipe();
      init_HTMLTextSystem();
      extensions.add(HTMLTextSystem);
      extensions.add(HTMLTextPipe);
    }
  });

  // node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs
  var _MeshGeometry, MeshGeometry;
  var init_MeshGeometry = __esm({
    "node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs"() {
      init_Buffer();
      init_const4();
      init_Geometry();
      init_deprecation();
      _MeshGeometry = class _MeshGeometry2 extends Geometry {
        constructor(...args) {
          let options2 = args[0] ?? {};
          if (options2 instanceof Float32Array) {
            deprecation(v8_0_0, "use new MeshGeometry({ positions, uvs, indices }) instead");
            options2 = {
              positions: options2,
              uvs: args[1],
              indices: args[2]
            };
          }
          options2 = { ..._MeshGeometry2.defaultOptions, ...options2 };
          const positions = options2.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
          const uvs = options2.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
          const indices = options2.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);
          const shrinkToFit = options2.shrinkBuffersToFit;
          const positionBuffer = new Buffer2({
            data: positions,
            label: "attribute-mesh-positions",
            shrinkToFit,
            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
          });
          const uvBuffer = new Buffer2({
            data: uvs,
            label: "attribute-mesh-uvs",
            shrinkToFit,
            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
          });
          const indexBuffer = new Buffer2({
            data: indices,
            label: "index-mesh-buffer",
            shrinkToFit,
            usage: BufferUsage.INDEX | BufferUsage.COPY_DST
          });
          super({
            attributes: {
              aPosition: {
                buffer: positionBuffer,
                format: "float32x2",
                stride: 2 * 4,
                offset: 0
              },
              aUV: {
                buffer: uvBuffer,
                format: "float32x2",
                stride: 2 * 4,
                offset: 0
              }
            },
            indexBuffer,
            topology: options2.topology
          });
          this.batchMode = "auto";
        }
        /** The positions of the mesh. */
        get positions() {
          return this.attributes.aPosition.buffer.data;
        }
        set positions(value12) {
          this.attributes.aPosition.buffer.data = value12;
        }
        /** The UVs of the mesh. */
        get uvs() {
          return this.attributes.aUV.buffer.data;
        }
        set uvs(value12) {
          this.attributes.aUV.buffer.data = value12;
        }
        /** The indices of the mesh. */
        get indices() {
          return this.indexBuffer.data;
        }
        set indices(value12) {
          this.indexBuffer.data = value12;
        }
      };
      _MeshGeometry.defaultOptions = {
        topology: "triangle-list",
        shrinkBuffersToFit: false
      };
      MeshGeometry = _MeshGeometry;
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs
  var localUniformBit, localUniformBitGroup2, localUniformBitGl;
  var init_localUniformBit = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs"() {
      "use strict";
      localUniformBit = {
        name: "local-uniform-bit",
        vertex: {
          header: (
            /* wgsl */
            `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `
          ),
          main: (
            /* wgsl */
            `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `
          ),
          end: (
            /* wgsl */
            `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
          )
        }
      };
      localUniformBitGroup2 = {
        ...localUniformBit,
        vertex: {
          ...localUniformBit.vertex,
          // replace the group!
          header: localUniformBit.vertex.header.replace("group(1)", "group(2)")
        }
      };
      localUniformBitGl = {
        name: "local-uniform-bit",
        vertex: {
          header: (
            /* glsl */
            `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `
          ),
          main: (
            /* glsl */
            `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `
          ),
          end: (
            /* glsl */
            `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
          )
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs
  var tilingBit, tilingBitGl;
  var init_tilingBit = __esm({
    "node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs"() {
      "use strict";
      tilingBit = {
        name: "tiling-bit",
        vertex: {
          header: (
            /* wgsl */
            `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `
          ),
          main: (
            /* wgsl */
            `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `
          )
        },
        fragment: {
          header: (
            /* wgsl */
            `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `
          ),
          main: (
            /* wgsl */
            `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            } 

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `
          )
        }
      };
      tilingBitGl = {
        name: "tiling-bit",
        vertex: {
          header: (
            /* glsl */
            `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;
        
        `
          ),
          main: (
            /* glsl */
            `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `
          )
        },
        fragment: {
          header: (
            /* glsl */
            `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `
          ),
          main: (
            /* glsl */
            `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);
        
        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0
    
        `
          )
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs
  var gpuProgram2, glProgram2, TilingSpriteShader;
  var init_TilingSpriteShader = __esm({
    "node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs"() {
      init_Matrix();
      init_compileHighShaderToProgram();
      init_localUniformBit();
      init_roundPixelsBit();
      init_Shader();
      init_UniformGroup();
      init_Texture();
      init_tilingBit();
      TilingSpriteShader = class extends Shader {
        constructor() {
          gpuProgram2 ?? (gpuProgram2 = compileHighShaderGpuProgram({
            name: "tiling-sprite-shader",
            bits: [
              localUniformBit,
              tilingBit,
              roundPixelsBit
            ]
          }));
          glProgram2 ?? (glProgram2 = compileHighShaderGlProgram({
            name: "tiling-sprite-shader",
            bits: [
              localUniformBitGl,
              tilingBitGl,
              roundPixelsBitGl
            ]
          }));
          const tilingUniforms = new UniformGroup({
            uMapCoord: { value: new Matrix(), type: "mat3x3<f32>" },
            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" },
            uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" },
            uTextureTransform: { value: new Matrix(), type: "mat3x3<f32>" },
            uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: "vec4<f32>" }
          });
          super({
            glProgram: glProgram2,
            gpuProgram: gpuProgram2,
            resources: {
              localUniforms: new UniformGroup({
                uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
                uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
                uRound: { value: 0, type: "f32" }
              }),
              tilingUniforms,
              uTexture: Texture.EMPTY.source,
              uSampler: Texture.EMPTY.source.style
            }
          });
        }
        updateUniforms(width8, height8, matrix, anchorX, anchorY, texture) {
          const tilingUniforms = this.resources.tilingUniforms;
          const textureWidth = texture.width;
          const textureHeight = texture.height;
          const textureMatrix = texture.textureMatrix;
          const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;
          uTextureTransform.set(
            matrix.a * textureWidth / width8,
            matrix.b * textureWidth / height8,
            matrix.c * textureHeight / width8,
            matrix.d * textureHeight / height8,
            matrix.tx / width8,
            matrix.ty / height8
          );
          uTextureTransform.invert();
          tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;
          tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;
          tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;
          tilingUniforms.uniforms.uTextureTransform = uTextureTransform;
          tilingUniforms.uniforms.uSizeAnchor[0] = width8;
          tilingUniforms.uniforms.uSizeAnchor[1] = height8;
          tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;
          tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;
          if (texture) {
            this.resources.uTexture = texture.source;
            this.resources.uSampler = texture.source.style;
          }
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs
  var QuadGeometry;
  var init_QuadGeometry = __esm({
    "node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs"() {
      init_MeshGeometry();
      QuadGeometry = class extends MeshGeometry {
        constructor() {
          super({
            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            indices: new Uint32Array([0, 1, 2, 0, 2, 3])
          });
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs
  function setPositions(tilingSprite, positions) {
    const anchorX = tilingSprite.anchor.x;
    const anchorY = tilingSprite.anchor.y;
    positions[0] = -anchorX * tilingSprite.width;
    positions[1] = -anchorY * tilingSprite.height;
    positions[2] = (1 - anchorX) * tilingSprite.width;
    positions[3] = -anchorY * tilingSprite.height;
    positions[4] = (1 - anchorX) * tilingSprite.width;
    positions[5] = (1 - anchorY) * tilingSprite.height;
    positions[6] = -anchorX * tilingSprite.width;
    positions[7] = (1 - anchorY) * tilingSprite.height;
  }
  var init_setPositions = __esm({
    "node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs
  function applyMatrix(array, stride, offset, matrix) {
    let index6 = 0;
    const size5 = array.length / (stride || 2);
    const a2 = matrix.a;
    const b2 = matrix.b;
    const c2 = matrix.c;
    const d2 = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    offset *= stride;
    while (index6 < size5) {
      const x2 = array[offset];
      const y2 = array[offset + 1];
      array[offset] = a2 * x2 + c2 * y2 + tx;
      array[offset + 1] = b2 * x2 + d2 * y2 + ty;
      offset += stride;
      index6++;
    }
  }
  var init_applyMatrix = __esm({
    "node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs
  function setUvs(tilingSprite, uvs) {
    const texture = tilingSprite.texture;
    const width8 = texture.frame.width;
    const height8 = texture.frame.height;
    let anchorX = 0;
    let anchorY = 0;
    if (tilingSprite._applyAnchorToTexture) {
      anchorX = tilingSprite.anchor.x;
      anchorY = tilingSprite.anchor.y;
    }
    uvs[0] = uvs[6] = -anchorX;
    uvs[2] = uvs[4] = 1 - anchorX;
    uvs[1] = uvs[3] = -anchorY;
    uvs[5] = uvs[7] = 1 - anchorY;
    const textureMatrix = Matrix.shared;
    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);
    textureMatrix.tx /= tilingSprite.width;
    textureMatrix.ty /= tilingSprite.height;
    textureMatrix.invert();
    textureMatrix.scale(tilingSprite.width / width8, tilingSprite.height / height8);
    applyMatrix(uvs, 2, 0, textureMatrix);
  }
  var init_setUvs = __esm({
    "node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs"() {
      init_Matrix();
      init_applyMatrix();
    }
  });

  // node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs
  var sharedQuad, TilingSpritePipe;
  var init_TilingSpritePipe = __esm({
    "node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs"() {
      init_Extensions();
      init_getAdjustedBlendModeBlend();
      init_State();
      init_types2();
      init_colorToUniform();
      init_BatchableMesh();
      init_MeshGeometry();
      init_TilingSpriteShader();
      init_QuadGeometry();
      init_setPositions();
      init_setUvs();
      sharedQuad = new QuadGeometry();
      TilingSpritePipe = class {
        constructor(renderer) {
          this._state = State.default2d;
          this._tilingSpriteDataHash = /* @__PURE__ */ Object.create(null);
          this._destroyRenderableBound = this.destroyRenderable.bind(this);
          this._renderer = renderer;
          this._renderer.renderableGC.addManagedHash(this, "_tilingSpriteDataHash");
        }
        validateRenderable(renderable) {
          const tilingSpriteData = this._getTilingSpriteData(renderable);
          const couldBatch = tilingSpriteData.canBatch;
          this._updateCanBatch(renderable);
          const canBatch = tilingSpriteData.canBatch;
          if (canBatch && canBatch === couldBatch) {
            const { batchableMesh } = tilingSpriteData;
            if (batchableMesh && batchableMesh.texture._source !== renderable.texture._source) {
              return !batchableMesh._batcher.checkAndUpdateTexture(batchableMesh, renderable.texture);
            }
          }
          return couldBatch !== canBatch;
        }
        addRenderable(tilingSprite, instructionSet) {
          const batcher = this._renderer.renderPipes.batch;
          this._updateCanBatch(tilingSprite);
          const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
          const { geometry, canBatch } = tilingSpriteData;
          if (canBatch) {
            tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new BatchableMesh());
            const batchableMesh = tilingSpriteData.batchableMesh;
            if (tilingSprite.didViewUpdate) {
              this._updateBatchableMesh(tilingSprite);
              batchableMesh.geometry = geometry;
              batchableMesh.renderable = tilingSprite;
              batchableMesh.transform = tilingSprite.groupTransform;
              batchableMesh.texture = tilingSprite._texture;
            }
            batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;
            batcher.addToBatch(batchableMesh, instructionSet);
          } else {
            batcher.break(instructionSet);
            tilingSpriteData.shader || (tilingSpriteData.shader = new TilingSpriteShader());
            this.updateRenderable(tilingSprite);
            instructionSet.add(tilingSprite);
          }
        }
        execute(tilingSprite) {
          const { shader } = this._tilingSpriteDataHash[tilingSprite.uid];
          shader.groups[0] = this._renderer.globalUniforms.bindGroup;
          const localUniforms = shader.resources.localUniforms.uniforms;
          localUniforms.uTransformMatrix = tilingSprite.groupTransform;
          localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;
          color32BitToUniform(
            tilingSprite.groupColorAlpha,
            localUniforms.uColor,
            0
          );
          this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);
          this._renderer.encoder.draw({
            geometry: sharedQuad,
            shader,
            state: this._state
          });
        }
        updateRenderable(tilingSprite) {
          const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
          const { canBatch } = tilingSpriteData;
          if (canBatch) {
            const { batchableMesh } = tilingSpriteData;
            if (tilingSprite.didViewUpdate)
              this._updateBatchableMesh(tilingSprite);
            batchableMesh._batcher.updateElement(batchableMesh);
          } else if (tilingSprite.didViewUpdate) {
            const { shader } = tilingSpriteData;
            shader.updateUniforms(
              tilingSprite.width,
              tilingSprite.height,
              tilingSprite._tileTransform.matrix,
              tilingSprite.anchor.x,
              tilingSprite.anchor.y,
              tilingSprite.texture
            );
          }
        }
        destroyRenderable(tilingSprite) {
          const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
          tilingSpriteData.batchableMesh = null;
          tilingSpriteData.shader?.destroy();
          this._tilingSpriteDataHash[tilingSprite.uid] = null;
          tilingSprite.off("destroyed", this._destroyRenderableBound);
        }
        _getTilingSpriteData(renderable) {
          return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);
        }
        _initTilingSpriteData(tilingSprite) {
          const geometry = new MeshGeometry({
            indices: sharedQuad.indices,
            positions: sharedQuad.positions.slice(),
            uvs: sharedQuad.uvs.slice()
          });
          this._tilingSpriteDataHash[tilingSprite.uid] = {
            canBatch: true,
            renderable: tilingSprite,
            geometry
          };
          tilingSprite.on("destroyed", this._destroyRenderableBound);
          return this._tilingSpriteDataHash[tilingSprite.uid];
        }
        _updateBatchableMesh(tilingSprite) {
          const renderableData = this._getTilingSpriteData(tilingSprite);
          const { geometry } = renderableData;
          const style3 = tilingSprite.texture.source.style;
          if (style3.addressMode !== "repeat") {
            style3.addressMode = "repeat";
            style3.update();
          }
          setUvs(tilingSprite, geometry.uvs);
          setPositions(tilingSprite, geometry.positions);
        }
        destroy() {
          for (const i2 in this._tilingSpriteDataHash) {
            this.destroyRenderable(this._tilingSpriteDataHash[i2].renderable);
          }
          this._tilingSpriteDataHash = null;
          this._renderer = null;
        }
        _updateCanBatch(tilingSprite) {
          const renderableData = this._getTilingSpriteData(tilingSprite);
          const texture = tilingSprite.texture;
          let _nonPowOf2wrapping = true;
          if (this._renderer.type === RendererType.WEBGL) {
            _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;
          }
          renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);
          return renderableData.canBatch;
        }
      };
      TilingSpritePipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "tilingSprite"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs
  var init_init12 = __esm({
    "node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs"() {
      init_Extensions();
      init_TilingSpritePipe();
      extensions.add(TilingSpritePipe);
    }
  });

  // node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs
  var _PlaneGeometry, PlaneGeometry;
  var init_PlaneGeometry = __esm({
    "node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs"() {
      init_deprecation();
      init_MeshGeometry();
      _PlaneGeometry = class _PlaneGeometry2 extends MeshGeometry {
        constructor(...args) {
          super({});
          let options2 = args[0] ?? {};
          if (typeof options2 === "number") {
            deprecation(v8_0_0, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead");
            options2 = {
              width: options2,
              height: args[1],
              verticesX: args[2],
              verticesY: args[3]
            };
          }
          this.build(options2);
        }
        /**
         * Refreshes plane coordinates
         * @param options - Options to be applied to plane geometry
         */
        build(options2) {
          options2 = { ..._PlaneGeometry2.defaultOptions, ...options2 };
          this.verticesX = this.verticesX ?? options2.verticesX;
          this.verticesY = this.verticesY ?? options2.verticesY;
          this.width = this.width ?? options2.width;
          this.height = this.height ?? options2.height;
          const total = this.verticesX * this.verticesY;
          const verts = [];
          const uvs = [];
          const indices = [];
          const verticesX = this.verticesX - 1;
          const verticesY = this.verticesY - 1;
          const sizeX = this.width / verticesX;
          const sizeY = this.height / verticesY;
          for (let i2 = 0; i2 < total; i2++) {
            const x2 = i2 % this.verticesX;
            const y2 = i2 / this.verticesX | 0;
            verts.push(x2 * sizeX, y2 * sizeY);
            uvs.push(x2 / verticesX, y2 / verticesY);
          }
          const totalSub = verticesX * verticesY;
          for (let i2 = 0; i2 < totalSub; i2++) {
            const xpos = i2 % verticesX;
            const ypos = i2 / verticesX | 0;
            const value12 = ypos * this.verticesX + xpos;
            const value22 = ypos * this.verticesX + xpos + 1;
            const value32 = (ypos + 1) * this.verticesX + xpos;
            const value42 = (ypos + 1) * this.verticesX + xpos + 1;
            indices.push(
              value12,
              value22,
              value32,
              value22,
              value42,
              value32
            );
          }
          this.buffers[0].data = new Float32Array(verts);
          this.buffers[1].data = new Float32Array(uvs);
          this.indexBuffer.data = new Uint32Array(indices);
          this.buffers[0].update();
          this.buffers[1].update();
          this.indexBuffer.update();
        }
      };
      _PlaneGeometry.defaultOptions = {
        width: 100,
        height: 100,
        verticesX: 10,
        verticesY: 10
      };
      PlaneGeometry = _PlaneGeometry;
    }
  });

  // node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs
  var _NineSliceGeometry, NineSliceGeometry;
  var init_NineSliceGeometry = __esm({
    "node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs"() {
      init_PlaneGeometry();
      _NineSliceGeometry = class _NineSliceGeometry2 extends PlaneGeometry {
        constructor(options2 = {}) {
          options2 = { ..._NineSliceGeometry2.defaultOptions, ...options2 };
          super({
            width: options2.width,
            height: options2.height,
            verticesX: 4,
            verticesY: 4
          });
          this.update(options2);
        }
        /**
         * Updates the NineSliceGeometry with the options.
         * @param options - The options of the NineSliceGeometry.
         */
        update(options2) {
          this.width = options2.width ?? this.width;
          this.height = options2.height ?? this.height;
          this._originalWidth = options2.originalWidth ?? this._originalWidth;
          this._originalHeight = options2.originalHeight ?? this._originalHeight;
          this._leftWidth = options2.leftWidth ?? this._leftWidth;
          this._rightWidth = options2.rightWidth ?? this._rightWidth;
          this._topHeight = options2.topHeight ?? this._topHeight;
          this._bottomHeight = options2.bottomHeight ?? this._bottomHeight;
          this.updateUvs();
          this.updatePositions();
        }
        /** Updates the positions of the vertices. */
        updatePositions() {
          const positions = this.positions;
          const w2 = this._leftWidth + this._rightWidth;
          const scaleW = this.width > w2 ? 1 : this.width / w2;
          const h2 = this._topHeight + this._bottomHeight;
          const scaleH = this.height > h2 ? 1 : this.height / h2;
          const scale = Math.min(scaleW, scaleH);
          positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale;
          positions[17] = positions[19] = positions[21] = positions[23] = this.height - this._bottomHeight * scale;
          positions[25] = positions[27] = positions[29] = positions[31] = this.height;
          positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale;
          positions[4] = positions[12] = positions[20] = positions[28] = this.width - this._rightWidth * scale;
          positions[6] = positions[14] = positions[22] = positions[30] = this.width;
          this.getBuffer("aPosition").update();
        }
        /** Updates the UVs of the vertices. */
        updateUvs() {
          const uvs = this.uvs;
          uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
          uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
          uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
          uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
          const _uvw = 1 / this._originalWidth;
          const _uvh = 1 / this._originalHeight;
          uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
          uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
          uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
          uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
          this.getBuffer("aUV").update();
        }
      };
      _NineSliceGeometry.defaultOptions = {
        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
        width: 100,
        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
        height: 100,
        /** The width of the left column. */
        leftWidth: 10,
        /** The height of the top row. */
        topHeight: 10,
        /** The width of the right column. */
        rightWidth: 10,
        /** The height of the bottom row. */
        bottomHeight: 10,
        /** The original width of the texture */
        originalWidth: 100,
        /** The original height of the texture */
        originalHeight: 100
      };
      NineSliceGeometry = _NineSliceGeometry;
    }
  });

  // node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs
  var NineSliceSpritePipe;
  var init_NineSliceSpritePipe = __esm({
    "node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs"() {
      init_Extensions();
      init_PoolGroup();
      init_BatchableMesh();
      init_NineSliceGeometry();
      NineSliceSpritePipe = class {
        constructor(renderer) {
          this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);
          this._destroyRenderableBound = this.destroyRenderable.bind(this);
          this._renderer = renderer;
          this._renderer.renderableGC.addManagedHash(this, "_gpuSpriteHash");
        }
        addRenderable(sprite, instructionSet) {
          const gpuSprite = this._getGpuSprite(sprite);
          if (sprite.didViewUpdate)
            this._updateBatchableSprite(sprite, gpuSprite);
          this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);
        }
        updateRenderable(sprite) {
          const gpuSprite = this._gpuSpriteHash[sprite.uid];
          if (sprite.didViewUpdate)
            this._updateBatchableSprite(sprite, gpuSprite);
          gpuSprite._batcher.updateElement(gpuSprite);
        }
        validateRenderable(sprite) {
          const texture = sprite._texture;
          const gpuSprite = this._getGpuSprite(sprite);
          if (gpuSprite.texture._source !== texture._source) {
            return !gpuSprite._batcher.checkAndUpdateTexture(gpuSprite, texture);
          }
          return false;
        }
        destroyRenderable(sprite) {
          const batchableMesh = this._gpuSpriteHash[sprite.uid];
          BigPool.return(batchableMesh.geometry);
          BigPool.return(batchableMesh);
          this._gpuSpriteHash[sprite.uid] = null;
          sprite.off("destroyed", this._destroyRenderableBound);
        }
        _updateBatchableSprite(sprite, batchableSprite) {
          batchableSprite.geometry.update(sprite);
          batchableSprite.texture = sprite._texture;
        }
        _getGpuSprite(sprite) {
          return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);
        }
        _initGPUSprite(sprite) {
          const batchableMesh = BigPool.get(BatchableMesh);
          batchableMesh.geometry = BigPool.get(NineSliceGeometry);
          batchableMesh.renderable = sprite;
          batchableMesh.transform = sprite.groupTransform;
          batchableMesh.texture = sprite._texture;
          batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
          this._gpuSpriteHash[sprite.uid] = batchableMesh;
          if (!sprite.didViewUpdate) {
            this._updateBatchableSprite(sprite, batchableMesh);
          }
          sprite.on("destroyed", this._destroyRenderableBound);
          return batchableMesh;
        }
        destroy() {
          for (const i2 in this._gpuSpriteHash) {
            const batchableMesh = this._gpuSpriteHash[i2];
            batchableMesh.geometry.destroy();
          }
          this._gpuSpriteHash = null;
          this._renderer = null;
        }
      };
      NineSliceSpritePipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "nineSliceSprite"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs
  var init_init13 = __esm({
    "node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs"() {
      init_Extensions();
      init_NineSliceSpritePipe();
      extensions.add(NineSliceSpritePipe);
    }
  });

  // node_modules/pixi.js/lib/filters/FilterPipe.mjs
  var FilterPipe;
  var init_FilterPipe = __esm({
    "node_modules/pixi.js/lib/filters/FilterPipe.mjs"() {
      init_Extensions();
      FilterPipe = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        push(filterEffect, container, instructionSet) {
          const renderPipes3 = this._renderer.renderPipes;
          renderPipes3.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "filter",
            canBundle: false,
            action: "pushFilter",
            container,
            filterEffect
          });
        }
        pop(_filterEffect, _container, instructionSet) {
          this._renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "filter",
            action: "popFilter",
            canBundle: false
          });
        }
        execute(instruction) {
          if (instruction.action === "pushFilter") {
            this._renderer.filter.push(instruction);
          } else if (instruction.action === "popFilter") {
            this._renderer.filter.pop();
          }
        }
        destroy() {
          this._renderer = null;
        }
      };
      FilterPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "filter"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.mjs
  function getFastGlobalBounds(target5, bounds) {
    bounds.clear();
    _getGlobalBoundsRecursive(target5, bounds);
    if (!bounds.isValid) {
      bounds.set(0, 0, 0, 0);
    }
    if (!target5.renderGroup) {
      bounds.applyMatrix(target5.parentRenderGroup.worldTransform);
    } else {
      bounds.applyMatrix(target5.renderGroup.localTransform);
    }
    return bounds;
  }
  function _getGlobalBoundsRecursive(target5, bounds) {
    if (target5.localDisplayStatus !== 7 || !target5.measurable) {
      return;
    }
    const manageEffects = !!target5.effects.length;
    let localBounds = bounds;
    if (target5.renderGroup || manageEffects) {
      localBounds = boundsPool.get().clear();
    }
    if (target5.boundsArea) {
      bounds.addRect(target5.boundsArea, target5.worldTransform);
    } else {
      if (target5.renderPipeId) {
        const viewBounds = target5.bounds;
        localBounds.addFrame(
          viewBounds.minX,
          viewBounds.minY,
          viewBounds.maxX,
          viewBounds.maxY,
          target5.groupTransform
        );
      }
      const children2 = target5.children;
      for (let i2 = 0; i2 < children2.length; i2++) {
        _getGlobalBoundsRecursive(children2[i2], localBounds);
      }
    }
    if (manageEffects) {
      let advanced = false;
      for (let i2 = 0; i2 < target5.effects.length; i2++) {
        if (target5.effects[i2].addBounds) {
          if (!advanced) {
            advanced = true;
            localBounds.applyMatrix(target5.parentRenderGroup.worldTransform);
          }
          target5.effects[i2].addBounds(localBounds, true);
        }
      }
      if (advanced) {
        localBounds.applyMatrix(target5.parentRenderGroup.worldTransform.copyTo(tempMatrix4).invert());
        bounds.addBounds(localBounds, target5.relativeGroupTransform);
      }
      bounds.addBounds(localBounds);
      boundsPool.return(localBounds);
    } else if (target5.renderGroup) {
      bounds.addBounds(localBounds, target5.relativeGroupTransform);
      boundsPool.return(localBounds);
    }
  }
  var tempMatrix4;
  var init_getFastGlobalBounds = __esm({
    "node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.mjs"() {
      init_Matrix();
      init_matrixAndBoundsPool();
      tempMatrix4 = new Matrix();
    }
  });

  // node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs
  function getGlobalRenderableBounds(renderables, bounds) {
    bounds.clear();
    const tempMatrix6 = bounds.matrix;
    for (let i2 = 0; i2 < renderables.length; i2++) {
      const renderable = renderables[i2];
      if (renderable.globalDisplayStatus < 7) {
        continue;
      }
      bounds.matrix = renderable.worldTransform;
      renderable.addBounds(bounds);
    }
    bounds.matrix = tempMatrix6;
    return bounds;
  }
  var init_getRenderableBounds = __esm({
    "node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/filters/FilterSystem.mjs
  var quadGeometry, FilterSystem;
  var init_FilterSystem = __esm({
    "node_modules/pixi.js/lib/filters/FilterSystem.mjs"() {
      init_Extensions();
      init_Matrix();
      init_Point();
      init_BindGroup();
      init_Geometry();
      init_UniformGroup();
      init_Texture();
      init_TexturePool();
      init_types2();
      init_Bounds();
      init_getFastGlobalBounds();
      init_getRenderableBounds();
      init_warn();
      quadGeometry = new Geometry({
        attributes: {
          aPosition: {
            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            format: "float32x2",
            stride: 2 * 4,
            offset: 0
          }
        },
        indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])
      });
      FilterSystem = class {
        constructor(renderer) {
          this._filterStackIndex = 0;
          this._filterStack = [];
          this._filterGlobalUniforms = new UniformGroup({
            uInputSize: { value: new Float32Array(4), type: "vec4<f32>" },
            uInputPixel: { value: new Float32Array(4), type: "vec4<f32>" },
            uInputClamp: { value: new Float32Array(4), type: "vec4<f32>" },
            uOutputFrame: { value: new Float32Array(4), type: "vec4<f32>" },
            uGlobalFrame: { value: new Float32Array(4), type: "vec4<f32>" },
            uOutputTexture: { value: new Float32Array(4), type: "vec4<f32>" }
          });
          this._globalFilterBindGroup = new BindGroup({});
          this.renderer = renderer;
        }
        /**
         * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.
         * @readonly
         */
        get activeBackTexture() {
          return this._activeFilterData?.backTexture;
        }
        push(instruction) {
          const renderer = this.renderer;
          const filters = instruction.filterEffect.filters;
          if (!this._filterStack[this._filterStackIndex]) {
            this._filterStack[this._filterStackIndex] = this._getFilterData();
          }
          const filterData = this._filterStack[this._filterStackIndex];
          this._filterStackIndex++;
          if (filters.length === 0) {
            filterData.skip = true;
            return;
          }
          const bounds = filterData.bounds;
          if (instruction.renderables) {
            getGlobalRenderableBounds(instruction.renderables, bounds);
          } else if (instruction.filterEffect.filterArea) {
            bounds.clear();
            bounds.addRect(instruction.filterEffect.filterArea);
            bounds.applyMatrix(instruction.container.worldTransform);
          } else {
            getFastGlobalBounds(instruction.container, bounds);
          }
          const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;
          let resolution = Infinity;
          let padding = 0;
          let antialias = true;
          let blendRequired = false;
          let enabled = false;
          let clipToViewport = true;
          for (let i2 = 0; i2 < filters.length; i2++) {
            const filter3 = filters[i2];
            resolution = Math.min(resolution, filter3.resolution === "inherit" ? colorTextureSource._resolution : filter3.resolution);
            padding += filter3.padding;
            if (filter3.antialias === "off") {
              antialias = false;
            } else if (filter3.antialias === "inherit") {
              antialias && (antialias = colorTextureSource.antialias);
            }
            if (!filter3.clipToViewport) {
              clipToViewport = false;
            }
            const isCompatible = !!(filter3.compatibleRenderers & renderer.type);
            if (!isCompatible) {
              enabled = false;
              break;
            }
            if (filter3.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {
              warn2("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.");
              enabled = false;
              break;
            }
            enabled = filter3.enabled || enabled;
            blendRequired = blendRequired || filter3.blendRequired;
          }
          if (!enabled) {
            filterData.skip = true;
            return;
          }
          bounds.scale(resolution);
          if (clipToViewport) {
            const viewPort = renderer.renderTarget.rootViewPort;
            bounds.fitBounds(0, viewPort.width, 0, viewPort.height);
          }
          bounds.ceil().scale(1 / resolution).pad(padding | 0);
          if (!bounds.isPositive) {
            filterData.skip = true;
            return;
          }
          filterData.skip = false;
          filterData.bounds = bounds;
          filterData.blendRequired = blendRequired;
          filterData.container = instruction.container;
          filterData.filterEffect = instruction.filterEffect;
          filterData.previousRenderSurface = renderer.renderTarget.renderSurface;
          filterData.inputTexture = TexturePool.getOptimalTexture(
            bounds.width,
            bounds.height,
            resolution,
            antialias
          );
          renderer.renderTarget.bind(filterData.inputTexture, true);
          renderer.globalUniforms.push({
            offset: bounds
          });
        }
        pop() {
          const renderer = this.renderer;
          this._filterStackIndex--;
          const filterData = this._filterStack[this._filterStackIndex];
          if (filterData.skip) {
            return;
          }
          this._activeFilterData = filterData;
          const inputTexture = filterData.inputTexture;
          const bounds = filterData.bounds;
          let backTexture = Texture.EMPTY;
          renderer.renderTarget.finishRenderPass();
          if (filterData.blendRequired) {
            const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;
            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);
            backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);
          }
          filterData.backTexture = backTexture;
          const filters = filterData.filterEffect.filters;
          this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);
          this._globalFilterBindGroup.setResource(backTexture.source, 3);
          renderer.globalUniforms.pop();
          if (filters.length === 1) {
            filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);
            TexturePool.returnTexture(inputTexture);
          } else {
            let flip2 = filterData.inputTexture;
            let flop = TexturePool.getOptimalTexture(
              bounds.width,
              bounds.height,
              flip2.source._resolution,
              false
            );
            let i2 = 0;
            for (i2 = 0; i2 < filters.length - 1; ++i2) {
              const filter3 = filters[i2];
              filter3.apply(this, flip2, flop, true);
              const t3 = flip2;
              flip2 = flop;
              flop = t3;
            }
            filters[i2].apply(this, flip2, filterData.previousRenderSurface, false);
            TexturePool.returnTexture(flip2);
            TexturePool.returnTexture(flop);
          }
          if (filterData.blendRequired) {
            TexturePool.returnTexture(backTexture);
          }
        }
        getBackTexture(lastRenderSurface, bounds, previousBounds) {
          const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;
          const backTexture = TexturePool.getOptimalTexture(
            bounds.width,
            bounds.height,
            backgroundResolution,
            false
          );
          let x2 = bounds.minX;
          let y2 = bounds.minY;
          if (previousBounds) {
            x2 -= previousBounds.minX;
            y2 -= previousBounds.minY;
          }
          x2 = Math.floor(x2 * backgroundResolution);
          y2 = Math.floor(y2 * backgroundResolution);
          const width8 = Math.ceil(bounds.width * backgroundResolution);
          const height8 = Math.ceil(bounds.height * backgroundResolution);
          this.renderer.renderTarget.copyToTexture(
            lastRenderSurface,
            backTexture,
            { x: x2, y: y2 },
            { width: width8, height: height8 },
            { x: 0, y: 0 }
          );
          return backTexture;
        }
        applyFilter(filter3, input, output2, clear2) {
          const renderer = this.renderer;
          const filterData = this._filterStack[this._filterStackIndex];
          const bounds = filterData.bounds;
          const offset = Point.shared;
          const previousRenderSurface = filterData.previousRenderSurface;
          const isFinalTarget = previousRenderSurface === output2;
          let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;
          let currentIndex = this._filterStackIndex - 1;
          while (currentIndex > 0 && this._filterStack[currentIndex].skip) {
            --currentIndex;
          }
          if (currentIndex > 0) {
            resolution = this._filterStack[currentIndex].inputTexture.source._resolution;
          }
          const filterUniforms = this._filterGlobalUniforms;
          const uniforms = filterUniforms.uniforms;
          const outputFrame = uniforms.uOutputFrame;
          const inputSize = uniforms.uInputSize;
          const inputPixel = uniforms.uInputPixel;
          const inputClamp = uniforms.uInputClamp;
          const globalFrame = uniforms.uGlobalFrame;
          const outputTexture = uniforms.uOutputTexture;
          if (isFinalTarget) {
            let lastIndex = this._filterStackIndex;
            while (lastIndex > 0) {
              lastIndex--;
              const filterData2 = this._filterStack[this._filterStackIndex - 1];
              if (!filterData2.skip) {
                offset.x = filterData2.bounds.minX;
                offset.y = filterData2.bounds.minY;
                break;
              }
            }
            outputFrame[0] = bounds.minX - offset.x;
            outputFrame[1] = bounds.minY - offset.y;
          } else {
            outputFrame[0] = 0;
            outputFrame[1] = 0;
          }
          outputFrame[2] = input.frame.width;
          outputFrame[3] = input.frame.height;
          inputSize[0] = input.source.width;
          inputSize[1] = input.source.height;
          inputSize[2] = 1 / inputSize[0];
          inputSize[3] = 1 / inputSize[1];
          inputPixel[0] = input.source.pixelWidth;
          inputPixel[1] = input.source.pixelHeight;
          inputPixel[2] = 1 / inputPixel[0];
          inputPixel[3] = 1 / inputPixel[1];
          inputClamp[0] = 0.5 * inputPixel[2];
          inputClamp[1] = 0.5 * inputPixel[3];
          inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];
          inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];
          const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;
          globalFrame[0] = offset.x * resolution;
          globalFrame[1] = offset.y * resolution;
          globalFrame[2] = rootTexture.source.width * resolution;
          globalFrame[3] = rootTexture.source.height * resolution;
          const renderTarget = this.renderer.renderTarget.getRenderTarget(output2);
          renderer.renderTarget.bind(output2, !!clear2);
          if (output2 instanceof Texture) {
            outputTexture[0] = output2.frame.width;
            outputTexture[1] = output2.frame.height;
          } else {
            outputTexture[0] = renderTarget.width;
            outputTexture[1] = renderTarget.height;
          }
          outputTexture[2] = renderTarget.isRoot ? -1 : 1;
          filterUniforms.update();
          if (renderer.renderPipes.uniformBatch) {
            const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(filterUniforms);
            this._globalFilterBindGroup.setResource(batchUniforms, 0);
          } else {
            this._globalFilterBindGroup.setResource(filterUniforms, 0);
          }
          this._globalFilterBindGroup.setResource(input.source, 1);
          this._globalFilterBindGroup.setResource(input.source.style, 2);
          filter3.groups[0] = this._globalFilterBindGroup;
          renderer.encoder.draw({
            geometry: quadGeometry,
            shader: filter3,
            state: filter3._state,
            topology: "triangle-list"
          });
          if (renderer.type === RendererType.WEBGL) {
            renderer.renderTarget.finishRenderPass();
          }
        }
        _getFilterData() {
          return {
            skip: false,
            inputTexture: null,
            bounds: new Bounds(),
            container: null,
            filterEffect: null,
            blendRequired: false,
            previousRenderSurface: null
          };
        }
        /**
         * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.
         *
         * Use `outputMatrix * vTextureCoord` in the shader.
         * @param outputMatrix - The matrix to output to.
         * @param {Sprite} sprite - The sprite to map to.
         * @returns The mapped matrix.
         */
        calculateSpriteMatrix(outputMatrix, sprite) {
          const data = this._activeFilterData;
          const mappedMatrix = outputMatrix.set(
            data.inputTexture._source.width,
            0,
            0,
            data.inputTexture._source.height,
            data.bounds.minX,
            data.bounds.minY
          );
          const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);
          worldTransform.invert();
          mappedMatrix.prepend(worldTransform);
          mappedMatrix.scale(
            1 / sprite.texture.frame.width,
            1 / sprite.texture.frame.height
          );
          mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
          return mappedMatrix;
        }
      };
      FilterSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "filter"
      };
    }
  });

  // node_modules/pixi.js/lib/filters/init.mjs
  var init_init14 = __esm({
    "node_modules/pixi.js/lib/filters/init.mjs"() {
      init_Extensions();
      init_FilterPipe();
      init_FilterSystem();
      extensions.add(FilterSystem);
      extensions.add(FilterPipe);
    }
  });

  // node_modules/pixi.js/lib/environment-browser/browserAll.mjs
  var browserAll_exports = {};
  var init_browserAll = __esm({
    "node_modules/pixi.js/lib/environment-browser/browserAll.mjs"() {
      init_init();
      init_init2();
      init_init3();
      init_init4();
      init_init5();
      init_init6();
      init_init7();
      init_init8();
      init_init9();
      init_init10();
      init_init11();
      init_init12();
      init_init13();
      init_init14();
    }
  });

  // node_modules/pixi.js/lib/environment-webworker/webworkerAll.mjs
  var webworkerAll_exports = {};
  var init_webworkerAll = __esm({
    "node_modules/pixi.js/lib/environment-webworker/webworkerAll.mjs"() {
      init_init2();
      init_init4();
      init_init5();
      init_init6();
      init_init7();
      init_init8();
      init_init9();
      init_init10();
      init_init11();
      init_init12();
      init_init13();
      init_init14();
    }
  });

  // node_modules/pixi.js/lib/filters/Filter.mjs
  var _Filter, Filter;
  var init_Filter = __esm({
    "node_modules/pixi.js/lib/filters/Filter.mjs"() {
      init_GlProgram();
      init_GpuProgram();
      init_Shader();
      init_State();
      _Filter = class _Filter2 extends Shader {
        /**
         * @param options - The optional parameters of this filter.
         */
        constructor(options2) {
          options2 = { ..._Filter2.defaultOptions, ...options2 };
          super(options2);
          this.enabled = true;
          this._state = State.for2d();
          this.blendMode = options2.blendMode;
          this.padding = options2.padding;
          if (typeof options2.antialias === "boolean") {
            this.antialias = options2.antialias ? "on" : "off";
          } else {
            this.antialias = options2.antialias;
          }
          this.resolution = options2.resolution;
          this.blendRequired = options2.blendRequired;
          this.clipToViewport = options2.clipToViewport;
          this.addResource("uTexture", 0, 1);
        }
        /**
         * Applies the filter
         * @param filterManager - The renderer to retrieve the filter from
         * @param input - The input render target.
         * @param output - The target to output to.
         * @param clearMode - Should the output be cleared before rendering to it
         */
        apply(filterManager, input, output2, clearMode) {
          filterManager.applyFilter(this, input, output2, clearMode);
        }
        /**
         * Get the blend mode of the filter.
         * @default "normal"
         */
        get blendMode() {
          return this._state.blendMode;
        }
        /** Sets the blend mode of the filter. */
        set blendMode(value12) {
          this._state.blendMode = value12;
        }
        /**
         * A short hand function to create a filter based of a vertex and fragment shader src.
         * @param options
         * @returns A shiny new PixiJS filter!
         */
        static from(options2) {
          const { gpu, gl, ...rest } = options2;
          let gpuProgram3;
          let glProgram3;
          if (gpu) {
            gpuProgram3 = GpuProgram.from(gpu);
          }
          if (gl) {
            glProgram3 = GlProgram.from(gl);
          }
          return new _Filter2({
            gpuProgram: gpuProgram3,
            glProgram: glProgram3,
            ...rest
          });
        }
      };
      _Filter.defaultOptions = {
        blendMode: "normal",
        resolution: 1,
        padding: 0,
        antialias: "off",
        blendRequired: false,
        clipToViewport: true
      };
      Filter = _Filter;
    }
  });

  // node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs
  async function loadEnvironmentExtensions(skip) {
    if (skip)
      return;
    for (let i2 = 0; i2 < environments.length; i2++) {
      const env = environments[i2];
      if (env.value.test()) {
        await env.value.load();
        return;
      }
    }
  }
  var environments;
  var init_autoDetectEnvironment = __esm({
    "node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs"() {
      init_Extensions();
      environments = [];
      extensions.handleByNamedList(ExtensionType.Environment, environments);
    }
  });

  // node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs
  function unsafeEvalSupported() {
    if (typeof unsafeEval === "boolean") {
      return unsafeEval;
    }
    try {
      const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
      unsafeEval = func({ a: "b" }, "a", "b") === true;
    } catch (e2) {
      unsafeEval = false;
    }
    return unsafeEval;
  }
  var unsafeEval;
  var init_unsafeEvalSupported = __esm({
    "node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs
  var CLEAR;
  var init_const7 = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs"() {
      "use strict";
      CLEAR = /* @__PURE__ */ ((CLEAR2) => {
        CLEAR2[CLEAR2["NONE"] = 0] = "NONE";
        CLEAR2[CLEAR2["COLOR"] = 16384] = "COLOR";
        CLEAR2[CLEAR2["STENCIL"] = 1024] = "STENCIL";
        CLEAR2[CLEAR2["DEPTH"] = 256] = "DEPTH";
        CLEAR2[CLEAR2["COLOR_DEPTH"] = 16640] = "COLOR_DEPTH";
        CLEAR2[CLEAR2["COLOR_STENCIL"] = 17408] = "COLOR_STENCIL";
        CLEAR2[CLEAR2["DEPTH_STENCIL"] = 1280] = "DEPTH_STENCIL";
        CLEAR2[CLEAR2["ALL"] = 17664] = "ALL";
        return CLEAR2;
      })(CLEAR || {});
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs
  var SystemRunner;
  var init_SystemRunner = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs"() {
      "use strict";
      SystemRunner = class {
        /**
         * @param name - The function name that will be executed on the listeners added to this Runner.
         */
        constructor(name16) {
          this.items = [];
          this._name = name16;
        }
        /* eslint-disable jsdoc/require-param, jsdoc/check-param-names */
        /**
         * Dispatch/Broadcast Runner to all listeners added to the queue.
         * @param {...any} params - (optional) parameters to pass to each listener
         */
        /*  eslint-enable jsdoc/require-param, jsdoc/check-param-names */
        emit(a0, a1, a2, a3, a4, a5, a6, a7) {
          const { name: name16, items } = this;
          for (let i2 = 0, len = items.length; i2 < len; i2++) {
            items[i2][name16](a0, a1, a2, a3, a4, a5, a6, a7);
          }
          return this;
        }
        /**
         * Add a listener to the Runner
         *
         * Runners do not need to have scope or functions passed to them.
         * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
         * as the name provided to the Runner when it was created.
         *
         * Eg A listener passed to this Runner will require a 'complete' function.
         *
         * ```
         * import { Runner } from 'pixi.js';
         *
         * const complete = new Runner('complete');
         * ```
         *
         * The scope used will be the object itself.
         * @param {any} item - The object that will be listening.
         */
        add(item) {
          if (item[this._name]) {
            this.remove(item);
            this.items.push(item);
          }
          return this;
        }
        /**
         * Remove a single listener from the dispatch queue.
         * @param {any} item - The listener that you would like to remove.
         */
        remove(item) {
          const index6 = this.items.indexOf(item);
          if (index6 !== -1) {
            this.items.splice(index6, 1);
          }
          return this;
        }
        /**
         * Check to see if the listener is already in the Runner
         * @param {any} item - The listener that you would like to check.
         */
        contains(item) {
          return this.items.indexOf(item) !== -1;
        }
        /** Remove all listeners from the Runner */
        removeAll() {
          this.items.length = 0;
          return this;
        }
        /** Remove all references, don't use after this. */
        destroy() {
          this.removeAll();
          this.items = null;
          this._name = null;
        }
        /**
         * `true` if there are no this Runner contains no listeners
         * @readonly
         */
        get empty() {
          return this.items.length === 0;
        }
        /**
         * The name of the runner.
         * @readonly
         */
        get name() {
          return this._name;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs
  var defaultRunners, _AbstractRenderer, AbstractRenderer;
  var init_AbstractRenderer = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs"() {
      init_Color();
      init_autoDetectEnvironment();
      init_Container();
      init_unsafeEvalSupported();
      init_deprecation();
      init_const7();
      init_SystemRunner();
      init_eventemitter3();
      defaultRunners = [
        "init",
        "destroy",
        "contextChange",
        "resolutionChange",
        "reset",
        "renderEnd",
        "renderStart",
        "render",
        "update",
        "postrender",
        "prerender"
      ];
      _AbstractRenderer = class _AbstractRenderer2 extends eventemitter3_default {
        /**
         * Set up a system with a collection of SystemClasses and runners.
         * Systems are attached dynamically to this class when added.
         * @param config - the config for the system manager
         */
        constructor(config2) {
          super();
          this.runners = /* @__PURE__ */ Object.create(null);
          this.renderPipes = /* @__PURE__ */ Object.create(null);
          this._initOptions = {};
          this._systemsHash = /* @__PURE__ */ Object.create(null);
          this.type = config2.type;
          this.name = config2.name;
          this.config = config2;
          const combinedRunners = [...defaultRunners, ...this.config.runners ?? []];
          this._addRunners(...combinedRunners);
          this._unsafeEvalCheck();
        }
        /**
         * Initialize the renderer.
         * @param options - The options to use to create the renderer.
         */
        async init(options2 = {}) {
          const skip = options2.skipExtensionImports === true ? true : options2.manageImports === false;
          await loadEnvironmentExtensions(skip);
          this._addSystems(this.config.systems);
          this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
          for (const systemName in this._systemsHash) {
            const system = this._systemsHash[systemName];
            const defaultSystemOptions = system.constructor.defaultOptions;
            options2 = { ...defaultSystemOptions, ...options2 };
          }
          options2 = { ..._AbstractRenderer2.defaultOptions, ...options2 };
          this._roundPixels = options2.roundPixels ? 1 : 0;
          for (let i2 = 0; i2 < this.runners.init.items.length; i2++) {
            await this.runners.init.items[i2].init(options2);
          }
          this._initOptions = options2;
        }
        render(args, deprecated) {
          let options2 = args;
          if (options2 instanceof Container) {
            options2 = { container: options2 };
            if (deprecated) {
              deprecation(v8_0_0, "passing a second argument is deprecated, please use render options instead");
              options2.target = deprecated.renderTexture;
            }
          }
          options2.target || (options2.target = this.view.renderTarget);
          if (options2.target === this.view.renderTarget) {
            this._lastObjectRendered = options2.container;
            options2.clearColor = this.background.colorRgba;
          }
          if (options2.clearColor) {
            const isRGBAArray = Array.isArray(options2.clearColor) && options2.clearColor.length === 4;
            options2.clearColor = isRGBAArray ? options2.clearColor : Color.shared.setValue(options2.clearColor).toArray();
          }
          if (!options2.transform) {
            options2.container.updateLocalTransform();
            options2.transform = options2.container.localTransform;
          }
          this.runners.prerender.emit(options2);
          this.runners.renderStart.emit(options2);
          this.runners.render.emit(options2);
          this.runners.renderEnd.emit(options2);
          this.runners.postrender.emit(options2);
        }
        /**
         * Resizes the WebGL view to the specified width and height.
         * @param desiredScreenWidth - The desired width of the screen.
         * @param desiredScreenHeight - The desired height of the screen.
         * @param resolution - The resolution / device pixel ratio of the renderer.
         */
        resize(desiredScreenWidth, desiredScreenHeight, resolution) {
          const previousResolution = this.view.resolution;
          this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);
          this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution);
          if (resolution !== void 0 && resolution !== previousResolution) {
            this.runners.resolutionChange.emit(resolution);
          }
        }
        clear(options2 = {}) {
          const renderer = this;
          options2.target || (options2.target = renderer.renderTarget.renderTarget);
          options2.clearColor || (options2.clearColor = this.background.colorRgba);
          options2.clear ?? (options2.clear = CLEAR.ALL);
          const { clear: clear2, clearColor, target: target5 } = options2;
          Color.shared.setValue(clearColor ?? this.background.colorRgba);
          renderer.renderTarget.clear(target5, clear2, Color.shared.toArray());
        }
        /** The resolution / device pixel ratio of the renderer. */
        get resolution() {
          return this.view.resolution;
        }
        set resolution(value12) {
          this.view.resolution = value12;
          this.runners.resolutionChange.emit(value12);
        }
        /**
         * Same as view.width, actual number of pixels in the canvas by horizontal.
         * @member {number}
         * @readonly
         * @default 800
         */
        get width() {
          return this.view.texture.frame.width;
        }
        /**
         * Same as view.height, actual number of pixels in the canvas by vertical.
         * @default 600
         */
        get height() {
          return this.view.texture.frame.height;
        }
        // NOTE: this was `view` in v7
        /**
         * The canvas element that everything is drawn to.
         * @type {environment.ICanvas}
         */
        get canvas() {
          return this.view.canvas;
        }
        /**
         * the last object rendered by the renderer. Useful for other plugins like interaction managers
         * @readonly
         */
        get lastObjectRendered() {
          return this._lastObjectRendered;
        }
        /**
         * Flag if we are rendering to the screen vs renderTexture
         * @readonly
         * @default true
         */
        get renderingToScreen() {
          const renderer = this;
          return renderer.renderTarget.renderingToScreen;
        }
        /**
         * Measurements of the screen. (0, 0, screenWidth, screenHeight).
         *
         * Its safe to use as filterArea or hitArea for the whole stage.
         */
        get screen() {
          return this.view.screen;
        }
        /**
         * Create a bunch of runners based of a collection of ids
         * @param runnerIds - the runner ids to add
         */
        _addRunners(...runnerIds) {
          runnerIds.forEach((runnerId) => {
            this.runners[runnerId] = new SystemRunner(runnerId);
          });
        }
        _addSystems(systems3) {
          let i2;
          for (i2 in systems3) {
            const val = systems3[i2];
            this._addSystem(val.value, val.name);
          }
        }
        /**
         * Add a new system to the renderer.
         * @param ClassRef - Class reference
         * @param name - Property name for system, if not specified
         *        will use a static `name` property on the class itself. This
         *        name will be assigned as s property on the Renderer so make
         *        sure it doesn't collide with properties on Renderer.
         * @returns Return instance of renderer
         */
        _addSystem(ClassRef, name16) {
          const system = new ClassRef(this);
          if (this[name16]) {
            throw new Error(`Whoops! The name "${name16}" is already in use`);
          }
          this[name16] = system;
          this._systemsHash[name16] = system;
          for (const i2 in this.runners) {
            this.runners[i2].add(system);
          }
          return this;
        }
        _addPipes(pipes, pipeAdaptors) {
          const adaptors = pipeAdaptors.reduce((acc, adaptor) => {
            acc[adaptor.name] = adaptor.value;
            return acc;
          }, {});
          pipes.forEach((pipe) => {
            const PipeClass = pipe.value;
            const name16 = pipe.name;
            const Adaptor = adaptors[name16];
            this.renderPipes[name16] = new PipeClass(
              this,
              Adaptor ? new Adaptor() : null
            );
          });
        }
        destroy(options2 = false) {
          this.runners.destroy.items.reverse();
          this.runners.destroy.emit(options2);
          Object.values(this.runners).forEach((runner) => {
            runner.destroy();
          });
          this._systemsHash = null;
          this.renderPipes = null;
        }
        /**
         * Generate a texture from a container.
         * @param options - options or container target to use when generating the texture
         * @returns a texture
         */
        generateTexture(options2) {
          return this.textureGenerator.generateTexture(options2);
        }
        /**
         * Whether the renderer will round coordinates to whole pixels when rendering.
         * Can be overridden on a per scene item basis.
         */
        get roundPixels() {
          return !!this._roundPixels;
        }
        /**
         * Overridable function by `pixi.js/unsafe-eval` to silence
         * throwing an error if platform doesn't support unsafe-evals.
         * @private
         * @ignore
         */
        _unsafeEvalCheck() {
          if (!unsafeEvalSupported()) {
            throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
          }
        }
      };
      _AbstractRenderer.defaultOptions = {
        /**
         * Default resolution / device pixel ratio of the renderer.
         * @default 1
         */
        resolution: 1,
        /**
         * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`
         * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be
         * performance issues when using WebGL.
         *
         * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many
         * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or
         * driver version blacklisted by the
         * browser.
         *
         * If your application requires high performance rendering, you may wish to set this to false.
         * We recommend one of two options if you decide to set this flag to false:
         *
         * 1: Use the Canvas renderer as a fallback in case high performance WebGL is
         *    not supported.
         *
         * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a
         *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their
         *    device & browser combination does not support high performance WebGL.
         *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.
         * @default false
         */
        failIfMajorPerformanceCaveat: false,
        /**
         * Should round pixels be forced when rendering?
         * @default false
         */
        roundPixels: false
      };
      AbstractRenderer = _AbstractRenderer;
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs
  var GpuGraphicsAdaptor;
  var init_GpuGraphicsAdaptor = __esm({
    "node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs"() {
      init_Extensions();
      init_Matrix();
      init_maxRecommendedTextures();
      init_getTextureBatchBindGroup();
      init_compileHighShaderToProgram();
      init_colorBit();
      init_generateTextureBatchBit();
      init_localUniformBit();
      init_roundPixelsBit();
      init_Shader();
      init_UniformGroup();
      GpuGraphicsAdaptor = class {
        init() {
          const localUniforms = new UniformGroup({
            uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uRound: { value: 0, type: "f32" }
          });
          const gpuProgram3 = compileHighShaderGpuProgram({
            name: "graphics",
            bits: [
              colorBit,
              generateTextureBatchBit(getMaxTexturesPerBatch()),
              localUniformBitGroup2,
              roundPixelsBit
            ]
          });
          this.shader = new Shader({
            gpuProgram: gpuProgram3,
            resources: {
              // added on the fly!
              localUniforms
            }
          });
        }
        execute(graphicsPipe, renderable) {
          const context3 = renderable.context;
          const shader = context3.customShader || this.shader;
          const renderer = graphicsPipe.renderer;
          const contextSystem = renderer.graphicsContext;
          const {
            batcher,
            instructions
          } = contextSystem.getContextRenderData(context3);
          const encoder = renderer.encoder;
          encoder.setPipelineFromGeometryProgramAndState(
            batcher.geometry,
            shader.gpuProgram,
            graphicsPipe.state
          );
          encoder.setGeometry(batcher.geometry, shader.gpuProgram);
          const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
          encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);
          const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);
          encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);
          const batches = instructions.instructions;
          for (let i2 = 0; i2 < instructions.instructionSize; i2++) {
            const batch = batches[i2];
            shader.groups[1] = batch.bindGroup;
            if (!batch.gpuBindGroup) {
              const textureBatch = batch.textures;
              batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);
              batch.gpuBindGroup = renderer.bindGroup.getBindGroup(
                batch.bindGroup,
                shader.gpuProgram,
                1
              );
            }
            encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);
            encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
          }
        }
        destroy() {
          this.shader.destroy(true);
          this.shader = null;
        }
      };
      GpuGraphicsAdaptor.extension = {
        type: [
          ExtensionType.WebGPUPipesAdaptor
        ],
        name: "graphics"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs
  var textureBit, textureBitGl;
  var init_textureBit = __esm({
    "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs"() {
      "use strict";
      textureBit = {
        name: "texture-bit",
        vertex: {
          header: (
            /* wgsl */
            `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `
          ),
          main: (
            /* wgsl */
            `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `
          )
        },
        fragment: {
          header: (
            /* wgsl */
            `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;

         
        `
          ),
          main: (
            /* wgsl */
            `
            outColor = textureSample(uTexture, uSampler, vUV);
        `
          )
        }
      };
      textureBitGl = {
        name: "texture-bit",
        vertex: {
          header: (
            /* glsl */
            `
            uniform mat3 uTextureMatrix;
        `
          ),
          main: (
            /* glsl */
            `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `
          )
        },
        fragment: {
          header: (
            /* glsl */
            `
        uniform sampler2D uTexture;

         
        `
          ),
          main: (
            /* glsl */
            `
            outColor = texture(uTexture, vUV);
        `
          )
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs
  var GpuMeshAdapter;
  var init_GpuMeshAdapter = __esm({
    "node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs"() {
      init_Extensions();
      init_Matrix();
      init_compileHighShaderToProgram();
      init_localUniformBit();
      init_roundPixelsBit();
      init_textureBit();
      init_Shader();
      init_Texture();
      init_warn();
      GpuMeshAdapter = class {
        init() {
          const gpuProgram3 = compileHighShaderGpuProgram({
            name: "mesh",
            bits: [
              localUniformBit,
              textureBit,
              roundPixelsBit
            ]
          });
          this._shader = new Shader({
            gpuProgram: gpuProgram3,
            resources: {
              uTexture: Texture.EMPTY._source,
              uSampler: Texture.EMPTY._source.style,
              textureUniforms: {
                uTextureMatrix: { type: "mat3x3<f32>", value: new Matrix() }
              }
            }
          });
        }
        execute(meshPipe, mesh) {
          const renderer = meshPipe.renderer;
          let shader = mesh._shader;
          if (!shader) {
            shader = this._shader;
            shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);
          } else if (!shader.gpuProgram) {
            warn2("Mesh shader has no gpuProgram", mesh.shader);
            return;
          }
          const gpuProgram3 = shader.gpuProgram;
          if (gpuProgram3.autoAssignGlobalUniforms) {
            shader.groups[0] = renderer.globalUniforms.bindGroup;
          }
          if (gpuProgram3.autoAssignLocalUniforms) {
            const localUniforms = meshPipe.localUniforms;
            shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);
          }
          renderer.encoder.draw({
            geometry: mesh._geometry,
            shader,
            state: mesh.state
          });
        }
        destroy() {
          this._shader.destroy(true);
          this._shader = null;
        }
      };
      GpuMeshAdapter.extension = {
        type: [
          ExtensionType.WebGPUPipesAdaptor
        ],
        name: "mesh"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs
  var tempState, GpuBatchAdaptor;
  var init_GpuBatchAdaptor = __esm({
    "node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs"() {
      init_Extensions();
      init_State();
      init_getTextureBatchBindGroup();
      tempState = State.for2d();
      GpuBatchAdaptor = class {
        start(batchPipe, geometry, shader) {
          const renderer = batchPipe.renderer;
          const encoder = renderer.encoder;
          const program = shader.gpuProgram;
          this._shader = shader;
          this._geometry = geometry;
          encoder.setGeometry(geometry, program);
          tempState.blendMode = "normal";
          renderer.pipeline.getPipeline(
            geometry,
            program,
            tempState
          );
          const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
          encoder.resetBindGroup(1);
          encoder.setBindGroup(0, globalUniformsBindGroup, program);
        }
        execute(batchPipe, batch) {
          const program = this._shader.gpuProgram;
          const renderer = batchPipe.renderer;
          const encoder = renderer.encoder;
          if (!batch.bindGroup) {
            const textureBatch = batch.textures;
            batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);
          }
          tempState.blendMode = batch.blendMode;
          const gpuBindGroup = renderer.bindGroup.getBindGroup(
            batch.bindGroup,
            program,
            1
          );
          const pipeline = renderer.pipeline.getPipeline(
            this._geometry,
            program,
            tempState
          );
          batch.bindGroup._touch(renderer.textureGC.count);
          encoder.setPipeline(pipeline);
          encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);
          encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
        }
      };
      GpuBatchAdaptor.extension = {
        type: [
          ExtensionType.WebGPUPipesAdaptor
        ],
        name: "batch"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs
  var CustomRenderPipe;
  var init_CustomRenderPipe = __esm({
    "node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs"() {
      init_Extensions();
      CustomRenderPipe = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        updateRenderable() {
        }
        destroyRenderable() {
        }
        validateRenderable() {
          return false;
        }
        addRenderable(container, instructionSet) {
          this._renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add(container);
        }
        execute(container) {
          if (!container.isRenderable)
            return;
          container.render(this._renderer);
        }
        destroy() {
          this._renderer = null;
        }
      };
      CustomRenderPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "customRender"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs
  function executeInstructions(renderGroup, renderer) {
    const instructionSet = renderGroup.instructionSet;
    const instructions = instructionSet.instructions;
    for (let i2 = 0; i2 < instructionSet.instructionSize; i2++) {
      const instruction = instructions[i2];
      renderer[instruction.renderPipeId].execute(instruction);
    }
  }
  var init_executeInstructions = __esm({
    "node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs
  var RenderGroupPipe;
  var init_RenderGroupPipe = __esm({
    "node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs"() {
      init_Extensions();
      init_executeInstructions();
      RenderGroupPipe = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        addRenderGroup(renderGroup, instructionSet) {
          this._renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add(renderGroup);
        }
        execute(renderGroup) {
          if (!renderGroup.isRenderable)
            return;
          this._renderer.globalUniforms.push({
            worldTransformMatrix: renderGroup.worldTransform,
            worldColor: renderGroup.worldColorAlpha
          });
          executeInstructions(renderGroup, this._renderer.renderPipes);
          this._renderer.globalUniforms.pop();
        }
        destroy() {
          this._renderer = null;
        }
      };
      RenderGroupPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "renderGroup"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/container/utils/buildInstructions.mjs
  function buildInstructions(renderGroup, rendererOrPipes) {
    const root = renderGroup.root;
    const instructionSet = renderGroup.instructionSet;
    instructionSet.reset();
    const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;
    const renderPipes3 = renderer.renderPipes;
    renderPipes3.batch.buildStart(instructionSet);
    renderPipes3.blendMode.buildStart();
    renderPipes3.colorMask.buildStart();
    if (root.sortableChildren) {
      root.sortChildren();
    }
    collectAllRenderablesAdvanced(root, instructionSet, renderer, true);
    renderPipes3.batch.buildEnd(instructionSet);
    renderPipes3.blendMode.buildEnd(instructionSet);
  }
  function collectAllRenderables(container, instructionSet, rendererOrPipes) {
    const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;
    if (container.globalDisplayStatus < 7 || !container.includeInBuild)
      return;
    if (container.sortableChildren) {
      container.sortChildren();
    }
    if (container.isSimple) {
      collectAllRenderablesSimple(container, instructionSet, renderer);
    } else {
      collectAllRenderablesAdvanced(container, instructionSet, renderer, false);
    }
  }
  function collectAllRenderablesSimple(container, instructionSet, renderer) {
    if (container.renderPipeId) {
      const renderable = container;
      const { renderPipes: renderPipes3, renderableGC } = renderer;
      renderPipes3.blendMode.setBlendMode(renderable, container.groupBlendMode, instructionSet);
      const rp = renderPipes3;
      rp[renderable.renderPipeId].addRenderable(renderable, instructionSet);
      renderableGC.addRenderable(renderable, instructionSet);
      renderable.didViewUpdate = false;
    }
    if (!container.renderGroup) {
      const children2 = container.children;
      const length9 = children2.length;
      for (let i2 = 0; i2 < length9; i2++) {
        collectAllRenderables(children2[i2], instructionSet, renderer);
      }
    }
  }
  function collectAllRenderablesAdvanced(container, instructionSet, renderer, isRoot) {
    const { renderPipes: renderPipes3, renderableGC } = renderer;
    if (!isRoot && container.renderGroup) {
      renderPipes3.renderGroup.addRenderGroup(container.renderGroup, instructionSet);
    } else {
      for (let i2 = 0; i2 < container.effects.length; i2++) {
        const effect = container.effects[i2];
        const pipe = renderPipes3[effect.pipe];
        pipe.push(effect, container, instructionSet);
      }
      const renderable = container;
      const renderPipeId = renderable.renderPipeId;
      if (renderPipeId) {
        renderPipes3.blendMode.setBlendMode(renderable, renderable.groupBlendMode, instructionSet);
        const pipe = renderPipes3[renderPipeId];
        pipe.addRenderable(renderable, instructionSet);
        renderableGC.addRenderable(renderable, instructionSet);
        renderable.didViewUpdate = false;
      }
      const children2 = container.children;
      if (children2.length) {
        for (let i2 = 0; i2 < children2.length; i2++) {
          collectAllRenderables(children2[i2], instructionSet, renderer);
        }
      }
      for (let i2 = container.effects.length - 1; i2 >= 0; i2--) {
        const effect = container.effects[i2];
        const pipe = renderPipes3[effect.pipe];
        pipe.pop(effect, container, instructionSet);
      }
    }
  }
  var init_buildInstructions = __esm({
    "node_modules/pixi.js/lib/scene/container/utils/buildInstructions.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/container/utils/clearList.mjs
  function clearList(list, index6) {
    index6 || (index6 = 0);
    for (let j2 = index6; j2 < list.length; j2++) {
      if (list[j2]) {
        list[j2] = null;
      } else {
        break;
      }
    }
  }
  var init_clearList = __esm({
    "node_modules/pixi.js/lib/scene/container/utils/clearList.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/container/utils/collectRenderGroups.mjs
  function collectRenderGroups(renderGroup, out2 = []) {
    out2.push(renderGroup);
    for (let i2 = 0; i2 < renderGroup.renderGroupChildren.length; i2++) {
      collectRenderGroups(renderGroup.renderGroupChildren[i2], out2);
    }
    return out2;
  }
  var init_collectRenderGroups = __esm({
    "node_modules/pixi.js/lib/scene/container/utils/collectRenderGroups.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/container/utils/mixHexColors.mjs
  function mixHexColors(color1, color2, ratio) {
    const r1 = color1 >> 16 & 255;
    const g1 = color1 >> 8 & 255;
    const b1 = color1 & 255;
    const r2 = color2 >> 16 & 255;
    const g2 = color2 >> 8 & 255;
    const b2 = color2 & 255;
    const r3 = r1 + (r2 - r1) * ratio;
    const g3 = g1 + (g2 - g1) * ratio;
    const b3 = b1 + (b2 - b1) * ratio;
    return (r3 << 16) + (g3 << 8) + b3;
  }
  var init_mixHexColors = __esm({
    "node_modules/pixi.js/lib/scene/container/utils/mixHexColors.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/container/utils/mixColors.mjs
  function mixColors(localBGRColor, parentBGRColor) {
    if (localBGRColor === WHITE_BGR || parentBGRColor === WHITE_BGR) {
      return localBGRColor + parentBGRColor - WHITE_BGR;
    }
    return mixHexColors(localBGRColor, parentBGRColor, 0.5);
  }
  var WHITE_BGR;
  var init_mixColors = __esm({
    "node_modules/pixi.js/lib/scene/container/utils/mixColors.mjs"() {
      init_mixHexColors();
      WHITE_BGR = 16777215;
    }
  });

  // node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs
  function updateRenderGroupTransforms(renderGroup, updateChildRenderGroups = false) {
    updateRenderGroupTransform(renderGroup);
    const childrenToUpdate = renderGroup.childrenToUpdate;
    const updateTick = renderGroup.updateTick++;
    for (const j2 in childrenToUpdate) {
      const renderGroupDepth = Number(j2);
      const childrenAtDepth = childrenToUpdate[j2];
      const list = childrenAtDepth.list;
      const index6 = childrenAtDepth.index;
      for (let i2 = 0; i2 < index6; i2++) {
        const child = list[i2];
        if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth) {
          updateTransformAndChildren(child, updateTick, 0);
        }
      }
      clearList(list, index6);
      childrenAtDepth.index = 0;
    }
    if (updateChildRenderGroups) {
      for (let i2 = 0; i2 < renderGroup.renderGroupChildren.length; i2++) {
        updateRenderGroupTransforms(renderGroup.renderGroupChildren[i2], updateChildRenderGroups);
      }
    }
  }
  function updateRenderGroupTransform(renderGroup) {
    const root = renderGroup.root;
    let worldAlpha;
    if (renderGroup.renderGroupParent) {
      const renderGroupParent = renderGroup.renderGroupParent;
      renderGroup.worldTransform.appendFrom(
        root.relativeGroupTransform,
        renderGroupParent.worldTransform
      );
      renderGroup.worldColor = mixColors(
        root.groupColor,
        renderGroupParent.worldColor
      );
      worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;
    } else {
      renderGroup.worldTransform.copyFrom(root.localTransform);
      renderGroup.worldColor = root.localColor;
      worldAlpha = root.localAlpha;
    }
    worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;
    renderGroup.worldAlpha = worldAlpha;
    renderGroup.worldColorAlpha = renderGroup.worldColor + ((worldAlpha * 255 | 0) << 24);
  }
  function updateTransformAndChildren(container, updateTick, updateFlags) {
    if (updateTick === container.updateTick)
      return;
    container.updateTick = updateTick;
    container.didChange = false;
    const localTransform = container.localTransform;
    container.updateLocalTransform();
    const parent2 = container.parent;
    if (parent2 && !parent2.renderGroup) {
      updateFlags = updateFlags | container._updateFlags;
      container.relativeGroupTransform.appendFrom(
        localTransform,
        parent2.relativeGroupTransform
      );
      if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {
        updateColorBlendVisibility(container, parent2, updateFlags);
      }
    } else {
      updateFlags = container._updateFlags;
      container.relativeGroupTransform.copyFrom(localTransform);
      if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {
        updateColorBlendVisibility(container, tempContainer, updateFlags);
      }
    }
    if (!container.renderGroup) {
      const children2 = container.children;
      const length9 = children2.length;
      for (let i2 = 0; i2 < length9; i2++) {
        updateTransformAndChildren(children2[i2], updateTick, updateFlags);
      }
      const renderGroup = container.parentRenderGroup;
      const renderable = container;
      if (renderable.renderPipeId && !renderGroup.structureDidChange) {
        renderGroup.updateRenderable(renderable);
      }
    }
  }
  function updateColorBlendVisibility(container, parent2, updateFlags) {
    if (updateFlags & UPDATE_COLOR) {
      container.groupColor = mixColors(
        container.localColor,
        parent2.groupColor
      );
      let groupAlpha = container.localAlpha * parent2.groupAlpha;
      groupAlpha = groupAlpha < 0 ? 0 : groupAlpha > 1 ? 1 : groupAlpha;
      container.groupAlpha = groupAlpha;
      container.groupColorAlpha = container.groupColor + ((groupAlpha * 255 | 0) << 24);
    }
    if (updateFlags & UPDATE_BLEND) {
      container.groupBlendMode = container.localBlendMode === "inherit" ? parent2.groupBlendMode : container.localBlendMode;
    }
    if (updateFlags & UPDATE_VISIBLE) {
      container.globalDisplayStatus = container.localDisplayStatus & parent2.globalDisplayStatus;
    }
    container._updateFlags = 0;
  }
  var tempContainer, UPDATE_BLEND_COLOR_VISIBLE;
  var init_updateRenderGroupTransforms = __esm({
    "node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs"() {
      init_Container();
      init_clearList();
      init_mixColors();
      tempContainer = new Container();
      UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;
    }
  });

  // node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs
  function validateRenderables(renderGroup, renderPipes3) {
    const { list, index: index6 } = renderGroup.childrenRenderablesToUpdate;
    let rebuildRequired = false;
    for (let i2 = 0; i2 < index6; i2++) {
      const container = list[i2];
      const renderable = container;
      const pipe = renderPipes3[renderable.renderPipeId];
      rebuildRequired = pipe.validateRenderable(container);
      if (rebuildRequired) {
        break;
      }
    }
    renderGroup.structureDidChange = rebuildRequired;
    return rebuildRequired;
  }
  var init_validateRenderables = __esm({
    "node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs
  function updateRenderables(renderGroup) {
    const { list, index: index6 } = renderGroup.childrenRenderablesToUpdate;
    for (let i2 = 0; i2 < index6; i2++) {
      const container = list[i2];
      if (container.didViewUpdate) {
        renderGroup.updateRenderable(container);
      }
    }
    clearList(list, index6);
  }
  var tempMatrix5, RenderGroupSystem;
  var init_RenderGroupSystem = __esm({
    "node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs"() {
      init_Extensions();
      init_Matrix();
      init_buildInstructions();
      init_clearList();
      init_collectRenderGroups();
      init_executeInstructions();
      init_updateRenderGroupTransforms();
      init_validateRenderables();
      tempMatrix5 = new Matrix();
      RenderGroupSystem = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        render({ container, transform: transform2 }) {
          container.isRenderGroup = true;
          const parent2 = container.parent;
          const renderGroupParent = container.renderGroup.renderGroupParent;
          container.parent = null;
          container.renderGroup.renderGroupParent = null;
          const renderer = this._renderer;
          const renderGroups = collectRenderGroups(container.renderGroup, []);
          let originalLocalTransform = tempMatrix5;
          if (transform2) {
            originalLocalTransform = originalLocalTransform.copyFrom(container.renderGroup.localTransform);
            container.renderGroup.localTransform.copyFrom(transform2);
          }
          const renderPipes3 = renderer.renderPipes;
          for (let i2 = 0; i2 < renderGroups.length; i2++) {
            const renderGroup = renderGroups[i2];
            renderGroup.runOnRender();
            renderGroup.instructionSet.renderPipes = renderPipes3;
            if (!renderGroup.structureDidChange) {
              validateRenderables(renderGroup, renderPipes3);
            } else {
              clearList(renderGroup.childrenRenderablesToUpdate.list, 0);
            }
            updateRenderGroupTransforms(renderGroup);
            if (renderGroup.structureDidChange) {
              renderGroup.structureDidChange = false;
              buildInstructions(renderGroup, renderer);
            } else {
              updateRenderables(renderGroup);
            }
            renderGroup.childrenRenderablesToUpdate.index = 0;
            renderer.renderPipes.batch.upload(renderGroup.instructionSet);
          }
          renderer.globalUniforms.start({
            worldTransformMatrix: transform2 ? container.renderGroup.localTransform : container.renderGroup.worldTransform,
            worldColor: container.renderGroup.worldColorAlpha
          });
          executeInstructions(container.renderGroup, renderPipes3);
          if (renderPipes3.uniformBatch) {
            renderPipes3.uniformBatch.renderEnd();
          }
          if (transform2) {
            container.renderGroup.localTransform.copyFrom(originalLocalTransform);
          }
          container.parent = parent2;
          container.renderGroup.renderGroupParent = renderGroupParent;
        }
        destroy() {
          this._renderer = null;
        }
      };
      RenderGroupSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "renderGroup"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs
  var SpritePipe;
  var init_SpritePipe = __esm({
    "node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs"() {
      init_Extensions();
      init_PoolGroup();
      init_BatchableSprite();
      SpritePipe = class {
        constructor(renderer) {
          this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);
          this._destroyRenderableBound = this.destroyRenderable.bind(this);
          this._renderer = renderer;
          this._renderer.renderableGC.addManagedHash(this, "_gpuSpriteHash");
        }
        addRenderable(sprite, instructionSet) {
          const gpuSprite = this._getGpuSprite(sprite);
          if (sprite.didViewUpdate)
            this._updateBatchableSprite(sprite, gpuSprite);
          this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);
        }
        updateRenderable(sprite) {
          const gpuSprite = this._gpuSpriteHash[sprite.uid];
          if (sprite.didViewUpdate)
            this._updateBatchableSprite(sprite, gpuSprite);
          gpuSprite._batcher.updateElement(gpuSprite);
        }
        validateRenderable(sprite) {
          const texture = sprite._texture;
          const gpuSprite = this._getGpuSprite(sprite);
          if (gpuSprite.texture._source !== texture._source) {
            return !gpuSprite._batcher.checkAndUpdateTexture(gpuSprite, texture);
          }
          return false;
        }
        destroyRenderable(sprite) {
          const batchableSprite = this._gpuSpriteHash[sprite.uid];
          BigPool.return(batchableSprite);
          this._gpuSpriteHash[sprite.uid] = null;
          sprite.off("destroyed", this._destroyRenderableBound);
        }
        _updateBatchableSprite(sprite, batchableSprite) {
          batchableSprite.bounds = sprite.bounds;
          batchableSprite.texture = sprite._texture;
        }
        _getGpuSprite(sprite) {
          return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);
        }
        _initGPUSprite(sprite) {
          const batchableSprite = BigPool.get(BatchableSprite);
          batchableSprite.renderable = sprite;
          batchableSprite.transform = sprite.groupTransform;
          batchableSprite.texture = sprite._texture;
          batchableSprite.bounds = sprite.bounds;
          batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
          this._gpuSpriteHash[sprite.uid] = batchableSprite;
          sprite.on("destroyed", this._destroyRenderableBound);
          return batchableSprite;
        }
        destroy() {
          for (const i2 in this._gpuSpriteHash) {
            BigPool.return(this._gpuSpriteHash[i2]);
          }
          this._gpuSpriteHash = null;
          this._renderer = null;
        }
      };
      SpritePipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "sprite"
      };
    }
  });

  // node_modules/pixi.js/lib/utils/const.mjs
  var VERSION;
  var init_const8 = __esm({
    "node_modules/pixi.js/lib/utils/const.mjs"() {
      init_eventemitter3();
      VERSION = "8.5.2";
    }
  });

  // node_modules/pixi.js/lib/utils/global/globalHooks.mjs
  var ApplicationInitHook, RendererInitHook;
  var init_globalHooks = __esm({
    "node_modules/pixi.js/lib/utils/global/globalHooks.mjs"() {
      init_Extensions();
      init_const8();
      ApplicationInitHook = class {
        static init() {
          globalThis.__PIXI_APP_INIT__?.(this, VERSION);
        }
        static destroy() {
        }
      };
      ApplicationInitHook.extension = ExtensionType.Application;
      RendererInitHook = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        init() {
          globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, VERSION);
        }
        destroy() {
          this._renderer = null;
        }
      };
      RendererInitHook.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "initHook",
        priority: -10
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs
  var _BatcherPipe, BatcherPipe;
  var init_BatcherPipe = __esm({
    "node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs"() {
      init_Extensions();
      init_State();
      init_DefaultBatcher();
      _BatcherPipe = class _BatcherPipe2 {
        constructor(renderer, adaptor) {
          this.state = State.for2d();
          this._batchersByInstructionSet = /* @__PURE__ */ Object.create(null);
          this._activeBatches = /* @__PURE__ */ Object.create(null);
          this.renderer = renderer;
          this._adaptor = adaptor;
          this._adaptor.init?.(this);
        }
        static getBatcher(name16) {
          return new this._availableBatchers[name16]();
        }
        buildStart(instructionSet) {
          let batchers = this._batchersByInstructionSet[instructionSet.uid];
          if (!batchers) {
            batchers = this._batchersByInstructionSet[instructionSet.uid] = /* @__PURE__ */ Object.create(null);
            batchers.default || (batchers.default = new DefaultBatcher());
          }
          this._activeBatches = batchers;
          this._activeBatch = this._activeBatches.default;
          for (const i2 in this._activeBatches) {
            this._activeBatches[i2].begin();
          }
        }
        addToBatch(batchableObject, instructionSet) {
          if (this._activeBatch.name !== batchableObject.batcherName) {
            this._activeBatch.break(instructionSet);
            let batch = this._activeBatches[batchableObject.batcherName];
            if (!batch) {
              batch = this._activeBatches[batchableObject.batcherName] = _BatcherPipe2.getBatcher(batchableObject.batcherName);
              batch.begin();
            }
            this._activeBatch = batch;
          }
          this._activeBatch.add(batchableObject);
        }
        break(instructionSet) {
          this._activeBatch.break(instructionSet);
        }
        buildEnd(instructionSet) {
          this._activeBatch.break(instructionSet);
          const batches = this._activeBatches;
          for (const i2 in batches) {
            const batch = batches[i2];
            const geometry = batch.geometry;
            geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);
            geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);
          }
        }
        upload(instructionSet) {
          const batchers = this._batchersByInstructionSet[instructionSet.uid];
          for (const i2 in batchers) {
            const batcher = batchers[i2];
            const geometry = batcher.geometry;
            if (batcher.dirty) {
              batcher.dirty = false;
              geometry.buffers[0].update(batcher.attributeSize * 4);
            }
          }
        }
        execute(batch) {
          if (batch.action === "startBatch") {
            const batcher = batch.batcher;
            const geometry = batcher.geometry;
            const shader = batcher.shader;
            this._adaptor.start(this, geometry, shader);
          }
          this._adaptor.execute(this, batch);
        }
        destroy() {
          this.state = null;
          this.renderer = null;
          this._adaptor = null;
          for (const i2 in this._activeBatches) {
            this._activeBatches[i2].destroy();
          }
          this._activeBatches = null;
        }
      };
      _BatcherPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "batch"
      };
      _BatcherPipe._availableBatchers = /* @__PURE__ */ Object.create(null);
      BatcherPipe = _BatcherPipe;
      extensions.handleByMap(ExtensionType.Batcher, BatcherPipe._availableBatchers);
      extensions.add(DefaultBatcher);
    }
  });

  // node_modules/pixi.js/lib/filters/mask/mask.frag.mjs
  var fragment2;
  var init_mask_frag = __esm({
    "node_modules/pixi.js/lib/filters/mask/mask.frag.mjs"() {
      fragment2 = "in vec2 vMaskCoord;\nin vec2 vTextureCoord;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMaskTexture;\n\nuniform float uAlpha;\nuniform vec4 uMaskClamp;\nuniform float uInverse;\n\nout vec4 finalColor;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(uMaskClamp.x, vMaskCoord.x) +\n        step(uMaskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, uMaskClamp.z) +\n        step(vMaskCoord.y, uMaskClamp.w));\n\n    // TODO look into why this is needed\n    float npmAlpha = uAlpha;\n    vec4 original = texture(uTexture, vTextureCoord);\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    float a = alphaMul * masky.r * npmAlpha * clip;\n\n    if (uInverse == 1.0) {\n        a = 1.0 - a;\n    }\n\n    finalColor = original * a;\n}\n";
    }
  });

  // node_modules/pixi.js/lib/filters/mask/mask.vert.mjs
  var vertex2;
  var init_mask_vert = __esm({
    "node_modules/pixi.js/lib/filters/mask/mask.vert.mjs"() {
      vertex2 = "in vec2 aPosition;\n\nout vec2 vTextureCoord;\nout vec2 vMaskCoord;\n\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\nuniform mat3 uFilterMatrix;\n\nvec4 filterVertexPosition(  vec2 aPosition )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n       \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord(  vec2 aPosition )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvec2 getFilterCoord( vec2 aPosition )\n{\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}   \n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition(aPosition);\n    vTextureCoord = filterTextureCoord(aPosition);\n    vMaskCoord = getFilterCoord(aPosition);\n}\n";
    }
  });

  // node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs
  var source2;
  var init_mask_wgsl = __esm({
    "node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs"() {
      source2 = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct MaskUniforms {\n  uFilterMatrix:mat3x3<f32>,\n  uMaskClamp:vec4<f32>,\n  uAlpha:f32,\n  uInverse:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n};\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>,\n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var maskClamp = filterUniforms.uMaskClamp;\n    var uAlpha = filterUniforms.uAlpha;\n\n    var clip = step(3.5,\n      step(maskClamp.x, filterUv.x) +\n      step(maskClamp.y, filterUv.y) +\n      step(filterUv.x, maskClamp.z) +\n      step(filterUv.y, maskClamp.w));\n\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\n    var source = textureSample(uTexture, uSampler, uv);\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\n\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\n\n    if (filterUniforms.uInverse == 1.0) {\n        a = 1.0 - a;\n    }\n\n    return source * a;\n}\n";
    }
  });

  // node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs
  var MaskFilter;
  var init_MaskFilter = __esm({
    "node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs"() {
      init_Matrix();
      init_GlProgram();
      init_GpuProgram();
      init_UniformGroup();
      init_TextureMatrix();
      init_Filter();
      init_mask_frag();
      init_mask_vert();
      init_mask_wgsl();
      MaskFilter = class extends Filter {
        constructor(options2) {
          const { sprite, ...rest } = options2;
          const textureMatrix = new TextureMatrix(sprite.texture);
          const filterUniforms = new UniformGroup({
            uFilterMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uMaskClamp: { value: textureMatrix.uClampFrame, type: "vec4<f32>" },
            uAlpha: { value: 1, type: "f32" },
            uInverse: { value: options2.inverse ? 1 : 0, type: "f32" }
          });
          const gpuProgram3 = GpuProgram.from({
            vertex: {
              source: source2,
              entryPoint: "mainVertex"
            },
            fragment: {
              source: source2,
              entryPoint: "mainFragment"
            }
          });
          const glProgram3 = GlProgram.from({
            vertex: vertex2,
            fragment: fragment2,
            name: "mask-filter"
          });
          super({
            ...rest,
            gpuProgram: gpuProgram3,
            glProgram: glProgram3,
            resources: {
              filterUniforms,
              uMaskTexture: sprite.texture.source
            }
          });
          this.sprite = sprite;
          this._textureMatrix = textureMatrix;
        }
        set inverse(value12) {
          this.resources.filterUniforms.uniforms.uInverse = value12 ? 1 : 0;
        }
        get inverse() {
          return this.resources.filterUniforms.uniforms.uInverse === 1;
        }
        apply(filterManager, input, output2, clearMode) {
          this._textureMatrix.texture = this.sprite.texture;
          filterManager.calculateSpriteMatrix(
            this.resources.filterUniforms.uniforms.uFilterMatrix,
            this.sprite
          ).prepend(this._textureMatrix.mapCoord);
          this.resources.uMaskTexture = this.sprite.texture.source;
          filterManager.applyFilter(this, input, output2, clearMode);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs
  var tempBounds3, AlphaMaskEffect, AlphaMaskPipe;
  var init_AlphaMaskPipe = __esm({
    "node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs"() {
      init_Extensions();
      init_FilterEffect();
      init_MaskFilter();
      init_Bounds();
      init_getGlobalBounds();
      init_buildInstructions();
      init_Sprite();
      init_PoolGroup();
      init_Texture();
      init_TexturePool();
      init_types2();
      tempBounds3 = new Bounds();
      AlphaMaskEffect = class extends FilterEffect {
        constructor() {
          super();
          this.filters = [new MaskFilter({
            sprite: new Sprite(Texture.EMPTY),
            inverse: false,
            resolution: "inherit",
            antialias: "inherit"
          })];
        }
        get sprite() {
          return this.filters[0].sprite;
        }
        set sprite(value12) {
          this.filters[0].sprite = value12;
        }
        get inverse() {
          return this.filters[0].inverse;
        }
        set inverse(value12) {
          this.filters[0].inverse = value12;
        }
      };
      AlphaMaskPipe = class {
        constructor(renderer) {
          this._activeMaskStage = [];
          this._renderer = renderer;
        }
        push(mask, maskedContainer, instructionSet) {
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "alphaMask",
            action: "pushMaskBegin",
            mask,
            inverse: maskedContainer._maskOptions.inverse,
            canBundle: false,
            maskedContainer
          });
          mask.inverse = maskedContainer._maskOptions.inverse;
          if (mask.renderMaskToTexture) {
            const maskContainer = mask.mask;
            maskContainer.includeInBuild = true;
            collectAllRenderables(
              maskContainer,
              instructionSet,
              renderer
            );
            maskContainer.includeInBuild = false;
          }
          renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "alphaMask",
            action: "pushMaskEnd",
            mask,
            maskedContainer,
            inverse: maskedContainer._maskOptions.inverse,
            canBundle: false
          });
        }
        pop(mask, _maskedContainer, instructionSet) {
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "alphaMask",
            action: "popMaskEnd",
            mask,
            inverse: _maskedContainer._maskOptions.inverse,
            canBundle: false
          });
        }
        execute(instruction) {
          const renderer = this._renderer;
          const renderMask = instruction.mask.renderMaskToTexture;
          if (instruction.action === "pushMaskBegin") {
            const filterEffect = BigPool.get(AlphaMaskEffect);
            filterEffect.inverse = instruction.inverse;
            if (renderMask) {
              instruction.mask.mask.measurable = true;
              const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds3);
              instruction.mask.mask.measurable = false;
              bounds.ceil();
              const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;
              const filterTexture = TexturePool.getOptimalTexture(
                bounds.width,
                bounds.height,
                colorTextureSource._resolution,
                colorTextureSource.antialias
              );
              renderer.renderTarget.push(filterTexture, true);
              renderer.globalUniforms.push({
                offset: bounds,
                worldColor: 4294967295
              });
              const sprite = filterEffect.sprite;
              sprite.texture = filterTexture;
              sprite.worldTransform.tx = bounds.minX;
              sprite.worldTransform.ty = bounds.minY;
              this._activeMaskStage.push({
                filterEffect,
                maskedContainer: instruction.maskedContainer,
                filterTexture
              });
            } else {
              filterEffect.sprite = instruction.mask.mask;
              this._activeMaskStage.push({
                filterEffect,
                maskedContainer: instruction.maskedContainer
              });
            }
          } else if (instruction.action === "pushMaskEnd") {
            const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];
            if (renderMask) {
              if (renderer.type === RendererType.WEBGL) {
                renderer.renderTarget.finishRenderPass();
              }
              renderer.renderTarget.pop();
              renderer.globalUniforms.pop();
            }
            renderer.filter.push({
              renderPipeId: "filter",
              action: "pushFilter",
              container: maskData.maskedContainer,
              filterEffect: maskData.filterEffect,
              canBundle: false
            });
          } else if (instruction.action === "popMaskEnd") {
            renderer.filter.pop();
            const maskData = this._activeMaskStage.pop();
            if (renderMask) {
              TexturePool.returnTexture(maskData.filterTexture);
            }
            BigPool.return(maskData.filterEffect);
          }
        }
        destroy() {
          this._renderer = null;
          this._activeMaskStage = null;
        }
      };
      AlphaMaskPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "alphaMask"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs
  var ColorMaskPipe;
  var init_ColorMaskPipe = __esm({
    "node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs"() {
      init_Extensions();
      ColorMaskPipe = class {
        constructor(renderer) {
          this._colorStack = [];
          this._colorStackIndex = 0;
          this._currentColor = 0;
          this._renderer = renderer;
        }
        buildStart() {
          this._colorStack[0] = 15;
          this._colorStackIndex = 1;
          this._currentColor = 15;
        }
        push(mask, _container, instructionSet) {
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          const colorStack = this._colorStack;
          colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;
          const currentColor = this._colorStack[this._colorStackIndex];
          if (currentColor !== this._currentColor) {
            this._currentColor = currentColor;
            instructionSet.add({
              renderPipeId: "colorMask",
              colorMask: currentColor,
              canBundle: false
            });
          }
          this._colorStackIndex++;
        }
        pop(_mask, _container, instructionSet) {
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          const colorStack = this._colorStack;
          this._colorStackIndex--;
          const currentColor = colorStack[this._colorStackIndex - 1];
          if (currentColor !== this._currentColor) {
            this._currentColor = currentColor;
            instructionSet.add({
              renderPipeId: "colorMask",
              colorMask: currentColor,
              canBundle: false
            });
          }
        }
        execute(instruction) {
          const renderer = this._renderer;
          renderer.colorMask.setMask(instruction.colorMask);
        }
        destroy() {
          this._colorStack = null;
        }
      };
      ColorMaskPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "colorMask"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs
  var StencilMaskPipe;
  var init_StencilMaskPipe = __esm({
    "node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs"() {
      init_Extensions();
      init_buildInstructions();
      init_const7();
      init_const3();
      StencilMaskPipe = class {
        constructor(renderer) {
          this._maskStackHash = {};
          this._maskHash = /* @__PURE__ */ new WeakMap();
          this._renderer = renderer;
        }
        push(mask, _container, instructionSet) {
          var _a2;
          const effect = mask;
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
          instructionSet.add({
            renderPipeId: "stencilMask",
            action: "pushMaskBegin",
            mask,
            inverse: _container._maskOptions.inverse,
            canBundle: false
          });
          const maskContainer = effect.mask;
          maskContainer.includeInBuild = true;
          if (!this._maskHash.has(effect)) {
            this._maskHash.set(effect, {
              instructionsStart: 0,
              instructionsLength: 0
            });
          }
          const maskData = this._maskHash.get(effect);
          maskData.instructionsStart = instructionSet.instructionSize;
          collectAllRenderables(
            maskContainer,
            instructionSet,
            renderer
          );
          maskContainer.includeInBuild = false;
          renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "stencilMask",
            action: "pushMaskEnd",
            mask,
            inverse: _container._maskOptions.inverse,
            canBundle: false
          });
          const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;
          maskData.instructionsLength = instructionsLength;
          const renderTargetUid = renderer.renderTarget.renderTarget.uid;
          (_a2 = this._maskStackHash)[renderTargetUid] ?? (_a2[renderTargetUid] = 0);
        }
        pop(mask, _container, instructionSet) {
          const effect = mask;
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
          instructionSet.add({
            renderPipeId: "stencilMask",
            action: "popMaskBegin",
            inverse: _container._maskOptions.inverse,
            canBundle: false
          });
          const maskData = this._maskHash.get(mask);
          for (let i2 = 0; i2 < maskData.instructionsLength; i2++) {
            instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];
          }
          instructionSet.add({
            renderPipeId: "stencilMask",
            action: "popMaskEnd",
            canBundle: false
          });
        }
        execute(instruction) {
          var _a2;
          const renderer = this._renderer;
          const renderTargetUid = renderer.renderTarget.renderTarget.uid;
          let maskStackIndex = (_a2 = this._maskStackHash)[renderTargetUid] ?? (_a2[renderTargetUid] = 0);
          if (instruction.action === "pushMaskBegin") {
            renderer.renderTarget.ensureDepthStencil();
            renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);
            maskStackIndex++;
            renderer.colorMask.setMask(0);
          } else if (instruction.action === "pushMaskEnd") {
            if (instruction.inverse) {
              renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);
            } else {
              renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
            }
            renderer.colorMask.setMask(15);
          } else if (instruction.action === "popMaskBegin") {
            renderer.colorMask.setMask(0);
            if (maskStackIndex !== 0) {
              renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);
            } else {
              renderer.renderTarget.clear(null, CLEAR.STENCIL);
              renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);
            }
            maskStackIndex--;
          } else if (instruction.action === "popMaskEnd") {
            if (instruction.inverse) {
              renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);
            } else {
              renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
            }
            renderer.colorMask.setMask(15);
          }
          this._maskStackHash[renderTargetUid] = maskStackIndex;
        }
        destroy() {
          this._renderer = null;
          this._maskStackHash = null;
          this._maskHash = null;
        }
      };
      StencilMaskPipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "stencilMask"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs
  var _BackgroundSystem, BackgroundSystem;
  var init_BackgroundSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs"() {
      init_Color();
      init_Extensions();
      _BackgroundSystem = class _BackgroundSystem2 {
        constructor() {
          this.clearBeforeRender = true;
          this._backgroundColor = new Color(0);
          this.color = this._backgroundColor;
          this.alpha = 1;
        }
        /**
         * initiates the background system
         * @param options - the options for the background colors
         */
        init(options2) {
          options2 = { ..._BackgroundSystem2.defaultOptions, ...options2 };
          this.clearBeforeRender = options2.clearBeforeRender;
          this.color = options2.background || options2.backgroundColor || this._backgroundColor;
          this.alpha = options2.backgroundAlpha;
          this._backgroundColor.setAlpha(options2.backgroundAlpha);
        }
        /** The background color to fill if not transparent */
        get color() {
          return this._backgroundColor;
        }
        set color(value12) {
          this._backgroundColor.setValue(value12);
        }
        /** The background color alpha. Setting this to 0 will make the canvas transparent. */
        get alpha() {
          return this._backgroundColor.alpha;
        }
        set alpha(value12) {
          this._backgroundColor.setAlpha(value12);
        }
        /** The background color as an [R, G, B, A] array. */
        get colorRgba() {
          return this._backgroundColor.toArray();
        }
        /**
         * destroys the background system
         * @internal
         * @ignore
         */
        destroy() {
        }
      };
      _BackgroundSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "background",
        priority: 0
      };
      _BackgroundSystem.defaultOptions = {
        /**
         * {@link WebGLOptions.backgroundAlpha}
         * @default 1
         */
        backgroundAlpha: 1,
        /**
         * {@link WebGLOptions.backgroundColor}
         * @default 0x000000
         */
        backgroundColor: 0,
        /**
         * {@link WebGLOptions.clearBeforeRender}
         * @default true
         */
        clearBeforeRender: true
      };
      BackgroundSystem = _BackgroundSystem;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs
  var BLEND_MODE_FILTERS, BlendModePipe;
  var init_BlendModePipe = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs"() {
      init_Extensions();
      init_FilterEffect();
      init_warn();
      BLEND_MODE_FILTERS = {};
      extensions.handle(ExtensionType.BlendMode, (value12) => {
        if (!value12.name) {
          throw new Error("BlendMode extension must have a name property");
        }
        BLEND_MODE_FILTERS[value12.name] = value12.ref;
      }, (value12) => {
        delete BLEND_MODE_FILTERS[value12.name];
      });
      BlendModePipe = class {
        constructor(renderer) {
          this._isAdvanced = false;
          this._filterHash = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        /**
         * This ensures that a blendMode switch is added to the instruction set if the blend mode has changed.
         * @param renderable - The renderable we are adding to the instruction set
         * @param blendMode - The blend mode of the renderable
         * @param instructionSet - The instruction set we are adding to
         */
        setBlendMode(renderable, blendMode, instructionSet) {
          if (this._activeBlendMode === blendMode) {
            if (this._isAdvanced)
              this._renderableList.push(renderable);
            return;
          }
          this._activeBlendMode = blendMode;
          if (this._isAdvanced) {
            this._endAdvancedBlendMode(instructionSet);
          }
          this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];
          if (this._isAdvanced) {
            this._beginAdvancedBlendMode(instructionSet);
            this._renderableList.push(renderable);
          }
        }
        _beginAdvancedBlendMode(instructionSet) {
          this._renderer.renderPipes.batch.break(instructionSet);
          const blendMode = this._activeBlendMode;
          if (!BLEND_MODE_FILTERS[blendMode]) {
            warn2(`Unable to assign BlendMode: '${blendMode}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);
            return;
          }
          let filterEffect = this._filterHash[blendMode];
          if (!filterEffect) {
            filterEffect = this._filterHash[blendMode] = new FilterEffect();
            filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode]()];
          }
          const instruction = {
            renderPipeId: "filter",
            action: "pushFilter",
            renderables: [],
            filterEffect,
            canBundle: false
          };
          this._renderableList = instruction.renderables;
          instructionSet.add(instruction);
        }
        _endAdvancedBlendMode(instructionSet) {
          this._renderableList = null;
          this._renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "filter",
            action: "popFilter",
            canBundle: false
          });
        }
        /**
         * called when the instruction build process is starting this will reset internally to the default blend mode
         * @internal
         * @ignore
         */
        buildStart() {
          this._isAdvanced = false;
        }
        /**
         * called when the instruction build process is finished, ensuring that if there is an advanced blend mode
         * active, we add the final render instructions added to the instruction set
         * @param instructionSet - The instruction set we are adding to
         * @internal
         * @ignore
         */
        buildEnd(instructionSet) {
          if (this._isAdvanced) {
            this._endAdvancedBlendMode(instructionSet);
          }
        }
        /**
         * @internal
         * @ignore
         */
        destroy() {
          this._renderer = null;
          this._renderableList = null;
          for (const i2 in this._filterHash) {
            this._filterHash[i2].destroy();
          }
          this._filterHash = null;
        }
      };
      BlendModePipe.extension = {
        type: [
          ExtensionType.WebGLPipes,
          ExtensionType.WebGPUPipes,
          ExtensionType.CanvasPipes
        ],
        name: "blendMode"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs
  var imageTypes, _ExtractSystem, ExtractSystem;
  var init_ExtractSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs"() {
      init_Extensions();
      init_Container();
      init_Texture();
      imageTypes = {
        png: "image/png",
        jpg: "image/jpeg",
        webp: "image/webp"
      };
      _ExtractSystem = class _ExtractSystem2 {
        /** @param renderer - The renderer this System works for. */
        constructor(renderer) {
          this._renderer = renderer;
        }
        _normalizeOptions(options2, defaults3 = {}) {
          if (options2 instanceof Container || options2 instanceof Texture) {
            return {
              target: options2,
              ...defaults3
            };
          }
          return {
            ...defaults3,
            ...options2
          };
        }
        /**
         * Will return a HTML Image of the target
         * @param options - The options for creating the image, or the target to extract
         * @returns - HTML Image of the target
         */
        async image(options2) {
          const image = new Image();
          image.src = await this.base64(options2);
          return image;
        }
        /**
         * Will return a base64 encoded string of this target. It works by calling
         * `Extract.canvas` and then running toDataURL on that.
         * @param options - The options for creating the image, or the target to extract
         */
        async base64(options2) {
          options2 = this._normalizeOptions(
            options2,
            _ExtractSystem2.defaultImageOptions
          );
          const { format, quality } = options2;
          const canvas2 = this.canvas(options2);
          if (canvas2.toBlob !== void 0) {
            return new Promise((resolve, reject) => {
              canvas2.toBlob((blob) => {
                if (!blob) {
                  reject(new Error("ICanvas.toBlob failed!"));
                  return;
                }
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
              }, imageTypes[format], quality);
            });
          }
          if (canvas2.toDataURL !== void 0) {
            return canvas2.toDataURL(imageTypes[format], quality);
          }
          if (canvas2.convertToBlob !== void 0) {
            const blob = await canvas2.convertToBlob({ type: imageTypes[format], quality });
            return new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.onload = () => resolve(reader.result);
              reader.onerror = reject;
              reader.readAsDataURL(blob);
            });
          }
          throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
        }
        /**
         * Creates a Canvas element, renders this target to it and then returns it.
         * @param options - The options for creating the canvas, or the target to extract
         * @returns - A Canvas element with the texture rendered on.
         */
        canvas(options2) {
          options2 = this._normalizeOptions(options2);
          const target5 = options2.target;
          const renderer = this._renderer;
          if (target5 instanceof Texture) {
            return renderer.texture.generateCanvas(target5);
          }
          const texture = renderer.textureGenerator.generateTexture(options2);
          const canvas2 = renderer.texture.generateCanvas(texture);
          texture.destroy();
          return canvas2;
        }
        /**
         * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA
         * order, with integer values between 0 and 255 (included).
         * @param options - The options for extracting the image, or the target to extract
         * @returns - One-dimensional array containing the pixel data of the entire texture
         */
        pixels(options2) {
          options2 = this._normalizeOptions(options2);
          const target5 = options2.target;
          const renderer = this._renderer;
          const texture = target5 instanceof Texture ? target5 : renderer.textureGenerator.generateTexture(options2);
          const pixelInfo = renderer.texture.getPixels(texture);
          if (target5 instanceof Container) {
            texture.destroy();
          }
          return pixelInfo;
        }
        /**
         * Will return a texture of the target
         * @param options - The options for creating the texture, or the target to extract
         * @returns - A texture of the target
         */
        texture(options2) {
          options2 = this._normalizeOptions(options2);
          if (options2.target instanceof Texture)
            return options2.target;
          return this._renderer.textureGenerator.generateTexture(options2);
        }
        /**
         * Will extract a HTMLImage of the target and download it
         * @param options - The options for downloading and extracting the image, or the target to extract
         */
        download(options2) {
          options2 = this._normalizeOptions(options2);
          const canvas2 = this.canvas(options2);
          const link = document.createElement("a");
          link.download = options2.filename ?? "image.png";
          link.href = canvas2.toDataURL("image/png");
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }
        /**
         * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.
         * @param options - The options for logging the image, or the target to log
         */
        log(options2) {
          const width8 = options2.width ?? 200;
          options2 = this._normalizeOptions(options2);
          const canvas2 = this.canvas(options2);
          const base64 = canvas2.toDataURL();
          console.log(`[Pixi Texture] ${canvas2.width}px ${canvas2.height}px`);
          const style3 = [
            "font-size: 1px;",
            `padding: ${width8}px ${300}px;`,
            `background: url(${base64}) no-repeat;`,
            "background-size: contain;"
          ].join(" ");
          console.log("%c ", style3);
        }
        destroy() {
          this._renderer = null;
        }
      };
      _ExtractSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "extract"
      };
      _ExtractSystem.defaultImageOptions = {
        /** The format of the image. */
        format: "png",
        /** The quality of the image. */
        quality: 1
      };
      ExtractSystem = _ExtractSystem;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs
  var RenderTexture;
  var init_RenderTexture = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs"() {
      init_TextureSource();
      init_Texture();
      RenderTexture = class _RenderTexture extends Texture {
        static create(options2) {
          return new _RenderTexture({
            source: new TextureSource(options2)
          });
        }
        /**
         * Resizes the render texture.
         * @param width - The new width of the render texture.
         * @param height - The new height of the render texture.
         * @param resolution - The new resolution of the render texture.
         * @returns This texture.
         */
        resize(width8, height8, resolution) {
          this.source.resize(width8, height8, resolution);
          return this;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs
  var tempRect2, tempBounds4, noColor, GenerateTextureSystem;
  var init_GenerateTextureSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs"() {
      init_Color();
      init_Extensions();
      init_Matrix();
      init_Rectangle();
      init_Bounds();
      init_getLocalBounds();
      init_Container();
      init_RenderTexture();
      tempRect2 = new Rectangle();
      tempBounds4 = new Bounds();
      noColor = [0, 0, 0, 0];
      GenerateTextureSystem = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        /**
         * A Useful function that returns a texture of the display object that can then be used to create sprites
         * This can be quite useful if your container is complicated and needs to be reused multiple times.
         * @param {GenerateTextureOptions | Container} options - Generate texture options.
         * @param {Container} [options.container] - If not given, the renderer's resolution is used.
         * @param {Rectangle} options.region - The region of the container, that shall be rendered,
         * @param {number} [options.resolution] - The resolution of the texture being generated.
         *        if no region is specified, defaults to the local bounds of the container.
         * @param {GenerateTextureSourceOptions} [options.textureSourceOptions] - Texture options for GPU.
         * @returns a shiny new texture of the container passed in
         */
        generateTexture(options2) {
          if (options2 instanceof Container) {
            options2 = {
              target: options2,
              frame: void 0,
              textureSourceOptions: {},
              resolution: void 0
            };
          }
          const resolution = options2.resolution || this._renderer.resolution;
          const antialias = options2.antialias || this._renderer.view.antialias;
          const container = options2.target;
          let clearColor = options2.clearColor;
          if (clearColor) {
            const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;
            clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();
          } else {
            clearColor = noColor;
          }
          const region = options2.frame?.copyTo(tempRect2) || getLocalBounds(container, tempBounds4).rectangle;
          region.width = Math.max(region.width, 1 / resolution) | 0;
          region.height = Math.max(region.height, 1 / resolution) | 0;
          const target5 = RenderTexture.create({
            ...options2.textureSourceOptions,
            width: region.width,
            height: region.height,
            resolution,
            antialias
          });
          const transform2 = Matrix.shared.translate(-region.x, -region.y);
          this._renderer.render({
            container,
            transform: transform2,
            target: target5,
            clearColor
          });
          target5.source.updateMipmaps();
          return target5;
        }
        destroy() {
          this._renderer = null;
        }
      };
      GenerateTextureSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "textureGenerator"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs
  var GlobalUniformSystem;
  var init_GlobalUniformSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs"() {
      init_Extensions();
      init_Matrix();
      init_Point();
      init_colorToUniform();
      init_BindGroup();
      init_types2();
      init_UniformGroup();
      GlobalUniformSystem = class {
        constructor(renderer) {
          this._stackIndex = 0;
          this._globalUniformDataStack = [];
          this._uniformsPool = [];
          this._activeUniforms = [];
          this._bindGroupPool = [];
          this._activeBindGroups = [];
          this._renderer = renderer;
        }
        reset() {
          this._stackIndex = 0;
          for (let i2 = 0; i2 < this._activeUniforms.length; i2++) {
            this._uniformsPool.push(this._activeUniforms[i2]);
          }
          for (let i2 = 0; i2 < this._activeBindGroups.length; i2++) {
            this._bindGroupPool.push(this._activeBindGroups[i2]);
          }
          this._activeUniforms.length = 0;
          this._activeBindGroups.length = 0;
        }
        start(options2) {
          this.reset();
          this.push(options2);
        }
        bind({
          size: size5,
          projectionMatrix,
          worldTransformMatrix,
          worldColor,
          offset
        }) {
          const renderTarget = this._renderer.renderTarget.renderTarget;
          const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {
            projectionData: renderTarget,
            worldTransformMatrix: new Matrix(),
            worldColor: 4294967295,
            offset: new Point()
          };
          const globalUniformData = {
            projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,
            resolution: size5 || renderTarget.size,
            worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,
            worldColor: worldColor || currentGlobalUniformData.worldColor,
            offset: offset || currentGlobalUniformData.offset,
            bindGroup: null
          };
          const uniformGroup = this._uniformsPool.pop() || this._createUniforms();
          this._activeUniforms.push(uniformGroup);
          const uniforms = uniformGroup.uniforms;
          uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;
          uniforms.uResolution = globalUniformData.resolution;
          uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);
          uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;
          uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;
          color32BitToUniform(
            globalUniformData.worldColor,
            uniforms.uWorldColorAlpha,
            0
          );
          uniformGroup.update();
          let bindGroup;
          if (this._renderer.renderPipes.uniformBatch) {
            bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);
          } else {
            bindGroup = this._bindGroupPool.pop() || new BindGroup();
            this._activeBindGroups.push(bindGroup);
            bindGroup.setResource(uniformGroup, 0);
          }
          globalUniformData.bindGroup = bindGroup;
          this._currentGlobalUniformData = globalUniformData;
        }
        push(options2) {
          this.bind(options2);
          this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;
        }
        pop() {
          this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];
          if (this._renderer.type === RendererType.WEBGL) {
            this._currentGlobalUniformData.bindGroup.resources[0].update();
          }
        }
        get bindGroup() {
          return this._currentGlobalUniformData.bindGroup;
        }
        get globalUniformData() {
          return this._currentGlobalUniformData;
        }
        get uniformGroup() {
          return this._currentGlobalUniformData.bindGroup.resources[0];
        }
        _createUniforms() {
          const globalUniforms = new UniformGroup({
            uProjectionMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uWorldTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>
            uWorldColorAlpha: { value: new Float32Array(4), type: "vec4<f32>" },
            uResolution: { value: [0, 0], type: "vec2<f32>" }
          }, {
            isStatic: true
          });
          return globalUniforms;
        }
        destroy() {
          this._renderer = null;
        }
      };
      GlobalUniformSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "globalUniforms"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs
  var uid2, SchedulerSystem;
  var init_SchedulerSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs"() {
      init_Extensions();
      init_Ticker();
      uid2 = 1;
      SchedulerSystem = class {
        constructor() {
          this._tasks = [];
          this._offset = 0;
        }
        /** Initializes the scheduler system and starts the ticker. */
        init() {
          Ticker.system.add(this._update, this);
        }
        /**
         * Schedules a repeating task.
         * @param func - The function to execute.
         * @param duration - The interval duration in milliseconds.
         * @param useOffset - this will spread out tasks so that they do not all run at the same time
         * @returns The unique identifier for the scheduled task.
         */
        repeat(func, duration2, useOffset = true) {
          const id5 = uid2++;
          let offset = 0;
          if (useOffset) {
            this._offset += 1e3;
            offset = this._offset;
          }
          this._tasks.push({
            func,
            duration: duration2,
            start: performance.now(),
            offset,
            last: performance.now(),
            repeat: true,
            id: id5
          });
          return id5;
        }
        /**
         * Cancels a scheduled task.
         * @param id - The unique identifier of the task to cancel.
         */
        cancel(id5) {
          for (let i2 = 0; i2 < this._tasks.length; i2++) {
            if (this._tasks[i2].id === id5) {
              this._tasks.splice(i2, 1);
              return;
            }
          }
        }
        /**
         * Updates and executes the scheduled tasks.
         * @private
         */
        _update() {
          const now3 = performance.now();
          for (let i2 = 0; i2 < this._tasks.length; i2++) {
            const task = this._tasks[i2];
            if (now3 - task.offset - task.last >= task.duration) {
              const elapsed = now3 - task.start;
              task.func(elapsed);
              task.last = now3;
            }
          }
        }
        /**
         * Destroys the scheduler system and removes all tasks.
         * @internal
         * @ignore
         */
        destroy() {
          Ticker.system.remove(this._update, this);
          this._tasks.length = 0;
        }
      };
      SchedulerSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "scheduler",
        priority: 0
      };
    }
  });

  // node_modules/pixi.js/lib/utils/sayHello.mjs
  function sayHello(type) {
    if (saidHello) {
      return;
    }
    if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
      const args = [
        `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/

`,
        "background: #E72264; padding:5px 0;",
        "background: #6CA2EA; padding:5px 0;",
        "background: #B5D33D; padding:5px 0;",
        "background: #FED23F; padding:5px 0;",
        "color: #FFFFFF; background: #E72264; padding:5px 0;",
        "color: #E72264; background: #FFFFFF; padding:5px 0;"
      ];
      globalThis.console.log(...args);
    } else if (globalThis.console) {
      globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);
    }
    saidHello = true;
  }
  var saidHello;
  var init_sayHello = __esm({
    "node_modules/pixi.js/lib/utils/sayHello.mjs"() {
      init_adapter();
      init_const8();
      saidHello = false;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs
  var HelloSystem;
  var init_HelloSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs"() {
      init_Extensions();
      init_sayHello();
      init_types2();
      HelloSystem = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        /**
         * It all starts here! This initiates every system, passing in the options for any system by name.
         * @param options - the config for the renderer and all its systems
         */
        init(options2) {
          if (options2.hello) {
            let name16 = this._renderer.name;
            if (this._renderer.type === RendererType.WEBGL) {
              name16 += ` ${this._renderer.context.webGLVersion}`;
            }
            sayHello(name16);
          }
        }
      };
      HelloSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "hello",
        priority: -2
      };
      HelloSystem.defaultOptions = {
        /** {@link WebGLOptions.hello} */
        hello: false
      };
    }
  });

  // node_modules/pixi.js/lib/utils/data/clean.mjs
  function cleanHash(hash2) {
    let clean = false;
    for (const i2 in hash2) {
      if (hash2[i2] == void 0) {
        clean = true;
        break;
      }
    }
    if (!clean)
      return hash2;
    const cleanHash2 = /* @__PURE__ */ Object.create(null);
    for (const i2 in hash2) {
      const value12 = hash2[i2];
      if (value12) {
        cleanHash2[i2] = value12;
      }
    }
    return cleanHash2;
  }
  function cleanArray(arr) {
    let offset = 0;
    for (let i2 = 0; i2 < arr.length; i2++) {
      if (arr[i2] == void 0) {
        offset++;
      } else {
        arr[i2 - offset] = arr[i2];
      }
    }
    arr.length = arr.length - offset;
    return arr;
  }
  var init_clean = __esm({
    "node_modules/pixi.js/lib/utils/data/clean.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs
  var _RenderableGCSystem, RenderableGCSystem;
  var init_RenderableGCSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs"() {
      init_Extensions();
      init_clean();
      _RenderableGCSystem = class _RenderableGCSystem2 {
        /** @param renderer - The renderer this System works for. */
        constructor(renderer) {
          this._managedRenderables = [];
          this._managedHashes = [];
          this._managedArrays = [];
          this._renderer = renderer;
        }
        init(options2) {
          options2 = { ..._RenderableGCSystem2.defaultOptions, ...options2 };
          this.maxUnusedTime = options2.renderableGCMaxUnusedTime;
          this._frequency = options2.renderableGCFrequency;
          this.enabled = options2.renderableGCActive;
        }
        get enabled() {
          return !!this._handler;
        }
        set enabled(value12) {
          if (this.enabled === value12)
            return;
          if (value12) {
            this._handler = this._renderer.scheduler.repeat(
              () => this.run(),
              this._frequency,
              false
            );
            this._hashHandler = this._renderer.scheduler.repeat(
              () => {
                for (const hash2 of this._managedHashes) {
                  hash2.context[hash2.hash] = cleanHash(hash2.context[hash2.hash]);
                }
              },
              this._frequency
            );
            this._arrayHandler = this._renderer.scheduler.repeat(
              () => {
                for (const array of this._managedArrays) {
                  cleanArray(array.context[array.hash]);
                }
              },
              this._frequency
            );
          } else {
            this._renderer.scheduler.cancel(this._handler);
            this._renderer.scheduler.cancel(this._hashHandler);
            this._renderer.scheduler.cancel(this._arrayHandler);
          }
        }
        addManagedHash(context3, hash2) {
          this._managedHashes.push({ context: context3, hash: hash2 });
        }
        addManagedArray(context3, hash2) {
          this._managedArrays.push({ context: context3, hash: hash2 });
        }
        prerender() {
          this._now = performance.now();
        }
        addRenderable(renderable, instructionSet) {
          if (!this.enabled)
            return;
          renderable._lastUsed = this._now;
          if (renderable._lastInstructionTick === -1) {
            this._managedRenderables.push(renderable);
            renderable.once("destroyed", this._removeRenderable, this);
          }
          renderable._lastInstructionTick = instructionSet.tick;
        }
        /** Runs the scheduled garbage collection */
        run() {
          const now3 = performance.now();
          const managedRenderables = this._managedRenderables;
          const renderPipes3 = this._renderer.renderPipes;
          let offset = 0;
          for (let i2 = 0; i2 < managedRenderables.length; i2++) {
            const renderable = managedRenderables[i2];
            if (renderable === null) {
              offset++;
              continue;
            }
            const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;
            const currentIndex = renderGroup?.instructionSet?.tick ?? -1;
            if (renderable._lastInstructionTick !== currentIndex && now3 - renderable._lastUsed > this.maxUnusedTime) {
              if (!renderable.destroyed) {
                const rp = renderPipes3;
                rp[renderable.renderPipeId].destroyRenderable(renderable);
              }
              renderable._lastInstructionTick = -1;
              offset++;
              renderable.off("destroyed", this._removeRenderable, this);
            } else {
              managedRenderables[i2 - offset] = renderable;
            }
          }
          managedRenderables.length = managedRenderables.length - offset;
        }
        destroy() {
          this.enabled = false;
          this._renderer = null;
          this._managedRenderables.length = 0;
          this._managedHashes.length = 0;
          this._managedArrays.length = 0;
        }
        _removeRenderable(renderable) {
          const index6 = this._managedRenderables.indexOf(renderable);
          if (index6 >= 0) {
            renderable.off("destroyed", this._removeRenderable, this);
            this._managedRenderables[index6] = null;
          }
        }
      };
      _RenderableGCSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "renderableGC",
        priority: 0
      };
      _RenderableGCSystem.defaultOptions = {
        /**
         * If set to true, this will enable the garbage collector on the GPU.
         * @default true
         */
        renderableGCActive: true,
        /**
         * The maximum idle frames before a texture is destroyed by garbage collection.
         * @default 60 * 60
         */
        renderableGCMaxUnusedTime: 6e4,
        /**
         * Frames between two garbage collections.
         * @default 600
         */
        renderableGCFrequency: 3e4
      };
      RenderableGCSystem = _RenderableGCSystem;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs
  var _TextureGCSystem, TextureGCSystem;
  var init_TextureGCSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs"() {
      init_Extensions();
      _TextureGCSystem = class _TextureGCSystem2 {
        /** @param renderer - The renderer this System works for. */
        constructor(renderer) {
          this._renderer = renderer;
          this.count = 0;
          this.checkCount = 0;
        }
        init(options2) {
          options2 = { ..._TextureGCSystem2.defaultOptions, ...options2 };
          this.checkCountMax = options2.textureGCCheckCountMax;
          this.maxIdle = options2.textureGCAMaxIdle ?? options2.textureGCMaxIdle;
          this.active = options2.textureGCActive;
        }
        /**
         * Checks to see when the last time a texture was used.
         * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
         */
        postrender() {
          if (!this._renderer.renderingToScreen) {
            return;
          }
          this.count++;
          if (!this.active)
            return;
          this.checkCount++;
          if (this.checkCount > this.checkCountMax) {
            this.checkCount = 0;
            this.run();
          }
        }
        /**
         * Checks to see when the last time a texture was used.
         * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
         */
        run() {
          const managedTextures = this._renderer.texture.managedTextures;
          for (let i2 = 0; i2 < managedTextures.length; i2++) {
            const texture = managedTextures[i2];
            if (texture.autoGarbageCollect && texture.resource && texture._touched > -1 && this.count - texture._touched > this.maxIdle) {
              texture._touched = -1;
              texture.unload();
            }
          }
        }
        destroy() {
          this._renderer = null;
        }
      };
      _TextureGCSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem
        ],
        name: "textureGC"
      };
      _TextureGCSystem.defaultOptions = {
        /**
         * If set to true, this will enable the garbage collector on the GPU.
         * @default true
         */
        textureGCActive: true,
        /**
         * @deprecated since 8.3.0
         * @see {@link TextureGCSystem.textureGCMaxIdle}
         */
        textureGCAMaxIdle: null,
        /**
         * The maximum idle frames before a texture is destroyed by garbage collection.
         * @default 60 * 60
         */
        textureGCMaxIdle: 60 * 60,
        /**
         * Frames between two garbage collections.
         * @default 600
         */
        textureGCCheckCountMax: 600
      };
      TextureGCSystem = _TextureGCSystem;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs
  var _RenderTarget, RenderTarget;
  var init_RenderTarget = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs"() {
      init_uid();
      init_TextureSource();
      init_Texture();
      _RenderTarget = class _RenderTarget2 {
        /**
         * @param [descriptor] - Options for creating a render target.
         */
        constructor(descriptor = {}) {
          this.uid = uid("renderTarget");
          this.colorTextures = [];
          this.dirtyId = 0;
          this.isRoot = false;
          this._size = new Float32Array(2);
          this._managedColorTextures = false;
          descriptor = { ..._RenderTarget2.defaultOptions, ...descriptor };
          this.stencil = descriptor.stencil;
          this.depth = descriptor.depth;
          this.isRoot = descriptor.isRoot;
          if (typeof descriptor.colorTextures === "number") {
            this._managedColorTextures = true;
            for (let i2 = 0; i2 < descriptor.colorTextures; i2++) {
              this.colorTextures.push(
                new TextureSource({
                  width: descriptor.width,
                  height: descriptor.height,
                  resolution: descriptor.resolution,
                  antialias: descriptor.antialias
                })
              );
            }
          } else {
            this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];
            const colorSource = this.colorTexture.source;
            this.resize(colorSource.width, colorSource.height, colorSource._resolution);
          }
          this.colorTexture.source.on("resize", this.onSourceResize, this);
          if (descriptor.depthStencilTexture || this.stencil) {
            if (descriptor.depthStencilTexture instanceof Texture || descriptor.depthStencilTexture instanceof TextureSource) {
              this.depthStencilTexture = descriptor.depthStencilTexture.source;
            } else {
              this.ensureDepthStencilTexture();
            }
          }
        }
        get size() {
          const _size = this._size;
          _size[0] = this.pixelWidth;
          _size[1] = this.pixelHeight;
          return _size;
        }
        get width() {
          return this.colorTexture.source.width;
        }
        get height() {
          return this.colorTexture.source.height;
        }
        get pixelWidth() {
          return this.colorTexture.source.pixelWidth;
        }
        get pixelHeight() {
          return this.colorTexture.source.pixelHeight;
        }
        get resolution() {
          return this.colorTexture.source._resolution;
        }
        get colorTexture() {
          return this.colorTextures[0];
        }
        onSourceResize(source3) {
          this.resize(source3.width, source3.height, source3._resolution, true);
        }
        /**
         * This will ensure a depthStencil texture is created for this render target.
         * Most likely called by the mask system to make sure we have stencil buffer added.
         * @internal
         * @ignore
         */
        ensureDepthStencilTexture() {
          if (!this.depthStencilTexture) {
            this.depthStencilTexture = new TextureSource({
              width: this.width,
              height: this.height,
              resolution: this.resolution,
              format: "depth24plus-stencil8",
              autoGenerateMipmaps: false,
              antialias: false,
              mipLevelCount: 1
              // sampleCount: handled by the render target system..
            });
          }
        }
        resize(width8, height8, resolution = this.resolution, skipColorTexture = false) {
          this.dirtyId++;
          this.colorTextures.forEach((colorTexture, i2) => {
            if (skipColorTexture && i2 === 0)
              return;
            colorTexture.source.resize(width8, height8, resolution);
          });
          if (this.depthStencilTexture) {
            this.depthStencilTexture.source.resize(width8, height8, resolution);
          }
        }
        destroy() {
          this.colorTexture.source.off("resize", this.onSourceResize, this);
          if (this._managedColorTextures) {
            this.colorTextures.forEach((texture) => {
              texture.destroy();
            });
          }
          if (this.depthStencilTexture) {
            this.depthStencilTexture.destroy();
            delete this.depthStencilTexture;
          }
        }
      };
      _RenderTarget.defaultOptions = {
        /** the width of the RenderTarget */
        width: 0,
        /** the height of the RenderTarget */
        height: 0,
        /** the resolution of the RenderTarget */
        resolution: 1,
        /** an array of textures, or a number indicating how many color textures there should be */
        colorTextures: 1,
        /** should this render target have a stencil buffer? */
        stencil: false,
        /** should this render target have a depth buffer? */
        depth: false,
        /** should this render target be antialiased? */
        antialias: false,
        // save on perf by default!
        /** is this a root element, true if this is gl context owners render target */
        isRoot: false
      };
      RenderTarget = _RenderTarget;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs
  function getCanvasTexture(canvas2, options2) {
    if (!canvasCache.has(canvas2)) {
      const texture = new Texture({
        source: new CanvasSource({
          resource: canvas2,
          ...options2
        })
      });
      const onDestroy = () => {
        if (canvasCache.get(canvas2) === texture) {
          canvasCache.delete(canvas2);
        }
      };
      texture.once("destroy", onDestroy);
      texture.source.once("destroy", onDestroy);
      canvasCache.set(canvas2, texture);
    }
    return canvasCache.get(canvas2);
  }
  var canvasCache;
  var init_getCanvasTexture = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs"() {
      init_CanvasSource();
      init_Texture();
      canvasCache = /* @__PURE__ */ new Map();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs
  var _ViewSystem, ViewSystem;
  var init_ViewSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs"() {
      init_adapter();
      init_Extensions();
      init_Rectangle();
      init_deprecation();
      init_RenderTarget();
      init_getCanvasTexture();
      _ViewSystem = class _ViewSystem2 {
        /**
         * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.
         * @member {boolean}
         */
        get autoDensity() {
          return this.texture.source.autoDensity;
        }
        set autoDensity(value12) {
          this.texture.source.autoDensity = value12;
        }
        /** The resolution / device pixel ratio of the renderer. */
        get resolution() {
          return this.texture.source._resolution;
        }
        set resolution(value12) {
          this.texture.source.resize(
            this.texture.source.width,
            this.texture.source.height,
            value12
          );
        }
        /**
         * initiates the view system
         * @param options - the options for the view
         */
        init(options2) {
          options2 = {
            ..._ViewSystem2.defaultOptions,
            ...options2
          };
          if (options2.view) {
            deprecation(v8_0_0, "ViewSystem.view has been renamed to ViewSystem.canvas");
            options2.canvas = options2.view;
          }
          this.screen = new Rectangle(0, 0, options2.width, options2.height);
          this.canvas = options2.canvas || DOMAdapter.get().createCanvas();
          this.antialias = !!options2.antialias;
          this.texture = getCanvasTexture(this.canvas, options2);
          this.renderTarget = new RenderTarget({
            colorTextures: [this.texture],
            depth: !!options2.depth,
            isRoot: true
          });
          this.texture.source.transparent = options2.backgroundAlpha < 1;
          this.resolution = options2.resolution;
        }
        /**
         * Resizes the screen and canvas to the specified dimensions.
         * @param desiredScreenWidth - The new width of the screen.
         * @param desiredScreenHeight - The new height of the screen.
         * @param resolution
         */
        resize(desiredScreenWidth, desiredScreenHeight, resolution) {
          this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);
          this.screen.width = this.texture.frame.width;
          this.screen.height = this.texture.frame.height;
        }
        /**
         * Destroys this System and optionally removes the canvas from the dom.
         * @param {options | false} options - The options for destroying the view, or "false".
         * @param options.removeView - Whether to remove the view element from the DOM. Defaults to `false`.
         */
        destroy(options2 = false) {
          const removeView = typeof options2 === "boolean" ? options2 : !!options2?.removeView;
          if (removeView && this.canvas.parentNode) {
            this.canvas.parentNode.removeChild(this.canvas);
          }
        }
      };
      _ViewSystem.extension = {
        type: [
          ExtensionType.WebGLSystem,
          ExtensionType.WebGPUSystem,
          ExtensionType.CanvasSystem
        ],
        name: "view",
        priority: 0
      };
      _ViewSystem.defaultOptions = {
        /**
         * {@link WebGLOptions.width}
         * @default 800
         */
        width: 800,
        /**
         * {@link WebGLOptions.height}
         * @default 600
         */
        height: 600,
        /**
         * {@link WebGLOptions.autoDensity}
         * @default false
         */
        autoDensity: false,
        /**
         * {@link WebGLOptions.antialias}
         * @default false
         */
        antialias: false
      };
      ViewSystem = _ViewSystem;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs
  var SharedSystems, SharedRenderPipes;
  var init_SharedSystems = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs"() {
      init_CustomRenderPipe();
      init_RenderGroupPipe();
      init_RenderGroupSystem();
      init_SpritePipe();
      init_globalHooks();
      init_BatcherPipe();
      init_AlphaMaskPipe();
      init_ColorMaskPipe();
      init_StencilMaskPipe();
      init_BackgroundSystem();
      init_BlendModePipe();
      init_ExtractSystem();
      init_GenerateTextureSystem();
      init_GlobalUniformSystem();
      init_SchedulerSystem();
      init_HelloSystem();
      init_RenderableGCSystem();
      init_TextureGCSystem();
      init_ViewSystem();
      SharedSystems = [
        BackgroundSystem,
        GlobalUniformSystem,
        HelloSystem,
        ViewSystem,
        RenderGroupSystem,
        TextureGCSystem,
        GenerateTextureSystem,
        ExtractSystem,
        RendererInitHook,
        RenderableGCSystem,
        SchedulerSystem
      ];
      SharedRenderPipes = [
        BlendModePipe,
        BatcherPipe,
        SpritePipe,
        RenderGroupPipe,
        AlphaMaskPipe,
        StencilMaskPipe,
        ColorMaskPipe,
        CustomRenderPipe
      ];
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs
  var BindGroupSystem;
  var init_BindGroupSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs"() {
      init_Extensions();
      BindGroupSystem = class {
        constructor(renderer) {
          this._hash = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
          this._renderer.renderableGC.addManagedHash(this, "_hash");
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
        getBindGroup(bindGroup, program, groupIndex) {
          bindGroup._updateKey();
          const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);
          return gpuBindGroup;
        }
        _createBindGroup(group4, program, groupIndex) {
          const device = this._gpu.device;
          const groupLayout = program.layout[groupIndex];
          const entries = [];
          const renderer = this._renderer;
          for (const j2 in groupLayout) {
            const resource = group4.resources[j2] ?? group4.resources[groupLayout[j2]];
            let gpuResource;
            if (resource._resourceType === "uniformGroup") {
              const uniformGroup = resource;
              renderer.ubo.updateUniformGroup(uniformGroup);
              const buffer = uniformGroup.buffer;
              gpuResource = {
                buffer: renderer.buffer.getGPUBuffer(buffer),
                offset: 0,
                size: buffer.descriptor.size
              };
            } else if (resource._resourceType === "buffer") {
              const buffer = resource;
              gpuResource = {
                buffer: renderer.buffer.getGPUBuffer(buffer),
                offset: 0,
                size: buffer.descriptor.size
              };
            } else if (resource._resourceType === "bufferResource") {
              const bufferResource = resource;
              gpuResource = {
                buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),
                offset: bufferResource.offset,
                size: bufferResource.size
              };
            } else if (resource._resourceType === "textureSampler") {
              const sampler = resource;
              gpuResource = renderer.texture.getGpuSampler(sampler);
            } else if (resource._resourceType === "textureSource") {
              const texture = resource;
              gpuResource = renderer.texture.getGpuSource(texture).createView({});
            }
            entries.push({
              binding: groupLayout[j2],
              resource: gpuResource
            });
          }
          const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];
          const gpuBindGroup = device.createBindGroup({
            layout,
            entries
          });
          this._hash[group4._key] = gpuBindGroup;
          return gpuBindGroup;
        }
        destroy() {
          for (const key of Object.keys(this._hash)) {
            this._hash[key] = null;
          }
          this._hash = null;
          this._renderer = null;
        }
      };
      BindGroupSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "bindGroup"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs
  var GpuBufferSystem;
  var init_GpuBufferSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs"() {
      init_Extensions();
      init_fastCopy();
      GpuBufferSystem = class {
        constructor(renderer) {
          this._gpuBuffers = /* @__PURE__ */ Object.create(null);
          this._managedBuffers = [];
          renderer.renderableGC.addManagedHash(this, "_gpuBuffers");
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
        getGPUBuffer(buffer) {
          return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);
        }
        updateBuffer(buffer) {
          const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);
          const data = buffer.data;
          if (buffer._updateID && data) {
            buffer._updateID = 0;
            this._gpu.device.queue.writeBuffer(
              gpuBuffer,
              0,
              data.buffer,
              0,
              // round to the nearest 4 bytes
              (buffer._updateSize || data.byteLength) + 3 & ~3
            );
          }
          return gpuBuffer;
        }
        /** dispose all WebGL resources of all managed buffers */
        destroyAll() {
          for (const id5 in this._gpuBuffers) {
            this._gpuBuffers[id5].destroy();
          }
          this._gpuBuffers = {};
        }
        createGPUBuffer(buffer) {
          if (!this._gpuBuffers[buffer.uid]) {
            buffer.on("update", this.updateBuffer, this);
            buffer.on("change", this.onBufferChange, this);
            buffer.on("destroy", this.onBufferDestroy, this);
            this._managedBuffers.push(buffer);
          }
          const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);
          buffer._updateID = 0;
          if (buffer.data) {
            fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());
            gpuBuffer.unmap();
          }
          this._gpuBuffers[buffer.uid] = gpuBuffer;
          return gpuBuffer;
        }
        onBufferChange(buffer) {
          const gpuBuffer = this._gpuBuffers[buffer.uid];
          gpuBuffer.destroy();
          buffer._updateID = 0;
          this._gpuBuffers[buffer.uid] = this.createGPUBuffer(buffer);
        }
        /**
         * Disposes buffer
         * @param buffer - buffer with data
         */
        onBufferDestroy(buffer) {
          this._managedBuffers.splice(this._managedBuffers.indexOf(buffer), 1);
          this._destroyBuffer(buffer);
        }
        destroy() {
          this._managedBuffers.forEach((buffer) => this._destroyBuffer(buffer));
          this._managedBuffers = null;
          this._gpuBuffers = null;
        }
        _destroyBuffer(buffer) {
          const gpuBuffer = this._gpuBuffers[buffer.uid];
          gpuBuffer.destroy();
          buffer.off("update", this.updateBuffer, this);
          buffer.off("change", this.onBufferChange, this);
          buffer.off("destroy", this.onBufferDestroy, this);
          this._gpuBuffers[buffer.uid] = null;
        }
      };
      GpuBufferSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "buffer"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs
  var GpuColorMaskSystem;
  var init_GpuColorMaskSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs"() {
      init_Extensions();
      GpuColorMaskSystem = class {
        constructor(renderer) {
          this._colorMaskCache = 15;
          this._renderer = renderer;
        }
        setMask(colorMask) {
          if (this._colorMaskCache === colorMask)
            return;
          this._colorMaskCache = colorMask;
          this._renderer.pipeline.setColorMask(colorMask);
        }
        destroy() {
          this._renderer = null;
          this._colorMaskCache = null;
        }
      };
      GpuColorMaskSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "colorMask"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs
  var GpuDeviceSystem;
  var init_GpuDeviceSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs"() {
      init_adapter();
      init_Extensions();
      GpuDeviceSystem = class {
        /**
         * @param {WebGPURenderer} renderer - The renderer this System works for.
         */
        constructor(renderer) {
          this._renderer = renderer;
        }
        async init(options2) {
          if (this._initPromise)
            return this._initPromise;
          this._initPromise = this._createDeviceAndAdaptor(options2).then((gpu) => {
            this.gpu = gpu;
            this._renderer.runners.contextChange.emit(this.gpu);
          });
          return this._initPromise;
        }
        /**
         * Handle the context change event
         * @param gpu
         */
        contextChange(gpu) {
          this._renderer.gpu = gpu;
        }
        /**
         * Helper class to create a WebGL Context
         * @param {object} options - An options object that gets passed in to the canvas element containing the
         *    context attributes
         * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
         * @returns {WebGLRenderingContext} the WebGL context
         */
        async _createDeviceAndAdaptor(options2) {
          const adapter = await DOMAdapter.get().getNavigator().gpu.requestAdapter({
            powerPreference: options2.powerPreference,
            forceFallbackAdapter: options2.forceFallbackAdapter
          });
          const requiredFeatures = [
            "texture-compression-bc",
            "texture-compression-astc",
            "texture-compression-etc2"
          ].filter((feature) => adapter.features.has(feature));
          const device = await adapter.requestDevice({
            requiredFeatures
          });
          return { adapter, device };
        }
        destroy() {
          this.gpu = null;
          this._renderer = null;
        }
      };
      GpuDeviceSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "device"
      };
      GpuDeviceSystem.defaultOptions = {
        /**
         * {@link WebGPUOptions.powerPreference}
         * @default default
         */
        powerPreference: void 0,
        /**
         * Force the use of the fallback adapter
         * @default false
         */
        forceFallbackAdapter: false
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs
  var GpuEncoderSystem;
  var init_GpuEncoderSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs"() {
      init_Extensions();
      GpuEncoderSystem = class {
        constructor(renderer) {
          this._boundBindGroup = /* @__PURE__ */ Object.create(null);
          this._boundVertexBuffer = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        renderStart() {
          this.commandFinished = new Promise((resolve) => {
            this._resolveCommandFinished = resolve;
          });
          this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();
        }
        beginRenderPass(gpuRenderTarget) {
          this.endRenderPass();
          this._clearCache();
          this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);
        }
        endRenderPass() {
          if (this.renderPassEncoder) {
            this.renderPassEncoder.end();
          }
          this.renderPassEncoder = null;
        }
        setViewport(viewport) {
          this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
        }
        setPipelineFromGeometryProgramAndState(geometry, program, state4, topology) {
          const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state4, topology);
          this.setPipeline(pipeline);
        }
        setPipeline(pipeline) {
          if (this._boundPipeline === pipeline)
            return;
          this._boundPipeline = pipeline;
          this.renderPassEncoder.setPipeline(pipeline);
        }
        _setVertexBuffer(index6, buffer) {
          if (this._boundVertexBuffer[index6] === buffer)
            return;
          this._boundVertexBuffer[index6] = buffer;
          this.renderPassEncoder.setVertexBuffer(index6, this._renderer.buffer.updateBuffer(buffer));
        }
        _setIndexBuffer(buffer) {
          if (this._boundIndexBuffer === buffer)
            return;
          this._boundIndexBuffer = buffer;
          const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32";
          this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);
        }
        resetBindGroup(index6) {
          this._boundBindGroup[index6] = null;
        }
        setBindGroup(index6, bindGroup, program) {
          if (this._boundBindGroup[index6] === bindGroup)
            return;
          this._boundBindGroup[index6] = bindGroup;
          bindGroup._touch(this._renderer.textureGC.count);
          const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index6);
          this.renderPassEncoder.setBindGroup(index6, gpuBindGroup);
        }
        setGeometry(geometry, program) {
          const buffersToBind = this._renderer.pipeline.getBufferNamesToBind(geometry, program);
          for (const i2 in buffersToBind) {
            this._setVertexBuffer(i2, geometry.attributes[buffersToBind[i2]].buffer);
          }
          if (geometry.indexBuffer) {
            this._setIndexBuffer(geometry.indexBuffer);
          }
        }
        _setShaderBindGroups(shader, skipSync) {
          for (const i2 in shader.groups) {
            const bindGroup = shader.groups[i2];
            if (!skipSync) {
              this._syncBindGroup(bindGroup);
            }
            this.setBindGroup(i2, bindGroup, shader.gpuProgram);
          }
        }
        _syncBindGroup(bindGroup) {
          for (const j2 in bindGroup.resources) {
            const resource = bindGroup.resources[j2];
            if (resource.isUniformGroup) {
              this._renderer.ubo.updateUniformGroup(resource);
            }
          }
        }
        draw(options2) {
          const { geometry, shader, state: state4, topology, size: size5, start: start3, instanceCount, skipSync } = options2;
          this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state4, topology);
          this.setGeometry(geometry, shader.gpuProgram);
          this._setShaderBindGroups(shader, skipSync);
          if (geometry.indexBuffer) {
            this.renderPassEncoder.drawIndexed(
              size5 || geometry.indexBuffer.data.length,
              instanceCount || geometry.instanceCount,
              start3 || 0
            );
          } else {
            this.renderPassEncoder.draw(size5 || geometry.getSize(), instanceCount || geometry.instanceCount, start3 || 0);
          }
        }
        finishRenderPass() {
          if (this.renderPassEncoder) {
            this.renderPassEncoder.end();
            this.renderPassEncoder = null;
          }
        }
        postrender() {
          this.finishRenderPass();
          this._gpu.device.queue.submit([this.commandEncoder.finish()]);
          this._resolveCommandFinished();
          this.commandEncoder = null;
        }
        // restores a render pass if finishRenderPass was called
        // not optimised as really used for debugging!
        // used when we want to stop drawing and log a texture..
        restoreRenderPass() {
          const descriptor = this._renderer.renderTarget.adaptor.getDescriptor(
            this._renderer.renderTarget.renderTarget,
            false,
            [0, 0, 0, 1]
          );
          this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);
          const boundPipeline = this._boundPipeline;
          const boundVertexBuffer = { ...this._boundVertexBuffer };
          const boundIndexBuffer = this._boundIndexBuffer;
          const boundBindGroup = { ...this._boundBindGroup };
          this._clearCache();
          const viewport = this._renderer.renderTarget.viewport;
          this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
          this.setPipeline(boundPipeline);
          for (const i2 in boundVertexBuffer) {
            this._setVertexBuffer(i2, boundVertexBuffer[i2]);
          }
          for (const i2 in boundBindGroup) {
            this.setBindGroup(i2, boundBindGroup[i2], null);
          }
          this._setIndexBuffer(boundIndexBuffer);
        }
        _clearCache() {
          for (let i2 = 0; i2 < 16; i2++) {
            this._boundBindGroup[i2] = null;
            this._boundVertexBuffer[i2] = null;
          }
          this._boundIndexBuffer = null;
          this._boundPipeline = null;
        }
        destroy() {
          this._renderer = null;
          this._gpu = null;
          this._boundBindGroup = null;
          this._boundVertexBuffer = null;
          this._boundIndexBuffer = null;
          this._boundPipeline = null;
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
      };
      GpuEncoderSystem.extension = {
        type: [ExtensionType.WebGPUSystem],
        name: "encoder",
        priority: 1
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs
  var GpuStencilSystem;
  var init_GpuStencilSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs"() {
      init_Extensions();
      init_const3();
      GpuStencilSystem = class {
        constructor(renderer) {
          this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
          renderer.renderTarget.onRenderTargetChange.add(this);
        }
        onRenderTargetChange(renderTarget) {
          let stencilState = this._renderTargetStencilState[renderTarget.uid];
          if (!stencilState) {
            stencilState = this._renderTargetStencilState[renderTarget.uid] = {
              stencilMode: STENCIL_MODES.DISABLED,
              stencilReference: 0
            };
          }
          this._activeRenderTarget = renderTarget;
          this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
        }
        setStencilMode(stencilMode, stencilReference) {
          const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
          stencilState.stencilMode = stencilMode;
          stencilState.stencilReference = stencilReference;
          const renderer = this._renderer;
          renderer.pipeline.setStencilMode(stencilMode);
          renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);
        }
        destroy() {
          this._renderer.renderTarget.onRenderTargetChange.remove(this);
          this._renderer = null;
          this._activeRenderTarget = null;
          this._renderTargetStencilState = null;
        }
      };
      GpuStencilSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "stencil"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs
  var UboSystem;
  var init_UboSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs"() {
      init_unsafeEvalSupported();
      init_Buffer();
      init_const4();
      UboSystem = class {
        constructor(adaptor) {
          this._syncFunctionHash = /* @__PURE__ */ Object.create(null);
          this._adaptor = adaptor;
          this._systemCheck();
        }
        /**
         * Overridable function by `pixi.js/unsafe-eval` to silence
         * throwing an error if platform doesn't support unsafe-evals.
         * @private
         */
        _systemCheck() {
          if (!unsafeEvalSupported()) {
            throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
          }
        }
        ensureUniformGroup(uniformGroup) {
          const uniformData = this.getUniformGroupData(uniformGroup);
          uniformGroup.buffer || (uniformGroup.buffer = new Buffer2({
            data: new Float32Array(uniformData.layout.size / 4),
            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
          }));
        }
        getUniformGroupData(uniformGroup) {
          return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);
        }
        _initUniformGroup(uniformGroup) {
          const uniformGroupSignature = uniformGroup._signature;
          let uniformData = this._syncFunctionHash[uniformGroupSignature];
          if (!uniformData) {
            const elements2 = Object.keys(uniformGroup.uniformStructures).map((i2) => uniformGroup.uniformStructures[i2]);
            const layout = this._adaptor.createUboElements(elements2);
            const syncFunction = this._generateUboSync(layout.uboElements);
            uniformData = this._syncFunctionHash[uniformGroupSignature] = {
              layout,
              syncFunction
            };
          }
          return this._syncFunctionHash[uniformGroupSignature];
        }
        _generateUboSync(uboElements) {
          return this._adaptor.generateUboSync(uboElements);
        }
        syncUniformGroup(uniformGroup, data, offset) {
          const uniformGroupData = this.getUniformGroupData(uniformGroup);
          uniformGroup.buffer || (uniformGroup.buffer = new Buffer2({
            data: new Float32Array(uniformGroupData.layout.size / 4),
            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
          }));
          data || (data = uniformGroup.buffer.data);
          offset || (offset = 0);
          uniformGroupData.syncFunction(uniformGroup.uniforms, data, offset);
          return true;
        }
        updateUniformGroup(uniformGroup) {
          if (uniformGroup.isStatic && !uniformGroup._dirtyId)
            return false;
          uniformGroup._dirtyId = 0;
          const synced = this.syncUniformGroup(uniformGroup);
          uniformGroup.buffer.update();
          return synced;
        }
        destroy() {
          this._syncFunctionHash = null;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs
  function createUboElementsWGSL(uniformData) {
    const uboElements = uniformData.map((data) => ({
      data,
      offset: 0,
      size: 0
    }));
    let offset = 0;
    for (let i2 = 0; i2 < uboElements.length; i2++) {
      const uboElement = uboElements[i2];
      let size5 = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;
      const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;
      if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type]) {
        throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);
      }
      if (uboElement.data.size > 1) {
        size5 = Math.max(size5, align) * uboElement.data.size;
      }
      offset = Math.ceil(offset / align) * align;
      uboElement.size = size5;
      uboElement.offset = offset;
      offset += size5;
    }
    offset = Math.ceil(offset / 16) * 16;
    return { uboElements, size: offset };
  }
  var WGSL_ALIGN_SIZE_DATA;
  var init_createUboElementsWGSL = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs"() {
      "use strict";
      WGSL_ALIGN_SIZE_DATA = {
        i32: { align: 4, size: 4 },
        u32: { align: 4, size: 4 },
        f32: { align: 4, size: 4 },
        f16: { align: 2, size: 2 },
        "vec2<i32>": { align: 8, size: 8 },
        "vec2<u32>": { align: 8, size: 8 },
        "vec2<f32>": { align: 8, size: 8 },
        "vec2<f16>": { align: 4, size: 4 },
        "vec3<i32>": { align: 16, size: 12 },
        "vec3<u32>": { align: 16, size: 12 },
        "vec3<f32>": { align: 16, size: 12 },
        "vec3<f16>": { align: 8, size: 6 },
        "vec4<i32>": { align: 16, size: 16 },
        "vec4<u32>": { align: 16, size: 16 },
        "vec4<f32>": { align: 16, size: 16 },
        "vec4<f16>": { align: 8, size: 8 },
        "mat2x2<f32>": { align: 8, size: 16 },
        "mat2x2<f16>": { align: 4, size: 8 },
        "mat3x2<f32>": { align: 8, size: 24 },
        "mat3x2<f16>": { align: 4, size: 12 },
        "mat4x2<f32>": { align: 8, size: 32 },
        "mat4x2<f16>": { align: 4, size: 16 },
        "mat2x3<f32>": { align: 16, size: 32 },
        "mat2x3<f16>": { align: 8, size: 16 },
        "mat3x3<f32>": { align: 16, size: 48 },
        "mat3x3<f16>": { align: 8, size: 24 },
        "mat4x3<f32>": { align: 16, size: 64 },
        "mat4x3<f16>": { align: 8, size: 32 },
        "mat2x4<f32>": { align: 16, size: 32 },
        "mat2x4<f16>": { align: 8, size: 16 },
        "mat3x4<f32>": { align: 16, size: 48 },
        "mat3x4<f16>": { align: 8, size: 24 },
        "mat4x4<f32>": { align: 16, size: 64 },
        "mat4x4<f16>": { align: 8, size: 32 }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs
  var uniformParsers;
  var init_uniformParsers = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs"() {
      "use strict";
      uniformParsers = [
        // uploading pixi matrix object to mat3
        {
          type: "mat3x3<f32>",
          test: (data) => {
            const value12 = data.value;
            return value12.a !== void 0;
          },
          ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
          uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `
        },
        // uploading a pixi rectangle as a vec4
        {
          type: "vec4<f32>",
          test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.width !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `
        },
        // uploading a pixi point as a vec2
        {
          type: "vec2<f32>",
          test: (data) => data.type === "vec2<f32>" && data.size === 1 && data.value.x !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `
        },
        // uploading a pixi color as a vec4
        {
          type: "vec4<f32>",
          test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.red !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `
        },
        // uploading a pixi color as a vec3
        {
          type: "vec3<f32>",
          test: (data) => data.type === "vec3<f32>" && data.size === 1 && data.value.red !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `
        }
      ];
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs
  function createUboSyncFunction(uboElements, parserCode, arrayGenerationFunction, singleSettersMap) {
    const funcFragments = [`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `];
    let prev = 0;
    for (let i2 = 0; i2 < uboElements.length; i2++) {
      const uboElement = uboElements[i2];
      const name16 = uboElement.data.name;
      let parsed = false;
      let offset = 0;
      for (let j2 = 0; j2 < uniformParsers.length; j2++) {
        const uniformParser = uniformParsers[j2];
        if (uniformParser.test(uboElement.data)) {
          offset = uboElement.offset / 4;
          funcFragments.push(
            `name = "${name16}";`,
            `offset += ${offset - prev};`,
            uniformParsers[j2][parserCode] || uniformParsers[j2].ubo
          );
          parsed = true;
          break;
        }
      }
      if (!parsed) {
        if (uboElement.data.size > 1) {
          offset = uboElement.offset / 4;
          funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));
        } else {
          const template = singleSettersMap[uboElement.data.type];
          offset = uboElement.offset / 4;
          funcFragments.push(
            /* wgsl */
            `
                    v = uv.${name16};
                    offset += ${offset - prev};
                    ${template};
                `
          );
        }
      }
      prev = offset;
    }
    const fragmentSrc = funcFragments.join("\n");
    return new Function(
      "uv",
      "data",
      "offset",
      fragmentSrc
    );
  }
  var init_createUboSyncFunction = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs"() {
      init_uniformParsers();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs
  function loopMatrix(col, row) {
    const total = col * row;
    return `
        for (let i = 0; i < ${total}; i++) {
            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];
        }
    `;
  }
  var uboSyncFunctionsSTD40, uboSyncFunctionsWGSL;
  var init_uboSyncFunctions = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs"() {
      "use strict";
      uboSyncFunctionsSTD40 = {
        f32: `
        data[offset] = v;`,
        i32: `
        data[offset] = v;`,
        "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
        "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
        "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
        "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
        "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
        "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
        "mat3x2<f32>": loopMatrix(3, 2),
        "mat4x2<f32>": loopMatrix(4, 2),
        "mat2x3<f32>": loopMatrix(2, 3),
        "mat4x3<f32>": loopMatrix(4, 3),
        "mat2x4<f32>": loopMatrix(2, 4),
        "mat3x4<f32>": loopMatrix(3, 4)
      };
      uboSyncFunctionsWGSL = {
        ...uboSyncFunctionsSTD40,
        "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs
  function generateArraySyncWGSL(uboElement, offsetToAdd) {
    const { size: size5, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];
    const remainder2 = (align - size5) / 4;
    return `
         v = uv.${uboElement.data.name};
         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : ""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${uboElement.data.size * (size5 / 4)}; i++)
         {
             for(var j = 0; j < ${size5 / 4}; j++)
             {
                 data[arrayOffset++] = v[t++];
             }
             ${remainder2 !== 0 ? `arrayOffset += ${remainder2};` : ""}
         }
     `;
  }
  var init_generateArraySyncWGSL = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs"() {
      init_createUboElementsWGSL();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs
  function createUboSyncFunctionWGSL(uboElements) {
    return createUboSyncFunction(
      uboElements,
      "uboWgsl",
      generateArraySyncWGSL,
      uboSyncFunctionsWGSL
    );
  }
  var init_createUboSyncFunctionWGSL = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs"() {
      init_createUboSyncFunction();
      init_uboSyncFunctions();
      init_generateArraySyncWGSL();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs
  var GpuUboSystem;
  var init_GpuUboSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs"() {
      init_Extensions();
      init_UboSystem();
      init_createUboElementsWGSL();
      init_createUboSyncFunctionWGSL();
      GpuUboSystem = class extends UboSystem {
        constructor() {
          super({
            createUboElements: createUboElementsWGSL,
            generateUboSync: createUboSyncFunctionWGSL
          });
        }
      };
      GpuUboSystem.extension = {
        type: [ExtensionType.WebGPUSystem],
        name: "ubo"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs
  var BufferResource;
  var init_BufferResource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs"() {
      init_eventemitter3();
      init_uid();
      BufferResource = class extends eventemitter3_default {
        /**
         * Create a new Buffer Resource.
         * @param options - The options for the buffer resource
         * @param options.buffer - The underlying buffer that this resource is using
         * @param options.offset - The offset of the buffer this resource is using.
         * If not provided, then it will use the offset of the buffer.
         * @param options.size - The size of the buffer this resource is using.
         * If not provided, then it will use the size of the buffer.
         */
        constructor({ buffer, offset, size: size5 }) {
          super();
          this.uid = uid("buffer");
          this._resourceType = "bufferResource";
          this._touched = 0;
          this._resourceId = uid("resource");
          this._bufferResource = true;
          this.destroyed = false;
          this.buffer = buffer;
          this.offset = offset | 0;
          this.size = size5;
          this.buffer.on("change", this.onBufferChange, this);
        }
        onBufferChange() {
          this._resourceId = uid("resource");
          this.emit("change", this);
        }
        /**
         * Destroys this resource. Make sure the underlying buffer is not used anywhere else
         * if you want to destroy it as well, or code will explode
         * @param destroyBuffer - Should the underlying buffer be destroyed as well?
         */
        destroy(destroyBuffer = false) {
          this.destroyed = true;
          if (destroyBuffer) {
            this.buffer.destroy();
          }
          this.emit("change", this);
          this.buffer = null;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs
  var UboBatch;
  var init_UboBatch = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs"() {
      "use strict";
      UboBatch = class {
        constructor({ minUniformOffsetAlignment: minUniformOffsetAlignment2 }) {
          this._minUniformOffsetAlignment = 256;
          this.byteIndex = 0;
          this._minUniformOffsetAlignment = minUniformOffsetAlignment2;
          this.data = new Float32Array(65535);
        }
        clear() {
          this.byteIndex = 0;
        }
        addEmptyGroup(size5) {
          if (size5 > this._minUniformOffsetAlignment / 4) {
            throw new Error(`UniformBufferBatch: array is too large: ${size5 * 4}`);
          }
          const start3 = this.byteIndex;
          let newSize = start3 + size5 * 4;
          newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;
          if (newSize > this.data.length * 4) {
            throw new Error("UniformBufferBatch: ubo batch got too big");
          }
          this.byteIndex = newSize;
          return start3;
        }
        addGroup(array) {
          const offset = this.addEmptyGroup(array.length);
          for (let i2 = 0; i2 < array.length; i2++) {
            this.data[offset / 4 + i2] = array[i2];
          }
          return offset;
        }
        destroy() {
          this._buffer.destroy();
          this._buffer = null;
          this.data = null;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs
  var minUniformOffsetAlignment, GpuUniformBatchPipe;
  var init_GpuUniformBatchPipe = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs"() {
      init_Extensions();
      init_Buffer();
      init_BufferResource();
      init_const4();
      init_UboBatch();
      init_BindGroup();
      minUniformOffsetAlignment = 128;
      GpuUniformBatchPipe = class {
        constructor(renderer) {
          this._bindGroupHash = /* @__PURE__ */ Object.create(null);
          this._buffers = [];
          this._bindGroups = [];
          this._bufferResources = [];
          this._renderer = renderer;
          this._renderer.renderableGC.addManagedHash(this, "_bindGroupHash");
          this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });
          const totalBuffers = 256 / minUniformOffsetAlignment;
          for (let i2 = 0; i2 < totalBuffers; i2++) {
            let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;
            if (i2 === 0)
              usage |= BufferUsage.COPY_SRC;
            this._buffers.push(new Buffer2({
              data: this._batchBuffer.data,
              usage
            }));
          }
        }
        renderEnd() {
          this._uploadBindGroups();
          this._resetBindGroups();
        }
        _resetBindGroups() {
          for (const i2 in this._bindGroupHash) {
            this._bindGroupHash[i2] = null;
          }
          this._batchBuffer.clear();
        }
        // just works for single bind groups for now
        getUniformBindGroup(group4, duplicate2) {
          if (!duplicate2 && this._bindGroupHash[group4.uid]) {
            return this._bindGroupHash[group4.uid];
          }
          this._renderer.ubo.ensureUniformGroup(group4);
          const data = group4.buffer.data;
          const offset = this._batchBuffer.addEmptyGroup(data.length);
          this._renderer.ubo.syncUniformGroup(group4, this._batchBuffer.data, offset / 4);
          this._bindGroupHash[group4.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);
          return this._bindGroupHash[group4.uid];
        }
        getUboResource(group4) {
          this._renderer.ubo.updateUniformGroup(group4);
          const data = group4.buffer.data;
          const offset = this._batchBuffer.addGroup(data);
          return this._getBufferResource(offset / minUniformOffsetAlignment);
        }
        getArrayBindGroup(data) {
          const offset = this._batchBuffer.addGroup(data);
          return this._getBindGroup(offset / minUniformOffsetAlignment);
        }
        getArrayBufferResource(data) {
          const offset = this._batchBuffer.addGroup(data);
          const index6 = offset / minUniformOffsetAlignment;
          return this._getBufferResource(index6);
        }
        _getBufferResource(index6) {
          if (!this._bufferResources[index6]) {
            const buffer = this._buffers[index6 % 2];
            this._bufferResources[index6] = new BufferResource({
              buffer,
              offset: (index6 / 2 | 0) * 256,
              size: minUniformOffsetAlignment
            });
          }
          return this._bufferResources[index6];
        }
        _getBindGroup(index6) {
          if (!this._bindGroups[index6]) {
            const bindGroup = new BindGroup({
              0: this._getBufferResource(index6)
            });
            this._bindGroups[index6] = bindGroup;
          }
          return this._bindGroups[index6];
        }
        _uploadBindGroups() {
          const bufferSystem = this._renderer.buffer;
          const firstBuffer = this._buffers[0];
          firstBuffer.update(this._batchBuffer.byteIndex);
          bufferSystem.updateBuffer(firstBuffer);
          const commandEncoder = this._renderer.gpu.device.createCommandEncoder();
          for (let i2 = 1; i2 < this._buffers.length; i2++) {
            const buffer = this._buffers[i2];
            commandEncoder.copyBufferToBuffer(
              bufferSystem.getGPUBuffer(firstBuffer),
              minUniformOffsetAlignment,
              bufferSystem.getGPUBuffer(buffer),
              0,
              this._batchBuffer.byteIndex
            );
          }
          this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);
        }
        destroy() {
          for (let i2 = 0; i2 < this._bindGroups.length; i2++) {
            this._bindGroups[i2].destroy();
          }
          this._bindGroups = null;
          this._bindGroupHash = null;
          for (let i2 = 0; i2 < this._buffers.length; i2++) {
            this._buffers[i2].destroy();
          }
          this._buffers = null;
          for (let i2 = 0; i2 < this._bufferResources.length; i2++) {
            this._bufferResources[i2].destroy();
          }
          this._bufferResources = null;
          this._batchBuffer.destroy();
          this._bindGroupHash = null;
          this._renderer = null;
        }
      };
      GpuUniformBatchPipe.extension = {
        type: [
          ExtensionType.WebGPUPipes
        ],
        name: "uniformBatch"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs
  function ensureAttributes(geometry, extractedData) {
    for (const i2 in geometry.attributes) {
      const attribute = geometry.attributes[i2];
      const attributeData2 = extractedData[i2];
      if (attributeData2) {
        attribute.format ?? (attribute.format = attributeData2.format);
        attribute.offset ?? (attribute.offset = attributeData2.offset);
        attribute.instance ?? (attribute.instance = attributeData2.instance);
      } else {
        warn2(`Attribute ${i2} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);
      }
    }
    ensureStartAndStride(geometry);
  }
  function ensureStartAndStride(geometry) {
    const { buffers, attributes } = geometry;
    const tempStride = {};
    const tempStart = {};
    for (const j2 in buffers) {
      const buffer = buffers[j2];
      tempStride[buffer.uid] = 0;
      tempStart[buffer.uid] = 0;
    }
    for (const j2 in attributes) {
      const attribute = attributes[j2];
      tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;
    }
    for (const j2 in attributes) {
      const attribute = attributes[j2];
      attribute.stride ?? (attribute.stride = tempStride[attribute.buffer.uid]);
      attribute.start ?? (attribute.start = tempStart[attribute.buffer.uid]);
      tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;
    }
  }
  var init_ensureAttributes = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs"() {
      init_warn();
      init_getAttributeInfoFromFormat();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs
  var GpuStencilModesToPixi;
  var init_GpuStencilModesToPixi = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs"() {
      init_const3();
      GpuStencilModesToPixi = [];
      GpuStencilModesToPixi[STENCIL_MODES.NONE] = void 0;
      GpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {
        stencilWriteMask: 0,
        stencilReadMask: 0
      };
      GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {
        stencilFront: {
          compare: "equal",
          passOp: "increment-clamp"
        },
        stencilBack: {
          compare: "equal",
          passOp: "increment-clamp"
        }
      };
      GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {
        stencilFront: {
          compare: "equal",
          passOp: "decrement-clamp"
        },
        stencilBack: {
          compare: "equal",
          passOp: "decrement-clamp"
        }
      };
      GpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {
        stencilWriteMask: 0,
        stencilFront: {
          compare: "equal",
          passOp: "keep"
        },
        stencilBack: {
          compare: "equal",
          passOp: "keep"
        }
      };
      GpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {
        stencilWriteMask: 0,
        stencilFront: {
          compare: "not-equal",
          passOp: "replace"
        },
        stencilBack: {
          compare: "not-equal",
          passOp: "replace"
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs
  function getGraphicsStateKey(geometryLayout, shaderKey, state4, blendMode, topology) {
    return geometryLayout << 24 | shaderKey << 16 | state4 << 10 | blendMode << 5 | topology;
  }
  function getGlobalStateKey(stencilStateId, multiSampleCount, colorMask, renderTarget) {
    return colorMask << 6 | stencilStateId << 3 | renderTarget << 1 | multiSampleCount;
  }
  var topologyStringToId, PipelineSystem;
  var init_PipelineSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs"() {
      init_Extensions();
      init_warn();
      init_ensureAttributes();
      init_const3();
      init_createIdFromString();
      init_GpuStencilModesToPixi();
      topologyStringToId = {
        "point-list": 0,
        "line-list": 1,
        "line-strip": 2,
        "triangle-list": 3,
        "triangle-strip": 4
      };
      PipelineSystem = class {
        constructor(renderer) {
          this._moduleCache = /* @__PURE__ */ Object.create(null);
          this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null);
          this._bindingNamesCache = /* @__PURE__ */ Object.create(null);
          this._pipeCache = /* @__PURE__ */ Object.create(null);
          this._pipeStateCaches = /* @__PURE__ */ Object.create(null);
          this._colorMask = 15;
          this._multisampleCount = 1;
          this._renderer = renderer;
        }
        contextChange(gpu) {
          this._gpu = gpu;
          this.setStencilMode(STENCIL_MODES.DISABLED);
          this._updatePipeHash();
        }
        setMultisampleCount(multisampleCount) {
          if (this._multisampleCount === multisampleCount)
            return;
          this._multisampleCount = multisampleCount;
          this._updatePipeHash();
        }
        setRenderTarget(renderTarget) {
          this._multisampleCount = renderTarget.msaaSamples;
          this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;
          this._updatePipeHash();
        }
        setColorMask(colorMask) {
          if (this._colorMask === colorMask)
            return;
          this._colorMask = colorMask;
          this._updatePipeHash();
        }
        setStencilMode(stencilMode) {
          if (this._stencilMode === stencilMode)
            return;
          this._stencilMode = stencilMode;
          this._stencilState = GpuStencilModesToPixi[stencilMode];
          this._updatePipeHash();
        }
        setPipeline(geometry, program, state4, passEncoder) {
          const pipeline = this.getPipeline(geometry, program, state4);
          passEncoder.setPipeline(pipeline);
        }
        getPipeline(geometry, program, state4, topology) {
          if (!geometry._layoutKey) {
            ensureAttributes(geometry, program.attributeData);
            this._generateBufferKey(geometry);
          }
          topology = topology || geometry.topology;
          const key = getGraphicsStateKey(
            geometry._layoutKey,
            program._layoutKey,
            state4.data,
            state4._blendModeId,
            topologyStringToId[topology]
          );
          if (this._pipeCache[key])
            return this._pipeCache[key];
          this._pipeCache[key] = this._createPipeline(geometry, program, state4, topology);
          return this._pipeCache[key];
        }
        _createPipeline(geometry, program, state4, topology) {
          const device = this._gpu.device;
          const buffers = this._createVertexBufferLayouts(geometry, program);
          const blendModes = this._renderer.state.getColorTargets(state4);
          blendModes[0].writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;
          const layout = this._renderer.shader.getProgramData(program).pipeline;
          const descriptor = {
            // TODO later check if its helpful to create..
            // layout,
            vertex: {
              module: this._getModule(program.vertex.source),
              entryPoint: program.vertex.entryPoint,
              // geometry..
              buffers
            },
            fragment: {
              module: this._getModule(program.fragment.source),
              entryPoint: program.fragment.entryPoint,
              targets: blendModes
            },
            primitive: {
              topology,
              cullMode: state4.cullMode
            },
            layout,
            multisample: {
              count: this._multisampleCount
            },
            // depthStencil,
            label: `PIXI Pipeline`
          };
          if (this._depthStencilAttachment) {
            descriptor.depthStencil = {
              ...this._stencilState,
              format: "depth24plus-stencil8",
              depthWriteEnabled: state4.depthTest,
              depthCompare: state4.depthTest ? "less" : "always"
            };
          }
          const pipeline = device.createRenderPipeline(descriptor);
          return pipeline;
        }
        _getModule(code) {
          return this._moduleCache[code] || this._createModule(code);
        }
        _createModule(code) {
          const device = this._gpu.device;
          this._moduleCache[code] = device.createShaderModule({
            code
          });
          return this._moduleCache[code];
        }
        _generateBufferKey(geometry) {
          const keyGen = [];
          let index6 = 0;
          const attributeKeys = Object.keys(geometry.attributes).sort();
          for (let i2 = 0; i2 < attributeKeys.length; i2++) {
            const attribute = geometry.attributes[attributeKeys[i2]];
            keyGen[index6++] = attribute.offset;
            keyGen[index6++] = attribute.format;
            keyGen[index6++] = attribute.stride;
            keyGen[index6++] = attribute.instance;
          }
          const stringKey = keyGen.join("|");
          geometry._layoutKey = createIdFromString(stringKey, "geometry");
          return geometry._layoutKey;
        }
        _generateAttributeLocationsKey(program) {
          const keyGen = [];
          let index6 = 0;
          const attributeKeys = Object.keys(program.attributeData).sort();
          for (let i2 = 0; i2 < attributeKeys.length; i2++) {
            const attribute = program.attributeData[attributeKeys[i2]];
            keyGen[index6++] = attribute.location;
          }
          const stringKey = keyGen.join("|");
          program._attributeLocationsKey = createIdFromString(stringKey, "programAttributes");
          return program._attributeLocationsKey;
        }
        /**
         * Returns a hash of buffer names mapped to bind locations.
         * This is used to bind the correct buffer to the correct location in the shader.
         * @param geometry - The geometry where to get the buffer names
         * @param program - The program where to get the buffer names
         * @returns An object of buffer names mapped to the bind location.
         */
        getBufferNamesToBind(geometry, program) {
          const key = geometry._layoutKey << 16 | program._attributeLocationsKey;
          if (this._bindingNamesCache[key])
            return this._bindingNamesCache[key];
          const data = this._createVertexBufferLayouts(geometry, program);
          const bufferNamesToBind = /* @__PURE__ */ Object.create(null);
          const attributeData2 = program.attributeData;
          for (let i2 = 0; i2 < data.length; i2++) {
            for (const j2 in attributeData2) {
              if (attributeData2[j2].location === i2) {
                bufferNamesToBind[i2] = j2;
                break;
              }
            }
          }
          this._bindingNamesCache[key] = bufferNamesToBind;
          return bufferNamesToBind;
        }
        _createVertexBufferLayouts(geometry, program) {
          if (!program._attributeLocationsKey)
            this._generateAttributeLocationsKey(program);
          const key = geometry._layoutKey << 16 | program._attributeLocationsKey;
          if (this._bufferLayoutsCache[key]) {
            return this._bufferLayoutsCache[key];
          }
          const vertexBuffersLayout = [];
          geometry.buffers.forEach((buffer) => {
            const bufferEntry = {
              arrayStride: 0,
              stepMode: "vertex",
              attributes: []
            };
            const bufferEntryAttributes = bufferEntry.attributes;
            for (const i2 in program.attributeData) {
              const attribute = geometry.attributes[i2];
              if ((attribute.divisor ?? 1) !== 1) {
                warn2(`Attribute ${i2} has an invalid divisor value of '${attribute.divisor}'. WebGPU only supports a divisor value of 1`);
              }
              if (attribute.buffer === buffer) {
                bufferEntry.arrayStride = attribute.stride;
                bufferEntry.stepMode = attribute.instance ? "instance" : "vertex";
                bufferEntryAttributes.push({
                  shaderLocation: program.attributeData[i2].location,
                  offset: attribute.offset,
                  format: attribute.format
                });
              }
            }
            if (bufferEntryAttributes.length) {
              vertexBuffersLayout.push(bufferEntry);
            }
          });
          this._bufferLayoutsCache[key] = vertexBuffersLayout;
          return vertexBuffersLayout;
        }
        _updatePipeHash() {
          const key = getGlobalStateKey(
            this._stencilMode,
            this._multisampleCount,
            this._colorMask,
            this._depthStencilAttachment
          );
          if (!this._pipeStateCaches[key]) {
            this._pipeStateCaches[key] = /* @__PURE__ */ Object.create(null);
          }
          this._pipeCache = this._pipeStateCaches[key];
        }
        destroy() {
          this._renderer = null;
          this._bufferLayoutsCache = null;
        }
      };
      PipelineSystem.extension = {
        type: [ExtensionType.WebGPUSystem],
        name: "pipeline"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs
  function calculateProjection(pm, x2, y2, width8, height8, flipY) {
    const sign2 = flipY ? 1 : -1;
    pm.identity();
    pm.a = 1 / width8 * 2;
    pm.d = sign2 * (1 / height8 * 2);
    pm.tx = -1 - x2 * pm.a;
    pm.ty = -sign2 - y2 * pm.d;
    return pm;
  }
  var init_calculateProjection = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs
  function isRenderingToScreen(renderTarget) {
    const resource = renderTarget.colorTexture.source.resource;
    return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement && document.body.contains(resource);
  }
  var init_isRenderingToScreen = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs
  var RenderTargetSystem;
  var init_RenderTargetSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs"() {
      init_Matrix();
      init_Rectangle();
      init_const7();
      init_calculateProjection();
      init_SystemRunner();
      init_CanvasSource();
      init_TextureSource();
      init_Texture();
      init_getCanvasTexture();
      init_isRenderingToScreen();
      init_RenderTarget();
      RenderTargetSystem = class {
        constructor(renderer) {
          this.rootViewPort = new Rectangle();
          this.viewport = new Rectangle();
          this.onRenderTargetChange = new SystemRunner("onRenderTargetChange");
          this.projectionMatrix = new Matrix();
          this.defaultClearColor = [0, 0, 0, 0];
          this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();
          this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
          this._renderTargetStack = [];
          this._renderer = renderer;
          renderer.renderableGC.addManagedHash(this, "_gpuRenderTargetHash");
        }
        /** called when dev wants to finish a render pass */
        finishRenderPass() {
          this.adaptor.finishRenderPass(this.renderTarget);
        }
        /**
         * called when the renderer starts to render a scene.
         * @param options
         * @param options.target - the render target to render to
         * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
         * @param options.clearColor - the color to clear to
         * @param options.frame - the frame to render to
         */
        renderStart({
          target: target5,
          clear: clear2,
          clearColor,
          frame
        }) {
          this._renderTargetStack.length = 0;
          this.push(
            target5,
            clear2,
            clearColor,
            frame
          );
          this.rootViewPort.copyFrom(this.viewport);
          this.rootRenderTarget = this.renderTarget;
          this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);
        }
        postrender() {
          this.adaptor.postrender?.(this.rootRenderTarget);
        }
        /**
         * Binding a render surface! This is the main function of the render target system.
         * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.
         * Once bound all draw calls will be rendered to the render surface.
         *
         * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.
         * @param renderSurface - the render surface to bind
         * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
         * @param clearColor - the color to clear to
         * @param frame - the frame to render to
         * @returns the render target that was bound
         */
        bind(renderSurface, clear2 = true, clearColor, frame) {
          const renderTarget = this.getRenderTarget(renderSurface);
          const didChange = this.renderTarget !== renderTarget;
          this.renderTarget = renderTarget;
          this.renderSurface = renderSurface;
          const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);
          if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {
            this.adaptor.resizeGpuRenderTarget(renderTarget);
            gpuRenderTarget.width = renderTarget.pixelWidth;
            gpuRenderTarget.height = renderTarget.pixelHeight;
          }
          const source3 = renderTarget.colorTexture;
          const viewport = this.viewport;
          const pixelWidth = source3.pixelWidth;
          const pixelHeight = source3.pixelHeight;
          if (!frame && renderSurface instanceof Texture) {
            frame = renderSurface.frame;
          }
          if (frame) {
            const resolution = source3._resolution;
            viewport.x = frame.x * resolution + 0.5 | 0;
            viewport.y = frame.y * resolution + 0.5 | 0;
            viewport.width = frame.width * resolution + 0.5 | 0;
            viewport.height = frame.height * resolution + 0.5 | 0;
          } else {
            viewport.x = 0;
            viewport.y = 0;
            viewport.width = pixelWidth;
            viewport.height = pixelHeight;
          }
          calculateProjection(
            this.projectionMatrix,
            0,
            0,
            viewport.width / source3.resolution,
            viewport.height / source3.resolution,
            !renderTarget.isRoot
          );
          this.adaptor.startRenderPass(renderTarget, clear2, clearColor, viewport);
          if (didChange) {
            this.onRenderTargetChange.emit(renderTarget);
          }
          return renderTarget;
        }
        clear(target5, clear2 = CLEAR.ALL, clearColor) {
          if (!clear2)
            return;
          if (target5) {
            target5 = this.getRenderTarget(target5);
          }
          this.adaptor.clear(
            target5 || this.renderTarget,
            clear2,
            clearColor,
            this.viewport
          );
        }
        contextChange() {
          this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
        }
        /**
         * Push a render surface to the renderer. This will bind the render surface to the renderer,
         * @param renderSurface - the render surface to push
         * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
         * @param clearColor - the color to clear to
         * @param frame - the frame to use when rendering to the render surface
         */
        push(renderSurface, clear2 = CLEAR.ALL, clearColor, frame) {
          const renderTarget = this.bind(renderSurface, clear2, clearColor, frame);
          this._renderTargetStack.push({
            renderTarget,
            frame
          });
          return renderTarget;
        }
        /** Pops the current render target from the renderer and restores the previous render target. */
        pop() {
          this._renderTargetStack.pop();
          const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];
          this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);
        }
        /**
         * Gets the render target from the provide render surface. Eg if its a texture,
         * it will return the render target for the texture.
         * If its a render target, it will return the same render target.
         * @param renderSurface - the render surface to get the render target for
         * @returns the render target for the render surface
         */
        getRenderTarget(renderSurface) {
          if (renderSurface.isTexture) {
            renderSurface = renderSurface.source;
          }
          return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);
        }
        /**
         * Copies a render surface to another texture
         * @param sourceRenderSurfaceTexture - the render surface to copy from
         * @param destinationTexture - the texture to copy to
         * @param originSrc - the origin of the copy
         * @param originSrc.x - the x origin of the copy
         * @param originSrc.y - the y origin of the copy
         * @param size - the size of the copy
         * @param size.width - the width of the copy
         * @param size.height - the height of the copy
         * @param originDest - the destination origin (top left to paste from!)
         * @param originDest.x - the x origin of the paste
         * @param originDest.y - the y origin of the paste
         */
        copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size5, originDest) {
          if (originSrc.x < 0) {
            size5.width += originSrc.x;
            originDest.x -= originSrc.x;
            originSrc.x = 0;
          }
          if (originSrc.y < 0) {
            size5.height += originSrc.y;
            originDest.y -= originSrc.y;
            originSrc.y = 0;
          }
          const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;
          size5.width = Math.min(size5.width, pixelWidth - originSrc.x);
          size5.height = Math.min(size5.height, pixelHeight - originSrc.y);
          return this.adaptor.copyToTexture(
            sourceRenderSurfaceTexture,
            destinationTexture,
            originSrc,
            size5,
            originDest
          );
        }
        /**
         * ensures that we have a depth stencil buffer available to render to
         * This is used by the mask system to make sure we have a stencil buffer.
         */
        ensureDepthStencil() {
          if (!this.renderTarget.stencil) {
            this.renderTarget.stencil = true;
            this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);
          }
        }
        /** nukes the render target system */
        destroy() {
          this._renderer = null;
          this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) => {
            if (renderTarget !== key) {
              renderTarget.destroy();
            }
          });
          this._renderSurfaceToRenderTargetHash.clear();
          this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
        }
        _initRenderTarget(renderSurface) {
          let renderTarget = null;
          if (CanvasSource.test(renderSurface)) {
            renderSurface = getCanvasTexture(renderSurface).source;
          }
          if (renderSurface instanceof RenderTarget) {
            renderTarget = renderSurface;
          } else if (renderSurface instanceof TextureSource) {
            renderTarget = new RenderTarget({
              colorTextures: [renderSurface]
            });
            if (CanvasSource.test(renderSurface.source.resource)) {
              renderTarget.isRoot = true;
            }
            renderSurface.once("destroy", () => {
              renderTarget.destroy();
              this._renderSurfaceToRenderTargetHash.delete(renderSurface);
              const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];
              if (gpuRenderTarget) {
                this._gpuRenderTargetHash[renderTarget.uid] = null;
                this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);
              }
            });
          }
          this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);
          return renderTarget;
        }
        getGpuRenderTarget(renderTarget) {
          return this._gpuRenderTargetHash[renderTarget.uid] || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs
  var GpuRenderTarget;
  var init_GpuRenderTarget = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs"() {
      "use strict";
      GpuRenderTarget = class {
        constructor() {
          this.contexts = [];
          this.msaaTextures = [];
          this.msaaSamples = 1;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs
  var GpuRenderTargetAdaptor;
  var init_GpuRenderTargetAdaptor = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs"() {
      init_const7();
      init_CanvasSource();
      init_TextureSource();
      init_GpuRenderTarget();
      GpuRenderTargetAdaptor = class {
        init(renderer, renderTargetSystem) {
          this._renderer = renderer;
          this._renderTargetSystem = renderTargetSystem;
        }
        copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size5, originDest) {
          const renderer = this._renderer;
          const baseGpuTexture = this._getGpuColorTexture(
            sourceRenderSurfaceTexture
          );
          const backGpuTexture = renderer.texture.getGpuSource(
            destinationTexture.source
          );
          renderer.encoder.commandEncoder.copyTextureToTexture(
            {
              texture: baseGpuTexture,
              origin: originSrc
            },
            {
              texture: backGpuTexture,
              origin: originDest
            },
            size5
          );
          return destinationTexture;
        }
        startRenderPass(renderTarget, clear2 = true, clearColor, viewport) {
          const renderTargetSystem = this._renderTargetSystem;
          const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
          const descriptor = this.getDescriptor(renderTarget, clear2, clearColor);
          gpuRenderTarget.descriptor = descriptor;
          this._renderer.pipeline.setRenderTarget(gpuRenderTarget);
          this._renderer.encoder.beginRenderPass(gpuRenderTarget);
          this._renderer.encoder.setViewport(viewport);
        }
        finishRenderPass() {
          this._renderer.encoder.endRenderPass();
        }
        /**
         * returns the gpu texture for the first color texture in the render target
         * mainly used by the filter manager to get copy the texture for blending
         * @param renderTarget
         * @returns a gpu texture
         */
        _getGpuColorTexture(renderTarget) {
          const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
          if (gpuRenderTarget.contexts[0]) {
            return gpuRenderTarget.contexts[0].getCurrentTexture();
          }
          return this._renderer.texture.getGpuSource(
            renderTarget.colorTextures[0].source
          );
        }
        getDescriptor(renderTarget, clear2, clearValue) {
          if (typeof clear2 === "boolean") {
            clear2 = clear2 ? CLEAR.ALL : CLEAR.NONE;
          }
          const renderTargetSystem = this._renderTargetSystem;
          const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
          const colorAttachments = renderTarget.colorTextures.map(
            (texture, i2) => {
              const context3 = gpuRenderTarget.contexts[i2];
              let view2;
              let resolveTarget;
              if (context3) {
                const currentTexture = context3.getCurrentTexture();
                const canvasTextureView = currentTexture.createView();
                view2 = canvasTextureView;
              } else {
                view2 = this._renderer.texture.getGpuSource(texture).createView({
                  mipLevelCount: 1
                });
              }
              if (gpuRenderTarget.msaaTextures[i2]) {
                resolveTarget = view2;
                view2 = this._renderer.texture.getTextureView(
                  gpuRenderTarget.msaaTextures[i2]
                );
              }
              const loadOp = clear2 & CLEAR.COLOR ? "clear" : "load";
              clearValue ?? (clearValue = renderTargetSystem.defaultClearColor);
              return {
                view: view2,
                resolveTarget,
                clearValue,
                storeOp: "store",
                loadOp
              };
            }
          );
          let depthStencilAttachment;
          if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture) {
            renderTarget.ensureDepthStencilTexture();
            renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;
          }
          if (renderTarget.depthStencilTexture) {
            const stencilLoadOp = clear2 & CLEAR.STENCIL ? "clear" : "load";
            const depthLoadOp = clear2 & CLEAR.DEPTH ? "clear" : "load";
            depthStencilAttachment = {
              view: this._renderer.texture.getGpuSource(renderTarget.depthStencilTexture.source).createView(),
              stencilStoreOp: "store",
              stencilLoadOp,
              depthClearValue: 1,
              depthLoadOp,
              depthStoreOp: "store"
            };
          }
          const descriptor = {
            colorAttachments,
            depthStencilAttachment
          };
          return descriptor;
        }
        clear(renderTarget, clear2 = true, clearColor, viewport) {
          if (!clear2)
            return;
          const { gpu, encoder } = this._renderer;
          const device = gpu.device;
          const standAlone = encoder.commandEncoder === null;
          if (standAlone) {
            const commandEncoder = device.createCommandEncoder();
            const renderPassDescriptor = this.getDescriptor(renderTarget, clear2, clearColor);
            const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
            passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
            passEncoder.end();
            const gpuCommands = commandEncoder.finish();
            device.queue.submit([gpuCommands]);
          } else {
            this.startRenderPass(renderTarget, clear2, clearColor, viewport);
          }
        }
        initGpuRenderTarget(renderTarget) {
          renderTarget.isRoot = true;
          const gpuRenderTarget = new GpuRenderTarget();
          renderTarget.colorTextures.forEach((colorTexture, i2) => {
            if (CanvasSource.test(colorTexture.resource)) {
              const context3 = colorTexture.resource.getContext(
                "webgpu"
              );
              const alphaMode = colorTexture.transparent ? "premultiplied" : "opaque";
              try {
                context3.configure({
                  device: this._renderer.gpu.device,
                  // eslint-disable-next-line max-len
                  usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
                  format: "bgra8unorm",
                  alphaMode
                });
              } catch (e2) {
                console.error(e2);
              }
              gpuRenderTarget.contexts[i2] = context3;
            }
            gpuRenderTarget.msaa = colorTexture.source.antialias;
            if (colorTexture.source.antialias) {
              const msaaTexture = new TextureSource({
                width: 0,
                height: 0,
                sampleCount: 4
              });
              gpuRenderTarget.msaaTextures[i2] = msaaTexture;
            }
          });
          if (gpuRenderTarget.msaa) {
            gpuRenderTarget.msaaSamples = 4;
            if (renderTarget.depthStencilTexture) {
              renderTarget.depthStencilTexture.source.sampleCount = 4;
            }
          }
          return gpuRenderTarget;
        }
        destroyGpuRenderTarget(gpuRenderTarget) {
          gpuRenderTarget.contexts.forEach((context3) => {
            context3.unconfigure();
          });
          gpuRenderTarget.msaaTextures.forEach((texture) => {
            texture.destroy();
          });
          gpuRenderTarget.msaaTextures.length = 0;
          gpuRenderTarget.contexts.length = 0;
        }
        ensureDepthStencilTexture(renderTarget) {
          const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
          if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa) {
            renderTarget.depthStencilTexture.source.sampleCount = 4;
          }
        }
        resizeGpuRenderTarget(renderTarget) {
          const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
          gpuRenderTarget.width = renderTarget.width;
          gpuRenderTarget.height = renderTarget.height;
          if (gpuRenderTarget.msaa) {
            renderTarget.colorTextures.forEach((colorTexture, i2) => {
              const msaaTexture = gpuRenderTarget.msaaTextures[i2];
              msaaTexture?.resize(
                colorTexture.source.width,
                colorTexture.source.height,
                colorTexture.source._resolution
              );
            });
          }
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs
  var GpuRenderTargetSystem;
  var init_GpuRenderTargetSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs"() {
      init_Extensions();
      init_RenderTargetSystem();
      init_GpuRenderTargetAdaptor();
      GpuRenderTargetSystem = class extends RenderTargetSystem {
        constructor(renderer) {
          super(renderer);
          this.adaptor = new GpuRenderTargetAdaptor();
          this.adaptor.init(renderer, this);
        }
      };
      GpuRenderTargetSystem.extension = {
        type: [ExtensionType.WebGPUSystem],
        name: "renderTarget"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs
  var GpuShaderSystem;
  var init_GpuShaderSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs"() {
      init_Extensions();
      GpuShaderSystem = class {
        constructor() {
          this._gpuProgramData = /* @__PURE__ */ Object.create(null);
        }
        contextChange(gpu) {
          this._gpu = gpu;
          this.maxTextures = gpu.device.limits.maxSampledTexturesPerShaderStage;
        }
        getProgramData(program) {
          return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);
        }
        _createGPUProgramData(program) {
          const device = this._gpu.device;
          const bindGroups = program.gpuLayout.map((group4) => device.createBindGroupLayout({ entries: group4 }));
          const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };
          this._gpuProgramData[program._layoutKey] = {
            bindGroups,
            pipeline: device.createPipelineLayout(pipelineLayoutDesc)
          };
          return this._gpuProgramData[program._layoutKey];
        }
        destroy() {
          this._gpu = null;
          this._gpuProgramData = null;
        }
      };
      GpuShaderSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "shader"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs
  var GpuBlendModesToPixi;
  var init_GpuBlendModesToPixi = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs"() {
      "use strict";
      GpuBlendModesToPixi = {};
      GpuBlendModesToPixi.normal = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.add = {
        alpha: {
          srcFactor: "src-alpha",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.multiply = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "dst",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.screen = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one-minus-src",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.overlay = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one-minus-src",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.none = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "zero",
          dstFactor: "zero",
          operation: "add"
        }
      };
      GpuBlendModesToPixi["normal-npm"] = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "src-alpha",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        }
      };
      GpuBlendModesToPixi["add-npm"] = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "add"
        },
        color: {
          srcFactor: "src-alpha",
          dstFactor: "one",
          operation: "add"
        }
      };
      GpuBlendModesToPixi["screen-npm"] = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "src-alpha",
          dstFactor: "one-minus-src",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.erase = {
        alpha: {
          srcFactor: "zero",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "zero",
          dstFactor: "one-minus-src",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.min = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "min"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "min"
        }
      };
      GpuBlendModesToPixi.max = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "max"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "max"
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs
  var GpuStateSystem;
  var init_GpuStateSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs"() {
      init_Extensions();
      init_State();
      init_GpuBlendModesToPixi();
      GpuStateSystem = class {
        constructor() {
          this.defaultState = new State();
          this.defaultState.blend = true;
        }
        contextChange(gpu) {
          this.gpu = gpu;
        }
        /**
         * Gets the blend mode data for the current state
         * @param state - The state to get the blend mode from
         */
        getColorTargets(state4) {
          const blend = GpuBlendModesToPixi[state4.blendMode] || GpuBlendModesToPixi.normal;
          return [
            {
              format: "bgra8unorm",
              writeMask: 0,
              blend
            }
          ];
        }
        destroy() {
          this.gpu = null;
        }
      };
      GpuStateSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "state"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs
  var gpuUploadBufferImageResource;
  var init_gpuUploadBufferImageResource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs"() {
      "use strict";
      gpuUploadBufferImageResource = {
        type: "image",
        upload(source3, gpuTexture, gpu) {
          const resource = source3.resource;
          const total = (source3.pixelWidth | 0) * (source3.pixelHeight | 0);
          const bytesPerPixel = resource.byteLength / total;
          gpu.device.queue.writeTexture(
            { texture: gpuTexture },
            resource,
            {
              offset: 0,
              rowsPerImage: source3.pixelHeight,
              bytesPerRow: source3.pixelHeight * bytesPerPixel
            },
            {
              width: source3.pixelWidth,
              height: source3.pixelHeight,
              depthOrArrayLayers: 1
            }
          );
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs
  var blockDataMap, defaultBlockData, gpuUploadCompressedTextureResource;
  var init_gpuUploadCompressedTextureResource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs"() {
      "use strict";
      blockDataMap = {
        "bc1-rgba-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
        "bc2-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "bc3-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "bc7-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "etc1-rgb-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
        "etc2-rgba8unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "astc-4x4-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }
      };
      defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };
      gpuUploadCompressedTextureResource = {
        type: "compressed",
        upload(source3, gpuTexture, gpu) {
          let mipWidth = source3.pixelWidth;
          let mipHeight = source3.pixelHeight;
          const blockData = blockDataMap[source3.format] || defaultBlockData;
          for (let i2 = 0; i2 < source3.resource.length; i2++) {
            const levelBuffer = source3.resource[i2];
            const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;
            gpu.device.queue.writeTexture(
              {
                texture: gpuTexture,
                mipLevel: i2
              },
              levelBuffer,
              {
                offset: 0,
                bytesPerRow
              },
              {
                width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,
                height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,
                depthOrArrayLayers: 1
              }
            );
            mipWidth = Math.max(mipWidth >> 1, 1);
            mipHeight = Math.max(mipHeight >> 1, 1);
          }
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs
  var gpuUploadImageResource;
  var init_gpuUploadImageSource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs"() {
      "use strict";
      gpuUploadImageResource = {
        type: "image",
        upload(source3, gpuTexture, gpu) {
          const resource = source3.resource;
          if (!resource)
            return;
          const width8 = Math.min(gpuTexture.width, source3.resourceWidth || source3.pixelWidth);
          const height8 = Math.min(gpuTexture.height, source3.resourceHeight || source3.pixelHeight);
          const premultipliedAlpha = source3.alphaMode === "premultiply-alpha-on-upload";
          gpu.device.queue.copyExternalImageToTexture(
            { source: resource },
            { texture: gpuTexture, premultipliedAlpha },
            {
              width: width8,
              height: height8
            }
          );
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs
  var gpuUploadVideoResource;
  var init_gpuUploadVideoSource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs"() {
      init_gpuUploadImageSource();
      gpuUploadVideoResource = {
        type: "video",
        upload(source3, gpuTexture, gpu) {
          gpuUploadImageResource.upload(source3, gpuTexture, gpu);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs
  var GpuMipmapGenerator;
  var init_GpuMipmapGenerator = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs"() {
      "use strict";
      GpuMipmapGenerator = class {
        constructor(device) {
          this.device = device;
          this.sampler = device.createSampler({ minFilter: "linear" });
          this.pipelines = {};
        }
        _getMipmapPipeline(format) {
          let pipeline = this.pipelines[format];
          if (!pipeline) {
            if (!this.mipmapShaderModule) {
              this.mipmapShaderModule = this.device.createShaderModule({
                code: (
                  /* wgsl */
                  `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `
                )
              });
            }
            pipeline = this.device.createRenderPipeline({
              layout: "auto",
              vertex: {
                module: this.mipmapShaderModule,
                entryPoint: "vertexMain"
              },
              fragment: {
                module: this.mipmapShaderModule,
                entryPoint: "fragmentMain",
                targets: [{ format }]
              }
            });
            this.pipelines[format] = pipeline;
          }
          return pipeline;
        }
        /**
         * Generates mipmaps for the given GPUTexture from the data in level 0.
         * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.
         * @returns {module:External.GPUTexture} - The originally passed texture
         */
        generateMipmap(texture) {
          const pipeline = this._getMipmapPipeline(texture.format);
          if (texture.dimension === "3d" || texture.dimension === "1d") {
            throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
          }
          let mipTexture = texture;
          const arrayLayerCount = texture.depthOrArrayLayers || 1;
          const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;
          if (!renderToSource) {
            const mipTextureDescriptor = {
              size: {
                width: Math.ceil(texture.width / 2),
                height: Math.ceil(texture.height / 2),
                depthOrArrayLayers: arrayLayerCount
              },
              format: texture.format,
              usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
              mipLevelCount: texture.mipLevelCount - 1
            };
            mipTexture = this.device.createTexture(mipTextureDescriptor);
          }
          const commandEncoder = this.device.createCommandEncoder({});
          const bindGroupLayout = pipeline.getBindGroupLayout(0);
          for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {
            let srcView = texture.createView({
              baseMipLevel: 0,
              mipLevelCount: 1,
              dimension: "2d",
              baseArrayLayer: arrayLayer,
              arrayLayerCount: 1
            });
            let dstMipLevel = renderToSource ? 1 : 0;
            for (let i2 = 1; i2 < texture.mipLevelCount; ++i2) {
              const dstView = mipTexture.createView({
                baseMipLevel: dstMipLevel++,
                mipLevelCount: 1,
                dimension: "2d",
                baseArrayLayer: arrayLayer,
                arrayLayerCount: 1
              });
              const passEncoder = commandEncoder.beginRenderPass({
                colorAttachments: [{
                  view: dstView,
                  storeOp: "store",
                  loadOp: "clear",
                  clearValue: { r: 0, g: 0, b: 0, a: 0 }
                }]
              });
              const bindGroup = this.device.createBindGroup({
                layout: bindGroupLayout,
                entries: [{
                  binding: 0,
                  resource: this.sampler
                }, {
                  binding: 1,
                  resource: srcView
                }]
              });
              passEncoder.setPipeline(pipeline);
              passEncoder.setBindGroup(0, bindGroup);
              passEncoder.draw(3, 1, 0, 0);
              passEncoder.end();
              srcView = dstView;
            }
          }
          if (!renderToSource) {
            const mipLevelSize = {
              width: Math.ceil(texture.width / 2),
              height: Math.ceil(texture.height / 2),
              depthOrArrayLayers: arrayLayerCount
            };
            for (let i2 = 1; i2 < texture.mipLevelCount; ++i2) {
              commandEncoder.copyTextureToTexture({
                texture: mipTexture,
                mipLevel: i2 - 1
              }, {
                texture,
                mipLevel: i2
              }, mipLevelSize);
              mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);
              mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);
            }
          }
          this.device.queue.submit([commandEncoder.finish()]);
          if (!renderToSource) {
            mipTexture.destroy();
          }
          return texture;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs
  var GpuTextureSystem;
  var init_GpuTextureSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs"() {
      init_adapter();
      init_Extensions();
      init_UniformGroup();
      init_CanvasPool();
      init_BindGroup();
      init_gpuUploadBufferImageResource();
      init_gpuUploadCompressedTextureResource();
      init_gpuUploadImageSource();
      init_gpuUploadVideoSource();
      init_GpuMipmapGenerator();
      GpuTextureSystem = class {
        constructor(renderer) {
          this.managedTextures = [];
          this._gpuSources = /* @__PURE__ */ Object.create(null);
          this._gpuSamplers = /* @__PURE__ */ Object.create(null);
          this._bindGroupHash = /* @__PURE__ */ Object.create(null);
          this._textureViewHash = /* @__PURE__ */ Object.create(null);
          this._uploads = {
            image: gpuUploadImageResource,
            buffer: gpuUploadBufferImageResource,
            video: gpuUploadVideoResource,
            compressed: gpuUploadCompressedTextureResource
          };
          this._renderer = renderer;
          renderer.renderableGC.addManagedHash(this, "_gpuSources");
          renderer.renderableGC.addManagedHash(this, "_gpuSamplers");
          renderer.renderableGC.addManagedHash(this, "_bindGroupHash");
          renderer.renderableGC.addManagedHash(this, "_textureViewHash");
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
        initSource(source3) {
          if (source3.autoGenerateMipmaps) {
            const biggestDimension = Math.max(source3.pixelWidth, source3.pixelHeight);
            source3.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
          }
          let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
          if (source3.uploadMethodId !== "compressed") {
            usage |= GPUTextureUsage.RENDER_ATTACHMENT;
            usage |= GPUTextureUsage.COPY_SRC;
          }
          const blockData = blockDataMap[source3.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };
          const width8 = Math.ceil(source3.pixelWidth / blockData.blockWidth) * blockData.blockWidth;
          const height8 = Math.ceil(source3.pixelHeight / blockData.blockHeight) * blockData.blockHeight;
          const textureDescriptor = {
            label: source3.label,
            size: { width: width8, height: height8 },
            format: source3.format,
            sampleCount: source3.sampleCount,
            mipLevelCount: source3.mipLevelCount,
            dimension: source3.dimension,
            usage
          };
          const gpuTexture = this._gpu.device.createTexture(textureDescriptor);
          this._gpuSources[source3.uid] = gpuTexture;
          if (!this.managedTextures.includes(source3)) {
            source3.on("update", this.onSourceUpdate, this);
            source3.on("resize", this.onSourceResize, this);
            source3.on("destroy", this.onSourceDestroy, this);
            source3.on("unload", this.onSourceUnload, this);
            source3.on("updateMipmaps", this.onUpdateMipmaps, this);
            this.managedTextures.push(source3);
          }
          this.onSourceUpdate(source3);
          return gpuTexture;
        }
        onSourceUpdate(source3) {
          const gpuTexture = this.getGpuSource(source3);
          if (!gpuTexture)
            return;
          if (this._uploads[source3.uploadMethodId]) {
            this._uploads[source3.uploadMethodId].upload(source3, gpuTexture, this._gpu);
          }
          if (source3.autoGenerateMipmaps && source3.mipLevelCount > 1) {
            this.onUpdateMipmaps(source3);
          }
        }
        onSourceUnload(source3) {
          const gpuTexture = this._gpuSources[source3.uid];
          if (gpuTexture) {
            this._gpuSources[source3.uid] = null;
            gpuTexture.destroy();
          }
        }
        onUpdateMipmaps(source3) {
          if (!this._mipmapGenerator) {
            this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);
          }
          const gpuTexture = this.getGpuSource(source3);
          this._mipmapGenerator.generateMipmap(gpuTexture);
        }
        onSourceDestroy(source3) {
          source3.off("update", this.onSourceUpdate, this);
          source3.off("unload", this.onSourceUnload, this);
          source3.off("destroy", this.onSourceDestroy, this);
          source3.off("resize", this.onSourceResize, this);
          source3.off("updateMipmaps", this.onUpdateMipmaps, this);
          this.managedTextures.splice(this.managedTextures.indexOf(source3), 1);
          this.onSourceUnload(source3);
        }
        onSourceResize(source3) {
          const gpuTexture = this._gpuSources[source3.uid];
          if (!gpuTexture) {
            this.initSource(source3);
          } else if (gpuTexture.width !== source3.pixelWidth || gpuTexture.height !== source3.pixelHeight) {
            this._textureViewHash[source3.uid] = null;
            this._bindGroupHash[source3.uid] = null;
            this.onSourceUnload(source3);
            this.initSource(source3);
          }
        }
        _initSampler(sampler) {
          this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);
          return this._gpuSamplers[sampler._resourceId];
        }
        getGpuSampler(sampler) {
          return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);
        }
        getGpuSource(source3) {
          return this._gpuSources[source3.uid] || this.initSource(source3);
        }
        /**
         * this returns s bind group for a specific texture, the bind group contains
         * - the texture source
         * - the texture style
         * - the texture matrix
         * This is cached so the bind group should only be created once per texture
         * @param texture - the texture you want the bindgroup for
         * @returns the bind group for the texture
         */
        getTextureBindGroup(texture) {
          return this._bindGroupHash[texture.uid] ?? this._createTextureBindGroup(texture);
        }
        _createTextureBindGroup(texture) {
          const source3 = texture.source;
          this._bindGroupHash[texture.uid] = new BindGroup({
            0: source3,
            1: source3.style,
            2: new UniformGroup({
              uTextureMatrix: { type: "mat3x3<f32>", value: texture.textureMatrix.mapCoord }
            })
          });
          return this._bindGroupHash[texture.uid];
        }
        getTextureView(texture) {
          const source3 = texture.source;
          return this._textureViewHash[source3.uid] ?? this._createTextureView(source3);
        }
        _createTextureView(texture) {
          this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();
          return this._textureViewHash[texture.uid];
        }
        generateCanvas(texture) {
          const renderer = this._renderer;
          const commandEncoder = renderer.gpu.device.createCommandEncoder();
          const canvas2 = DOMAdapter.get().createCanvas();
          canvas2.width = texture.source.pixelWidth;
          canvas2.height = texture.source.pixelHeight;
          const context3 = canvas2.getContext("webgpu");
          context3.configure({
            device: renderer.gpu.device,
            // eslint-disable-next-line max-len
            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
            format: DOMAdapter.get().getNavigator().gpu.getPreferredCanvasFormat(),
            alphaMode: "premultiplied"
          });
          commandEncoder.copyTextureToTexture({
            texture: renderer.texture.getGpuSource(texture.source),
            origin: {
              x: 0,
              y: 0
            }
          }, {
            texture: context3.getCurrentTexture()
          }, {
            width: canvas2.width,
            height: canvas2.height
          });
          renderer.gpu.device.queue.submit([commandEncoder.finish()]);
          return canvas2;
        }
        getPixels(texture) {
          const webGPUCanvas = this.generateCanvas(texture);
          const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);
          const context3 = canvasAndContext.context;
          context3.drawImage(webGPUCanvas, 0, 0);
          const { width: width8, height: height8 } = webGPUCanvas;
          const imageData = context3.getImageData(0, 0, width8, height8);
          const pixels = new Uint8ClampedArray(imageData.data.buffer);
          CanvasPool.returnCanvasAndContext(canvasAndContext);
          return { pixels, width: width8, height: height8 };
        }
        destroy() {
          this.managedTextures.slice().forEach((source3) => this.onSourceDestroy(source3));
          this.managedTextures = null;
          for (const k2 of Object.keys(this._bindGroupHash)) {
            const key = Number(k2);
            const bindGroup = this._bindGroupHash[key];
            bindGroup?.destroy();
            this._bindGroupHash[key] = null;
          }
          this._gpu = null;
          this._mipmapGenerator = null;
          this._gpuSources = null;
          this._bindGroupHash = null;
          this._textureViewHash = null;
          this._gpuSamplers = null;
        }
      };
      GpuTextureSystem.extension = {
        type: [
          ExtensionType.WebGPUSystem
        ],
        name: "texture"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs
  var WebGPURenderer_exports = {};
  __export(WebGPURenderer_exports, {
    WebGPURenderer: () => WebGPURenderer
  });
  var DefaultWebGPUSystems, DefaultWebGPUPipes, DefaultWebGPUAdapters, systems, renderPipes, renderPipeAdaptors, WebGPURenderer;
  var init_WebGPURenderer = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs"() {
      init_Extensions();
      init_GpuGraphicsAdaptor();
      init_GpuMeshAdapter();
      init_GpuBatchAdaptor();
      init_AbstractRenderer();
      init_SharedSystems();
      init_types2();
      init_BindGroupSystem();
      init_GpuBufferSystem();
      init_GpuColorMaskSystem();
      init_GpuDeviceSystem();
      init_GpuEncoderSystem();
      init_GpuStencilSystem();
      init_GpuUboSystem();
      init_GpuUniformBatchPipe();
      init_PipelineSystem();
      init_GpuRenderTargetSystem();
      init_GpuShaderSystem();
      init_GpuStateSystem();
      init_GpuTextureSystem();
      DefaultWebGPUSystems = [
        ...SharedSystems,
        GpuUboSystem,
        GpuEncoderSystem,
        GpuDeviceSystem,
        GpuBufferSystem,
        GpuTextureSystem,
        GpuRenderTargetSystem,
        GpuShaderSystem,
        GpuStateSystem,
        PipelineSystem,
        GpuColorMaskSystem,
        GpuStencilSystem,
        BindGroupSystem
      ];
      DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];
      DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];
      systems = [];
      renderPipes = [];
      renderPipeAdaptors = [];
      extensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);
      extensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);
      extensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);
      extensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);
      WebGPURenderer = class extends AbstractRenderer {
        constructor() {
          const systemConfig = {
            name: "webgpu",
            type: RendererType.WEBGPU,
            systems,
            renderPipes,
            renderPipeAdaptors
          };
          super(systemConfig);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs
  var GlGraphicsAdaptor;
  var init_GlGraphicsAdaptor = __esm({
    "node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs"() {
      init_Extensions();
      init_Matrix();
      init_maxRecommendedTextures();
      init_compileHighShaderToProgram();
      init_colorBit();
      init_generateTextureBatchBit();
      init_localUniformBit();
      init_roundPixelsBit();
      init_getBatchSamplersUniformGroup();
      init_Shader();
      init_UniformGroup();
      GlGraphicsAdaptor = class {
        init() {
          const uniforms = new UniformGroup({
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
            uRound: { value: 0, type: "f32" }
          });
          const maxTextures2 = getMaxTexturesPerBatch();
          const glProgram3 = compileHighShaderGlProgram({
            name: "graphics",
            bits: [
              colorBitGl,
              generateTextureBatchBitGl(maxTextures2),
              localUniformBitGl,
              roundPixelsBitGl
            ]
          });
          this.shader = new Shader({
            glProgram: glProgram3,
            resources: {
              localUniforms: uniforms,
              batchSamplers: getBatchSamplersUniformGroup(maxTextures2)
            }
          });
        }
        execute(graphicsPipe, renderable) {
          const context3 = renderable.context;
          const shader = context3.customShader || this.shader;
          const renderer = graphicsPipe.renderer;
          const contextSystem = renderer.graphicsContext;
          const {
            batcher,
            instructions
          } = contextSystem.getContextRenderData(context3);
          shader.groups[0] = renderer.globalUniforms.bindGroup;
          renderer.state.set(graphicsPipe.state);
          renderer.shader.bind(shader);
          renderer.geometry.bind(batcher.geometry, shader.glProgram);
          const batches = instructions.instructions;
          for (let i2 = 0; i2 < instructions.instructionSize; i2++) {
            const batch = batches[i2];
            if (batch.size) {
              for (let j2 = 0; j2 < batch.textures.count; j2++) {
                renderer.texture.bind(batch.textures.textures[j2], j2);
              }
              renderer.geometry.draw("triangle-list", batch.size, batch.start);
            }
          }
        }
        destroy() {
          this.shader.destroy(true);
          this.shader = null;
        }
      };
      GlGraphicsAdaptor.extension = {
        type: [
          ExtensionType.WebGLPipesAdaptor
        ],
        name: "graphics"
      };
    }
  });

  // node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs
  var GlMeshAdaptor;
  var init_GlMeshAdaptor = __esm({
    "node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs"() {
      init_Extensions();
      init_Matrix();
      init_compileHighShaderToProgram();
      init_localUniformBit();
      init_roundPixelsBit();
      init_textureBit();
      init_Shader();
      init_Texture();
      init_warn();
      GlMeshAdaptor = class {
        init() {
          const glProgram3 = compileHighShaderGlProgram({
            name: "mesh",
            bits: [
              localUniformBitGl,
              textureBitGl,
              roundPixelsBitGl
            ]
          });
          this._shader = new Shader({
            glProgram: glProgram3,
            resources: {
              uTexture: Texture.EMPTY.source,
              textureUniforms: {
                uTextureMatrix: { type: "mat3x3<f32>", value: new Matrix() }
              }
            }
          });
        }
        execute(meshPipe, mesh) {
          const renderer = meshPipe.renderer;
          let shader = mesh._shader;
          if (!shader) {
            shader = this._shader;
            const texture = mesh.texture;
            const source3 = texture.source;
            shader.resources.uTexture = source3;
            shader.resources.uSampler = source3.style;
            shader.resources.textureUniforms.uniforms.uTextureMatrix = texture.textureMatrix.mapCoord;
          } else if (!shader.glProgram) {
            warn2("Mesh shader has no glProgram", mesh.shader);
            return;
          }
          shader.groups[100] = renderer.globalUniforms.bindGroup;
          shader.groups[101] = meshPipe.localUniformsBindGroup;
          renderer.encoder.draw({
            geometry: mesh._geometry,
            shader,
            state: mesh.state
          });
        }
        destroy() {
          this._shader.destroy(true);
          this._shader = null;
        }
      };
      GlMeshAdaptor.extension = {
        type: [
          ExtensionType.WebGLPipesAdaptor
        ],
        name: "mesh"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs
  var GlBatchAdaptor;
  var init_GlBatchAdaptor = __esm({
    "node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs"() {
      init_Extensions();
      init_State();
      GlBatchAdaptor = class {
        constructor() {
          this._didUpload = false;
          this._tempState = State.for2d();
        }
        init(batcherPipe) {
          batcherPipe.renderer.runners.contextChange.add(this);
        }
        contextChange() {
          this._didUpload = false;
        }
        start(batchPipe, geometry, shader) {
          const renderer = batchPipe.renderer;
          renderer.shader.bind(shader, this._didUpload);
          renderer.shader.updateUniformGroup(renderer.globalUniforms.uniformGroup);
          renderer.geometry.bind(geometry, shader.glProgram);
        }
        execute(batchPipe, batch) {
          const renderer = batchPipe.renderer;
          this._didUpload = true;
          this._tempState.blendMode = batch.blendMode;
          renderer.state.set(this._tempState);
          const textures = batch.textures.textures;
          for (let i2 = 0; i2 < batch.textures.count; i2++) {
            renderer.texture.bind(textures[i2], i2);
          }
          renderer.geometry.draw("triangle-list", batch.size, batch.start);
        }
      };
      GlBatchAdaptor.extension = {
        type: [
          ExtensionType.WebGLPipesAdaptor
        ],
        name: "batch"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs
  var BUFFER_TYPE;
  var init_const9 = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs"() {
      "use strict";
      BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {
        BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
        BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
        BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
        return BUFFER_TYPE2;
      })(BUFFER_TYPE || {});
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs
  var GlBuffer;
  var init_GlBuffer = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs"() {
      "use strict";
      GlBuffer = class {
        constructor(buffer, type) {
          this.buffer = buffer || null;
          this.updateID = -1;
          this.byteLength = -1;
          this.type = type;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs
  var GlBufferSystem;
  var init_GlBufferSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs"() {
      init_Extensions();
      init_const4();
      init_const9();
      init_GlBuffer();
      GlBufferSystem = class {
        /**
         * @param {Renderer} renderer - The renderer this System works for.
         */
        constructor(renderer) {
          this._gpuBuffers = /* @__PURE__ */ Object.create(null);
          this._boundBufferBases = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
          this._renderer.renderableGC.addManagedHash(this, "_gpuBuffers");
        }
        /**
         * @ignore
         */
        destroy() {
          this._renderer = null;
          this._gl = null;
          this._gpuBuffers = null;
          this._boundBufferBases = null;
        }
        /** Sets up the renderer context and necessary buffers. */
        contextChange() {
          this._gpuBuffers = /* @__PURE__ */ Object.create(null);
          this._gl = this._renderer.gl;
        }
        getGlBuffer(buffer) {
          return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);
        }
        /**
         * This binds specified buffer. On first run, it will create the webGL buffers for the context too
         * @param buffer - the buffer to bind to the renderer
         */
        bind(buffer) {
          const { _gl: gl } = this;
          const glBuffer = this.getGlBuffer(buffer);
          gl.bindBuffer(glBuffer.type, glBuffer.buffer);
        }
        /**
         * Binds an uniform buffer to at the given index.
         *
         * A cache is used so a buffer will not be bound again if already bound.
         * @param buffer - the buffer to bind
         * @param index - the base index to bind it to.
         */
        bindBufferBase(buffer, index6) {
          const { _gl: gl } = this;
          if (this._boundBufferBases[index6] !== buffer) {
            const glBuffer = this.getGlBuffer(buffer);
            this._boundBufferBases[index6] = buffer;
            gl.bindBufferBase(gl.UNIFORM_BUFFER, index6, glBuffer.buffer);
          }
        }
        /**
         * Binds a buffer whilst also binding its range.
         * This will make the buffer start from the offset supplied rather than 0 when it is read.
         * @param buffer - the buffer to bind
         * @param index - the base index to bind at, defaults to 0
         * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc
         */
        bindBufferRange(buffer, index6, offset) {
          const { _gl: gl } = this;
          offset = offset || 0;
          const glBuffer = this.getGlBuffer(buffer);
          gl.bindBufferRange(gl.UNIFORM_BUFFER, index6 || 0, glBuffer.buffer, offset * 256, 256);
        }
        /**
         * Will ensure the data in the buffer is uploaded to the GPU.
         * @param {Buffer} buffer - the buffer to update
         */
        updateBuffer(buffer) {
          const { _gl: gl } = this;
          const glBuffer = this.getGlBuffer(buffer);
          if (buffer._updateID === glBuffer.updateID) {
            return glBuffer;
          }
          glBuffer.updateID = buffer._updateID;
          gl.bindBuffer(glBuffer.type, glBuffer.buffer);
          const data = buffer.data;
          if (glBuffer.byteLength >= buffer.data.byteLength) {
            gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);
          } else {
            const drawType = buffer.descriptor.usage & BufferUsage.STATIC ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
            glBuffer.byteLength = data.byteLength;
            gl.bufferData(glBuffer.type, data, drawType);
          }
          return glBuffer;
        }
        /** dispose all WebGL resources of all managed buffers */
        destroyAll() {
          const gl = this._gl;
          for (const id5 in this._gpuBuffers) {
            gl.deleteBuffer(this._gpuBuffers[id5].buffer);
          }
          this._gpuBuffers = /* @__PURE__ */ Object.create(null);
        }
        /**
         * Disposes buffer
         * @param {Buffer} buffer - buffer with data
         * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray
         */
        onBufferDestroy(buffer, contextLost) {
          const glBuffer = this._gpuBuffers[buffer.uid];
          const gl = this._gl;
          if (!contextLost) {
            gl.deleteBuffer(glBuffer.buffer);
          }
          this._gpuBuffers[buffer.uid] = null;
        }
        /**
         * creates and attaches a GLBuffer object tied to the current context.
         * @param buffer
         * @protected
         */
        createGLBuffer(buffer) {
          const { _gl: gl } = this;
          let type = BUFFER_TYPE.ARRAY_BUFFER;
          if (buffer.descriptor.usage & BufferUsage.INDEX) {
            type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
          } else if (buffer.descriptor.usage & BufferUsage.UNIFORM) {
            type = BUFFER_TYPE.UNIFORM_BUFFER;
          }
          const glBuffer = new GlBuffer(gl.createBuffer(), type);
          this._gpuBuffers[buffer.uid] = glBuffer;
          buffer.on("destroy", this.onBufferDestroy, this);
          return glBuffer;
        }
      };
      GlBufferSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "buffer"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs
  var _GlContextSystem, GlContextSystem;
  var init_GlContextSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs"() {
      init_adapter();
      init_Extensions();
      init_warn();
      _GlContextSystem = class _GlContextSystem2 {
        /** @param renderer - The renderer this System works for. */
        constructor(renderer) {
          this.supports = {
            /** Support for 32-bit indices buffer. */
            uint32Indices: true,
            /** Support for UniformBufferObjects */
            uniformBufferObject: true,
            /** Support for VertexArrayObjects */
            vertexArrayObject: true,
            /** Support for SRGB texture format */
            srgbTextures: true,
            /** Support for wrapping modes if a texture is non-power of two */
            nonPowOf2wrapping: true,
            /** Support for MSAA (antialiasing of dynamic textures) */
            msaa: true,
            /** Support for mipmaps if a texture is non-power of two */
            nonPowOf2mipmaps: true
          };
          this._renderer = renderer;
          this.extensions = /* @__PURE__ */ Object.create(null);
          this.handleContextLost = this.handleContextLost.bind(this);
          this.handleContextRestored = this.handleContextRestored.bind(this);
        }
        /**
         * `true` if the context is lost
         * @readonly
         */
        get isLost() {
          return !this.gl || this.gl.isContextLost();
        }
        /**
         * Handles the context change event.
         * @param {WebGLRenderingContext} gl - New WebGL context.
         */
        contextChange(gl) {
          this.gl = gl;
          this._renderer.gl = gl;
        }
        init(options2) {
          options2 = { ..._GlContextSystem2.defaultOptions, ...options2 };
          let multiView = this.multiView = options2.multiView;
          if (options2.context && multiView) {
            warn2("Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together.");
            multiView = false;
          }
          if (multiView) {
            this.canvas = DOMAdapter.get().createCanvas(this._renderer.canvas.width, this._renderer.canvas.height);
          } else {
            this.canvas = this._renderer.view.canvas;
          }
          if (options2.context) {
            this.initFromContext(options2.context);
          } else {
            const alpha = this._renderer.background.alpha < 1;
            const premultipliedAlpha = options2.premultipliedAlpha ?? true;
            const antialias = options2.antialias && !this._renderer.backBuffer.useBackBuffer;
            this.createContext(options2.preferWebGLVersion, {
              alpha,
              premultipliedAlpha,
              antialias,
              stencil: true,
              preserveDrawingBuffer: options2.preserveDrawingBuffer,
              powerPreference: options2.powerPreference ?? "default"
            });
          }
        }
        ensureCanvasSize(targetCanvas) {
          if (!this.multiView) {
            if (targetCanvas !== this.canvas) {
              warn2("multiView is disabled, but targetCanvas is not the main canvas");
            }
            return;
          }
          const { canvas: canvas2 } = this;
          if (canvas2.width < targetCanvas.width || canvas2.height < targetCanvas.height) {
            canvas2.width = Math.max(targetCanvas.width, targetCanvas.width);
            canvas2.height = Math.max(targetCanvas.height, targetCanvas.height);
          }
        }
        /**
         * Initializes the context.
         * @protected
         * @param {WebGLRenderingContext} gl - WebGL context
         */
        initFromContext(gl) {
          this.gl = gl;
          this.webGLVersion = gl instanceof DOMAdapter.get().getWebGLRenderingContext() ? 1 : 2;
          this.getExtensions();
          this.validateContext(gl);
          this._renderer.runners.contextChange.emit(gl);
          const element = this._renderer.view.canvas;
          element.addEventListener("webglcontextlost", this.handleContextLost, false);
          element.addEventListener("webglcontextrestored", this.handleContextRestored, false);
        }
        /**
         * Initialize from context options
         * @protected
         * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
         * @param preferWebGLVersion
         * @param {object} options - context attributes
         */
        createContext(preferWebGLVersion, options2) {
          let gl;
          const canvas2 = this.canvas;
          if (preferWebGLVersion === 2) {
            gl = canvas2.getContext("webgl2", options2);
          }
          if (!gl) {
            gl = canvas2.getContext("webgl", options2);
            if (!gl) {
              throw new Error("This browser does not support WebGL. Try using the canvas renderer");
            }
          }
          this.gl = gl;
          this.initFromContext(this.gl);
        }
        /** Auto-populate the {@link GlContextSystem.extensions extensions}. */
        getExtensions() {
          const { gl } = this;
          const common = {
            anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
            floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
            s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
            s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
            // eslint-disable-line camelcase
            etc: gl.getExtension("WEBGL_compressed_texture_etc"),
            etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
            pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            atc: gl.getExtension("WEBGL_compressed_texture_atc"),
            astc: gl.getExtension("WEBGL_compressed_texture_astc"),
            bptc: gl.getExtension("EXT_texture_compression_bptc"),
            rgtc: gl.getExtension("EXT_texture_compression_rgtc"),
            loseContext: gl.getExtension("WEBGL_lose_context")
          };
          if (this.webGLVersion === 1) {
            this.extensions = {
              ...common,
              drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
              depthTexture: gl.getExtension("WEBGL_depth_texture"),
              vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
              uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
              // Floats and half-floats
              floatTexture: gl.getExtension("OES_texture_float"),
              floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
              textureHalfFloat: gl.getExtension("OES_texture_half_float"),
              textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear"),
              vertexAttribDivisorANGLE: gl.getExtension("ANGLE_instanced_arrays"),
              srgb: gl.getExtension("EXT_sRGB")
            };
          } else {
            this.extensions = {
              ...common,
              colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
            };
            const provokeExt = gl.getExtension("WEBGL_provoking_vertex");
            if (provokeExt) {
              provokeExt.provokingVertexWEBGL(provokeExt.FIRST_VERTEX_CONVENTION_WEBGL);
            }
          }
        }
        /**
         * Handles a lost webgl context
         * @param {WebGLContextEvent} event - The context lost event.
         */
        handleContextLost(event) {
          event.preventDefault();
          if (this._contextLossForced) {
            this._contextLossForced = false;
            setTimeout(() => {
              if (this.gl.isContextLost()) {
                this.extensions.loseContext?.restoreContext();
              }
            }, 0);
          }
        }
        /** Handles a restored webgl context. */
        handleContextRestored() {
          this._renderer.runners.contextChange.emit(this.gl);
        }
        destroy() {
          const element = this._renderer.view.canvas;
          this._renderer = null;
          element.removeEventListener("webglcontextlost", this.handleContextLost);
          element.removeEventListener("webglcontextrestored", this.handleContextRestored);
          this.gl.useProgram(null);
          this.extensions.loseContext?.loseContext();
        }
        /**
         * this function can be called to force a webGL context loss
         * this will release all resources on the GPU.
         * Useful if you need to put Pixi to sleep, and save some GPU memory
         *
         * As soon as render is called - all resources will be created again.
         */
        forceContextLoss() {
          this.extensions.loseContext?.loseContext();
          this._contextLossForced = true;
        }
        /**
         * Validate context.
         * @param {WebGLRenderingContext} gl - Render context.
         */
        validateContext(gl) {
          const attributes = gl.getContextAttributes();
          if (attributes && !attributes.stencil) {
            warn2("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
          }
          const supports = this.supports;
          const isWebGl2 = this.webGLVersion === 2;
          const extensions2 = this.extensions;
          supports.uint32Indices = isWebGl2 || !!extensions2.uint32ElementIndex;
          supports.uniformBufferObject = isWebGl2;
          supports.vertexArrayObject = isWebGl2 || !!extensions2.vertexArrayObject;
          supports.srgbTextures = isWebGl2 || !!extensions2.srgb;
          supports.nonPowOf2wrapping = isWebGl2;
          supports.nonPowOf2mipmaps = isWebGl2;
          supports.msaa = isWebGl2;
          if (!supports.uint32Indices) {
            warn2("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly");
          }
        }
      };
      _GlContextSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "context"
      };
      _GlContextSystem.defaultOptions = {
        /**
         * {@link WebGLOptions.context}
         * @default null
         */
        context: null,
        /**
         * {@link WebGLOptions.premultipliedAlpha}
         * @default true
         */
        premultipliedAlpha: true,
        /**
         * {@link WebGLOptions.preserveDrawingBuffer}
         * @default false
         */
        preserveDrawingBuffer: false,
        /**
         * {@link WebGLOptions.powerPreference}
         * @default default
         */
        powerPreference: void 0,
        /**
         * {@link WebGLOptions.webGLVersion}
         * @default 2
         */
        preferWebGLVersion: 2,
        /**
         * {@link WebGLOptions.multiView}
         * @default false
         */
        multiView: false
      };
      GlContextSystem = _GlContextSystem;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs
  var GL_FORMATS, GL_TARGETS, GL_TYPES;
  var init_const10 = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs"() {
      "use strict";
      GL_FORMATS = /* @__PURE__ */ ((GL_FORMATS2) => {
        GL_FORMATS2[GL_FORMATS2["RGBA"] = 6408] = "RGBA";
        GL_FORMATS2[GL_FORMATS2["RGB"] = 6407] = "RGB";
        GL_FORMATS2[GL_FORMATS2["RG"] = 33319] = "RG";
        GL_FORMATS2[GL_FORMATS2["RED"] = 6403] = "RED";
        GL_FORMATS2[GL_FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
        GL_FORMATS2[GL_FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
        GL_FORMATS2[GL_FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
        GL_FORMATS2[GL_FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
        GL_FORMATS2[GL_FORMATS2["ALPHA"] = 6406] = "ALPHA";
        GL_FORMATS2[GL_FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
        GL_FORMATS2[GL_FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
        GL_FORMATS2[GL_FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
        GL_FORMATS2[GL_FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
        return GL_FORMATS2;
      })(GL_FORMATS || {});
      GL_TARGETS = /* @__PURE__ */ ((GL_TARGETS2) => {
        GL_TARGETS2[GL_TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
        return GL_TARGETS2;
      })(GL_TARGETS || {});
      GL_TYPES = /* @__PURE__ */ ((GL_TYPES2) => {
        GL_TYPES2[GL_TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
        GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
        GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
        GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
        GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
        GL_TYPES2[GL_TYPES2["BYTE"] = 5120] = "BYTE";
        GL_TYPES2[GL_TYPES2["SHORT"] = 5122] = "SHORT";
        GL_TYPES2[GL_TYPES2["INT"] = 5124] = "INT";
        GL_TYPES2[GL_TYPES2["FLOAT"] = 5126] = "FLOAT";
        GL_TYPES2[GL_TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
        GL_TYPES2[GL_TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
        return GL_TYPES2;
      })(GL_TYPES || {});
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs
  function getGlTypeFromFormat(format) {
    return infoMap[format] ?? infoMap.float32;
  }
  var infoMap;
  var init_getGlTypeFromFormat = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs"() {
      init_const10();
      infoMap = {
        uint8x2: GL_TYPES.UNSIGNED_BYTE,
        uint8x4: GL_TYPES.UNSIGNED_BYTE,
        sint8x2: GL_TYPES.BYTE,
        sint8x4: GL_TYPES.BYTE,
        unorm8x2: GL_TYPES.UNSIGNED_BYTE,
        unorm8x4: GL_TYPES.UNSIGNED_BYTE,
        snorm8x2: GL_TYPES.BYTE,
        snorm8x4: GL_TYPES.BYTE,
        uint16x2: GL_TYPES.UNSIGNED_SHORT,
        uint16x4: GL_TYPES.UNSIGNED_SHORT,
        sint16x2: GL_TYPES.SHORT,
        sint16x4: GL_TYPES.SHORT,
        unorm16x2: GL_TYPES.UNSIGNED_SHORT,
        unorm16x4: GL_TYPES.UNSIGNED_SHORT,
        snorm16x2: GL_TYPES.SHORT,
        snorm16x4: GL_TYPES.SHORT,
        float16x2: GL_TYPES.HALF_FLOAT,
        float16x4: GL_TYPES.HALF_FLOAT,
        float32: GL_TYPES.FLOAT,
        float32x2: GL_TYPES.FLOAT,
        float32x3: GL_TYPES.FLOAT,
        float32x4: GL_TYPES.FLOAT,
        uint32: GL_TYPES.UNSIGNED_INT,
        uint32x2: GL_TYPES.UNSIGNED_INT,
        uint32x3: GL_TYPES.UNSIGNED_INT,
        uint32x4: GL_TYPES.UNSIGNED_INT,
        sint32: GL_TYPES.INT,
        sint32x2: GL_TYPES.INT,
        sint32x3: GL_TYPES.INT,
        sint32x4: GL_TYPES.INT
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs
  var topologyToGlMap, GlGeometrySystem;
  var init_GlGeometrySystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs"() {
      init_Extensions();
      init_getAttributeInfoFromFormat();
      init_ensureAttributes();
      init_getGlTypeFromFormat();
      topologyToGlMap = {
        "point-list": 0,
        "line-list": 1,
        "line-strip": 3,
        "triangle-list": 4,
        "triangle-strip": 5
      };
      GlGeometrySystem = class {
        /** @param renderer - The renderer this System works for. */
        constructor(renderer) {
          this._geometryVaoHash = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
          this._activeGeometry = null;
          this._activeVao = null;
          this.hasVao = true;
          this.hasInstance = true;
          this._renderer.renderableGC.addManagedHash(this, "_geometryVaoHash");
        }
        /** Sets up the renderer context and necessary buffers. */
        contextChange() {
          const gl = this.gl = this._renderer.gl;
          if (!this._renderer.context.supports.vertexArrayObject) {
            throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");
          }
          const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;
          if (nativeVaoExtension) {
            gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();
            gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);
            gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);
          }
          const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;
          if (nativeInstancedExtension) {
            gl.drawArraysInstanced = (a2, b2, c2, d2) => {
              nativeInstancedExtension.drawArraysInstancedANGLE(a2, b2, c2, d2);
            };
            gl.drawElementsInstanced = (a2, b2, c2, d2, e2) => {
              nativeInstancedExtension.drawElementsInstancedANGLE(a2, b2, c2, d2, e2);
            };
            gl.vertexAttribDivisor = (a2, b2) => nativeInstancedExtension.vertexAttribDivisorANGLE(a2, b2);
          }
          this._activeGeometry = null;
          this._activeVao = null;
          this._geometryVaoHash = /* @__PURE__ */ Object.create(null);
        }
        /**
         * Binds geometry so that is can be drawn. Creating a Vao if required
         * @param geometry - Instance of geometry to bind.
         * @param program - Instance of program to use vao for.
         */
        bind(geometry, program) {
          const gl = this.gl;
          this._activeGeometry = geometry;
          const vao = this.getVao(geometry, program);
          if (this._activeVao !== vao) {
            this._activeVao = vao;
            gl.bindVertexArray(vao);
          }
          this.updateBuffers();
        }
        /** Reset and unbind any active VAO and geometry. */
        reset() {
          this.unbind();
        }
        /** Update buffers of the currently bound geometry. */
        updateBuffers() {
          const geometry = this._activeGeometry;
          const bufferSystem = this._renderer.buffer;
          for (let i2 = 0; i2 < geometry.buffers.length; i2++) {
            const buffer = geometry.buffers[i2];
            bufferSystem.updateBuffer(buffer);
          }
        }
        /**
         * Check compatibility between a geometry and a program
         * @param geometry - Geometry instance.
         * @param program - Program instance.
         */
        checkCompatibility(geometry, program) {
          const geometryAttributes = geometry.attributes;
          const shaderAttributes = program._attributeData;
          for (const j2 in shaderAttributes) {
            if (!geometryAttributes[j2]) {
              throw new Error(`shader and geometry incompatible, geometry missing the "${j2}" attribute`);
            }
          }
        }
        /**
         * Takes a geometry and program and generates a unique signature for them.
         * @param geometry - To get signature from.
         * @param program - To test geometry against.
         * @returns - Unique signature of the geometry and program
         */
        getSignature(geometry, program) {
          const attribs = geometry.attributes;
          const shaderAttributes = program._attributeData;
          const strings = ["g", geometry.uid];
          for (const i2 in attribs) {
            if (shaderAttributes[i2]) {
              strings.push(i2, shaderAttributes[i2].location);
            }
          }
          return strings.join("-");
        }
        getVao(geometry, program) {
          return this._geometryVaoHash[geometry.uid]?.[program._key] || this.initGeometryVao(geometry, program);
        }
        /**
         * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
         * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the
         * attribute locations.
         * @param geometry - Instance of geometry to to generate Vao for.
         * @param program
         * @param _incRefCount - Increment refCount of all geometry buffers.
         */
        initGeometryVao(geometry, program, _incRefCount = true) {
          const gl = this._renderer.gl;
          const bufferSystem = this._renderer.buffer;
          this._renderer.shader._getProgramData(program);
          this.checkCompatibility(geometry, program);
          const signature = this.getSignature(geometry, program);
          if (!this._geometryVaoHash[geometry.uid]) {
            this._geometryVaoHash[geometry.uid] = /* @__PURE__ */ Object.create(null);
            geometry.on("destroy", this.onGeometryDestroy, this);
          }
          const vaoObjectHash = this._geometryVaoHash[geometry.uid];
          let vao = vaoObjectHash[signature];
          if (vao) {
            vaoObjectHash[program._key] = vao;
            return vao;
          }
          ensureAttributes(geometry, program._attributeData);
          const buffers = geometry.buffers;
          vao = gl.createVertexArray();
          gl.bindVertexArray(vao);
          for (let i2 = 0; i2 < buffers.length; i2++) {
            const buffer = buffers[i2];
            bufferSystem.bind(buffer);
          }
          this.activateVao(geometry, program);
          vaoObjectHash[program._key] = vao;
          vaoObjectHash[signature] = vao;
          gl.bindVertexArray(null);
          return vao;
        }
        /**
         * Disposes geometry.
         * @param geometry - Geometry with buffers. Only VAO will be disposed
         * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray
         */
        onGeometryDestroy(geometry, contextLost) {
          const vaoObjectHash = this._geometryVaoHash[geometry.uid];
          const gl = this.gl;
          if (vaoObjectHash) {
            if (contextLost) {
              for (const i2 in vaoObjectHash) {
                if (this._activeVao !== vaoObjectHash[i2]) {
                  this.unbind();
                }
                gl.deleteVertexArray(vaoObjectHash[i2]);
              }
            }
            this._geometryVaoHash[geometry.uid] = null;
          }
        }
        /**
         * Dispose all WebGL resources of all managed geometries.
         * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls
         */
        destroyAll(contextLost = false) {
          const gl = this.gl;
          for (const i2 in this._geometryVaoHash) {
            if (contextLost) {
              for (const j2 in this._geometryVaoHash[i2]) {
                const vaoObjectHash = this._geometryVaoHash[i2];
                if (this._activeVao !== vaoObjectHash) {
                  this.unbind();
                }
                gl.deleteVertexArray(vaoObjectHash[j2]);
              }
            }
            this._geometryVaoHash[i2] = null;
          }
        }
        /**
         * Activate vertex array object.
         * @param geometry - Geometry instance.
         * @param program - Shader program instance.
         */
        activateVao(geometry, program) {
          const gl = this._renderer.gl;
          const bufferSystem = this._renderer.buffer;
          const attributes = geometry.attributes;
          if (geometry.indexBuffer) {
            bufferSystem.bind(geometry.indexBuffer);
          }
          let lastBuffer = null;
          for (const j2 in attributes) {
            const attribute = attributes[j2];
            const buffer = attribute.buffer;
            const glBuffer = bufferSystem.getGlBuffer(buffer);
            const programAttrib = program._attributeData[j2];
            if (programAttrib) {
              if (lastBuffer !== glBuffer) {
                bufferSystem.bind(buffer);
                lastBuffer = glBuffer;
              }
              const location2 = programAttrib.location;
              gl.enableVertexAttribArray(location2);
              const attributeInfo = getAttributeInfoFromFormat(attribute.format);
              const type = getGlTypeFromFormat(attribute.format);
              if (programAttrib.format?.substring(1, 4) === "int") {
                gl.vertexAttribIPointer(
                  location2,
                  attributeInfo.size,
                  type,
                  attribute.stride,
                  attribute.offset
                );
              } else {
                gl.vertexAttribPointer(
                  location2,
                  attributeInfo.size,
                  type,
                  attributeInfo.normalised,
                  attribute.stride,
                  attribute.offset
                );
              }
              if (attribute.instance) {
                if (this.hasInstance) {
                  const divisor = attribute.divisor ?? 1;
                  gl.vertexAttribDivisor(location2, divisor);
                } else {
                  throw new Error("geometry error, GPU Instancing is not supported on this device");
                }
              }
            }
          }
        }
        /**
         * Draws the currently bound geometry.
         * @param topology - The type primitive to render.
         * @param size - The number of elements to be rendered. If not specified, all vertices after the
         *  starting vertex will be drawn.
         * @param start - The starting vertex in the geometry to start drawing from. If not specified,
         *  drawing will start from the first vertex.
         * @param instanceCount - The number of instances of the set of elements to execute. If not specified,
         *  all instances will be drawn.
         */
        draw(topology, size5, start3, instanceCount) {
          const { gl } = this._renderer;
          const geometry = this._activeGeometry;
          const glTopology = topologyToGlMap[geometry.topology || topology];
          instanceCount || (instanceCount = geometry.instanceCount);
          if (geometry.indexBuffer) {
            const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
            const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
            if (instanceCount > 1) {
              gl.drawElementsInstanced(glTopology, size5 || geometry.indexBuffer.data.length, glType, (start3 || 0) * byteSize, instanceCount);
            } else {
              gl.drawElements(glTopology, size5 || geometry.indexBuffer.data.length, glType, (start3 || 0) * byteSize);
            }
          } else if (instanceCount > 1) {
            gl.drawArraysInstanced(glTopology, start3 || 0, size5 || geometry.getSize(), instanceCount);
          } else {
            gl.drawArrays(glTopology, start3 || 0, size5 || geometry.getSize());
          }
          return this;
        }
        /** Unbind/reset everything. */
        unbind() {
          this.gl.bindVertexArray(null);
          this._activeVao = null;
          this._activeGeometry = null;
        }
        destroy() {
          this._renderer = null;
          this.gl = null;
          this._activeVao = null;
          this._activeGeometry = null;
        }
      };
      GlGeometrySystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "geometry"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs
  var bigTriangleGeometry, _GlBackBufferSystem, GlBackBufferSystem;
  var init_GlBackBufferSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs"() {
      init_Extensions();
      init_warn();
      init_Geometry();
      init_Shader();
      init_State();
      init_TextureSource();
      init_Texture();
      init_GlProgram();
      bigTriangleGeometry = new Geometry({
        attributes: {
          aPosition: [
            -1,
            -1,
            // Bottom left corner
            3,
            -1,
            // Bottom right corner, extending beyond right edge
            -1,
            3
            // Top left corner, extending beyond top edge
          ]
        }
      });
      _GlBackBufferSystem = class _GlBackBufferSystem2 {
        constructor(renderer) {
          this.useBackBuffer = false;
          this._useBackBufferThisRender = false;
          this._renderer = renderer;
        }
        init(options2 = {}) {
          const { useBackBuffer, antialias } = { ..._GlBackBufferSystem2.defaultOptions, ...options2 };
          this.useBackBuffer = useBackBuffer;
          this._antialias = antialias;
          if (!this._renderer.context.supports.msaa) {
            warn2("antialiasing, is not supported on when using the back buffer");
            this._antialias = false;
          }
          this._state = State.for2d();
          const bigTriangleProgram = new GlProgram({
            vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
            fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
            name: "big-triangle"
          });
          this._bigTriangleShader = new Shader({
            glProgram: bigTriangleProgram,
            resources: {
              uTexture: Texture.WHITE.source
            }
          });
        }
        /**
         * This is called before the RenderTargetSystem is started. This is where
         * we replace the target with the back buffer if required.
         * @param options - The options for this render.
         */
        renderStart(options2) {
          const renderTarget = this._renderer.renderTarget.getRenderTarget(options2.target);
          this._useBackBufferThisRender = this.useBackBuffer && !!renderTarget.isRoot;
          if (this._useBackBufferThisRender) {
            const renderTarget2 = this._renderer.renderTarget.getRenderTarget(options2.target);
            this._targetTexture = renderTarget2.colorTexture;
            options2.target = this._getBackBufferTexture(renderTarget2.colorTexture);
          }
        }
        renderEnd() {
          this._presentBackBuffer();
        }
        _presentBackBuffer() {
          const renderer = this._renderer;
          renderer.renderTarget.finishRenderPass();
          if (!this._useBackBufferThisRender)
            return;
          renderer.renderTarget.bind(this._targetTexture, false);
          this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source;
          renderer.encoder.draw({
            geometry: bigTriangleGeometry,
            shader: this._bigTriangleShader,
            state: this._state
          });
        }
        _getBackBufferTexture(targetSourceTexture) {
          this._backBufferTexture = this._backBufferTexture || new Texture({
            source: new TextureSource({
              width: targetSourceTexture.width,
              height: targetSourceTexture.height,
              resolution: targetSourceTexture._resolution,
              antialias: this._antialias
            })
          });
          this._backBufferTexture.source.resize(
            targetSourceTexture.width,
            targetSourceTexture.height,
            targetSourceTexture._resolution
          );
          return this._backBufferTexture;
        }
        /** destroys the back buffer */
        destroy() {
          if (this._backBufferTexture) {
            this._backBufferTexture.destroy();
            this._backBufferTexture = null;
          }
        }
      };
      _GlBackBufferSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "backBuffer",
        priority: 1
      };
      _GlBackBufferSystem.defaultOptions = {
        /** if true will use the back buffer where required */
        useBackBuffer: false
      };
      GlBackBufferSystem = _GlBackBufferSystem;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs
  var GlColorMaskSystem;
  var init_GlColorMaskSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs"() {
      init_Extensions();
      GlColorMaskSystem = class {
        constructor(renderer) {
          this._colorMaskCache = 15;
          this._renderer = renderer;
        }
        setMask(colorMask) {
          if (this._colorMaskCache === colorMask)
            return;
          this._colorMaskCache = colorMask;
          this._renderer.gl.colorMask(
            !!(colorMask & 8),
            !!(colorMask & 4),
            !!(colorMask & 2),
            !!(colorMask & 1)
          );
        }
      };
      GlColorMaskSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "colorMask"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs
  var GlEncoderSystem;
  var init_GlEncoderSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs"() {
      init_Extensions();
      GlEncoderSystem = class {
        constructor(renderer) {
          this.commandFinished = Promise.resolve();
          this._renderer = renderer;
        }
        setGeometry(geometry, shader) {
          this._renderer.geometry.bind(geometry, shader.glProgram);
        }
        finishRenderPass() {
        }
        draw(options2) {
          const renderer = this._renderer;
          const { geometry, shader, state: state4, skipSync, topology: type, size: size5, start: start3, instanceCount } = options2;
          renderer.shader.bind(shader, skipSync);
          renderer.geometry.bind(geometry, renderer.shader._activeProgram);
          if (state4) {
            renderer.state.set(state4);
          }
          renderer.geometry.draw(type, size5, start3, instanceCount ?? geometry.instanceCount);
        }
        destroy() {
          this._renderer = null;
        }
      };
      GlEncoderSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "encoder"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs
  var GlStencilSystem;
  var init_GlStencilSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs"() {
      init_Extensions();
      init_GpuStencilModesToPixi();
      init_const3();
      GlStencilSystem = class {
        constructor(renderer) {
          this._stencilCache = {
            enabled: false,
            stencilReference: 0,
            stencilMode: STENCIL_MODES.NONE
          };
          this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
          renderer.renderTarget.onRenderTargetChange.add(this);
        }
        contextChange(gl) {
          this._gl = gl;
          this._comparisonFuncMapping = {
            always: gl.ALWAYS,
            never: gl.NEVER,
            equal: gl.EQUAL,
            "not-equal": gl.NOTEQUAL,
            less: gl.LESS,
            "less-equal": gl.LEQUAL,
            greater: gl.GREATER,
            "greater-equal": gl.GEQUAL
          };
          this._stencilOpsMapping = {
            keep: gl.KEEP,
            zero: gl.ZERO,
            replace: gl.REPLACE,
            invert: gl.INVERT,
            "increment-clamp": gl.INCR,
            "decrement-clamp": gl.DECR,
            "increment-wrap": gl.INCR_WRAP,
            "decrement-wrap": gl.DECR_WRAP
          };
          this._stencilCache.enabled = false;
          this._stencilCache.stencilMode = STENCIL_MODES.NONE;
          this._stencilCache.stencilReference = 0;
        }
        onRenderTargetChange(renderTarget) {
          if (this._activeRenderTarget === renderTarget)
            return;
          this._activeRenderTarget = renderTarget;
          let stencilState = this._renderTargetStencilState[renderTarget.uid];
          if (!stencilState) {
            stencilState = this._renderTargetStencilState[renderTarget.uid] = {
              stencilMode: STENCIL_MODES.DISABLED,
              stencilReference: 0
            };
          }
          this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
        }
        setStencilMode(stencilMode, stencilReference) {
          const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
          const gl = this._gl;
          const mode = GpuStencilModesToPixi[stencilMode];
          const _stencilCache = this._stencilCache;
          stencilState.stencilMode = stencilMode;
          stencilState.stencilReference = stencilReference;
          if (stencilMode === STENCIL_MODES.DISABLED) {
            if (this._stencilCache.enabled) {
              this._stencilCache.enabled = false;
              gl.disable(gl.STENCIL_TEST);
            }
            return;
          }
          if (!this._stencilCache.enabled) {
            this._stencilCache.enabled = true;
            gl.enable(gl.STENCIL_TEST);
          }
          if (stencilMode !== _stencilCache.stencilMode || _stencilCache.stencilReference !== stencilReference) {
            _stencilCache.stencilMode = stencilMode;
            _stencilCache.stencilReference = stencilReference;
            gl.stencilFunc(this._comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 255);
            gl.stencilOp(gl.KEEP, gl.KEEP, this._stencilOpsMapping[mode.stencilBack.passOp]);
          }
        }
      };
      GlStencilSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "stencil"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs
  function createUboElementsSTD40(uniformData) {
    const uboElements = uniformData.map((data) => ({
      data,
      offset: 0,
      size: 0
    }));
    let size5 = 0;
    let chunkSize = 0;
    let offset = 0;
    for (let i2 = 0; i2 < uboElements.length; i2++) {
      const uboElement = uboElements[i2];
      size5 = WGSL_TO_STD40_SIZE[uboElement.data.type];
      if (!size5) {
        throw new Error(`Unknown type ${uboElement.data.type}`);
      }
      if (uboElement.data.size > 1) {
        size5 = Math.max(size5, 16) * uboElement.data.size;
      }
      uboElement.size = size5;
      if (chunkSize % size5 !== 0 && chunkSize < 16) {
        const lineUpValue = chunkSize % size5 % 16;
        chunkSize += lineUpValue;
        offset += lineUpValue;
      }
      if (chunkSize + size5 > 16) {
        offset = Math.ceil(offset / 16) * 16;
        uboElement.offset = offset;
        offset += size5;
        chunkSize = size5;
      } else {
        uboElement.offset = offset;
        chunkSize += size5;
        offset += size5;
      }
    }
    offset = Math.ceil(offset / 16) * 16;
    return { uboElements, size: offset };
  }
  var WGSL_TO_STD40_SIZE;
  var init_createUboElementsSTD40 = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs"() {
      "use strict";
      WGSL_TO_STD40_SIZE = {
        f32: 4,
        "vec2<f32>": 8,
        "vec3<f32>": 12,
        "vec4<f32>": 16,
        "mat2x2<f32>": 16 * 2,
        "mat3x3<f32>": 16 * 3,
        "mat4x4<f32>": 16 * 4
        // TODO - not essential for now but support these in the future
        // int:      4,
        // ivec2:    8,
        // ivec3:    12,
        // ivec4:    16,
        // uint:     4,
        // uvec2:    8,
        // uvec3:    12,
        // uvec4:    16,
        // bool:     4,
        // bvec2:    8,
        // bvec3:    12,
        // bvec4:    16,
        // mat2:     16 * 2,
        // mat3:     16 * 3,
        // mat4:     16 * 4,
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs
  function generateArraySyncSTD40(uboElement, offsetToAdd) {
    const rowSize = Math.max(WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
    const elementSize = uboElement.data.value.length / uboElement.data.size;
    const remainder2 = (4 - elementSize % 4) % 4;
    return `
        v = uv.${uboElement.data.name};
        offset += ${offsetToAdd};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
        {
            for(var j = 0; j < ${elementSize}; j++)
            {
                data[arrayOffset++] = v[t++];
            }
            ${remainder2 !== 0 ? `arrayOffset += ${remainder2};` : ""}
        }
    `;
  }
  var init_generateArraySyncSTD40 = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs"() {
      init_createUboElementsSTD40();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs
  function createUboSyncFunctionSTD40(uboElements) {
    return createUboSyncFunction(
      uboElements,
      "uboStd40",
      generateArraySyncSTD40,
      uboSyncFunctionsSTD40
    );
  }
  var init_createUboSyncSTD40 = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs"() {
      init_createUboSyncFunction();
      init_uboSyncFunctions();
      init_generateArraySyncSTD40();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.mjs
  var GlUboSystem;
  var init_GlUboSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.mjs"() {
      init_Extensions();
      init_UboSystem();
      init_createUboElementsSTD40();
      init_createUboSyncSTD40();
      GlUboSystem = class extends UboSystem {
        constructor() {
          super({
            createUboElements: createUboElementsSTD40,
            generateUboSync: createUboSyncFunctionSTD40
          });
        }
      };
      GlUboSystem.extension = {
        type: [ExtensionType.WebGLSystem],
        name: "ubo"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs
  var GlRenderTarget;
  var init_GlRenderTarget = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs"() {
      "use strict";
      GlRenderTarget = class {
        constructor() {
          this.width = -1;
          this.height = -1;
          this.msaa = false;
          this.msaaRenderBuffer = [];
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs
  var GlRenderTargetAdaptor;
  var init_GlRenderTargetAdaptor = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs"() {
      init_Rectangle();
      init_warn();
      init_CanvasSource();
      init_const7();
      init_GlRenderTarget();
      GlRenderTargetAdaptor = class {
        constructor() {
          this._clearColorCache = [0, 0, 0, 0];
          this._viewPortCache = new Rectangle();
        }
        init(renderer, renderTargetSystem) {
          this._renderer = renderer;
          this._renderTargetSystem = renderTargetSystem;
          renderer.runners.contextChange.add(this);
        }
        contextChange() {
          this._clearColorCache = [0, 0, 0, 0];
          this._viewPortCache = new Rectangle();
        }
        copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size5, originDest) {
          const renderTargetSystem = this._renderTargetSystem;
          const renderer = this._renderer;
          const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);
          const gl = renderer.gl;
          this.finishRenderPass(sourceRenderSurfaceTexture);
          gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
          renderer.texture.bind(destinationTexture, 0);
          gl.copyTexSubImage2D(
            gl.TEXTURE_2D,
            0,
            originDest.x,
            originDest.y,
            originSrc.x,
            originSrc.y,
            size5.width,
            size5.height
          );
          return destinationTexture;
        }
        startRenderPass(renderTarget, clear2 = true, clearColor, viewport) {
          const renderTargetSystem = this._renderTargetSystem;
          const source3 = renderTarget.colorTexture;
          const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
          let viewPortY = viewport.y;
          if (renderTarget.isRoot) {
            viewPortY = source3.pixelHeight - viewport.height;
          }
          renderTarget.colorTextures.forEach((texture) => {
            this._renderer.texture.unbind(texture);
          });
          const gl = this._renderer.gl;
          gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);
          const viewPortCache = this._viewPortCache;
          if (viewPortCache.x !== viewport.x || viewPortCache.y !== viewPortY || viewPortCache.width !== viewport.width || viewPortCache.height !== viewport.height) {
            viewPortCache.x = viewport.x;
            viewPortCache.y = viewPortY;
            viewPortCache.width = viewport.width;
            viewPortCache.height = viewport.height;
            gl.viewport(
              viewport.x,
              viewPortY,
              viewport.width,
              viewport.height
            );
          }
          if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth)) {
            this._initStencil(gpuRenderTarget);
          }
          this.clear(renderTarget, clear2, clearColor);
        }
        finishRenderPass(renderTarget) {
          const renderTargetSystem = this._renderTargetSystem;
          const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
          if (!glRenderTarget.msaa)
            return;
          const gl = this._renderer.gl;
          gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
          gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);
          gl.blitFramebuffer(
            0,
            0,
            glRenderTarget.width,
            glRenderTarget.height,
            0,
            0,
            glRenderTarget.width,
            glRenderTarget.height,
            gl.COLOR_BUFFER_BIT,
            gl.NEAREST
          );
          gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);
        }
        initGpuRenderTarget(renderTarget) {
          const renderer = this._renderer;
          const gl = renderer.gl;
          const glRenderTarget = new GlRenderTarget();
          const colorTexture = renderTarget.colorTexture;
          if (colorTexture.resource === renderer.canvas) {
            this._renderer.context.ensureCanvasSize(renderTarget.colorTexture.resource);
            glRenderTarget.framebuffer = null;
            return glRenderTarget;
          }
          this._initColor(renderTarget, glRenderTarget);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          return glRenderTarget;
        }
        destroyGpuRenderTarget(gpuRenderTarget) {
          const gl = this._renderer.gl;
          if (gpuRenderTarget.framebuffer) {
            gl.deleteFramebuffer(gpuRenderTarget.framebuffer);
            gpuRenderTarget.framebuffer = null;
          }
          if (gpuRenderTarget.resolveTargetFramebuffer) {
            gl.deleteFramebuffer(gpuRenderTarget.resolveTargetFramebuffer);
            gpuRenderTarget.resolveTargetFramebuffer = null;
          }
          if (gpuRenderTarget.depthStencilRenderBuffer) {
            gl.deleteRenderbuffer(gpuRenderTarget.depthStencilRenderBuffer);
            gpuRenderTarget.depthStencilRenderBuffer = null;
          }
          gpuRenderTarget.msaaRenderBuffer.forEach((renderBuffer) => {
            gl.deleteRenderbuffer(renderBuffer);
          });
          gpuRenderTarget.msaaRenderBuffer = null;
        }
        clear(_renderTarget, clear2, clearColor) {
          if (!clear2)
            return;
          const renderTargetSystem = this._renderTargetSystem;
          if (typeof clear2 === "boolean") {
            clear2 = clear2 ? CLEAR.ALL : CLEAR.NONE;
          }
          const gl = this._renderer.gl;
          if (clear2 & CLEAR.COLOR) {
            clearColor ?? (clearColor = renderTargetSystem.defaultClearColor);
            const clearColorCache = this._clearColorCache;
            const clearColorArray = clearColor;
            if (clearColorCache[0] !== clearColorArray[0] || clearColorCache[1] !== clearColorArray[1] || clearColorCache[2] !== clearColorArray[2] || clearColorCache[3] !== clearColorArray[3]) {
              clearColorCache[0] = clearColorArray[0];
              clearColorCache[1] = clearColorArray[1];
              clearColorCache[2] = clearColorArray[2];
              clearColorCache[3] = clearColorArray[3];
              gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);
            }
          }
          gl.clear(clear2);
        }
        resizeGpuRenderTarget(renderTarget) {
          if (renderTarget.isRoot)
            return;
          const renderTargetSystem = this._renderTargetSystem;
          const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
          this._resizeColor(renderTarget, glRenderTarget);
          if (renderTarget.stencil || renderTarget.depth) {
            this._resizeStencil(glRenderTarget);
          }
        }
        _initColor(renderTarget, glRenderTarget) {
          const renderer = this._renderer;
          const gl = renderer.gl;
          const resolveTargetFramebuffer = gl.createFramebuffer();
          glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;
          gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);
          glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;
          glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;
          renderTarget.colorTextures.forEach((colorTexture, i2) => {
            const source3 = colorTexture.source;
            if (source3.antialias) {
              if (renderer.context.supports.msaa) {
                glRenderTarget.msaa = true;
              } else {
                warn2("[RenderTexture] Antialiasing on textures is not supported in WebGL1");
              }
            }
            renderer.texture.bindSource(source3, 0);
            const glSource = renderer.texture.getGlSource(source3);
            const glTexture = glSource.texture;
            gl.framebufferTexture2D(
              gl.FRAMEBUFFER,
              gl.COLOR_ATTACHMENT0 + i2,
              3553,
              // texture.target,
              glTexture,
              0
            );
          });
          if (glRenderTarget.msaa) {
            const viewFramebuffer = gl.createFramebuffer();
            glRenderTarget.framebuffer = viewFramebuffer;
            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
            renderTarget.colorTextures.forEach((_, i2) => {
              const msaaRenderBuffer = gl.createRenderbuffer();
              glRenderTarget.msaaRenderBuffer[i2] = msaaRenderBuffer;
            });
          } else {
            glRenderTarget.framebuffer = resolveTargetFramebuffer;
          }
          this._resizeColor(renderTarget, glRenderTarget);
        }
        _resizeColor(renderTarget, glRenderTarget) {
          const source3 = renderTarget.colorTexture.source;
          glRenderTarget.width = source3.pixelWidth;
          glRenderTarget.height = source3.pixelHeight;
          renderTarget.colorTextures.forEach((colorTexture, i2) => {
            if (i2 === 0)
              return;
            colorTexture.source.resize(source3.width, source3.height, source3._resolution);
          });
          if (glRenderTarget.msaa) {
            const renderer = this._renderer;
            const gl = renderer.gl;
            const viewFramebuffer = glRenderTarget.framebuffer;
            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
            renderTarget.colorTextures.forEach((colorTexture, i2) => {
              const source22 = colorTexture.source;
              renderer.texture.bindSource(source22, 0);
              const glSource = renderer.texture.getGlSource(source22);
              const glInternalFormat = glSource.internalFormat;
              const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i2];
              gl.bindRenderbuffer(
                gl.RENDERBUFFER,
                msaaRenderBuffer
              );
              gl.renderbufferStorageMultisample(
                gl.RENDERBUFFER,
                4,
                glInternalFormat,
                source22.pixelWidth,
                source22.pixelHeight
              );
              gl.framebufferRenderbuffer(
                gl.FRAMEBUFFER,
                gl.COLOR_ATTACHMENT0 + i2,
                gl.RENDERBUFFER,
                msaaRenderBuffer
              );
            });
          }
        }
        _initStencil(glRenderTarget) {
          if (glRenderTarget.framebuffer === null)
            return;
          const gl = this._renderer.gl;
          const depthStencilRenderBuffer = gl.createRenderbuffer();
          glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;
          gl.bindRenderbuffer(
            gl.RENDERBUFFER,
            depthStencilRenderBuffer
          );
          gl.framebufferRenderbuffer(
            gl.FRAMEBUFFER,
            gl.DEPTH_STENCIL_ATTACHMENT,
            gl.RENDERBUFFER,
            depthStencilRenderBuffer
          );
          this._resizeStencil(glRenderTarget);
        }
        _resizeStencil(glRenderTarget) {
          const gl = this._renderer.gl;
          gl.bindRenderbuffer(
            gl.RENDERBUFFER,
            glRenderTarget.depthStencilRenderBuffer
          );
          if (glRenderTarget.msaa) {
            gl.renderbufferStorageMultisample(
              gl.RENDERBUFFER,
              4,
              gl.DEPTH24_STENCIL8,
              glRenderTarget.width,
              glRenderTarget.height
            );
          } else {
            gl.renderbufferStorage(
              gl.RENDERBUFFER,
              this._renderer.context.webGLVersion === 2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
              glRenderTarget.width,
              glRenderTarget.height
            );
          }
        }
        postrender(renderTarget) {
          if (!this._renderer.context.multiView)
            return;
          if (CanvasSource.test(renderTarget.colorTexture.resource)) {
            const contextCanvas = this._renderer.context.canvas;
            const canvasSource = renderTarget.colorTexture;
            canvasSource.context2D.drawImage(
              contextCanvas,
              0,
              canvasSource.pixelHeight - contextCanvas.height
            );
          }
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs
  var GlRenderTargetSystem;
  var init_GlRenderTargetSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs"() {
      init_Extensions();
      init_RenderTargetSystem();
      init_GlRenderTargetAdaptor();
      GlRenderTargetSystem = class extends RenderTargetSystem {
        constructor(renderer) {
          super(renderer);
          this.adaptor = new GlRenderTargetAdaptor();
          this.adaptor.init(renderer, this);
        }
      };
      GlRenderTargetSystem.extension = {
        type: [ExtensionType.WebGLSystem],
        name: "renderTarget"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs
  function generateShaderSyncCode(shader, shaderSystem) {
    const funcFragments = [];
    const headerFragments = [`
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `];
    let addedTextreSystem = false;
    let blockIndex = 0;
    let textureCount = 0;
    const programData = shaderSystem._getProgramData(shader.glProgram);
    for (const i2 in shader.groups) {
      const group4 = shader.groups[i2];
      funcFragments.push(`
            resources = g[${i2}].resources;
        `);
      for (const j2 in group4.resources) {
        const resource = group4.resources[j2];
        if (resource instanceof UniformGroup) {
          if (resource.ubo) {
            funcFragments.push(`
                        sS.bindUniformBlock(
                            resources[${j2}],
                            sS._uniformBindMap[${i2}[${j2}],
                            ${blockIndex++}
                        );
                    `);
          } else {
            funcFragments.push(`
                        ugS.updateUniformGroup(resources[${j2}], p, sD);
                    `);
          }
        } else if (resource instanceof BufferResource) {
          funcFragments.push(`
                    sS.bindUniformBlock(
                        resources[${j2}],
                        sS._uniformBindMap[${i2}[${j2}],
                        ${blockIndex++}
                    );
                `);
        } else if (resource instanceof TextureSource) {
          const uniformName = shader._uniformBindMap[i2][j2];
          const uniformData = programData.uniformData[uniformName];
          if (uniformData) {
            if (!addedTextreSystem) {
              addedTextreSystem = true;
              headerFragments.push(`
                        var tS = r.texture;
                        `);
            }
            shaderSystem._gl.uniform1i(uniformData.location, textureCount);
            funcFragments.push(`
                        tS.bind(resources[${j2}], ${textureCount});
                    `);
            textureCount++;
          }
        }
      }
    }
    const functionSource = [...headerFragments, ...funcFragments].join("\n");
    return new Function("r", "s", "sD", functionSource);
  }
  var init_GenerateShaderSyncCode = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs"() {
      init_BufferResource();
      init_UniformGroup();
      init_TextureSource();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs
  var GlProgramData;
  var init_GlProgramData = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs"() {
      "use strict";
      GlProgramData = class {
        /**
         * Makes a new Pixi program.
         * @param program - webgl program
         * @param uniformData - uniforms
         */
        constructor(program, uniformData) {
          this.program = program;
          this.uniformData = uniformData;
          this.uniformGroups = {};
          this.uniformDirtyGroups = {};
          this.uniformBlockBindings = {};
        }
        /** Destroys this program. */
        destroy() {
          this.uniformData = null;
          this.uniformGroups = null;
          this.uniformDirtyGroups = null;
          this.uniformBlockBindings = null;
          this.program = null;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs
  function compileShader(gl, type, src9) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, src9);
    gl.compileShader(shader);
    return shader;
  }
  var init_compileShader = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs
  function booleanArray(size5) {
    const array = new Array(size5);
    for (let i2 = 0; i2 < array.length; i2++) {
      array[i2] = false;
    }
    return array;
  }
  function defaultValue(type, size5) {
    switch (type) {
      case "float":
        return 0;
      case "vec2":
        return new Float32Array(2 * size5);
      case "vec3":
        return new Float32Array(3 * size5);
      case "vec4":
        return new Float32Array(4 * size5);
      case "int":
      case "uint":
      case "sampler2D":
      case "sampler2DArray":
        return 0;
      case "ivec2":
        return new Int32Array(2 * size5);
      case "ivec3":
        return new Int32Array(3 * size5);
      case "ivec4":
        return new Int32Array(4 * size5);
      case "uvec2":
        return new Uint32Array(2 * size5);
      case "uvec3":
        return new Uint32Array(3 * size5);
      case "uvec4":
        return new Uint32Array(4 * size5);
      case "bool":
        return false;
      case "bvec2":
        return booleanArray(2 * size5);
      case "bvec3":
        return booleanArray(3 * size5);
      case "bvec4":
        return booleanArray(4 * size5);
      case "mat2":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }
  var init_defaultValue = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs
  function mapType(gl, type) {
    if (!GL_TABLE) {
      const typeNames = Object.keys(GL_TO_GLSL_TYPES);
      GL_TABLE = {};
      for (let i2 = 0; i2 < typeNames.length; ++i2) {
        const tn = typeNames[i2];
        GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
      }
    }
    return GL_TABLE[type];
  }
  function mapGlToVertexFormat(gl, type) {
    const typeValue = mapType(gl, type);
    return GLSL_TO_VERTEX_TYPES[typeValue] || "float32";
  }
  var GL_TABLE, GL_TO_GLSL_TYPES, GLSL_TO_VERTEX_TYPES;
  var init_mapType = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs"() {
      "use strict";
      GL_TABLE = null;
      GL_TO_GLSL_TYPES = {
        FLOAT: "float",
        FLOAT_VEC2: "vec2",
        FLOAT_VEC3: "vec3",
        FLOAT_VEC4: "vec4",
        INT: "int",
        INT_VEC2: "ivec2",
        INT_VEC3: "ivec3",
        INT_VEC4: "ivec4",
        UNSIGNED_INT: "uint",
        UNSIGNED_INT_VEC2: "uvec2",
        UNSIGNED_INT_VEC3: "uvec3",
        UNSIGNED_INT_VEC4: "uvec4",
        BOOL: "bool",
        BOOL_VEC2: "bvec2",
        BOOL_VEC3: "bvec3",
        BOOL_VEC4: "bvec4",
        FLOAT_MAT2: "mat2",
        FLOAT_MAT3: "mat3",
        FLOAT_MAT4: "mat4",
        SAMPLER_2D: "sampler2D",
        INT_SAMPLER_2D: "sampler2D",
        UNSIGNED_INT_SAMPLER_2D: "sampler2D",
        SAMPLER_CUBE: "samplerCube",
        INT_SAMPLER_CUBE: "samplerCube",
        UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
        SAMPLER_2D_ARRAY: "sampler2DArray",
        INT_SAMPLER_2D_ARRAY: "sampler2DArray",
        UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
      };
      GLSL_TO_VERTEX_TYPES = {
        float: "float32",
        vec2: "float32x2",
        vec3: "float32x3",
        vec4: "float32x4",
        int: "sint32",
        ivec2: "sint32x2",
        ivec3: "sint32x3",
        ivec4: "sint32x4",
        uint: "uint32",
        uvec2: "uint32x2",
        uvec3: "uint32x3",
        uvec4: "uint32x4",
        bool: "uint32",
        bvec2: "uint32x2",
        bvec3: "uint32x3",
        bvec4: "uint32x4"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs
  function extractAttributesFromGlProgram(program, gl, sortAttributes = false) {
    const attributes = {};
    const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (let i2 = 0; i2 < totalAttributes; i2++) {
      const attribData = gl.getActiveAttrib(program, i2);
      if (attribData.name.startsWith("gl_")) {
        continue;
      }
      const format = mapGlToVertexFormat(gl, attribData.type);
      attributes[attribData.name] = {
        location: 0,
        // set further down..
        format,
        stride: getAttributeInfoFromFormat(format).stride,
        offset: 0,
        instance: false,
        start: 0
      };
    }
    const keys6 = Object.keys(attributes);
    if (sortAttributes) {
      keys6.sort((a2, b2) => a2 > b2 ? 1 : -1);
      for (let i2 = 0; i2 < keys6.length; i2++) {
        attributes[keys6[i2]].location = i2;
        gl.bindAttribLocation(program, i2, keys6[i2]);
      }
      gl.linkProgram(program);
    } else {
      for (let i2 = 0; i2 < keys6.length; i2++) {
        attributes[keys6[i2]].location = gl.getAttribLocation(program, keys6[i2]);
      }
    }
    return attributes;
  }
  var init_extractAttributesFromGlProgram = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs"() {
      init_getAttributeInfoFromFormat();
      init_mapType();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.mjs
  function getUboData(program, gl) {
    if (!gl.ACTIVE_UNIFORM_BLOCKS)
      return {};
    const uniformBlocks = {};
    const totalUniformsBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);
    for (let i2 = 0; i2 < totalUniformsBlocks; i2++) {
      const name16 = gl.getActiveUniformBlockName(program, i2);
      const uniformBlockIndex = gl.getUniformBlockIndex(program, name16);
      const size5 = gl.getActiveUniformBlockParameter(program, i2, gl.UNIFORM_BLOCK_DATA_SIZE);
      uniformBlocks[name16] = {
        name: name16,
        index: uniformBlockIndex,
        size: size5
      };
    }
    return uniformBlocks;
  }
  var init_getUboData = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs
  function getUniformData(program, gl) {
    const uniforms = {};
    const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (let i2 = 0; i2 < totalUniforms; i2++) {
      const uniformData = gl.getActiveUniform(program, i2);
      const name16 = uniformData.name.replace(/\[.*?\]$/, "");
      const isArray2 = !!uniformData.name.match(/\[.*?\]$/);
      const type = mapType(gl, uniformData.type);
      uniforms[name16] = {
        name: name16,
        index: i2,
        type,
        size: uniformData.size,
        isArray: isArray2,
        value: defaultValue(type, uniformData.size)
      };
    }
    return uniforms;
  }
  var init_getUniformData = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs"() {
      init_defaultValue();
      init_mapType();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs
  function logPrettyShaderError(gl, shader) {
    const shaderSrc = gl.getShaderSource(shader).split("\n").map((line, index6) => `${index6}: ${line}`);
    const shaderLog = gl.getShaderInfoLog(shader);
    const splitShader = shaderLog.split("\n");
    const dedupe = {};
    const lineNumbers2 = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n2) => {
      if (n2 && !dedupe[n2]) {
        dedupe[n2] = true;
        return true;
      }
      return false;
    });
    const logArgs = [""];
    lineNumbers2.forEach((number2) => {
      shaderSrc[number2 - 1] = `%c${shaderSrc[number2 - 1]}%c`;
      logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
    });
    const fragmentSourceToLog = shaderSrc.join("\n");
    logArgs[0] = fragmentSourceToLog;
    console.error(shaderLog);
    console.groupCollapsed("click to view full shader code");
    console.warn(...logArgs);
    console.groupEnd();
  }
  function logProgramError(gl, program, vertexShader, fragmentShader) {
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        logPrettyShaderError(gl, vertexShader);
      }
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        logPrettyShaderError(gl, fragmentShader);
      }
      console.error("PixiJS Error: Could not initialize shader.");
      if (gl.getProgramInfoLog(program) !== "") {
        console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
      }
    }
  }
  var init_logProgramError = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs
  function generateProgram(gl, program) {
    const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertex);
    const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragment);
    const webGLProgram = gl.createProgram();
    gl.attachShader(webGLProgram, glVertShader);
    gl.attachShader(webGLProgram, glFragShader);
    const transformFeedbackVaryings = program.transformFeedbackVaryings;
    if (transformFeedbackVaryings) {
      if (typeof gl.transformFeedbackVaryings !== "function") {
        warn2(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);
      } else {
        gl.transformFeedbackVaryings(
          webGLProgram,
          transformFeedbackVaryings.names,
          transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS
        );
      }
    }
    gl.linkProgram(webGLProgram);
    if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
      logProgramError(gl, webGLProgram, glVertShader, glFragShader);
    }
    program._attributeData = extractAttributesFromGlProgram(
      webGLProgram,
      gl,
      !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertex)
    );
    program._uniformData = getUniformData(webGLProgram, gl);
    program._uniformBlockData = getUboData(webGLProgram, gl);
    gl.deleteShader(glVertShader);
    gl.deleteShader(glFragShader);
    const uniformData = {};
    for (const i2 in program._uniformData) {
      const data = program._uniformData[i2];
      uniformData[i2] = {
        location: gl.getUniformLocation(webGLProgram, i2),
        value: defaultValue(data.type, data.size)
      };
    }
    const glProgram3 = new GlProgramData(webGLProgram, uniformData);
    return glProgram3;
  }
  var init_generateProgram = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs"() {
      init_warn();
      init_GlProgramData();
      init_compileShader();
      init_defaultValue();
      init_extractAttributesFromGlProgram();
      init_getUboData();
      init_getUniformData();
      init_logProgramError();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs
  var defaultSyncData, GlShaderSystem;
  var init_GlShaderSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs"() {
      init_Extensions();
      init_maxRecommendedTextures();
      init_GenerateShaderSyncCode();
      init_generateProgram();
      defaultSyncData = {
        textureCount: 0,
        blockIndex: 0
      };
      GlShaderSystem = class {
        constructor(renderer) {
          this._activeProgram = null;
          this._programDataHash = /* @__PURE__ */ Object.create(null);
          this._nextIndex = 0;
          this._boundUniformsIdsToIndexHash = /* @__PURE__ */ Object.create(null);
          this._boundIndexToUniformsHash = /* @__PURE__ */ Object.create(null);
          this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
          this._renderer.renderableGC.addManagedHash(this, "_programDataHash");
        }
        contextChange(gl) {
          this._gl = gl;
          this._maxBindings = gl.MAX_UNIFORM_BUFFER_BINDINGS ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
          this._programDataHash = /* @__PURE__ */ Object.create(null);
          this._boundUniformsIdsToIndexHash = /* @__PURE__ */ Object.create(null);
          this._boundIndexToUniformsHash = /* @__PURE__ */ Object.create(null);
          this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);
          this._activeProgram = null;
          this.maxTextures = getMaxTexturesPerBatch();
        }
        /**
         * Changes the current shader to the one given in parameter.
         * @param shader - the new shader
         * @param skipSync - false if the shader should automatically sync its uniforms.
         * @returns the glProgram that belongs to the shader.
         */
        bind(shader, skipSync) {
          this._setProgram(shader.glProgram);
          if (skipSync)
            return;
          defaultSyncData.textureCount = 0;
          defaultSyncData.blockIndex = 0;
          let syncFunction = this._shaderSyncFunctions[shader.glProgram._key];
          if (!syncFunction) {
            syncFunction = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this);
          }
          syncFunction(this._renderer, shader, defaultSyncData);
        }
        /**
         * Updates the uniform group.
         * @param uniformGroup - the uniform group to update
         */
        updateUniformGroup(uniformGroup) {
          this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData);
        }
        /**
         * Binds a uniform block to the shader.
         * @param uniformGroup - the uniform group to bind
         * @param name - the name of the uniform block
         * @param index - the index of the uniform block
         */
        bindUniformBlock(uniformGroup, name16, index6 = 0) {
          const bufferSystem = this._renderer.buffer;
          const programData = this._getProgramData(this._activeProgram);
          const isBufferResource = uniformGroup._bufferResource;
          if (isBufferResource) {
            this._renderer.ubo.updateUniformGroup(uniformGroup);
          }
          bufferSystem.updateBuffer(uniformGroup.buffer);
          let boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid];
          if (boundIndex === void 0) {
            const nextIndex = this._nextIndex++ % this._maxBindings;
            const currentBoundUniformGroup = this._boundIndexToUniformsHash[nextIndex];
            if (currentBoundUniformGroup) {
              this._boundUniformsIdsToIndexHash[currentBoundUniformGroup.uid] = void 0;
            }
            boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid] = nextIndex;
            this._boundIndexToUniformsHash[nextIndex] = uniformGroup;
            if (isBufferResource) {
              bufferSystem.bindBufferRange(uniformGroup.buffer, nextIndex, uniformGroup.offset);
            } else {
              bufferSystem.bindBufferBase(uniformGroup.buffer, nextIndex);
            }
          }
          const gl = this._gl;
          const uniformBlockIndex = this._activeProgram._uniformBlockData[name16].index;
          if (programData.uniformBlockBindings[index6] === boundIndex)
            return;
          programData.uniformBlockBindings[index6] = boundIndex;
          gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundIndex);
        }
        _setProgram(program) {
          if (this._activeProgram === program)
            return;
          this._activeProgram = program;
          const programData = this._getProgramData(program);
          this._gl.useProgram(programData.program);
        }
        /**
         * @param program - the program to get the data for
         * @internal
         * @private
         */
        _getProgramData(program) {
          return this._programDataHash[program._key] || this._createProgramData(program);
        }
        _createProgramData(program) {
          const key = program._key;
          this._programDataHash[key] = generateProgram(this._gl, program);
          return this._programDataHash[key];
        }
        destroy() {
          for (const key of Object.keys(this._programDataHash)) {
            const programData = this._programDataHash[key];
            programData.destroy();
            this._programDataHash[key] = null;
          }
          this._programDataHash = null;
          this._boundUniformsIdsToIndexHash = null;
        }
        /**
         * Creates a function that can be executed that will sync the shader as efficiently as possible.
         * Overridden by the unsafe eval package if you don't want eval used in your project.
         * @param shader - the shader to generate the sync function for
         * @param shaderSystem - the shader system to use
         * @returns - the generated sync function
         * @ignore
         */
        _generateShaderSync(shader, shaderSystem) {
          return generateShaderSyncCode(shader, shaderSystem);
        }
      };
      GlShaderSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "shader"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs
  var UNIFORM_TO_SINGLE_SETTERS, UNIFORM_TO_ARRAY_SETTERS;
  var init_generateUniformsSyncTypes = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs"() {
      "use strict";
      UNIFORM_TO_SINGLE_SETTERS = {
        f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
        "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
        "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
        "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
        i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
        "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
        "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
        "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
        bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,
        "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,
        "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`
      };
      UNIFORM_TO_ARRAY_SETTERS = {
        f32: `gl.uniform1fv(location, v);`,
        "vec2<f32>": `gl.uniform2fv(location, v);`,
        "vec3<f32>": `gl.uniform3fv(location, v);`,
        "vec4<f32>": `gl.uniform4fv(location, v);`,
        "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,
        "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,
        "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`,
        i32: `gl.uniform1iv(location, v);`,
        "vec2<i32>": `gl.uniform2iv(location, v);`,
        "vec3<i32>": `gl.uniform3iv(location, v);`,
        "vec4<i32>": `gl.uniform4iv(location, v);`,
        u32: `gl.uniform1iv(location, v);`,
        "vec2<u32>": `gl.uniform2iv(location, v);`,
        "vec3<u32>": `gl.uniform3iv(location, v);`,
        "vec4<u32>": `gl.uniform4iv(location, v);`,
        bool: `gl.uniform1iv(location, v);`,
        "vec2<bool>": `gl.uniform2iv(location, v);`,
        "vec3<bool>": `gl.uniform3iv(location, v);`,
        "vec4<bool>": `gl.uniform4iv(location, v);`
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.mjs
  function generateUniformsSync(group4, uniformData) {
    const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `];
    for (const i2 in group4.uniforms) {
      if (!uniformData[i2]) {
        if (group4.uniforms[i2] instanceof UniformGroup) {
          if (group4.uniforms[i2].ubo) {
            funcFragments.push(`
                        renderer.shader.bindUniformBlock(uv.${i2}, "${i2}");
                    `);
          } else {
            funcFragments.push(`
                        renderer.shader.updateUniformGroup(uv.${i2});
                    `);
          }
        } else if (group4.uniforms[i2] instanceof BufferResource) {
          funcFragments.push(`
                        renderer.shader.bindBufferResource(uv.${i2}, "${i2}");
                    `);
        }
        continue;
      }
      const uniform2 = group4.uniformStructures[i2];
      let parsed = false;
      for (let j2 = 0; j2 < uniformParsers.length; j2++) {
        const parser2 = uniformParsers[j2];
        if (uniform2.type === parser2.type && parser2.test(uniform2)) {
          funcFragments.push(`name = "${i2}";`, uniformParsers[j2].uniform);
          parsed = true;
          break;
        }
      }
      if (!parsed) {
        const templateType = uniform2.size === 1 ? UNIFORM_TO_SINGLE_SETTERS : UNIFORM_TO_ARRAY_SETTERS;
        const template = templateType[uniform2.type].replace("location", `ud["${i2}"].location`);
        funcFragments.push(`
            cu = ud["${i2}"];
            cv = cu.value;
            v = uv["${i2}"];
            ${template};`);
      }
    }
    return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
  }
  var init_generateUniformsSync = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.mjs"() {
      init_BufferResource();
      init_UniformGroup();
      init_uniformParsers();
      init_generateUniformsSyncTypes();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs
  var GlUniformGroupSystem;
  var init_GlUniformGroupSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs"() {
      init_Extensions();
      init_generateUniformsSync();
      GlUniformGroupSystem = class {
        /** @param renderer - The renderer this System works for. */
        constructor(renderer) {
          this._cache = {};
          this._uniformGroupSyncHash = {};
          this._renderer = renderer;
          this.gl = null;
          this._cache = {};
        }
        contextChange(gl) {
          this.gl = gl;
        }
        /**
         * Uploads the uniforms values to the currently bound shader.
         * @param group - the uniforms values that be applied to the current shader
         * @param program
         * @param syncData
         * @param syncData.textureCount
         */
        updateUniformGroup(group4, program, syncData) {
          const programData = this._renderer.shader._getProgramData(program);
          if (!group4.isStatic || group4._dirtyId !== programData.uniformDirtyGroups[group4.uid]) {
            programData.uniformDirtyGroups[group4.uid] = group4._dirtyId;
            const syncFunc = this._getUniformSyncFunction(group4, program);
            syncFunc(programData.uniformData, group4.uniforms, this._renderer, syncData);
          }
        }
        /**
         * Overridable by the pixi.js/unsafe-eval package to use static syncUniforms instead.
         * @param group
         * @param program
         */
        _getUniformSyncFunction(group4, program) {
          return this._uniformGroupSyncHash[group4._signature]?.[program._key] || this._createUniformSyncFunction(group4, program);
        }
        _createUniformSyncFunction(group4, program) {
          const uniformGroupSyncHash = this._uniformGroupSyncHash[group4._signature] || (this._uniformGroupSyncHash[group4._signature] = {});
          const id5 = this._getSignature(group4, program._uniformData, "u");
          if (!this._cache[id5]) {
            this._cache[id5] = this._generateUniformsSync(group4, program._uniformData);
          }
          uniformGroupSyncHash[program._key] = this._cache[id5];
          return uniformGroupSyncHash[program._key];
        }
        _generateUniformsSync(group4, uniformData) {
          return generateUniformsSync(group4, uniformData);
        }
        /**
         * Takes a uniform group and data and generates a unique signature for them.
         * @param group - The uniform group to get signature of
         * @param group.uniforms
         * @param uniformData - Uniform information generated by the shader
         * @param preFix
         * @returns Unique signature of the uniform group
         */
        _getSignature(group4, uniformData, preFix) {
          const uniforms = group4.uniforms;
          const strings = [`${preFix}-`];
          for (const i2 in uniforms) {
            strings.push(i2);
            if (uniformData[i2]) {
              strings.push(uniformData[i2].type);
            }
          }
          return strings.join("-");
        }
        /** Destroys this System and removes all its textures. */
        destroy() {
          this._renderer = null;
          this._cache = null;
        }
      };
      GlUniformGroupSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "uniformGroup"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs
  function mapWebGLBlendModesToPixi(gl) {
    const blendMap = {};
    blendMap.normal = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.add = [gl.ONE, gl.ONE];
    blendMap.multiply = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.screen = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.none = [0, 0];
    blendMap["normal-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap["add-npm"] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
    blendMap["screen-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.erase = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
    const isWebGl2 = !(gl instanceof DOMAdapter.get().getWebGLRenderingContext());
    if (isWebGl2) {
      blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MIN, gl.MIN];
      blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MAX, gl.MAX];
    } else {
      const ext = gl.getExtension("EXT_blend_minmax");
      if (ext) {
        blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MIN_EXT, ext.MIN_EXT];
        blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MAX_EXT, ext.MAX_EXT];
      }
    }
    return blendMap;
  }
  var init_mapWebGLBlendModesToPixi = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs"() {
      init_adapter();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs
  var BLEND2, OFFSET2, CULLING2, DEPTH_TEST2, WINDING2, DEPTH_MASK2, _GlStateSystem, GlStateSystem;
  var init_GlStateSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs"() {
      init_Extensions();
      init_State();
      init_mapWebGLBlendModesToPixi();
      BLEND2 = 0;
      OFFSET2 = 1;
      CULLING2 = 2;
      DEPTH_TEST2 = 3;
      WINDING2 = 4;
      DEPTH_MASK2 = 5;
      _GlStateSystem = class _GlStateSystem2 {
        constructor() {
          this.gl = null;
          this.stateId = 0;
          this.polygonOffset = 0;
          this.blendMode = "none";
          this._blendEq = false;
          this.map = [];
          this.map[BLEND2] = this.setBlend;
          this.map[OFFSET2] = this.setOffset;
          this.map[CULLING2] = this.setCullFace;
          this.map[DEPTH_TEST2] = this.setDepthTest;
          this.map[WINDING2] = this.setFrontFace;
          this.map[DEPTH_MASK2] = this.setDepthMask;
          this.checks = [];
          this.defaultState = State.for2d();
        }
        contextChange(gl) {
          this.gl = gl;
          this.blendModesMap = mapWebGLBlendModesToPixi(gl);
          this.reset();
        }
        /**
         * Sets the current state
         * @param {*} state - The state to set.
         */
        set(state4) {
          state4 = state4 || this.defaultState;
          if (this.stateId !== state4.data) {
            let diff = this.stateId ^ state4.data;
            let i2 = 0;
            while (diff) {
              if (diff & 1) {
                this.map[i2].call(this, !!(state4.data & 1 << i2));
              }
              diff = diff >> 1;
              i2++;
            }
            this.stateId = state4.data;
          }
          for (let i2 = 0; i2 < this.checks.length; i2++) {
            this.checks[i2](this, state4);
          }
        }
        /**
         * Sets the state, when previous state is unknown.
         * @param {*} state - The state to set
         */
        forceState(state4) {
          state4 = state4 || this.defaultState;
          for (let i2 = 0; i2 < this.map.length; i2++) {
            this.map[i2].call(this, !!(state4.data & 1 << i2));
          }
          for (let i2 = 0; i2 < this.checks.length; i2++) {
            this.checks[i2](this, state4);
          }
          this.stateId = state4.data;
        }
        /**
         * Sets whether to enable or disable blending.
         * @param value - Turn on or off WebGl blending.
         */
        setBlend(value12) {
          this._updateCheck(_GlStateSystem2._checkBlendMode, value12);
          this.gl[value12 ? "enable" : "disable"](this.gl.BLEND);
        }
        /**
         * Sets whether to enable or disable polygon offset fill.
         * @param value - Turn on or off webgl polygon offset testing.
         */
        setOffset(value12) {
          this._updateCheck(_GlStateSystem2._checkPolygonOffset, value12);
          this.gl[value12 ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
        }
        /**
         * Sets whether to enable or disable depth test.
         * @param value - Turn on or off webgl depth testing.
         */
        setDepthTest(value12) {
          this.gl[value12 ? "enable" : "disable"](this.gl.DEPTH_TEST);
        }
        /**
         * Sets whether to enable or disable depth mask.
         * @param value - Turn on or off webgl depth mask.
         */
        setDepthMask(value12) {
          this.gl.depthMask(value12);
        }
        /**
         * Sets whether to enable or disable cull face.
         * @param {boolean} value - Turn on or off webgl cull face.
         */
        setCullFace(value12) {
          this.gl[value12 ? "enable" : "disable"](this.gl.CULL_FACE);
        }
        /**
         * Sets the gl front face.
         * @param {boolean} value - true is clockwise and false is counter-clockwise
         */
        setFrontFace(value12) {
          this.gl.frontFace(this.gl[value12 ? "CW" : "CCW"]);
        }
        /**
         * Sets the blend mode.
         * @param {number} value - The blend mode to set to.
         */
        setBlendMode(value12) {
          if (!this.blendModesMap[value12]) {
            value12 = "normal";
          }
          if (value12 === this.blendMode) {
            return;
          }
          this.blendMode = value12;
          const mode = this.blendModesMap[value12];
          const gl = this.gl;
          if (mode.length === 2) {
            gl.blendFunc(mode[0], mode[1]);
          } else {
            gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
          }
          if (mode.length === 6) {
            this._blendEq = true;
            gl.blendEquationSeparate(mode[4], mode[5]);
          } else if (this._blendEq) {
            this._blendEq = false;
            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
          }
        }
        /**
         * Sets the polygon offset.
         * @param {number} value - the polygon offset
         * @param {number} scale - the polygon offset scale
         */
        setPolygonOffset(value12, scale) {
          this.gl.polygonOffset(value12, scale);
        }
        // used
        /** Resets all the logic and disables the VAOs. */
        reset() {
          this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
          this.forceState(this.defaultState);
          this._blendEq = true;
          this.blendMode = "";
          this.setBlendMode("normal");
        }
        /**
         * Checks to see which updates should be checked based on which settings have been activated.
         *
         * For example, if blend is enabled then we should check the blend modes each time the state is changed
         * or if polygon fill is activated then we need to check if the polygon offset changes.
         * The idea is that we only check what we have too.
         * @param func - the checking function to add or remove
         * @param value - should the check function be added or removed.
         */
        _updateCheck(func, value12) {
          const index6 = this.checks.indexOf(func);
          if (value12 && index6 === -1) {
            this.checks.push(func);
          } else if (!value12 && index6 !== -1) {
            this.checks.splice(index6, 1);
          }
        }
        /**
         * A private little wrapper function that we call to check the blend mode.
         * @param system - the System to perform the state check on
         * @param state - the state that the blendMode will pulled from
         */
        static _checkBlendMode(system, state4) {
          system.setBlendMode(state4.blendMode);
        }
        /**
         * A private little wrapper function that we call to check the polygon offset.
         * @param system - the System to perform the state check on
         * @param state - the state that the blendMode will pulled from
         */
        static _checkPolygonOffset(system, state4) {
          system.setPolygonOffset(1, state4.polygonOffset);
        }
        /**
         * @ignore
         */
        destroy() {
          this.gl = null;
          this.checks.length = 0;
        }
      };
      _GlStateSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "state"
      };
      GlStateSystem = _GlStateSystem;
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs
  var GlTexture;
  var init_GlTexture = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs"() {
      init_const10();
      GlTexture = class {
        constructor(texture) {
          this.target = GL_TARGETS.TEXTURE_2D;
          this.texture = texture;
          this.width = -1;
          this.height = -1;
          this.type = GL_TYPES.UNSIGNED_BYTE;
          this.internalFormat = GL_FORMATS.RGBA;
          this.format = GL_FORMATS.RGBA;
          this.samplerType = 0;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs
  var glUploadBufferImageResource;
  var init_glUploadBufferImageResource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs"() {
      "use strict";
      glUploadBufferImageResource = {
        id: "buffer",
        upload(source3, glTexture, gl) {
          if (glTexture.width === source3.width || glTexture.height === source3.height) {
            gl.texSubImage2D(
              gl.TEXTURE_2D,
              0,
              0,
              0,
              source3.width,
              source3.height,
              glTexture.format,
              glTexture.type,
              source3.resource
            );
          } else {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              source3.width,
              source3.height,
              0,
              glTexture.format,
              glTexture.type,
              source3.resource
            );
          }
          glTexture.width = source3.width;
          glTexture.height = source3.height;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs
  var compressedFormatMap, glUploadCompressedTextureResource;
  var init_glUploadCompressedTextureResource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs"() {
      "use strict";
      compressedFormatMap = {
        "bc1-rgba-unorm": true,
        "bc1-rgba-unorm-srgb": true,
        "bc2-rgba-unorm": true,
        "bc2-rgba-unorm-srgb": true,
        "bc3-rgba-unorm": true,
        "bc3-rgba-unorm-srgb": true,
        "bc4-r-unorm": true,
        "bc4-r-snorm": true,
        "bc5-rg-unorm": true,
        "bc5-rg-snorm": true,
        "bc6h-rgb-ufloat": true,
        "bc6h-rgb-float": true,
        "bc7-rgba-unorm": true,
        "bc7-rgba-unorm-srgb": true,
        // ETC2 compressed formats usable if "texture-compression-etc2" is both
        // supported by the device/user agent and enabled in requestDevice.
        "etc2-rgb8unorm": true,
        "etc2-rgb8unorm-srgb": true,
        "etc2-rgb8a1unorm": true,
        "etc2-rgb8a1unorm-srgb": true,
        "etc2-rgba8unorm": true,
        "etc2-rgba8unorm-srgb": true,
        "eac-r11unorm": true,
        "eac-r11snorm": true,
        "eac-rg11unorm": true,
        "eac-rg11snorm": true,
        // ASTC compressed formats usable if "texture-compression-astc" is both
        // supported by the device/user agent and enabled in requestDevice.
        "astc-4x4-unorm": true,
        "astc-4x4-unorm-srgb": true,
        "astc-5x4-unorm": true,
        "astc-5x4-unorm-srgb": true,
        "astc-5x5-unorm": true,
        "astc-5x5-unorm-srgb": true,
        "astc-6x5-unorm": true,
        "astc-6x5-unorm-srgb": true,
        "astc-6x6-unorm": true,
        "astc-6x6-unorm-srgb": true,
        "astc-8x5-unorm": true,
        "astc-8x5-unorm-srgb": true,
        "astc-8x6-unorm": true,
        "astc-8x6-unorm-srgb": true,
        "astc-8x8-unorm": true,
        "astc-8x8-unorm-srgb": true,
        "astc-10x5-unorm": true,
        "astc-10x5-unorm-srgb": true,
        "astc-10x6-unorm": true,
        "astc-10x6-unorm-srgb": true,
        "astc-10x8-unorm": true,
        "astc-10x8-unorm-srgb": true,
        "astc-10x10-unorm": true,
        "astc-10x10-unorm-srgb": true,
        "astc-12x10-unorm": true,
        "astc-12x10-unorm-srgb": true,
        "astc-12x12-unorm": true,
        "astc-12x12-unorm-srgb": true
      };
      glUploadCompressedTextureResource = {
        id: "compressed",
        upload(source3, glTexture, gl) {
          gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
          let mipWidth = source3.pixelWidth;
          let mipHeight = source3.pixelHeight;
          const compressed = !!compressedFormatMap[source3.format];
          for (let i2 = 0; i2 < source3.resource.length; i2++) {
            const levelBuffer = source3.resource[i2];
            if (compressed) {
              gl.compressedTexImage2D(
                gl.TEXTURE_2D,
                i2,
                glTexture.internalFormat,
                mipWidth,
                mipHeight,
                0,
                levelBuffer
              );
            } else {
              gl.texImage2D(
                gl.TEXTURE_2D,
                i2,
                glTexture.internalFormat,
                mipWidth,
                mipHeight,
                0,
                glTexture.format,
                glTexture.type,
                levelBuffer
              );
            }
            mipWidth = Math.max(mipWidth >> 1, 1);
            mipHeight = Math.max(mipHeight >> 1, 1);
          }
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs
  var glUploadImageResource;
  var init_glUploadImageResource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs"() {
      "use strict";
      glUploadImageResource = {
        id: "image",
        upload(source3, glTexture, gl, webGLVersion) {
          const premultipliedAlpha = source3.alphaMode === "premultiply-alpha-on-upload";
          gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);
          const glWidth = glTexture.width;
          const glHeight = glTexture.height;
          const textureWidth = source3.pixelWidth;
          const textureHeight = source3.pixelHeight;
          const resourceWidth = source3.resourceWidth;
          const resourceHeight = source3.resourceHeight;
          if (resourceWidth < textureWidth || resourceHeight < textureHeight) {
            if (glWidth !== textureWidth || glHeight !== textureHeight) {
              gl.texImage2D(
                glTexture.target,
                0,
                glTexture.internalFormat,
                textureWidth,
                textureHeight,
                0,
                glTexture.format,
                glTexture.type,
                null
              );
            }
            if (webGLVersion === 2) {
              gl.texSubImage2D(
                gl.TEXTURE_2D,
                0,
                0,
                0,
                resourceWidth,
                resourceHeight,
                glTexture.format,
                glTexture.type,
                source3.resource
              );
            } else {
              gl.texSubImage2D(
                gl.TEXTURE_2D,
                0,
                0,
                0,
                glTexture.format,
                glTexture.type,
                source3.resource
              );
            }
          } else if (glWidth === textureWidth || glHeight === textureHeight) {
            gl.texSubImage2D(
              gl.TEXTURE_2D,
              0,
              0,
              0,
              glTexture.format,
              glTexture.type,
              source3.resource
            );
          } else if (webGLVersion === 2) {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              textureWidth,
              textureHeight,
              0,
              glTexture.format,
              glTexture.type,
              source3.resource
            );
          } else {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              glTexture.format,
              glTexture.type,
              source3.resource
            );
          }
          glTexture.width = textureWidth;
          glTexture.height = textureHeight;
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs
  var glUploadVideoResource;
  var init_glUploadVideoResource = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs"() {
      init_glUploadImageResource();
      glUploadVideoResource = {
        id: "video",
        upload(source3, glTexture, gl, webGLVersion) {
          if (!source3.isValid) {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              1,
              1,
              0,
              glTexture.format,
              glTexture.type,
              null
            );
            return;
          }
          glUploadImageResource.upload(source3, glTexture, gl, webGLVersion);
        }
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs
  var scaleModeToGlFilter, mipmapScaleModeToGlFilter, wrapModeToGlAddress, compareModeToGlCompare;
  var init_pixiToGlMaps = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs"() {
      "use strict";
      scaleModeToGlFilter = {
        linear: 9729,
        nearest: 9728
      };
      mipmapScaleModeToGlFilter = {
        linear: {
          linear: 9987,
          nearest: 9985
        },
        nearest: {
          linear: 9986,
          nearest: 9984
        }
      };
      wrapModeToGlAddress = {
        "clamp-to-edge": 33071,
        repeat: 10497,
        "mirror-repeat": 33648
      };
      compareModeToGlCompare = {
        never: 512,
        less: 513,
        equal: 514,
        "less-equal": 515,
        greater: 516,
        "not-equal": 517,
        "greater-equal": 518,
        always: 519
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs
  function applyStyleParams(style3, gl, mipmaps, anisotropicExt, glFunctionName, firstParam, forceClamp, firstCreation) {
    const castParam = firstParam;
    if (!firstCreation || style3.addressModeU !== "repeat" || style3.addressModeV !== "repeat" || style3.addressModeW !== "repeat") {
      const wrapModeS = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style3.addressModeU];
      const wrapModeT = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style3.addressModeV];
      const wrapModeR = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style3.addressModeW];
      gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeS);
      gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeT);
      if (gl.TEXTURE_WRAP_R)
        gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeR);
    }
    if (!firstCreation || style3.magFilter !== "linear") {
      gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style3.magFilter]);
    }
    if (mipmaps) {
      if (!firstCreation || style3.mipmapFilter !== "linear") {
        const glFilterMode = mipmapScaleModeToGlFilter[style3.minFilter][style3.mipmapFilter];
        gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);
      }
    } else {
      gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style3.minFilter]);
    }
    if (anisotropicExt && style3.maxAnisotropy > 1) {
      const level = Math.min(style3.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
      gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
    }
    if (style3.compare) {
      gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style3.compare]);
    }
  }
  var init_applyStyleParams = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs"() {
      init_pixiToGlMaps();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs
  function mapFormatToGlFormat(gl) {
    return {
      // 8-bit formats
      r8unorm: gl.RED,
      r8snorm: gl.RED,
      r8uint: gl.RED,
      r8sint: gl.RED,
      // 16-bit formats
      r16uint: gl.RED,
      r16sint: gl.RED,
      r16float: gl.RED,
      rg8unorm: gl.RG,
      rg8snorm: gl.RG,
      rg8uint: gl.RG,
      rg8sint: gl.RG,
      // 32-bit formats
      r32uint: gl.RED,
      r32sint: gl.RED,
      r32float: gl.RED,
      rg16uint: gl.RG,
      rg16sint: gl.RG,
      rg16float: gl.RG,
      rgba8unorm: gl.RGBA,
      "rgba8unorm-srgb": gl.RGBA,
      // Packed 32-bit formats
      rgba8snorm: gl.RGBA,
      rgba8uint: gl.RGBA,
      rgba8sint: gl.RGBA,
      bgra8unorm: gl.RGBA,
      "bgra8unorm-srgb": gl.RGBA,
      rgb9e5ufloat: gl.RGB,
      rgb10a2unorm: gl.RGBA,
      rg11b10ufloat: gl.RGB,
      // 64-bit formats
      rg32uint: gl.RG,
      rg32sint: gl.RG,
      rg32float: gl.RG,
      rgba16uint: gl.RGBA,
      rgba16sint: gl.RGBA,
      rgba16float: gl.RGBA,
      // 128-bit formats
      rgba32uint: gl.RGBA,
      rgba32sint: gl.RGBA,
      rgba32float: gl.RGBA,
      // Depth/stencil formats
      stencil8: gl.STENCIL_INDEX8,
      depth16unorm: gl.DEPTH_COMPONENT,
      depth24plus: gl.DEPTH_COMPONENT,
      "depth24plus-stencil8": gl.DEPTH_STENCIL,
      depth32float: gl.DEPTH_COMPONENT,
      "depth32float-stencil8": gl.DEPTH_STENCIL
    };
  }
  var init_mapFormatToGlFormat = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs
  function mapFormatToGlInternalFormat(gl, extensions2) {
    let srgb = {};
    let bgra8unorm = gl.RGBA;
    if (!(gl instanceof DOMAdapter.get().getWebGLRenderingContext())) {
      srgb = {
        "rgba8unorm-srgb": gl.SRGB8_ALPHA8,
        "bgra8unorm-srgb": gl.SRGB8_ALPHA8
      };
      bgra8unorm = gl.RGBA8;
    } else if (extensions2.srgb) {
      srgb = {
        "rgba8unorm-srgb": extensions2.srgb.SRGB8_ALPHA8_EXT,
        "bgra8unorm-srgb": extensions2.srgb.SRGB8_ALPHA8_EXT
      };
    }
    return {
      // 8-bit formats
      r8unorm: gl.R8,
      r8snorm: gl.R8_SNORM,
      r8uint: gl.R8UI,
      r8sint: gl.R8I,
      // 16-bit formats
      r16uint: gl.R16UI,
      r16sint: gl.R16I,
      r16float: gl.R16F,
      rg8unorm: gl.RG8,
      rg8snorm: gl.RG8_SNORM,
      rg8uint: gl.RG8UI,
      rg8sint: gl.RG8I,
      // 32-bit formats
      r32uint: gl.R32UI,
      r32sint: gl.R32I,
      r32float: gl.R32F,
      rg16uint: gl.RG16UI,
      rg16sint: gl.RG16I,
      rg16float: gl.RG16F,
      rgba8unorm: gl.RGBA,
      ...srgb,
      // Packed 32-bit formats
      rgba8snorm: gl.RGBA8_SNORM,
      rgba8uint: gl.RGBA8UI,
      rgba8sint: gl.RGBA8I,
      bgra8unorm,
      rgb9e5ufloat: gl.RGB9_E5,
      rgb10a2unorm: gl.RGB10_A2,
      rg11b10ufloat: gl.R11F_G11F_B10F,
      // 64-bit formats
      rg32uint: gl.RG32UI,
      rg32sint: gl.RG32I,
      rg32float: gl.RG32F,
      rgba16uint: gl.RGBA16UI,
      rgba16sint: gl.RGBA16I,
      rgba16float: gl.RGBA16F,
      // 128-bit formats
      rgba32uint: gl.RGBA32UI,
      rgba32sint: gl.RGBA32I,
      rgba32float: gl.RGBA32F,
      // Depth/stencil formats
      stencil8: gl.STENCIL_INDEX8,
      depth16unorm: gl.DEPTH_COMPONENT16,
      depth24plus: gl.DEPTH_COMPONENT24,
      "depth24plus-stencil8": gl.DEPTH24_STENCIL8,
      depth32float: gl.DEPTH_COMPONENT32F,
      "depth32float-stencil8": gl.DEPTH32F_STENCIL8,
      // Compressed formats
      ...extensions2.s3tc ? {
        "bc1-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        "bc2-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        "bc3-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT
      } : {},
      ...extensions2.s3tc_sRGB ? {
        "bc1-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
        "bc2-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
        "bc3-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
      } : {},
      ...extensions2.rgtc ? {
        "bc4-r-unorm": extensions2.rgtc.COMPRESSED_RED_RGTC1_EXT,
        "bc4-r-snorm": extensions2.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
        "bc5-rg-unorm": extensions2.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
        "bc5-rg-snorm": extensions2.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
      } : {},
      ...extensions2.bptc ? {
        "bc6h-rgb-float": extensions2.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
        "bc6h-rgb-ufloat": extensions2.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
        "bc7-rgba-unorm": extensions2.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
        "bc7-rgba-unorm-srgb": extensions2.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
      } : {},
      ...extensions2.etc ? {
        "etc2-rgb8unorm": extensions2.etc.COMPRESSED_RGB8_ETC2,
        "etc2-rgb8unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_ETC2,
        "etc2-rgb8a1unorm": extensions2.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
        "etc2-rgb8a1unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
        "etc2-rgba8unorm": extensions2.etc.COMPRESSED_RGBA8_ETC2_EAC,
        "etc2-rgba8unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
        "eac-r11unorm": extensions2.etc.COMPRESSED_R11_EAC,
        // 'eac-r11snorm'
        "eac-rg11unorm": extensions2.etc.COMPRESSED_SIGNED_RG11_EAC
        // 'eac-rg11snorm'
      } : {},
      ...extensions2.astc ? {
        "astc-4x4-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
        "astc-4x4-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
        "astc-5x4-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
        "astc-5x4-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
        "astc-5x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
        "astc-5x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
        "astc-6x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
        "astc-6x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
        "astc-6x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
        "astc-6x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
        "astc-8x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
        "astc-8x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
        "astc-8x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
        "astc-8x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
        "astc-8x8-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
        "astc-8x8-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
        "astc-10x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
        "astc-10x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
        "astc-10x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
        "astc-10x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
        "astc-10x8-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
        "astc-10x8-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
        "astc-10x10-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
        "astc-10x10-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
        "astc-12x10-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
        "astc-12x10-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
        "astc-12x12-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
        "astc-12x12-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
      } : {}
    };
  }
  var init_mapFormatToGlInternalFormat = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs"() {
      init_adapter();
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs
  function mapFormatToGlType(gl) {
    return {
      // 8-bit formats
      r8unorm: gl.UNSIGNED_BYTE,
      r8snorm: gl.BYTE,
      r8uint: gl.UNSIGNED_BYTE,
      r8sint: gl.BYTE,
      // 16-bit formats
      r16uint: gl.UNSIGNED_SHORT,
      r16sint: gl.SHORT,
      r16float: gl.HALF_FLOAT,
      rg8unorm: gl.UNSIGNED_BYTE,
      rg8snorm: gl.BYTE,
      rg8uint: gl.UNSIGNED_BYTE,
      rg8sint: gl.BYTE,
      // 32-bit formats
      r32uint: gl.UNSIGNED_INT,
      r32sint: gl.INT,
      r32float: gl.FLOAT,
      rg16uint: gl.UNSIGNED_SHORT,
      rg16sint: gl.SHORT,
      rg16float: gl.HALF_FLOAT,
      rgba8unorm: gl.UNSIGNED_BYTE,
      "rgba8unorm-srgb": gl.UNSIGNED_BYTE,
      // Packed 32-bit formats
      rgba8snorm: gl.BYTE,
      rgba8uint: gl.UNSIGNED_BYTE,
      rgba8sint: gl.BYTE,
      bgra8unorm: gl.UNSIGNED_BYTE,
      "bgra8unorm-srgb": gl.UNSIGNED_BYTE,
      rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,
      rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,
      rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,
      // 64-bit formats
      rg32uint: gl.UNSIGNED_INT,
      rg32sint: gl.INT,
      rg32float: gl.FLOAT,
      rgba16uint: gl.UNSIGNED_SHORT,
      rgba16sint: gl.SHORT,
      rgba16float: gl.HALF_FLOAT,
      // 128-bit formats
      rgba32uint: gl.UNSIGNED_INT,
      rgba32sint: gl.INT,
      rgba32float: gl.FLOAT,
      // Depth/stencil formats
      stencil8: gl.UNSIGNED_BYTE,
      depth16unorm: gl.UNSIGNED_SHORT,
      depth24plus: gl.UNSIGNED_INT,
      "depth24plus-stencil8": gl.UNSIGNED_INT_24_8,
      depth32float: gl.FLOAT,
      "depth32float-stencil8": gl.FLOAT_32_UNSIGNED_INT_24_8_REV
    };
  }
  var init_mapFormatToGlType = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs
  var BYTES_PER_PIXEL, GlTextureSystem;
  var init_GlTextureSystem = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs"() {
      init_adapter();
      init_Extensions();
      init_Texture();
      init_GlTexture();
      init_glUploadBufferImageResource();
      init_glUploadCompressedTextureResource();
      init_glUploadImageResource();
      init_glUploadVideoResource();
      init_applyStyleParams();
      init_mapFormatToGlFormat();
      init_mapFormatToGlInternalFormat();
      init_mapFormatToGlType();
      BYTES_PER_PIXEL = 4;
      GlTextureSystem = class {
        constructor(renderer) {
          this.managedTextures = [];
          this._glTextures = /* @__PURE__ */ Object.create(null);
          this._glSamplers = /* @__PURE__ */ Object.create(null);
          this._boundTextures = [];
          this._activeTextureLocation = -1;
          this._boundSamplers = /* @__PURE__ */ Object.create(null);
          this._uploads = {
            image: glUploadImageResource,
            buffer: glUploadBufferImageResource,
            video: glUploadVideoResource,
            compressed: glUploadCompressedTextureResource
          };
          this._useSeparateSamplers = false;
          this._renderer = renderer;
          this._renderer.renderableGC.addManagedHash(this, "_glTextures");
          this._renderer.renderableGC.addManagedHash(this, "_glSamplers");
        }
        contextChange(gl) {
          this._gl = gl;
          if (!this._mapFormatToInternalFormat) {
            this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl, this._renderer.context.extensions);
            this._mapFormatToType = mapFormatToGlType(gl);
            this._mapFormatToFormat = mapFormatToGlFormat(gl);
          }
          this._glTextures = /* @__PURE__ */ Object.create(null);
          this._glSamplers = /* @__PURE__ */ Object.create(null);
          this._boundSamplers = /* @__PURE__ */ Object.create(null);
          for (let i2 = 0; i2 < 16; i2++) {
            this.bind(Texture.EMPTY, i2);
          }
        }
        initSource(source3) {
          this.bind(source3);
        }
        bind(texture, location2 = 0) {
          const source3 = texture.source;
          if (texture) {
            this.bindSource(source3, location2);
            if (this._useSeparateSamplers) {
              this._bindSampler(source3.style, location2);
            }
          } else {
            this.bindSource(null, location2);
            if (this._useSeparateSamplers) {
              this._bindSampler(null, location2);
            }
          }
        }
        bindSource(source3, location2 = 0) {
          const gl = this._gl;
          source3._touched = this._renderer.textureGC.count;
          if (this._boundTextures[location2] !== source3) {
            this._boundTextures[location2] = source3;
            this._activateLocation(location2);
            source3 = source3 || Texture.EMPTY.source;
            const glTexture = this.getGlSource(source3);
            gl.bindTexture(glTexture.target, glTexture.texture);
          }
        }
        _bindSampler(style3, location2 = 0) {
          const gl = this._gl;
          if (!style3) {
            this._boundSamplers[location2] = null;
            gl.bindSampler(location2, null);
            return;
          }
          const sampler = this._getGlSampler(style3);
          if (this._boundSamplers[location2] !== sampler) {
            this._boundSamplers[location2] = sampler;
            gl.bindSampler(location2, sampler);
          }
        }
        unbind(texture) {
          const source3 = texture.source;
          const boundTextures = this._boundTextures;
          const gl = this._gl;
          for (let i2 = 0; i2 < boundTextures.length; i2++) {
            if (boundTextures[i2] === source3) {
              this._activateLocation(i2);
              const glTexture = this.getGlSource(source3);
              gl.bindTexture(glTexture.target, null);
              boundTextures[i2] = null;
            }
          }
        }
        _activateLocation(location2) {
          if (this._activeTextureLocation !== location2) {
            this._activeTextureLocation = location2;
            this._gl.activeTexture(this._gl.TEXTURE0 + location2);
          }
        }
        _initSource(source3) {
          const gl = this._gl;
          const glTexture = new GlTexture(gl.createTexture());
          glTexture.type = this._mapFormatToType[source3.format];
          glTexture.internalFormat = this._mapFormatToInternalFormat[source3.format];
          glTexture.format = this._mapFormatToFormat[source3.format];
          if (source3.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source3.isPowerOfTwo)) {
            const biggestDimension = Math.max(source3.width, source3.height);
            source3.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
          }
          this._glTextures[source3.uid] = glTexture;
          if (!this.managedTextures.includes(source3)) {
            source3.on("update", this.onSourceUpdate, this);
            source3.on("resize", this.onSourceUpdate, this);
            source3.on("styleChange", this.onStyleChange, this);
            source3.on("destroy", this.onSourceDestroy, this);
            source3.on("unload", this.onSourceUnload, this);
            source3.on("updateMipmaps", this.onUpdateMipmaps, this);
            this.managedTextures.push(source3);
          }
          this.onSourceUpdate(source3);
          this.updateStyle(source3, false);
          return glTexture;
        }
        onStyleChange(source3) {
          this.updateStyle(source3, false);
        }
        updateStyle(source3, firstCreation) {
          const gl = this._gl;
          const glTexture = this.getGlSource(source3);
          gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
          this._boundTextures[this._activeTextureLocation] = source3;
          applyStyleParams(
            source3.style,
            gl,
            source3.mipLevelCount > 1,
            this._renderer.context.extensions.anisotropicFiltering,
            "texParameteri",
            gl.TEXTURE_2D,
            // will force a clamp to edge if the texture is not a power of two
            !this._renderer.context.supports.nonPowOf2wrapping && !source3.isPowerOfTwo,
            firstCreation
          );
        }
        onSourceUnload(source3) {
          const glTexture = this._glTextures[source3.uid];
          if (!glTexture)
            return;
          this.unbind(source3);
          this._glTextures[source3.uid] = null;
          this._gl.deleteTexture(glTexture.texture);
        }
        onSourceUpdate(source3) {
          const gl = this._gl;
          const glTexture = this.getGlSource(source3);
          gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
          this._boundTextures[this._activeTextureLocation] = source3;
          if (this._uploads[source3.uploadMethodId]) {
            this._uploads[source3.uploadMethodId].upload(source3, glTexture, gl, this._renderer.context.webGLVersion);
          } else {
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source3.pixelWidth, source3.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
          }
          if (source3.autoGenerateMipmaps && source3.mipLevelCount > 1) {
            this.onUpdateMipmaps(source3, false);
          }
        }
        onUpdateMipmaps(source3, bind8 = true) {
          if (bind8)
            this.bindSource(source3, 0);
          const glTexture = this.getGlSource(source3);
          this._gl.generateMipmap(glTexture.target);
        }
        onSourceDestroy(source3) {
          source3.off("destroy", this.onSourceDestroy, this);
          source3.off("update", this.onSourceUpdate, this);
          source3.off("resize", this.onSourceUpdate, this);
          source3.off("unload", this.onSourceUnload, this);
          source3.off("styleChange", this.onStyleChange, this);
          source3.off("updateMipmaps", this.onUpdateMipmaps, this);
          this.managedTextures.splice(this.managedTextures.indexOf(source3), 1);
          this.onSourceUnload(source3);
        }
        _initSampler(style3) {
          const gl = this._gl;
          const glSampler = this._gl.createSampler();
          this._glSamplers[style3._resourceId] = glSampler;
          applyStyleParams(
            style3,
            gl,
            this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,
            this._renderer.context.extensions.anisotropicFiltering,
            "samplerParameteri",
            glSampler,
            false,
            true
          );
          return this._glSamplers[style3._resourceId];
        }
        _getGlSampler(sampler) {
          return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);
        }
        getGlSource(source3) {
          return this._glTextures[source3.uid] || this._initSource(source3);
        }
        generateCanvas(texture) {
          const { pixels, width: width8, height: height8 } = this.getPixels(texture);
          const canvas2 = DOMAdapter.get().createCanvas();
          canvas2.width = width8;
          canvas2.height = height8;
          const ctx = canvas2.getContext("2d");
          if (ctx) {
            const imageData = ctx.createImageData(width8, height8);
            imageData.data.set(pixels);
            ctx.putImageData(imageData, 0, 0);
          }
          return canvas2;
        }
        getPixels(texture) {
          const resolution = texture.source.resolution;
          const frame = texture.frame;
          const width8 = Math.max(Math.round(frame.width * resolution), 1);
          const height8 = Math.max(Math.round(frame.height * resolution), 1);
          const pixels = new Uint8Array(BYTES_PER_PIXEL * width8 * height8);
          const renderer = this._renderer;
          const renderTarget = renderer.renderTarget.getRenderTarget(texture);
          const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);
          const gl = renderer.gl;
          gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);
          gl.readPixels(
            Math.round(frame.x * resolution),
            Math.round(frame.y * resolution),
            width8,
            height8,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            pixels
          );
          if (false) {
            unpremultiplyAlpha(pixels);
          }
          return { pixels: new Uint8ClampedArray(pixels.buffer), width: width8, height: height8 };
        }
        destroy() {
          this.managedTextures.slice().forEach((source3) => this.onSourceDestroy(source3));
          this.managedTextures = null;
          this._renderer = null;
        }
      };
      GlTextureSystem.extension = {
        type: [
          ExtensionType.WebGLSystem
        ],
        name: "texture"
      };
    }
  });

  // node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs
  var WebGLRenderer_exports = {};
  __export(WebGLRenderer_exports, {
    WebGLRenderer: () => WebGLRenderer
  });
  var DefaultWebGLSystems, DefaultWebGLPipes, DefaultWebGLAdapters, systems2, renderPipes2, renderPipeAdaptors2, WebGLRenderer;
  var init_WebGLRenderer = __esm({
    "node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs"() {
      init_Extensions();
      init_GlGraphicsAdaptor();
      init_GlMeshAdaptor();
      init_GlBatchAdaptor();
      init_AbstractRenderer();
      init_SharedSystems();
      init_types2();
      init_GlBufferSystem();
      init_GlContextSystem();
      init_GlGeometrySystem();
      init_GlBackBufferSystem();
      init_GlColorMaskSystem();
      init_GlEncoderSystem();
      init_GlStencilSystem();
      init_GlUboSystem();
      init_GlRenderTargetSystem();
      init_GlShaderSystem();
      init_GlUniformGroupSystem();
      init_GlStateSystem();
      init_GlTextureSystem();
      DefaultWebGLSystems = [
        ...SharedSystems,
        GlUboSystem,
        GlBackBufferSystem,
        GlContextSystem,
        GlBufferSystem,
        GlTextureSystem,
        GlRenderTargetSystem,
        GlGeometrySystem,
        GlUniformGroupSystem,
        GlShaderSystem,
        GlEncoderSystem,
        GlStateSystem,
        GlStencilSystem,
        GlColorMaskSystem
      ];
      DefaultWebGLPipes = [...SharedRenderPipes];
      DefaultWebGLAdapters = [GlBatchAdaptor, GlMeshAdaptor, GlGraphicsAdaptor];
      systems2 = [];
      renderPipes2 = [];
      renderPipeAdaptors2 = [];
      extensions.handleByNamedList(ExtensionType.WebGLSystem, systems2);
      extensions.handleByNamedList(ExtensionType.WebGLPipes, renderPipes2);
      extensions.handleByNamedList(ExtensionType.WebGLPipesAdaptor, renderPipeAdaptors2);
      extensions.add(...DefaultWebGLSystems, ...DefaultWebGLPipes, ...DefaultWebGLAdapters);
      WebGLRenderer = class extends AbstractRenderer {
        constructor() {
          const systemConfig = {
            name: "webgl",
            type: RendererType.WEBGL,
            systems: systems2,
            renderPipes: renderPipes2,
            renderPipeAdaptors: renderPipeAdaptors2
          };
          super(systemConfig);
        }
      };
    }
  });

  // output/Control.Apply/foreign.js
  var arrayApply = function(fs) {
    return function(xs) {
      var l2 = fs.length;
      var k2 = xs.length;
      var result = new Array(l2 * k2);
      var n2 = 0;
      for (var i2 = 0; i2 < l2; i2++) {
        var f2 = fs[i2];
        for (var j2 = 0; j2 < k2; j2++) {
          result[n2++] = f2(xs[j2]);
        }
      }
      return result;
    };
  };

  // output/Control.Semigroupoid/index.js
  var semigroupoidFn = {
    compose: function(f2) {
      return function(g2) {
        return function(x2) {
          return f2(g2(x2));
        };
      };
    }
  };
  var compose = function(dict) {
    return dict.compose;
  };

  // output/Control.Category/index.js
  var identity = function(dict) {
    return dict.identity;
  };
  var categoryFn = {
    identity: function(x2) {
      return x2;
    },
    Semigroupoid0: function() {
      return semigroupoidFn;
    }
  };

  // output/Data.Boolean/index.js
  var otherwise = true;

  // output/Data.Function/index.js
  var flip = function(f2) {
    return function(b2) {
      return function(a2) {
        return f2(a2)(b2);
      };
    };
  };
  var $$const = function(a2) {
    return function(v2) {
      return a2;
    };
  };

  // output/Data.Functor/foreign.js
  var arrayMap = function(f2) {
    return function(arr) {
      var l2 = arr.length;
      var result = new Array(l2);
      for (var i2 = 0; i2 < l2; i2++) {
        result[i2] = f2(arr[i2]);
      }
      return result;
    };
  };

  // output/Data.Unit/foreign.js
  var unit = void 0;

  // output/Type.Proxy/index.js
  var $$Proxy = /* @__PURE__ */ function() {
    function $$Proxy2() {
    }
    ;
    $$Proxy2.value = new $$Proxy2();
    return $$Proxy2;
  }();

  // output/Data.Functor/index.js
  var map = function(dict) {
    return dict.map;
  };
  var mapFlipped = function(dictFunctor) {
    var map110 = map(dictFunctor);
    return function(fa) {
      return function(f2) {
        return map110(f2)(fa);
      };
    };
  };
  var $$void = function(dictFunctor) {
    return map(dictFunctor)($$const(unit));
  };
  var functorFn = {
    map: /* @__PURE__ */ compose(semigroupoidFn)
  };
  var functorArray = {
    map: arrayMap
  };

  // output/Control.Apply/index.js
  var identity2 = /* @__PURE__ */ identity(categoryFn);
  var applyFn = {
    apply: function(f2) {
      return function(g2) {
        return function(x2) {
          return f2(x2)(g2(x2));
        };
      };
    },
    Functor0: function() {
      return functorFn;
    }
  };
  var applyArray = {
    apply: arrayApply,
    Functor0: function() {
      return functorArray;
    }
  };
  var apply = function(dict) {
    return dict.apply;
  };
  var applySecond = function(dictApply) {
    var apply1 = apply(dictApply);
    var map27 = map(dictApply.Functor0());
    return function(a2) {
      return function(b2) {
        return apply1(map27($$const(identity2))(a2))(b2);
      };
    };
  };

  // output/Control.Applicative/index.js
  var pure = function(dict) {
    return dict.pure;
  };
  var when = function(dictApplicative) {
    var pure19 = pure(dictApplicative);
    return function(v2) {
      return function(v1) {
        if (v2) {
          return v1;
        }
        ;
        if (!v2) {
          return pure19(unit);
        }
        ;
        throw new Error("Failed pattern match at Control.Applicative (line 63, column 1 - line 63, column 63): " + [v2.constructor.name, v1.constructor.name]);
      };
    };
  };
  var liftA1 = function(dictApplicative) {
    var apply5 = apply(dictApplicative.Apply0());
    var pure19 = pure(dictApplicative);
    return function(f2) {
      return function(a2) {
        return apply5(pure19(f2))(a2);
      };
    };
  };
  var applicativeFn = {
    pure: function(x2) {
      return function(v2) {
        return x2;
      };
    },
    Apply0: function() {
      return applyFn;
    }
  };
  var applicativeArray = {
    pure: function(x2) {
      return [x2];
    },
    Apply0: function() {
      return applyArray;
    }
  };

  // output/Control.Bind/foreign.js
  var arrayBind = function(arr) {
    return function(f2) {
      var result = [];
      for (var i2 = 0, l2 = arr.length; i2 < l2; i2++) {
        Array.prototype.push.apply(result, f2(arr[i2]));
      }
      return result;
    };
  };

  // output/Control.Bind/index.js
  var discard = function(dict) {
    return dict.discard;
  };
  var bindFn = {
    bind: function(m2) {
      return function(f2) {
        return function(x2) {
          return f2(m2(x2))(x2);
        };
      };
    },
    Apply0: function() {
      return applyFn;
    }
  };
  var bindArray = {
    bind: arrayBind,
    Apply0: function() {
      return applyArray;
    }
  };
  var bind = function(dict) {
    return dict.bind;
  };
  var bindFlipped = function(dictBind) {
    return flip(bind(dictBind));
  };
  var composeKleisliFlipped = function(dictBind) {
    var bindFlipped1 = bindFlipped(dictBind);
    return function(f2) {
      return function(g2) {
        return function(a2) {
          return bindFlipped1(f2)(g2(a2));
        };
      };
    };
  };
  var discardUnit = {
    discard: function(dictBind) {
      return bind(dictBind);
    }
  };

  // output/Control.Monad/index.js
  var monadFn = {
    Applicative0: function() {
      return applicativeFn;
    },
    Bind1: function() {
      return bindFn;
    }
  };
  var ap = function(dictMonad) {
    var bind8 = bind(dictMonad.Bind1());
    var pure19 = pure(dictMonad.Applicative0());
    return function(f2) {
      return function(a2) {
        return bind8(f2)(function(f$prime) {
          return bind8(a2)(function(a$prime) {
            return pure19(f$prime(a$prime));
          });
        });
      };
    };
  };

  // output/Control.Monad.Reader.Class/index.js
  var monadAskFun = {
    ask: /* @__PURE__ */ identity(categoryFn),
    Monad0: function() {
      return monadFn;
    }
  };
  var ask = function(dict) {
    return dict.ask;
  };

  // output/Unsafe.Coerce/foreign.js
  var unsafeCoerce = function(x2) {
    return x2;
  };

  // output/Control.Monad.ST.Internal/foreign.js
  var map_ = function(f2) {
    return function(a2) {
      return function() {
        return f2(a2());
      };
    };
  };
  var foreach = function(as) {
    return function(f2) {
      return function() {
        for (var i2 = 0, l2 = as.length; i2 < l2; i2++) {
          f2(as[i2])();
        }
      };
    };
  };

  // output/Data.Semigroup/foreign.js
  var concatString = function(s1) {
    return function(s2) {
      return s1 + s2;
    };
  };
  var concatArray = function(xs) {
    return function(ys) {
      if (xs.length === 0) return ys;
      if (ys.length === 0) return xs;
      return xs.concat(ys);
    };
  };

  // output/Data.Symbol/index.js
  var reflectSymbol = function(dict) {
    return dict.reflectSymbol;
  };

  // output/Record.Unsafe/foreign.js
  var unsafeGet = function(label4) {
    return function(rec) {
      return rec[label4];
    };
  };

  // output/Data.Semigroup/index.js
  var semigroupString = {
    append: concatString
  };
  var semigroupArray = {
    append: concatArray
  };
  var append = function(dict) {
    return dict.append;
  };

  // output/Control.Alt/index.js
  var alt = function(dict) {
    return dict.alt;
  };

  // output/Data.Bounded/foreign.js
  var topInt = 2147483647;
  var bottomInt = -2147483648;
  var topChar = String.fromCharCode(65535);
  var bottomChar = String.fromCharCode(0);
  var topNumber = Number.POSITIVE_INFINITY;
  var bottomNumber = Number.NEGATIVE_INFINITY;

  // output/Data.Ord/foreign.js
  var unsafeCompareImpl = function(lt2) {
    return function(eq3) {
      return function(gt) {
        return function(x2) {
          return function(y2) {
            return x2 < y2 ? lt2 : x2 === y2 ? eq3 : gt;
          };
        };
      };
    };
  };
  var ordIntImpl = unsafeCompareImpl;
  var ordNumberImpl = unsafeCompareImpl;
  var ordStringImpl = unsafeCompareImpl;
  var ordCharImpl = unsafeCompareImpl;

  // output/Data.Eq/foreign.js
  var refEq = function(r1) {
    return function(r2) {
      return r1 === r2;
    };
  };
  var eqBooleanImpl = refEq;
  var eqIntImpl = refEq;
  var eqNumberImpl = refEq;
  var eqCharImpl = refEq;
  var eqStringImpl = refEq;
  var eqArrayImpl = function(f2) {
    return function(xs) {
      return function(ys) {
        if (xs.length !== ys.length) return false;
        for (var i2 = 0; i2 < xs.length; i2++) {
          if (!f2(xs[i2])(ys[i2])) return false;
        }
        return true;
      };
    };
  };

  // output/Data.Eq/index.js
  var eqString = {
    eq: eqStringImpl
  };
  var eqRowNil = {
    eqRecord: function(v2) {
      return function(v1) {
        return function(v22) {
          return true;
        };
      };
    }
  };
  var eqRecord = function(dict) {
    return dict.eqRecord;
  };
  var eqRec = function() {
    return function(dictEqRecord) {
      return {
        eq: eqRecord(dictEqRecord)($$Proxy.value)
      };
    };
  };
  var eqNumber = {
    eq: eqNumberImpl
  };
  var eqInt = {
    eq: eqIntImpl
  };
  var eqChar = {
    eq: eqCharImpl
  };
  var eqBoolean = {
    eq: eqBooleanImpl
  };
  var eq1 = function(dict) {
    return dict.eq1;
  };
  var eq = function(dict) {
    return dict.eq;
  };
  var eq2 = /* @__PURE__ */ eq(eqBoolean);
  var eqArray = function(dictEq) {
    return {
      eq: eqArrayImpl(eq(dictEq))
    };
  };
  var eqRowCons = function(dictEqRecord) {
    var eqRecord1 = eqRecord(dictEqRecord);
    return function() {
      return function(dictIsSymbol) {
        var reflectSymbol2 = reflectSymbol(dictIsSymbol);
        return function(dictEq) {
          var eq3 = eq(dictEq);
          return {
            eqRecord: function(v2) {
              return function(ra) {
                return function(rb) {
                  var tail4 = eqRecord1($$Proxy.value)(ra)(rb);
                  var key = reflectSymbol2($$Proxy.value);
                  var get4 = unsafeGet(key);
                  return eq3(get4(ra))(get4(rb)) && tail4;
                };
              };
            }
          };
        };
      };
    };
  };
  var notEq = function(dictEq) {
    var eq3 = eq(dictEq);
    return function(x2) {
      return function(y2) {
        return eq2(eq3(x2)(y2))(false);
      };
    };
  };

  // output/Data.Ordering/index.js
  var LT = /* @__PURE__ */ function() {
    function LT2() {
    }
    ;
    LT2.value = new LT2();
    return LT2;
  }();
  var GT = /* @__PURE__ */ function() {
    function GT2() {
    }
    ;
    GT2.value = new GT2();
    return GT2;
  }();
  var EQ = /* @__PURE__ */ function() {
    function EQ2() {
    }
    ;
    EQ2.value = new EQ2();
    return EQ2;
  }();

  // output/Data.Ring/foreign.js
  var intSub = function(x2) {
    return function(y2) {
      return x2 - y2 | 0;
    };
  };

  // output/Data.Semiring/foreign.js
  var intAdd = function(x2) {
    return function(y2) {
      return x2 + y2 | 0;
    };
  };
  var intMul = function(x2) {
    return function(y2) {
      return x2 * y2 | 0;
    };
  };
  var numAdd = function(n1) {
    return function(n2) {
      return n1 + n2;
    };
  };
  var numMul = function(n1) {
    return function(n2) {
      return n1 * n2;
    };
  };

  // output/Data.Semiring/index.js
  var zero = function(dict) {
    return dict.zero;
  };
  var semiringNumber = {
    add: numAdd,
    zero: 0,
    mul: numMul,
    one: 1
  };
  var semiringInt = {
    add: intAdd,
    zero: 0,
    mul: intMul,
    one: 1
  };
  var one = function(dict) {
    return dict.one;
  };
  var mul = function(dict) {
    return dict.mul;
  };
  var add = function(dict) {
    return dict.add;
  };

  // output/Data.Ring/index.js
  var ringInt = {
    sub: intSub,
    Semiring0: function() {
      return semiringInt;
    }
  };

  // output/Data.Ord/index.js
  var ordString = /* @__PURE__ */ function() {
    return {
      compare: ordStringImpl(LT.value)(EQ.value)(GT.value),
      Eq0: function() {
        return eqString;
      }
    };
  }();
  var ordNumber = /* @__PURE__ */ function() {
    return {
      compare: ordNumberImpl(LT.value)(EQ.value)(GT.value),
      Eq0: function() {
        return eqNumber;
      }
    };
  }();
  var ordInt = /* @__PURE__ */ function() {
    return {
      compare: ordIntImpl(LT.value)(EQ.value)(GT.value),
      Eq0: function() {
        return eqInt;
      }
    };
  }();
  var ordChar = /* @__PURE__ */ function() {
    return {
      compare: ordCharImpl(LT.value)(EQ.value)(GT.value),
      Eq0: function() {
        return eqChar;
      }
    };
  }();
  var compare = function(dict) {
    return dict.compare;
  };
  var max = function(dictOrd) {
    var compare32 = compare(dictOrd);
    return function(x2) {
      return function(y2) {
        var v2 = compare32(x2)(y2);
        if (v2 instanceof LT) {
          return y2;
        }
        ;
        if (v2 instanceof EQ) {
          return x2;
        }
        ;
        if (v2 instanceof GT) {
          return x2;
        }
        ;
        throw new Error("Failed pattern match at Data.Ord (line 181, column 3 - line 184, column 12): " + [v2.constructor.name]);
      };
    };
  };
  var min = function(dictOrd) {
    var compare32 = compare(dictOrd);
    return function(x2) {
      return function(y2) {
        var v2 = compare32(x2)(y2);
        if (v2 instanceof LT) {
          return x2;
        }
        ;
        if (v2 instanceof EQ) {
          return x2;
        }
        ;
        if (v2 instanceof GT) {
          return y2;
        }
        ;
        throw new Error("Failed pattern match at Data.Ord (line 172, column 3 - line 175, column 12): " + [v2.constructor.name]);
      };
    };
  };

  // output/Data.Bounded/index.js
  var top = function(dict) {
    return dict.top;
  };
  var boundedInt = {
    top: topInt,
    bottom: bottomInt,
    Ord0: function() {
      return ordInt;
    }
  };
  var boundedChar = {
    top: topChar,
    bottom: bottomChar,
    Ord0: function() {
      return ordChar;
    }
  };
  var bottom = function(dict) {
    return dict.bottom;
  };

  // output/Data.Show/foreign.js
  var showIntImpl = function(n2) {
    return n2.toString();
  };
  var showNumberImpl = function(n2) {
    var str = n2.toString();
    return isNaN(str + ".0") ? str : str + ".0";
  };
  var showStringImpl = function(s2) {
    var l2 = s2.length;
    return '"' + s2.replace(
      /[\0-\x1F\x7F"\\]/g,
      // eslint-disable-line no-control-regex
      function(c2, i2) {
        switch (c2) {
          case '"':
          case "\\":
            return "\\" + c2;
          case "\x07":
            return "\\a";
          case "\b":
            return "\\b";
          case "\f":
            return "\\f";
          case "\n":
            return "\\n";
          case "\r":
            return "\\r";
          case "	":
            return "\\t";
          case "\v":
            return "\\v";
        }
        var k2 = i2 + 1;
        var empty7 = k2 < l2 && s2[k2] >= "0" && s2[k2] <= "9" ? "\\&" : "";
        return "\\" + c2.charCodeAt(0).toString(10) + empty7;
      }
    ) + '"';
  };
  var showArrayImpl = function(f2) {
    return function(xs) {
      var ss = [];
      for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
        ss[i2] = f2(xs[i2]);
      }
      return "[" + ss.join(",") + "]";
    };
  };

  // output/Data.Show/index.js
  var showUnit = {
    show: function(v2) {
      return "unit";
    }
  };
  var showString = {
    show: showStringImpl
  };
  var showRecordFields = function(dict) {
    return dict.showRecordFields;
  };
  var showRecord = function() {
    return function() {
      return function(dictShowRecordFields) {
        var showRecordFields1 = showRecordFields(dictShowRecordFields);
        return {
          show: function(record) {
            return "{" + (showRecordFields1($$Proxy.value)(record) + "}");
          }
        };
      };
    };
  };
  var showNumber = {
    show: showNumberImpl
  };
  var showInt = {
    show: showIntImpl
  };
  var showBoolean = {
    show: function(v2) {
      if (v2) {
        return "true";
      }
      ;
      if (!v2) {
        return "false";
      }
      ;
      throw new Error("Failed pattern match at Data.Show (line 29, column 1 - line 31, column 23): " + [v2.constructor.name]);
    }
  };
  var show = function(dict) {
    return dict.show;
  };
  var showArray = function(dictShow) {
    return {
      show: showArrayImpl(show(dictShow))
    };
  };
  var showRecordFieldsCons = function(dictIsSymbol) {
    var reflectSymbol2 = reflectSymbol(dictIsSymbol);
    return function(dictShowRecordFields) {
      var showRecordFields1 = showRecordFields(dictShowRecordFields);
      return function(dictShow) {
        var show17 = show(dictShow);
        return {
          showRecordFields: function(v2) {
            return function(record) {
              var tail4 = showRecordFields1($$Proxy.value)(record);
              var key = reflectSymbol2($$Proxy.value);
              var focus2 = unsafeGet(key)(record);
              return " " + (key + (": " + (show17(focus2) + ("," + tail4))));
            };
          }
        };
      };
    };
  };
  var showRecordFieldsConsNil = function(dictIsSymbol) {
    var reflectSymbol2 = reflectSymbol(dictIsSymbol);
    return function(dictShow) {
      var show17 = show(dictShow);
      return {
        showRecordFields: function(v2) {
          return function(record) {
            var key = reflectSymbol2($$Proxy.value);
            var focus2 = unsafeGet(key)(record);
            return " " + (key + (": " + (show17(focus2) + " ")));
          };
        }
      };
    };
  };

  // output/Data.Generic.Rep/index.js
  var Inl = /* @__PURE__ */ function() {
    function Inl2(value0) {
      this.value0 = value0;
    }
    ;
    Inl2.create = function(value0) {
      return new Inl2(value0);
    };
    return Inl2;
  }();
  var Inr = /* @__PURE__ */ function() {
    function Inr2(value0) {
      this.value0 = value0;
    }
    ;
    Inr2.create = function(value0) {
      return new Inr2(value0);
    };
    return Inr2;
  }();
  var NoArguments = /* @__PURE__ */ function() {
    function NoArguments2() {
    }
    ;
    NoArguments2.value = new NoArguments2();
    return NoArguments2;
  }();
  var Constructor = function(x2) {
    return x2;
  };
  var Argument = function(x2) {
    return x2;
  };
  var to = function(dict) {
    return dict.to;
  };
  var from = function(dict) {
    return dict.from;
  };

  // output/Data.Maybe/index.js
  var identity3 = /* @__PURE__ */ identity(categoryFn);
  var Nothing = /* @__PURE__ */ function() {
    function Nothing2() {
    }
    ;
    Nothing2.value = new Nothing2();
    return Nothing2;
  }();
  var Just = /* @__PURE__ */ function() {
    function Just2(value0) {
      this.value0 = value0;
    }
    ;
    Just2.create = function(value0) {
      return new Just2(value0);
    };
    return Just2;
  }();
  var showMaybe = function(dictShow) {
    var show11 = show(dictShow);
    return {
      show: function(v2) {
        if (v2 instanceof Just) {
          return "(Just " + (show11(v2.value0) + ")");
        }
        ;
        if (v2 instanceof Nothing) {
          return "Nothing";
        }
        ;
        throw new Error("Failed pattern match at Data.Maybe (line 223, column 1 - line 225, column 28): " + [v2.constructor.name]);
      }
    };
  };
  var maybe = function(v2) {
    return function(v1) {
      return function(v22) {
        if (v22 instanceof Nothing) {
          return v2;
        }
        ;
        if (v22 instanceof Just) {
          return v1(v22.value0);
        }
        ;
        throw new Error("Failed pattern match at Data.Maybe (line 237, column 1 - line 237, column 51): " + [v2.constructor.name, v1.constructor.name, v22.constructor.name]);
      };
    };
  };
  var isNothing = /* @__PURE__ */ maybe(true)(/* @__PURE__ */ $$const(false));
  var functorMaybe = {
    map: function(v2) {
      return function(v1) {
        if (v1 instanceof Just) {
          return new Just(v2(v1.value0));
        }
        ;
        return Nothing.value;
      };
    }
  };
  var map2 = /* @__PURE__ */ map(functorMaybe);
  var fromMaybe = function(a2) {
    return maybe(a2)(identity3);
  };
  var fromJust = function() {
    return function(v2) {
      if (v2 instanceof Just) {
        return v2.value0;
      }
      ;
      throw new Error("Failed pattern match at Data.Maybe (line 288, column 1 - line 288, column 46): " + [v2.constructor.name]);
    };
  };
  var eqMaybe = function(dictEq) {
    var eq3 = eq(dictEq);
    return {
      eq: function(x2) {
        return function(y2) {
          if (x2 instanceof Nothing && y2 instanceof Nothing) {
            return true;
          }
          ;
          if (x2 instanceof Just && y2 instanceof Just) {
            return eq3(x2.value0)(y2.value0);
          }
          ;
          return false;
        };
      }
    };
  };
  var applyMaybe = {
    apply: function(v2) {
      return function(v1) {
        if (v2 instanceof Just) {
          return map2(v2.value0)(v1);
        }
        ;
        if (v2 instanceof Nothing) {
          return Nothing.value;
        }
        ;
        throw new Error("Failed pattern match at Data.Maybe (line 67, column 1 - line 69, column 30): " + [v2.constructor.name, v1.constructor.name]);
      };
    },
    Functor0: function() {
      return functorMaybe;
    }
  };
  var bindMaybe = {
    bind: function(v2) {
      return function(v1) {
        if (v2 instanceof Just) {
          return v1(v2.value0);
        }
        ;
        if (v2 instanceof Nothing) {
          return Nothing.value;
        }
        ;
        throw new Error("Failed pattern match at Data.Maybe (line 125, column 1 - line 127, column 28): " + [v2.constructor.name, v1.constructor.name]);
      };
    },
    Apply0: function() {
      return applyMaybe;
    }
  };
  var applicativeMaybe = /* @__PURE__ */ function() {
    return {
      pure: Just.create,
      Apply0: function() {
        return applyMaybe;
      }
    };
  }();

  // output/Data.Either/index.js
  var Left = /* @__PURE__ */ function() {
    function Left2(value0) {
      this.value0 = value0;
    }
    ;
    Left2.create = function(value0) {
      return new Left2(value0);
    };
    return Left2;
  }();
  var Right = /* @__PURE__ */ function() {
    function Right2(value0) {
      this.value0 = value0;
    }
    ;
    Right2.create = function(value0) {
      return new Right2(value0);
    };
    return Right2;
  }();
  var functorEither = {
    map: function(f2) {
      return function(m2) {
        if (m2 instanceof Left) {
          return new Left(m2.value0);
        }
        ;
        if (m2 instanceof Right) {
          return new Right(f2(m2.value0));
        }
        ;
        throw new Error("Failed pattern match at Data.Either (line 0, column 0 - line 0, column 0): " + [m2.constructor.name]);
      };
    }
  };
  var map3 = /* @__PURE__ */ map(functorEither);
  var either = function(v2) {
    return function(v1) {
      return function(v22) {
        if (v22 instanceof Left) {
          return v2(v22.value0);
        }
        ;
        if (v22 instanceof Right) {
          return v1(v22.value0);
        }
        ;
        throw new Error("Failed pattern match at Data.Either (line 208, column 1 - line 208, column 64): " + [v2.constructor.name, v1.constructor.name, v22.constructor.name]);
      };
    };
  };
  var applyEither = {
    apply: function(v2) {
      return function(v1) {
        if (v2 instanceof Left) {
          return new Left(v2.value0);
        }
        ;
        if (v2 instanceof Right) {
          return map3(v2.value0)(v1);
        }
        ;
        throw new Error("Failed pattern match at Data.Either (line 70, column 1 - line 72, column 30): " + [v2.constructor.name, v1.constructor.name]);
      };
    },
    Functor0: function() {
      return functorEither;
    }
  };
  var applicativeEither = /* @__PURE__ */ function() {
    return {
      pure: Right.create,
      Apply0: function() {
        return applyEither;
      }
    };
  }();

  // output/Data.Identity/index.js
  var Identity = function(x2) {
    return x2;
  };
  var functorIdentity = {
    map: function(f2) {
      return function(m2) {
        return f2(m2);
      };
    }
  };
  var applyIdentity = {
    apply: function(v2) {
      return function(v1) {
        return v2(v1);
      };
    },
    Functor0: function() {
      return functorIdentity;
    }
  };
  var bindIdentity = {
    bind: function(v2) {
      return function(f2) {
        return f2(v2);
      };
    },
    Apply0: function() {
      return applyIdentity;
    }
  };
  var applicativeIdentity = {
    pure: Identity,
    Apply0: function() {
      return applyIdentity;
    }
  };
  var monadIdentity = {
    Applicative0: function() {
      return applicativeIdentity;
    },
    Bind1: function() {
      return bindIdentity;
    }
  };

  // output/Data.EuclideanRing/foreign.js
  var intDegree = function(x2) {
    return Math.min(Math.abs(x2), 2147483647);
  };
  var intDiv = function(x2) {
    return function(y2) {
      if (y2 === 0) return 0;
      return y2 > 0 ? Math.floor(x2 / y2) : -Math.floor(x2 / -y2);
    };
  };
  var intMod = function(x2) {
    return function(y2) {
      if (y2 === 0) return 0;
      var yy = Math.abs(y2);
      return (x2 % yy + yy) % yy;
    };
  };

  // output/Data.CommutativeRing/index.js
  var commutativeRingInt = {
    Ring0: function() {
      return ringInt;
    }
  };

  // output/Data.EuclideanRing/index.js
  var mod = function(dict) {
    return dict.mod;
  };
  var euclideanRingInt = {
    degree: intDegree,
    div: intDiv,
    mod: intMod,
    CommutativeRing0: function() {
      return commutativeRingInt;
    }
  };
  var div = function(dict) {
    return dict.div;
  };

  // output/Data.Monoid/index.js
  var monoidString = {
    mempty: "",
    Semigroup0: function() {
      return semigroupString;
    }
  };
  var monoidArray = {
    mempty: [],
    Semigroup0: function() {
      return semigroupArray;
    }
  };
  var mempty = function(dict) {
    return dict.mempty;
  };

  // output/Effect/foreign.js
  var pureE = function(a2) {
    return function() {
      return a2;
    };
  };
  var bindE = function(a2) {
    return function(f2) {
      return function() {
        return f2(a2())();
      };
    };
  };

  // output/Effect/index.js
  var $runtime_lazy = function(name16, moduleName, init6) {
    var state4 = 0;
    var val;
    return function(lineNumber) {
      if (state4 === 2) return val;
      if (state4 === 1) throw new ReferenceError(name16 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
      state4 = 1;
      val = init6();
      state4 = 2;
      return val;
    };
  };
  var monadEffect = {
    Applicative0: function() {
      return applicativeEffect;
    },
    Bind1: function() {
      return bindEffect;
    }
  };
  var bindEffect = {
    bind: bindE,
    Apply0: function() {
      return $lazy_applyEffect(0);
    }
  };
  var applicativeEffect = {
    pure: pureE,
    Apply0: function() {
      return $lazy_applyEffect(0);
    }
  };
  var $lazy_functorEffect = /* @__PURE__ */ $runtime_lazy("functorEffect", "Effect", function() {
    return {
      map: liftA1(applicativeEffect)
    };
  });
  var $lazy_applyEffect = /* @__PURE__ */ $runtime_lazy("applyEffect", "Effect", function() {
    return {
      apply: ap(monadEffect),
      Functor0: function() {
        return $lazy_functorEffect(0);
      }
    };
  });
  var functorEffect = /* @__PURE__ */ $lazy_functorEffect(20);

  // output/Effect.Ref/foreign.js
  var _new = function(val) {
    return function() {
      return { value: val };
    };
  };
  var read = function(ref) {
    return function() {
      return ref.value;
    };
  };
  var write = function(val) {
    return function(ref) {
      return function() {
        ref.value = val;
      };
    };
  };

  // output/Effect.Ref/index.js
  var $$new = _new;

  // output/Control.Monad.ST.Internal/index.js
  var functorST = {
    map: map_
  };

  // output/Data.HeytingAlgebra/foreign.js
  var boolConj = function(b1) {
    return function(b2) {
      return b1 && b2;
    };
  };
  var boolDisj = function(b1) {
    return function(b2) {
      return b1 || b2;
    };
  };
  var boolNot = function(b2) {
    return !b2;
  };

  // output/Data.HeytingAlgebra/index.js
  var not = function(dict) {
    return dict.not;
  };
  var disj = function(dict) {
    return dict.disj;
  };
  var heytingAlgebraBoolean = {
    ff: false,
    tt: true,
    implies: function(a2) {
      return function(b2) {
        return disj(heytingAlgebraBoolean)(not(heytingAlgebraBoolean)(a2))(b2);
      };
    },
    conj: boolConj,
    disj: boolDisj,
    not: boolNot
  };

  // output/Data.Tuple/index.js
  var Tuple = /* @__PURE__ */ function() {
    function Tuple2(value0, value1) {
      this.value0 = value0;
      this.value1 = value1;
    }
    ;
    Tuple2.create = function(value0) {
      return function(value1) {
        return new Tuple2(value0, value1);
      };
    };
    return Tuple2;
  }();
  var snd = function(v2) {
    return v2.value1;
  };
  var showTuple = function(dictShow) {
    var show11 = show(dictShow);
    return function(dictShow1) {
      var show17 = show(dictShow1);
      return {
        show: function(v2) {
          return "(Tuple " + (show11(v2.value0) + (" " + (show17(v2.value1) + ")")));
        }
      };
    };
  };
  var functorTuple = {
    map: function(f2) {
      return function(m2) {
        return new Tuple(m2.value0, f2(m2.value1));
      };
    }
  };
  var fst = function(v2) {
    return v2.value0;
  };

  // output/Control.Monad.State.Class/index.js
  var state = function(dict) {
    return dict.state;
  };
  var put = function(dictMonadState) {
    var state1 = state(dictMonadState);
    return function(s2) {
      return state1(function(v2) {
        return new Tuple(unit, s2);
      });
    };
  };
  var get = function(dictMonadState) {
    return state(dictMonadState)(function(s2) {
      return new Tuple(s2, s2);
    });
  };

  // output/Control.Monad.Trans.Class/index.js
  var lift = function(dict) {
    return dict.lift;
  };

  // output/Effect.Class/index.js
  var monadEffectEffect = {
    liftEffect: /* @__PURE__ */ identity(categoryFn),
    Monad0: function() {
      return monadEffect;
    }
  };
  var liftEffect = function(dict) {
    return dict.liftEffect;
  };

  // output/Effect.Exception/foreign.js
  function error(msg) {
    return new Error(msg);
  }
  function message(e2) {
    return e2.message;
  }
  function throwException(e2) {
    return function() {
      throw e2;
    };
  }
  function catchException(c2) {
    return function(t3) {
      return function() {
        try {
          return t3();
        } catch (e2) {
          if (e2 instanceof Error || Object.prototype.toString.call(e2) === "[object Error]") {
            return c2(e2)();
          } else {
            return c2(new Error(e2.toString()))();
          }
        }
      };
    };
  }

  // output/Effect.Exception/index.js
  var pure2 = /* @__PURE__ */ pure(applicativeEffect);
  var map4 = /* @__PURE__ */ map(functorEffect);
  var $$try = function(action2) {
    return catchException(function($3) {
      return pure2(Left.create($3));
    })(map4(Right.create)(action2));
  };
  var $$throw = function($4) {
    return throwException(error($4));
  };

  // output/Control.Monad.Error.Class/index.js
  var throwError = function(dict) {
    return dict.throwError;
  };
  var catchError = function(dict) {
    return dict.catchError;
  };
  var $$try2 = function(dictMonadError) {
    var catchError1 = catchError(dictMonadError);
    var Monad0 = dictMonadError.MonadThrow0().Monad0();
    var map27 = map(Monad0.Bind1().Apply0().Functor0());
    var pure19 = pure(Monad0.Applicative0());
    return function(a2) {
      return catchError1(map27(Right.create)(a2))(function($52) {
        return pure19(Left.create($52));
      });
    };
  };

  // output/Control.Monad.Writer.Class/index.js
  var tell = function(dict) {
    return dict.tell;
  };

  // output/Control.Monad.Except.Trans/index.js
  var map5 = /* @__PURE__ */ map(functorEither);
  var ExceptT = function(x2) {
    return x2;
  };
  var withExceptT = function(dictFunctor) {
    var map110 = map(dictFunctor);
    return function(f2) {
      return function(v2) {
        var mapLeft = function(v1) {
          return function(v22) {
            if (v22 instanceof Right) {
              return new Right(v22.value0);
            }
            ;
            if (v22 instanceof Left) {
              return new Left(v1(v22.value0));
            }
            ;
            throw new Error("Failed pattern match at Control.Monad.Except.Trans (line 43, column 3 - line 43, column 32): " + [v1.constructor.name, v22.constructor.name]);
          };
        };
        return map110(mapLeft(f2))(v2);
      };
    };
  };
  var runExceptT = function(v2) {
    return v2;
  };
  var mapExceptT = function(f2) {
    return function(v2) {
      return f2(v2);
    };
  };
  var functorExceptT = function(dictFunctor) {
    var map110 = map(dictFunctor);
    return {
      map: function(f2) {
        return mapExceptT(map110(map5(f2)));
      }
    };
  };
  var except = function(dictApplicative) {
    var $191 = pure(dictApplicative);
    return function($192) {
      return ExceptT($191($192));
    };
  };
  var monadExceptT = function(dictMonad) {
    return {
      Applicative0: function() {
        return applicativeExceptT(dictMonad);
      },
      Bind1: function() {
        return bindExceptT(dictMonad);
      }
    };
  };
  var bindExceptT = function(dictMonad) {
    var bind8 = bind(dictMonad.Bind1());
    var pure19 = pure(dictMonad.Applicative0());
    return {
      bind: function(v2) {
        return function(k2) {
          return bind8(v2)(either(function($193) {
            return pure19(Left.create($193));
          })(function(a2) {
            var v1 = k2(a2);
            return v1;
          }));
        };
      },
      Apply0: function() {
        return applyExceptT(dictMonad);
      }
    };
  };
  var applyExceptT = function(dictMonad) {
    var functorExceptT1 = functorExceptT(dictMonad.Bind1().Apply0().Functor0());
    return {
      apply: ap(monadExceptT(dictMonad)),
      Functor0: function() {
        return functorExceptT1;
      }
    };
  };
  var applicativeExceptT = function(dictMonad) {
    return {
      pure: function() {
        var $194 = pure(dictMonad.Applicative0());
        return function($195) {
          return ExceptT($194(Right.create($195)));
        };
      }(),
      Apply0: function() {
        return applyExceptT(dictMonad);
      }
    };
  };
  var monadThrowExceptT = function(dictMonad) {
    var monadExceptT1 = monadExceptT(dictMonad);
    return {
      throwError: function() {
        var $204 = pure(dictMonad.Applicative0());
        return function($205) {
          return ExceptT($204(Left.create($205)));
        };
      }(),
      Monad0: function() {
        return monadExceptT1;
      }
    };
  };
  var altExceptT = function(dictSemigroup) {
    var append6 = append(dictSemigroup);
    return function(dictMonad) {
      var Bind1 = dictMonad.Bind1();
      var bind8 = bind(Bind1);
      var pure19 = pure(dictMonad.Applicative0());
      var functorExceptT1 = functorExceptT(Bind1.Apply0().Functor0());
      return {
        alt: function(v2) {
          return function(v1) {
            return bind8(v2)(function(rm2) {
              if (rm2 instanceof Right) {
                return pure19(new Right(rm2.value0));
              }
              ;
              if (rm2 instanceof Left) {
                return bind8(v1)(function(rn) {
                  if (rn instanceof Right) {
                    return pure19(new Right(rn.value0));
                  }
                  ;
                  if (rn instanceof Left) {
                    return pure19(new Left(append6(rm2.value0)(rn.value0)));
                  }
                  ;
                  throw new Error("Failed pattern match at Control.Monad.Except.Trans (line 87, column 9 - line 89, column 49): " + [rn.constructor.name]);
                });
              }
              ;
              throw new Error("Failed pattern match at Control.Monad.Except.Trans (line 83, column 5 - line 89, column 49): " + [rm2.constructor.name]);
            });
          };
        },
        Functor0: function() {
          return functorExceptT1;
        }
      };
    };
  };

  // output/Control.Plus/index.js
  var empty = function(dict) {
    return dict.empty;
  };

  // output/Safe.Coerce/index.js
  var coerce = function() {
    return unsafeCoerce;
  };

  // output/Data.Newtype/index.js
  var coerce2 = /* @__PURE__ */ coerce();
  var unwrap = function() {
    return coerce2;
  };

  // output/Control.Monad.Reader.Trans/index.js
  var ReaderT = function(x2) {
    return x2;
  };
  var runReaderT = function(v2) {
    return v2;
  };
  var monadTransReaderT = {
    lift: function(dictMonad) {
      return function($153) {
        return ReaderT($$const($153));
      };
    }
  };
  var lift3 = /* @__PURE__ */ lift(monadTransReaderT);
  var mapReaderT = function(f2) {
    return function(v2) {
      return function($154) {
        return f2(v2($154));
      };
    };
  };
  var functorReaderT = function(dictFunctor) {
    return {
      map: function() {
        var $155 = map(dictFunctor);
        return function($156) {
          return mapReaderT($155($156));
        };
      }()
    };
  };
  var applyReaderT = function(dictApply) {
    var apply5 = apply(dictApply);
    var functorReaderT1 = functorReaderT(dictApply.Functor0());
    return {
      apply: function(v2) {
        return function(v1) {
          return function(r2) {
            return apply5(v2(r2))(v1(r2));
          };
        };
      },
      Functor0: function() {
        return functorReaderT1;
      }
    };
  };
  var bindReaderT = function(dictBind) {
    var bind8 = bind(dictBind);
    var applyReaderT1 = applyReaderT(dictBind.Apply0());
    return {
      bind: function(v2) {
        return function(k2) {
          return function(r2) {
            return bind8(v2(r2))(function(a2) {
              var v1 = k2(a2);
              return v1(r2);
            });
          };
        };
      },
      Apply0: function() {
        return applyReaderT1;
      }
    };
  };
  var applicativeReaderT = function(dictApplicative) {
    var applyReaderT1 = applyReaderT(dictApplicative.Apply0());
    return {
      pure: function() {
        var $160 = pure(dictApplicative);
        return function($161) {
          return ReaderT($$const($160($161)));
        };
      }(),
      Apply0: function() {
        return applyReaderT1;
      }
    };
  };
  var monadReaderT = function(dictMonad) {
    var applicativeReaderT1 = applicativeReaderT(dictMonad.Applicative0());
    var bindReaderT1 = bindReaderT(dictMonad.Bind1());
    return {
      Applicative0: function() {
        return applicativeReaderT1;
      },
      Bind1: function() {
        return bindReaderT1;
      }
    };
  };
  var monadAskReaderT = function(dictMonad) {
    var monadReaderT1 = monadReaderT(dictMonad);
    return {
      ask: pure(dictMonad.Applicative0()),
      Monad0: function() {
        return monadReaderT1;
      }
    };
  };
  var monadEffectReader = function(dictMonadEffect) {
    var Monad0 = dictMonadEffect.Monad0();
    var monadReaderT1 = monadReaderT(Monad0);
    return {
      liftEffect: function() {
        var $163 = lift3(Monad0);
        var $164 = liftEffect(dictMonadEffect);
        return function($165) {
          return $163($164($165));
        };
      }(),
      Monad0: function() {
        return monadReaderT1;
      }
    };
  };

  // output/Control.Parallel.Class/index.js
  var sequential = function(dict) {
    return dict.sequential;
  };
  var parallel = function(dict) {
    return dict.parallel;
  };

  // output/Data.Foldable/foreign.js
  var foldrArray = function(f2) {
    return function(init6) {
      return function(xs) {
        var acc = init6;
        var len = xs.length;
        for (var i2 = len - 1; i2 >= 0; i2--) {
          acc = f2(xs[i2])(acc);
        }
        return acc;
      };
    };
  };
  var foldlArray = function(f2) {
    return function(init6) {
      return function(xs) {
        var acc = init6;
        var len = xs.length;
        for (var i2 = 0; i2 < len; i2++) {
          acc = f2(acc)(xs[i2]);
        }
        return acc;
      };
    };
  };

  // output/Data.Bifunctor/index.js
  var identity4 = /* @__PURE__ */ identity(categoryFn);
  var bimap = function(dict) {
    return dict.bimap;
  };
  var lmap = function(dictBifunctor) {
    var bimap1 = bimap(dictBifunctor);
    return function(f2) {
      return bimap1(f2)(identity4);
    };
  };
  var bifunctorEither = {
    bimap: function(v2) {
      return function(v1) {
        return function(v22) {
          if (v22 instanceof Left) {
            return new Left(v2(v22.value0));
          }
          ;
          if (v22 instanceof Right) {
            return new Right(v1(v22.value0));
          }
          ;
          throw new Error("Failed pattern match at Data.Bifunctor (line 32, column 1 - line 34, column 36): " + [v2.constructor.name, v1.constructor.name, v22.constructor.name]);
        };
      };
    }
  };

  // output/Data.Foldable/index.js
  var foldr = function(dict) {
    return dict.foldr;
  };
  var traverse_ = function(dictApplicative) {
    var applySecond2 = applySecond(dictApplicative.Apply0());
    var pure19 = pure(dictApplicative);
    return function(dictFoldable) {
      var foldr22 = foldr(dictFoldable);
      return function(f2) {
        return foldr22(function($454) {
          return applySecond2(f2($454));
        })(pure19(unit));
      };
    };
  };
  var for_ = function(dictApplicative) {
    var traverse_1 = traverse_(dictApplicative);
    return function(dictFoldable) {
      return flip(traverse_1(dictFoldable));
    };
  };
  var foldl = function(dict) {
    return dict.foldl;
  };
  var intercalate = function(dictFoldable) {
    var foldl22 = foldl(dictFoldable);
    return function(dictMonoid) {
      var append6 = append(dictMonoid.Semigroup0());
      var mempty4 = mempty(dictMonoid);
      return function(sep) {
        return function(xs) {
          var go2 = function(v2) {
            return function(v1) {
              if (v2.init) {
                return {
                  init: false,
                  acc: v1
                };
              }
              ;
              return {
                init: false,
                acc: append6(v2.acc)(append6(sep)(v1))
              };
            };
          };
          return foldl22(go2)({
            init: true,
            acc: mempty4
          })(xs).acc;
        };
      };
    };
  };
  var foldableMaybe = {
    foldr: function(v2) {
      return function(v1) {
        return function(v22) {
          if (v22 instanceof Nothing) {
            return v1;
          }
          ;
          if (v22 instanceof Just) {
            return v2(v22.value0)(v1);
          }
          ;
          throw new Error("Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): " + [v2.constructor.name, v1.constructor.name, v22.constructor.name]);
        };
      };
    },
    foldl: function(v2) {
      return function(v1) {
        return function(v22) {
          if (v22 instanceof Nothing) {
            return v1;
          }
          ;
          if (v22 instanceof Just) {
            return v2(v1)(v22.value0);
          }
          ;
          throw new Error("Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): " + [v2.constructor.name, v1.constructor.name, v22.constructor.name]);
        };
      };
    },
    foldMap: function(dictMonoid) {
      var mempty4 = mempty(dictMonoid);
      return function(v2) {
        return function(v1) {
          if (v1 instanceof Nothing) {
            return mempty4;
          }
          ;
          if (v1 instanceof Just) {
            return v2(v1.value0);
          }
          ;
          throw new Error("Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): " + [v2.constructor.name, v1.constructor.name]);
        };
      };
    }
  };
  var foldMapDefaultR = function(dictFoldable) {
    var foldr22 = foldr(dictFoldable);
    return function(dictMonoid) {
      var append6 = append(dictMonoid.Semigroup0());
      var mempty4 = mempty(dictMonoid);
      return function(f2) {
        return foldr22(function(x2) {
          return function(acc) {
            return append6(f2(x2))(acc);
          };
        })(mempty4);
      };
    };
  };
  var foldableArray = {
    foldr: foldrArray,
    foldl: foldlArray,
    foldMap: function(dictMonoid) {
      return foldMapDefaultR(foldableArray)(dictMonoid);
    }
  };
  var foldMap = function(dict) {
    return dict.foldMap;
  };
  var foldM = function(dictFoldable) {
    var foldl22 = foldl(dictFoldable);
    return function(dictMonad) {
      var bind8 = bind(dictMonad.Bind1());
      var pure19 = pure(dictMonad.Applicative0());
      return function(f2) {
        return function(b0) {
          return foldl22(function(b2) {
            return function(a2) {
              return bind8(b2)(flip(f2)(a2));
            };
          })(pure19(b0));
        };
      };
    };
  };

  // output/Control.Parallel/index.js
  var parTraverse_ = function(dictParallel) {
    var sequential2 = sequential(dictParallel);
    var parallel3 = parallel(dictParallel);
    return function(dictApplicative) {
      var traverse_3 = traverse_(dictApplicative);
      return function(dictFoldable) {
        var traverse_1 = traverse_3(dictFoldable);
        return function(f2) {
          var $51 = traverse_1(function($53) {
            return parallel3(f2($53));
          });
          return function($52) {
            return sequential2($51($52));
          };
        };
      };
    };
  };

  // output/Data.Time.Duration/index.js
  var show2 = /* @__PURE__ */ show(showNumber);
  var identity5 = /* @__PURE__ */ identity(categoryFn);
  var showMilliseconds = {
    show: function(v2) {
      return "(Milliseconds " + (show2(v2) + ")");
    }
  };
  var fromDuration = function(dict) {
    return dict.fromDuration;
  };
  var eqMilliseconds = eqNumber;
  var durationMilliseconds = {
    fromDuration: identity5,
    toDuration: identity5
  };

  // output/Data.Typelevel.Undefined/index.js
  var $$undefined = unit;

  // output/Partial.Unsafe/foreign.js
  var _unsafePartial = function(f2) {
    return f2();
  };

  // output/Partial/foreign.js
  var _crashWith = function(msg) {
    throw new Error(msg);
  };

  // output/Partial/index.js
  var crashWith = function() {
    return _crashWith;
  };

  // output/Partial.Unsafe/index.js
  var crashWith2 = /* @__PURE__ */ crashWith();
  var unsafePartial = _unsafePartial;
  var unsafeCrashWith = function(msg) {
    return unsafePartial(function() {
      return crashWith2(msg);
    });
  };

  // output/Data.Typelevel.Num.Sets/index.js
  var toInt = function(dict) {
    return dict.toInt;
  };
  var toInt$prime = function(dictNat) {
    var toInt1 = toInt(dictNat);
    return function(v2) {
      return toInt1($$undefined);
    };
  };
  var natD1 = {
    toInt: function(v2) {
      return 1;
    }
  };
  var posD1 = {
    Nat0: function() {
      return natD1;
    }
  };
  var div10Dec = function(dictNat) {
    return function(v2) {
      return $$undefined;
    };
  };
  var subLastDec = function(dictNat) {
    var div10Dec1 = div10Dec(dictNat);
    return function(dictNat1) {
      var $146 = toInt(dictNat1);
      return function($147) {
        return function(v2) {
          return 10 * v2 | 0;
        }($146(div10Dec1($147)));
      };
    };
  };
  var posNatD6 = function(dictPos) {
    var Nat0 = dictPos.Nat0();
    return {
      toInt: function(n2) {
        return subLastDec(posNatD6(dictPos))(Nat0)(n2) + 6 | 0;
      }
    };
  };
  var posPosD6 = function(dictPos) {
    var posNatD61 = posNatD6(dictPos);
    return {
      Nat0: function() {
        return posNatD61;
      }
    };
  };

  // output/Effect.Aff/foreign.js
  var Aff = function() {
    var EMPTY = {};
    var PURE = "Pure";
    var THROW = "Throw";
    var CATCH = "Catch";
    var SYNC = "Sync";
    var ASYNC = "Async";
    var BIND = "Bind";
    var BRACKET = "Bracket";
    var FORK = "Fork";
    var SEQ = "Sequential";
    var MAP = "Map";
    var APPLY = "Apply";
    var ALT = "Alt";
    var CONS = "Cons";
    var RESUME = "Resume";
    var RELEASE = "Release";
    var FINALIZER = "Finalizer";
    var FINALIZED = "Finalized";
    var FORKED = "Forked";
    var FIBER = "Fiber";
    var THUNK = "Thunk";
    function Aff2(tag, _1, _2, _3) {
      this.tag = tag;
      this._1 = _1;
      this._2 = _2;
      this._3 = _3;
    }
    function AffCtr(tag) {
      var fn = function(_1, _2, _3) {
        return new Aff2(tag, _1, _2, _3);
      };
      fn.tag = tag;
      return fn;
    }
    function nonCanceler(error5) {
      return new Aff2(PURE, void 0);
    }
    function runEff(eff) {
      try {
        eff();
      } catch (error5) {
        setTimeout(function() {
          throw error5;
        }, 0);
      }
    }
    function runSync(left, right, eff) {
      try {
        return right(eff());
      } catch (error5) {
        return left(error5);
      }
    }
    function runAsync(left, eff, k2) {
      try {
        return eff(k2)();
      } catch (error5) {
        k2(left(error5))();
        return nonCanceler;
      }
    }
    var Scheduler = function() {
      var limit = 1024;
      var size5 = 0;
      var ix3 = 0;
      var queue = new Array(limit);
      var draining = false;
      function drain() {
        var thunk;
        draining = true;
        while (size5 !== 0) {
          size5--;
          thunk = queue[ix3];
          queue[ix3] = void 0;
          ix3 = (ix3 + 1) % limit;
          thunk();
        }
        draining = false;
      }
      return {
        isDraining: function() {
          return draining;
        },
        enqueue: function(cb) {
          var i2, tmp;
          if (size5 === limit) {
            tmp = draining;
            drain();
            draining = tmp;
          }
          queue[(ix3 + size5) % limit] = cb;
          size5++;
          if (!draining) {
            drain();
          }
        }
      };
    }();
    function Supervisor(util) {
      var fibers = {};
      var fiberId = 0;
      var count2 = 0;
      return {
        register: function(fiber) {
          var fid = fiberId++;
          fiber.onComplete({
            rethrow: true,
            handler: function(result) {
              return function() {
                count2--;
                delete fibers[fid];
              };
            }
          })();
          fibers[fid] = fiber;
          count2++;
        },
        isEmpty: function() {
          return count2 === 0;
        },
        killAll: function(killError, cb) {
          return function() {
            if (count2 === 0) {
              return cb();
            }
            var killCount = 0;
            var kills = {};
            function kill(fid) {
              kills[fid] = fibers[fid].kill(killError, function(result) {
                return function() {
                  delete kills[fid];
                  killCount--;
                  if (util.isLeft(result) && util.fromLeft(result)) {
                    setTimeout(function() {
                      throw util.fromLeft(result);
                    }, 0);
                  }
                  if (killCount === 0) {
                    cb();
                  }
                };
              })();
            }
            for (var k2 in fibers) {
              if (fibers.hasOwnProperty(k2)) {
                killCount++;
                kill(k2);
              }
            }
            fibers = {};
            fiberId = 0;
            count2 = 0;
            return function(error5) {
              return new Aff2(SYNC, function() {
                for (var k3 in kills) {
                  if (kills.hasOwnProperty(k3)) {
                    kills[k3]();
                  }
                }
              });
            };
          };
        }
      };
    }
    var SUSPENDED = 0;
    var CONTINUE = 1;
    var STEP_BIND = 2;
    var STEP_RESULT = 3;
    var PENDING = 4;
    var RETURN = 5;
    var COMPLETED = 6;
    function Fiber(util, supervisor, aff) {
      var runTick = 0;
      var status = SUSPENDED;
      var step2 = aff;
      var fail6 = null;
      var interrupt = null;
      var bhead = null;
      var btail = null;
      var attempts = null;
      var bracketCount = 0;
      var joinId = 0;
      var joins = null;
      var rethrow = true;
      function run4(localRunTick) {
        var tmp, result, attempt;
        while (true) {
          tmp = null;
          result = null;
          attempt = null;
          switch (status) {
            case STEP_BIND:
              status = CONTINUE;
              try {
                step2 = bhead(step2);
                if (btail === null) {
                  bhead = null;
                } else {
                  bhead = btail._1;
                  btail = btail._2;
                }
              } catch (e2) {
                status = RETURN;
                fail6 = util.left(e2);
                step2 = null;
              }
              break;
            case STEP_RESULT:
              if (util.isLeft(step2)) {
                status = RETURN;
                fail6 = step2;
                step2 = null;
              } else if (bhead === null) {
                status = RETURN;
              } else {
                status = STEP_BIND;
                step2 = util.fromRight(step2);
              }
              break;
            case CONTINUE:
              switch (step2.tag) {
                case BIND:
                  if (bhead) {
                    btail = new Aff2(CONS, bhead, btail);
                  }
                  bhead = step2._2;
                  status = CONTINUE;
                  step2 = step2._1;
                  break;
                case PURE:
                  if (bhead === null) {
                    status = RETURN;
                    step2 = util.right(step2._1);
                  } else {
                    status = STEP_BIND;
                    step2 = step2._1;
                  }
                  break;
                case SYNC:
                  status = STEP_RESULT;
                  step2 = runSync(util.left, util.right, step2._1);
                  break;
                case ASYNC:
                  status = PENDING;
                  step2 = runAsync(util.left, step2._1, function(result2) {
                    return function() {
                      if (runTick !== localRunTick) {
                        return;
                      }
                      runTick++;
                      Scheduler.enqueue(function() {
                        if (runTick !== localRunTick + 1) {
                          return;
                        }
                        status = STEP_RESULT;
                        step2 = result2;
                        run4(runTick);
                      });
                    };
                  });
                  return;
                case THROW:
                  status = RETURN;
                  fail6 = util.left(step2._1);
                  step2 = null;
                  break;
                // Enqueue the Catch so that we can call the error handler later on
                // in case of an exception.
                case CATCH:
                  if (bhead === null) {
                    attempts = new Aff2(CONS, step2, attempts, interrupt);
                  } else {
                    attempts = new Aff2(CONS, step2, new Aff2(CONS, new Aff2(RESUME, bhead, btail), attempts, interrupt), interrupt);
                  }
                  bhead = null;
                  btail = null;
                  status = CONTINUE;
                  step2 = step2._1;
                  break;
                // Enqueue the Bracket so that we can call the appropriate handlers
                // after resource acquisition.
                case BRACKET:
                  bracketCount++;
                  if (bhead === null) {
                    attempts = new Aff2(CONS, step2, attempts, interrupt);
                  } else {
                    attempts = new Aff2(CONS, step2, new Aff2(CONS, new Aff2(RESUME, bhead, btail), attempts, interrupt), interrupt);
                  }
                  bhead = null;
                  btail = null;
                  status = CONTINUE;
                  step2 = step2._1;
                  break;
                case FORK:
                  status = STEP_RESULT;
                  tmp = Fiber(util, supervisor, step2._2);
                  if (supervisor) {
                    supervisor.register(tmp);
                  }
                  if (step2._1) {
                    tmp.run();
                  }
                  step2 = util.right(tmp);
                  break;
                case SEQ:
                  status = CONTINUE;
                  step2 = sequential2(util, supervisor, step2._1);
                  break;
              }
              break;
            case RETURN:
              bhead = null;
              btail = null;
              if (attempts === null) {
                status = COMPLETED;
                step2 = interrupt || fail6 || step2;
              } else {
                tmp = attempts._3;
                attempt = attempts._1;
                attempts = attempts._2;
                switch (attempt.tag) {
                  // We cannot recover from an unmasked interrupt. Otherwise we should
                  // continue stepping, or run the exception handler if an exception
                  // was raised.
                  case CATCH:
                    if (interrupt && interrupt !== tmp && bracketCount === 0) {
                      status = RETURN;
                    } else if (fail6) {
                      status = CONTINUE;
                      step2 = attempt._2(util.fromLeft(fail6));
                      fail6 = null;
                    }
                    break;
                  // We cannot resume from an unmasked interrupt or exception.
                  case RESUME:
                    if (interrupt && interrupt !== tmp && bracketCount === 0 || fail6) {
                      status = RETURN;
                    } else {
                      bhead = attempt._1;
                      btail = attempt._2;
                      status = STEP_BIND;
                      step2 = util.fromRight(step2);
                    }
                    break;
                  // If we have a bracket, we should enqueue the handlers,
                  // and continue with the success branch only if the fiber has
                  // not been interrupted. If the bracket acquisition failed, we
                  // should not run either.
                  case BRACKET:
                    bracketCount--;
                    if (fail6 === null) {
                      result = util.fromRight(step2);
                      attempts = new Aff2(CONS, new Aff2(RELEASE, attempt._2, result), attempts, tmp);
                      if (interrupt === tmp || bracketCount > 0) {
                        status = CONTINUE;
                        step2 = attempt._3(result);
                      }
                    }
                    break;
                  // Enqueue the appropriate handler. We increase the bracket count
                  // because it should not be cancelled.
                  case RELEASE:
                    attempts = new Aff2(CONS, new Aff2(FINALIZED, step2, fail6), attempts, interrupt);
                    status = CONTINUE;
                    if (interrupt && interrupt !== tmp && bracketCount === 0) {
                      step2 = attempt._1.killed(util.fromLeft(interrupt))(attempt._2);
                    } else if (fail6) {
                      step2 = attempt._1.failed(util.fromLeft(fail6))(attempt._2);
                    } else {
                      step2 = attempt._1.completed(util.fromRight(step2))(attempt._2);
                    }
                    fail6 = null;
                    bracketCount++;
                    break;
                  case FINALIZER:
                    bracketCount++;
                    attempts = new Aff2(CONS, new Aff2(FINALIZED, step2, fail6), attempts, interrupt);
                    status = CONTINUE;
                    step2 = attempt._1;
                    break;
                  case FINALIZED:
                    bracketCount--;
                    status = RETURN;
                    step2 = attempt._1;
                    fail6 = attempt._2;
                    break;
                }
              }
              break;
            case COMPLETED:
              for (var k2 in joins) {
                if (joins.hasOwnProperty(k2)) {
                  rethrow = rethrow && joins[k2].rethrow;
                  runEff(joins[k2].handler(step2));
                }
              }
              joins = null;
              if (interrupt && fail6) {
                setTimeout(function() {
                  throw util.fromLeft(fail6);
                }, 0);
              } else if (util.isLeft(step2) && rethrow) {
                setTimeout(function() {
                  if (rethrow) {
                    throw util.fromLeft(step2);
                  }
                }, 0);
              }
              return;
            case SUSPENDED:
              status = CONTINUE;
              break;
            case PENDING:
              return;
          }
        }
      }
      function onComplete(join3) {
        return function() {
          if (status === COMPLETED) {
            rethrow = rethrow && join3.rethrow;
            join3.handler(step2)();
            return function() {
            };
          }
          var jid = joinId++;
          joins = joins || {};
          joins[jid] = join3;
          return function() {
            if (joins !== null) {
              delete joins[jid];
            }
          };
        };
      }
      function kill(error5, cb) {
        return function() {
          if (status === COMPLETED) {
            cb(util.right(void 0))();
            return function() {
            };
          }
          var canceler = onComplete({
            rethrow: false,
            handler: function() {
              return cb(util.right(void 0));
            }
          })();
          switch (status) {
            case SUSPENDED:
              interrupt = util.left(error5);
              status = COMPLETED;
              step2 = interrupt;
              run4(runTick);
              break;
            case PENDING:
              if (interrupt === null) {
                interrupt = util.left(error5);
              }
              if (bracketCount === 0) {
                if (status === PENDING) {
                  attempts = new Aff2(CONS, new Aff2(FINALIZER, step2(error5)), attempts, interrupt);
                }
                status = RETURN;
                step2 = null;
                fail6 = null;
                run4(++runTick);
              }
              break;
            default:
              if (interrupt === null) {
                interrupt = util.left(error5);
              }
              if (bracketCount === 0) {
                status = RETURN;
                step2 = null;
                fail6 = null;
              }
          }
          return canceler;
        };
      }
      function join2(cb) {
        return function() {
          var canceler = onComplete({
            rethrow: false,
            handler: cb
          })();
          if (status === SUSPENDED) {
            run4(runTick);
          }
          return canceler;
        };
      }
      return {
        kill,
        join: join2,
        onComplete,
        isSuspended: function() {
          return status === SUSPENDED;
        },
        run: function() {
          if (status === SUSPENDED) {
            if (!Scheduler.isDraining()) {
              Scheduler.enqueue(function() {
                run4(runTick);
              });
            } else {
              run4(runTick);
            }
          }
        }
      };
    }
    function runPar(util, supervisor, par, cb) {
      var fiberId = 0;
      var fibers = {};
      var killId = 0;
      var kills = {};
      var early = new Error("[ParAff] Early exit");
      var interrupt = null;
      var root = EMPTY;
      function kill(error5, par2, cb2) {
        var step2 = par2;
        var head5 = null;
        var tail4 = null;
        var count2 = 0;
        var kills2 = {};
        var tmp, kid;
        loop: while (true) {
          tmp = null;
          switch (step2.tag) {
            case FORKED:
              if (step2._3 === EMPTY) {
                tmp = fibers[step2._1];
                kills2[count2++] = tmp.kill(error5, function(result) {
                  return function() {
                    count2--;
                    if (count2 === 0) {
                      cb2(result)();
                    }
                  };
                });
              }
              if (head5 === null) {
                break loop;
              }
              step2 = head5._2;
              if (tail4 === null) {
                head5 = null;
              } else {
                head5 = tail4._1;
                tail4 = tail4._2;
              }
              break;
            case MAP:
              step2 = step2._2;
              break;
            case APPLY:
            case ALT:
              if (head5) {
                tail4 = new Aff2(CONS, head5, tail4);
              }
              head5 = step2;
              step2 = step2._1;
              break;
          }
        }
        if (count2 === 0) {
          cb2(util.right(void 0))();
        } else {
          kid = 0;
          tmp = count2;
          for (; kid < tmp; kid++) {
            kills2[kid] = kills2[kid]();
          }
        }
        return kills2;
      }
      function join2(result, head5, tail4) {
        var fail6, step2, lhs, rhs, tmp, kid;
        if (util.isLeft(result)) {
          fail6 = result;
          step2 = null;
        } else {
          step2 = result;
          fail6 = null;
        }
        loop: while (true) {
          lhs = null;
          rhs = null;
          tmp = null;
          kid = null;
          if (interrupt !== null) {
            return;
          }
          if (head5 === null) {
            cb(fail6 || step2)();
            return;
          }
          if (head5._3 !== EMPTY) {
            return;
          }
          switch (head5.tag) {
            case MAP:
              if (fail6 === null) {
                head5._3 = util.right(head5._1(util.fromRight(step2)));
                step2 = head5._3;
              } else {
                head5._3 = fail6;
              }
              break;
            case APPLY:
              lhs = head5._1._3;
              rhs = head5._2._3;
              if (fail6) {
                head5._3 = fail6;
                tmp = true;
                kid = killId++;
                kills[kid] = kill(early, fail6 === lhs ? head5._2 : head5._1, function() {
                  return function() {
                    delete kills[kid];
                    if (tmp) {
                      tmp = false;
                    } else if (tail4 === null) {
                      join2(fail6, null, null);
                    } else {
                      join2(fail6, tail4._1, tail4._2);
                    }
                  };
                });
                if (tmp) {
                  tmp = false;
                  return;
                }
              } else if (lhs === EMPTY || rhs === EMPTY) {
                return;
              } else {
                step2 = util.right(util.fromRight(lhs)(util.fromRight(rhs)));
                head5._3 = step2;
              }
              break;
            case ALT:
              lhs = head5._1._3;
              rhs = head5._2._3;
              if (lhs === EMPTY && util.isLeft(rhs) || rhs === EMPTY && util.isLeft(lhs)) {
                return;
              }
              if (lhs !== EMPTY && util.isLeft(lhs) && rhs !== EMPTY && util.isLeft(rhs)) {
                fail6 = step2 === lhs ? rhs : lhs;
                step2 = null;
                head5._3 = fail6;
              } else {
                head5._3 = step2;
                tmp = true;
                kid = killId++;
                kills[kid] = kill(early, step2 === lhs ? head5._2 : head5._1, function() {
                  return function() {
                    delete kills[kid];
                    if (tmp) {
                      tmp = false;
                    } else if (tail4 === null) {
                      join2(step2, null, null);
                    } else {
                      join2(step2, tail4._1, tail4._2);
                    }
                  };
                });
                if (tmp) {
                  tmp = false;
                  return;
                }
              }
              break;
          }
          if (tail4 === null) {
            head5 = null;
          } else {
            head5 = tail4._1;
            tail4 = tail4._2;
          }
        }
      }
      function resolve(fiber) {
        return function(result) {
          return function() {
            delete fibers[fiber._1];
            fiber._3 = result;
            join2(result, fiber._2._1, fiber._2._2);
          };
        };
      }
      function run4() {
        var status = CONTINUE;
        var step2 = par;
        var head5 = null;
        var tail4 = null;
        var tmp, fid;
        loop: while (true) {
          tmp = null;
          fid = null;
          switch (status) {
            case CONTINUE:
              switch (step2.tag) {
                case MAP:
                  if (head5) {
                    tail4 = new Aff2(CONS, head5, tail4);
                  }
                  head5 = new Aff2(MAP, step2._1, EMPTY, EMPTY);
                  step2 = step2._2;
                  break;
                case APPLY:
                  if (head5) {
                    tail4 = new Aff2(CONS, head5, tail4);
                  }
                  head5 = new Aff2(APPLY, EMPTY, step2._2, EMPTY);
                  step2 = step2._1;
                  break;
                case ALT:
                  if (head5) {
                    tail4 = new Aff2(CONS, head5, tail4);
                  }
                  head5 = new Aff2(ALT, EMPTY, step2._2, EMPTY);
                  step2 = step2._1;
                  break;
                default:
                  fid = fiberId++;
                  status = RETURN;
                  tmp = step2;
                  step2 = new Aff2(FORKED, fid, new Aff2(CONS, head5, tail4), EMPTY);
                  tmp = Fiber(util, supervisor, tmp);
                  tmp.onComplete({
                    rethrow: false,
                    handler: resolve(step2)
                  })();
                  fibers[fid] = tmp;
                  if (supervisor) {
                    supervisor.register(tmp);
                  }
              }
              break;
            case RETURN:
              if (head5 === null) {
                break loop;
              }
              if (head5._1 === EMPTY) {
                head5._1 = step2;
                status = CONTINUE;
                step2 = head5._2;
                head5._2 = EMPTY;
              } else {
                head5._2 = step2;
                step2 = head5;
                if (tail4 === null) {
                  head5 = null;
                } else {
                  head5 = tail4._1;
                  tail4 = tail4._2;
                }
              }
          }
        }
        root = step2;
        for (fid = 0; fid < fiberId; fid++) {
          fibers[fid].run();
        }
      }
      function cancel(error5, cb2) {
        interrupt = util.left(error5);
        var innerKills;
        for (var kid in kills) {
          if (kills.hasOwnProperty(kid)) {
            innerKills = kills[kid];
            for (kid in innerKills) {
              if (innerKills.hasOwnProperty(kid)) {
                innerKills[kid]();
              }
            }
          }
        }
        kills = null;
        var newKills = kill(error5, root, cb2);
        return function(killError) {
          return new Aff2(ASYNC, function(killCb) {
            return function() {
              for (var kid2 in newKills) {
                if (newKills.hasOwnProperty(kid2)) {
                  newKills[kid2]();
                }
              }
              return nonCanceler;
            };
          });
        };
      }
      run4();
      return function(killError) {
        return new Aff2(ASYNC, function(killCb) {
          return function() {
            return cancel(killError, killCb);
          };
        });
      };
    }
    function sequential2(util, supervisor, par) {
      return new Aff2(ASYNC, function(cb) {
        return function() {
          return runPar(util, supervisor, par, cb);
        };
      });
    }
    Aff2.EMPTY = EMPTY;
    Aff2.Pure = AffCtr(PURE);
    Aff2.Throw = AffCtr(THROW);
    Aff2.Catch = AffCtr(CATCH);
    Aff2.Sync = AffCtr(SYNC);
    Aff2.Async = AffCtr(ASYNC);
    Aff2.Bind = AffCtr(BIND);
    Aff2.Bracket = AffCtr(BRACKET);
    Aff2.Fork = AffCtr(FORK);
    Aff2.Seq = AffCtr(SEQ);
    Aff2.ParMap = AffCtr(MAP);
    Aff2.ParApply = AffCtr(APPLY);
    Aff2.ParAlt = AffCtr(ALT);
    Aff2.Fiber = Fiber;
    Aff2.Supervisor = Supervisor;
    Aff2.Scheduler = Scheduler;
    Aff2.nonCanceler = nonCanceler;
    return Aff2;
  }();
  var _pure = Aff.Pure;
  var _throwError = Aff.Throw;
  function _catchError(aff) {
    return function(k2) {
      return Aff.Catch(aff, k2);
    };
  }
  function _map(f2) {
    return function(aff) {
      if (aff.tag === Aff.Pure.tag) {
        return Aff.Pure(f2(aff._1));
      } else {
        return Aff.Bind(aff, function(value12) {
          return Aff.Pure(f2(value12));
        });
      }
    };
  }
  function _bind(aff) {
    return function(k2) {
      return Aff.Bind(aff, k2);
    };
  }
  function _fork(immediate) {
    return function(aff) {
      return Aff.Fork(immediate, aff);
    };
  }
  var _liftEffect = Aff.Sync;
  function _parAffMap(f2) {
    return function(aff) {
      return Aff.ParMap(f2, aff);
    };
  }
  function _parAffApply(aff1) {
    return function(aff2) {
      return Aff.ParApply(aff1, aff2);
    };
  }
  var makeAff = Aff.Async;
  function _makeFiber(util, aff) {
    return function() {
      return Aff.Fiber(util, null, aff);
    };
  }
  var _delay = /* @__PURE__ */ function() {
    function setDelay(n2, k2) {
      if (n2 === 0 && typeof setImmediate !== "undefined") {
        return setImmediate(k2);
      } else {
        return setTimeout(k2, n2);
      }
    }
    function clearDelay(n2, t3) {
      if (n2 === 0 && typeof clearImmediate !== "undefined") {
        return clearImmediate(t3);
      } else {
        return clearTimeout(t3);
      }
    }
    return function(right, ms) {
      return Aff.Async(function(cb) {
        return function() {
          var timer = setDelay(ms, cb(right()));
          return function() {
            return Aff.Sync(function() {
              return right(clearDelay(ms, timer));
            });
          };
        };
      });
    };
  }();
  var _sequential = Aff.Seq;

  // output/Effect.Unsafe/foreign.js
  var unsafePerformEffect = function(f2) {
    return f2();
  };

  // output/Effect.Aff/index.js
  var $runtime_lazy2 = function(name16, moduleName, init6) {
    var state4 = 0;
    var val;
    return function(lineNumber) {
      if (state4 === 2) return val;
      if (state4 === 1) throw new ReferenceError(name16 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
      state4 = 1;
      val = init6();
      state4 = 2;
      return val;
    };
  };
  var pure3 = /* @__PURE__ */ pure(applicativeEffect);
  var $$void2 = /* @__PURE__ */ $$void(functorEffect);
  var map6 = /* @__PURE__ */ map(functorEffect);
  var Canceler = function(x2) {
    return x2;
  };
  var functorParAff = {
    map: _parAffMap
  };
  var functorAff = {
    map: _map
  };
  var forkAff = /* @__PURE__ */ _fork(true);
  var ffiUtil = /* @__PURE__ */ function() {
    var unsafeFromRight = function(v2) {
      if (v2 instanceof Right) {
        return v2.value0;
      }
      ;
      if (v2 instanceof Left) {
        return unsafeCrashWith("unsafeFromRight: Left");
      }
      ;
      throw new Error("Failed pattern match at Effect.Aff (line 412, column 21 - line 414, column 54): " + [v2.constructor.name]);
    };
    var unsafeFromLeft = function(v2) {
      if (v2 instanceof Left) {
        return v2.value0;
      }
      ;
      if (v2 instanceof Right) {
        return unsafeCrashWith("unsafeFromLeft: Right");
      }
      ;
      throw new Error("Failed pattern match at Effect.Aff (line 407, column 20 - line 409, column 55): " + [v2.constructor.name]);
    };
    var isLeft = function(v2) {
      if (v2 instanceof Left) {
        return true;
      }
      ;
      if (v2 instanceof Right) {
        return false;
      }
      ;
      throw new Error("Failed pattern match at Effect.Aff (line 402, column 12 - line 404, column 21): " + [v2.constructor.name]);
    };
    return {
      isLeft,
      fromLeft: unsafeFromLeft,
      fromRight: unsafeFromRight,
      left: Left.create,
      right: Right.create
    };
  }();
  var makeFiber = function(aff) {
    return _makeFiber(ffiUtil, aff);
  };
  var launchAff = function(aff) {
    return function __do() {
      var fiber = makeFiber(aff)();
      fiber.run();
      return fiber;
    };
  };
  var delay = function(v2) {
    return _delay(Right.create, v2);
  };
  var applyParAff = {
    apply: _parAffApply,
    Functor0: function() {
      return functorParAff;
    }
  };
  var monadAff = {
    Applicative0: function() {
      return applicativeAff;
    },
    Bind1: function() {
      return bindAff;
    }
  };
  var bindAff = {
    bind: _bind,
    Apply0: function() {
      return $lazy_applyAff(0);
    }
  };
  var applicativeAff = {
    pure: _pure,
    Apply0: function() {
      return $lazy_applyAff(0);
    }
  };
  var $lazy_applyAff = /* @__PURE__ */ $runtime_lazy2("applyAff", "Effect.Aff", function() {
    return {
      apply: ap(monadAff),
      Functor0: function() {
        return functorAff;
      }
    };
  });
  var applyAff = /* @__PURE__ */ $lazy_applyAff(73);
  var pure22 = /* @__PURE__ */ pure(applicativeAff);
  var bind1 = /* @__PURE__ */ bind(bindAff);
  var bindFlipped2 = /* @__PURE__ */ bindFlipped(bindAff);
  var parallelAff = {
    parallel: unsafeCoerce,
    sequential: _sequential,
    Apply0: function() {
      return applyAff;
    },
    Apply1: function() {
      return applyParAff;
    }
  };
  var parallel2 = /* @__PURE__ */ parallel(parallelAff);
  var applicativeParAff = {
    pure: function($76) {
      return parallel2(pure22($76));
    },
    Apply0: function() {
      return applyParAff;
    }
  };
  var monadEffectAff = {
    liftEffect: _liftEffect,
    Monad0: function() {
      return monadAff;
    }
  };
  var liftEffect2 = /* @__PURE__ */ liftEffect(monadEffectAff);
  var effectCanceler = function($77) {
    return Canceler($$const(liftEffect2($77)));
  };
  var killFiber = function(e2) {
    return function(v2) {
      return bind1(liftEffect2(v2.isSuspended))(function(suspended) {
        if (suspended) {
          return liftEffect2($$void2(v2.kill(e2, $$const(pure3(unit)))));
        }
        ;
        return makeAff(function(k2) {
          return map6(effectCanceler)(v2.kill(e2, k2));
        });
      });
    };
  };
  var monadThrowAff = {
    throwError: _throwError,
    Monad0: function() {
      return monadAff;
    }
  };
  var monadErrorAff = {
    catchError: _catchError,
    MonadThrow0: function() {
      return monadThrowAff;
    }
  };
  var $$try3 = /* @__PURE__ */ $$try2(monadErrorAff);
  var runAff = function(k2) {
    return function(aff) {
      return launchAff(bindFlipped2(function($83) {
        return liftEffect2(k2($83));
      })($$try3(aff)));
    };
  };
  var runAff_ = function(k2) {
    return function(aff) {
      return $$void2(runAff(k2)(aff));
    };
  };

  // output/Effect.Console/foreign.js
  var log = function(s2) {
    return function() {
      console.log(s2);
    };
  };
  var error2 = function(s2) {
    return function() {
      console.error(s2);
    };
  };
  var debug = function(s2) {
    return function() {
      console.debug(s2);
    };
  };

  // output/Effect.Class.Console/index.js
  var error3 = function(dictMonadEffect) {
    var $79 = liftEffect(dictMonadEffect);
    return function($80) {
      return $79(error2($80));
    };
  };
  var debug2 = function(dictMonadEffect) {
    var $83 = liftEffect(dictMonadEffect);
    return function($84) {
      return $83(debug($84));
    };
  };

  // output/Effect.Now/foreign.js
  function now() {
    return Date.now();
  }

  // output/Data.Enum/foreign.js
  function toCharCode(c2) {
    return c2.charCodeAt(0);
  }
  function fromCharCode(c2) {
    return String.fromCharCode(c2);
  }

  // output/Data.Unfoldable/foreign.js
  var unfoldrArrayImpl = function(isNothing2) {
    return function(fromJust6) {
      return function(fst2) {
        return function(snd2) {
          return function(f2) {
            return function(b2) {
              var result = [];
              var value12 = b2;
              while (true) {
                var maybe2 = f2(value12);
                if (isNothing2(maybe2)) return result;
                var tuple = fromJust6(maybe2);
                result.push(fst2(tuple));
                value12 = snd2(tuple);
              }
            };
          };
        };
      };
    };
  };

  // output/Data.Unfoldable1/foreign.js
  var unfoldr1ArrayImpl = function(isNothing2) {
    return function(fromJust6) {
      return function(fst2) {
        return function(snd2) {
          return function(f2) {
            return function(b2) {
              var result = [];
              var value12 = b2;
              while (true) {
                var tuple = f2(value12);
                result.push(fst2(tuple));
                var maybe2 = snd2(tuple);
                if (isNothing2(maybe2)) return result;
                value12 = fromJust6(maybe2);
              }
            };
          };
        };
      };
    };
  };

  // output/Data.Unfoldable1/index.js
  var fromJust2 = /* @__PURE__ */ fromJust();
  var unfoldable1Array = {
    unfoldr1: /* @__PURE__ */ unfoldr1ArrayImpl(isNothing)(fromJust2)(fst)(snd)
  };

  // output/Data.Unfoldable/index.js
  var fromJust3 = /* @__PURE__ */ fromJust();
  var unfoldr = function(dict) {
    return dict.unfoldr;
  };
  var unfoldableArray = {
    unfoldr: /* @__PURE__ */ unfoldrArrayImpl(isNothing)(fromJust3)(fst)(snd),
    Unfoldable10: function() {
      return unfoldable1Array;
    }
  };

  // output/Data.Enum/index.js
  var bottom1 = /* @__PURE__ */ bottom(boundedChar);
  var top1 = /* @__PURE__ */ top(boundedChar);
  var toEnum = function(dict) {
    return dict.toEnum;
  };
  var fromEnum = function(dict) {
    return dict.fromEnum;
  };
  var toEnumWithDefaults = function(dictBoundedEnum) {
    var toEnum1 = toEnum(dictBoundedEnum);
    var fromEnum1 = fromEnum(dictBoundedEnum);
    var bottom22 = bottom(dictBoundedEnum.Bounded0());
    return function(low2) {
      return function(high2) {
        return function(x2) {
          var v2 = toEnum1(x2);
          if (v2 instanceof Just) {
            return v2.value0;
          }
          ;
          if (v2 instanceof Nothing) {
            var $140 = x2 < fromEnum1(bottom22);
            if ($140) {
              return low2;
            }
            ;
            return high2;
          }
          ;
          throw new Error("Failed pattern match at Data.Enum (line 158, column 33 - line 160, column 62): " + [v2.constructor.name]);
        };
      };
    };
  };
  var defaultSucc = function(toEnum$prime) {
    return function(fromEnum$prime) {
      return function(a2) {
        return toEnum$prime(fromEnum$prime(a2) + 1 | 0);
      };
    };
  };
  var defaultPred = function(toEnum$prime) {
    return function(fromEnum$prime) {
      return function(a2) {
        return toEnum$prime(fromEnum$prime(a2) - 1 | 0);
      };
    };
  };
  var charToEnum = function(v2) {
    if (v2 >= toCharCode(bottom1) && v2 <= toCharCode(top1)) {
      return new Just(fromCharCode(v2));
    }
    ;
    return Nothing.value;
  };
  var enumChar = {
    succ: /* @__PURE__ */ defaultSucc(charToEnum)(toCharCode),
    pred: /* @__PURE__ */ defaultPred(charToEnum)(toCharCode),
    Ord0: function() {
      return ordChar;
    }
  };
  var boundedEnumChar = /* @__PURE__ */ function() {
    return {
      cardinality: toCharCode(top1) - toCharCode(bottom1) | 0,
      toEnum: charToEnum,
      fromEnum: toCharCode,
      Bounded0: function() {
        return boundedChar;
      },
      Enum1: function() {
        return enumChar;
      }
    };
  }();

  // output/Data.Int/foreign.js
  var fromNumberImpl = function(just) {
    return function(nothing) {
      return function(n2) {
        return (n2 | 0) === n2 ? just(n2) : nothing;
      };
    };
  };
  var toNumber = function(n2) {
    return n2;
  };

  // output/Data.Number/foreign.js
  var isFiniteImpl = isFinite;
  var floor = Math.floor;
  var remainder = function(n2) {
    return function(m2) {
      return n2 % m2;
    };
  };

  // output/Data.Int/index.js
  var top2 = /* @__PURE__ */ top(boundedInt);
  var bottom2 = /* @__PURE__ */ bottom(boundedInt);
  var fromNumber = /* @__PURE__ */ function() {
    return fromNumberImpl(Just.create)(Nothing.value);
  }();
  var unsafeClamp = function(x2) {
    if (!isFiniteImpl(x2)) {
      return 0;
    }
    ;
    if (x2 >= toNumber(top2)) {
      return top2;
    }
    ;
    if (x2 <= toNumber(bottom2)) {
      return bottom2;
    }
    ;
    if (otherwise) {
      return fromMaybe(0)(fromNumber(x2));
    }
    ;
    throw new Error("Failed pattern match at Data.Int (line 72, column 1 - line 72, column 29): " + [x2.constructor.name]);
  };
  var floor2 = function($39) {
    return unsafeClamp(floor($39));
  };

  // output/Data.DateTime.Instant/index.js
  var show3 = /* @__PURE__ */ show(showMilliseconds);
  var showInstant = {
    show: function(v2) {
      return "(Instant " + (show3(v2) + ")");
    }
  };
  var eqDateTime = eqMilliseconds;

  // output/Flame.Application.Internal.Dom/foreign.js
  function querySelector_(selector) {
    return document.querySelector(selector);
  }
  function createWindowListener_(eventName, updater) {
    window.addEventListener(eventName, function(event) {
      updater(event)();
    });
  }
  function createDocumentListener_(eventName, updater) {
    document.addEventListener(eventName, function(event) {
      updater(event)();
    });
  }
  function createCustomListener_(eventName, updater) {
    document.addEventListener(eventName, function(event) {
      updater(event.detail)();
    });
  }
  function dispatchCustomEvent_(eventName, payload) {
    document.dispatchEvent(new CustomEvent(eventName, { detail: payload }));
  }

  // output/Data.Nullable/foreign.js
  function nullable(a2, r2, f2) {
    return a2 == null ? r2 : f2(a2);
  }

  // output/Data.Nullable/index.js
  var toMaybe = function(n2) {
    return nullable(n2, Nothing.value, Just.create);
  };

  // output/Effect.Uncurried/foreign.js
  var runEffectFn1 = function runEffectFn12(fn) {
    return function(a2) {
      return function() {
        return fn(a2);
      };
    };
  };
  var runEffectFn2 = function runEffectFn22(fn) {
    return function(a2) {
      return function(b2) {
        return function() {
          return fn(a2, b2);
        };
      };
    };
  };
  var runEffectFn4 = function runEffectFn42(fn) {
    return function(a2) {
      return function(b2) {
        return function(c2) {
          return function(d2) {
            return function() {
              return fn(a2, b2, c2, d2);
            };
          };
        };
      };
    };
  };

  // output/Flame.Application.Internal.Dom/index.js
  var querySelector = function(selector) {
    return function __do() {
      var selected2 = querySelector_(selector);
      return toMaybe(selected2);
    };
  };
  var dispatchCustomEvent = /* @__PURE__ */ runEffectFn2(dispatchCustomEvent_);
  var createWindowListener = /* @__PURE__ */ runEffectFn2(createWindowListener_);
  var createDocumentListener = /* @__PURE__ */ runEffectFn2(createDocumentListener_);
  var createCustomListener = /* @__PURE__ */ runEffectFn2(createCustomListener_);

  // output/Data.String.Regex/foreign.js
  var regexImpl = function(left) {
    return function(right) {
      return function(s1) {
        return function(s2) {
          try {
            return right(new RegExp(s1, s2));
          } catch (e2) {
            return left(e2.message);
          }
        };
      };
    };
  };
  var test = function(r2) {
    return function(s2) {
      var lastIndex = r2.lastIndex;
      var result = r2.test(s2);
      r2.lastIndex = lastIndex;
      return result;
    };
  };
  var _match = function(just) {
    return function(nothing) {
      return function(r2) {
        return function(s2) {
          var m2 = s2.match(r2);
          if (m2 == null || m2.length === 0) {
            return nothing;
          } else {
            for (var i2 = 0; i2 < m2.length; i2++) {
              m2[i2] = m2[i2] == null ? nothing : just(m2[i2]);
            }
            return just(m2);
          }
        };
      };
    };
  };
  var _replaceBy = function(just) {
    return function(nothing) {
      return function(r2) {
        return function(f2) {
          return function(s2) {
            return s2.replace(r2, function(match2) {
              var groups = [];
              var group4, i2 = 1;
              while (typeof (group4 = arguments[i2++]) !== "number") {
                groups.push(group4 == null ? nothing : just(group4));
              }
              return f2(match2)(groups);
            });
          };
        };
      };
    };
  };

  // output/Data.String.CodeUnits/foreign.js
  var singleton2 = function(c2) {
    return c2;
  };
  var length = function(s2) {
    return s2.length;
  };
  var drop = function(n2) {
    return function(s2) {
      return s2.substring(n2);
    };
  };

  // output/Data.String.Unsafe/foreign.js
  var charAt = function(i2) {
    return function(s2) {
      if (i2 >= 0 && i2 < s2.length) return s2.charAt(i2);
      throw new Error("Data.String.Unsafe.charAt: Invalid index.");
    };
  };

  // output/Data.String.Common/foreign.js
  var split = function(sep) {
    return function(s2) {
      return s2.split(sep);
    };
  };
  var toLower = function(s2) {
    return s2.toLowerCase();
  };
  var toUpper = function(s2) {
    return s2.toUpperCase();
  };
  var joinWith = function(s2) {
    return function(xs) {
      return xs.join(s2);
    };
  };

  // output/Data.String.Common/index.js
  var $$null = function(s2) {
    return s2 === "";
  };

  // output/Data.String.Regex.Flags/index.js
  var global = {
    global: true,
    ignoreCase: false,
    multiline: false,
    dotAll: false,
    sticky: false,
    unicode: false
  };

  // output/Data.String.Regex/index.js
  var replace$prime = /* @__PURE__ */ function() {
    return _replaceBy(Just.create)(Nothing.value);
  }();
  var renderFlags = function(v2) {
    return function() {
      if (v2.global) {
        return "g";
      }
      ;
      return "";
    }() + (function() {
      if (v2.ignoreCase) {
        return "i";
      }
      ;
      return "";
    }() + (function() {
      if (v2.multiline) {
        return "m";
      }
      ;
      return "";
    }() + (function() {
      if (v2.dotAll) {
        return "s";
      }
      ;
      return "";
    }() + (function() {
      if (v2.sticky) {
        return "y";
      }
      ;
      return "";
    }() + function() {
      if (v2.unicode) {
        return "u";
      }
      ;
      return "";
    }()))));
  };
  var regex = function(s2) {
    return function(f2) {
      return regexImpl(Left.create)(Right.create)(s2)(renderFlags(f2));
    };
  };
  var match = /* @__PURE__ */ function() {
    return _match(Just.create)(Nothing.value);
  }();

  // output/Data.String.Regex.Unsafe/index.js
  var identity6 = /* @__PURE__ */ identity(categoryFn);
  var unsafeRegex = function(s2) {
    return function(f2) {
      return either(unsafeCrashWith)(identity6)(regex(s2)(f2));
    };
  };

  // output/Flame.Html.Attribute.Internal/foreign.js
  var styleData = 1;
  var classData = 2;
  var propertyData = 3;
  function createProperty(name16) {
    return function(value12) {
      return [propertyData, name16, value12];
    };
  }
  function createClass(array) {
    return [classData, array];
  }
  function createStyle(object) {
    return [styleData, object];
  }

  // output/Data.Array/foreign.js
  var rangeImpl = function(start3, end) {
    var step2 = start3 > end ? -1 : 1;
    var result = new Array(step2 * (end - start3) + 1);
    var i2 = start3, n2 = 0;
    while (i2 !== end) {
      result[n2++] = i2;
      i2 += step2;
    }
    result[n2] = i2;
    return result;
  };
  var replicateFill = function(count2, value12) {
    if (count2 < 1) {
      return [];
    }
    var result = new Array(count2);
    return result.fill(value12);
  };
  var replicatePolyfill = function(count2, value12) {
    var result = [];
    var n2 = 0;
    for (var i2 = 0; i2 < count2; i2++) {
      result[n2++] = value12;
    }
    return result;
  };
  var replicateImpl = typeof Array.prototype.fill === "function" ? replicateFill : replicatePolyfill;
  var fromFoldableImpl = /* @__PURE__ */ function() {
    function Cons2(head5, tail4) {
      this.head = head5;
      this.tail = tail4;
    }
    var emptyList = {};
    function curryCons(head5) {
      return function(tail4) {
        return new Cons2(head5, tail4);
      };
    }
    function listToArray(list) {
      var result = [];
      var count2 = 0;
      var xs = list;
      while (xs !== emptyList) {
        result[count2++] = xs.head;
        xs = xs.tail;
      }
      return result;
    }
    return function(foldr3, xs) {
      return listToArray(foldr3(curryCons)(emptyList)(xs));
    };
  }();
  var length2 = function(xs) {
    return xs.length;
  };
  var filterImpl = function(f2, xs) {
    return xs.filter(f2);
  };
  var unsafeIndexImpl = function(xs, n2) {
    return xs[n2];
  };

  // output/Data.Function.Uncurried/foreign.js
  var runFn2 = function(fn) {
    return function(a2) {
      return function(b2) {
        return fn(a2, b2);
      };
    };
  };
  var runFn4 = function(fn) {
    return function(a2) {
      return function(b2) {
        return function(c2) {
          return function(d2) {
            return fn(a2, b2, c2, d2);
          };
        };
      };
    };
  };

  // output/Data.FunctorWithIndex/foreign.js
  var mapWithIndexArray = function(f2) {
    return function(xs) {
      var l2 = xs.length;
      var result = Array(l2);
      for (var i2 = 0; i2 < l2; i2++) {
        result[i2] = f2(i2)(xs[i2]);
      }
      return result;
    };
  };

  // output/Data.FunctorWithIndex/index.js
  var mapWithIndex = function(dict) {
    return dict.mapWithIndex;
  };
  var functorWithIndexArray = {
    mapWithIndex: mapWithIndexArray,
    Functor0: function() {
      return functorArray;
    }
  };

  // output/Data.Array/index.js
  var unsafeIndex = function() {
    return runFn2(unsafeIndexImpl);
  };
  var unsafeIndex1 = /* @__PURE__ */ unsafeIndex();
  var toUnfoldable = function(dictUnfoldable) {
    var unfoldr3 = unfoldr(dictUnfoldable);
    return function(xs) {
      var len = length2(xs);
      var f2 = function(i2) {
        if (i2 < len) {
          return new Just(new Tuple(unsafeIndex1(xs)(i2), i2 + 1 | 0));
        }
        ;
        if (otherwise) {
          return Nothing.value;
        }
        ;
        throw new Error("Failed pattern match at Data.Array (line 163, column 3 - line 165, column 26): " + [i2.constructor.name]);
      };
      return unfoldr3(f2)(0);
    };
  };
  var singleton3 = function(a2) {
    return [a2];
  };
  var range2 = /* @__PURE__ */ runFn2(rangeImpl);
  var $$null2 = function(xs) {
    return length2(xs) === 0;
  };
  var fromFoldable = function(dictFoldable) {
    return runFn2(fromFoldableImpl)(foldr(dictFoldable));
  };
  var foldl2 = /* @__PURE__ */ foldl(foldableArray);
  var filter = /* @__PURE__ */ runFn2(filterImpl);
  var concatMap = /* @__PURE__ */ flip(/* @__PURE__ */ bind(bindArray));
  var mapMaybe = function(f2) {
    return concatMap(function() {
      var $189 = maybe([])(singleton3);
      return function($190) {
        return $189(f2($190));
      };
    }());
  };
  var catMaybes = /* @__PURE__ */ mapMaybe(/* @__PURE__ */ identity(categoryFn));

  // output/Data.String.CodePoints/foreign.js
  var hasArrayFrom = typeof Array.from === "function";
  var hasStringIterator = typeof Symbol !== "undefined" && Symbol != null && typeof Symbol.iterator !== "undefined" && typeof String.prototype[Symbol.iterator] === "function";
  var hasFromCodePoint = typeof String.prototype.fromCodePoint === "function";
  var hasCodePointAt = typeof String.prototype.codePointAt === "function";
  var _unsafeCodePointAt0 = function(fallback) {
    return hasCodePointAt ? function(str) {
      return str.codePointAt(0);
    } : fallback;
  };
  var _fromCodePointArray = function(singleton9) {
    return hasFromCodePoint ? function(cps) {
      if (cps.length < 1e4) {
        return String.fromCodePoint.apply(String, cps);
      }
      return cps.map(singleton9).join("");
    } : function(cps) {
      return cps.map(singleton9).join("");
    };
  };
  var _singleton = function(fallback) {
    return hasFromCodePoint ? String.fromCodePoint : fallback;
  };
  var _take = function(fallback) {
    return function(n2) {
      if (hasStringIterator) {
        return function(str) {
          var accum = "";
          var iter = str[Symbol.iterator]();
          for (var i2 = 0; i2 < n2; ++i2) {
            var o2 = iter.next();
            if (o2.done) return accum;
            accum += o2.value;
          }
          return accum;
        };
      }
      return fallback(n2);
    };
  };
  var _toCodePointArray = function(fallback) {
    return function(unsafeCodePointAt02) {
      if (hasArrayFrom) {
        return function(str) {
          return Array.from(str, unsafeCodePointAt02);
        };
      }
      return fallback;
    };
  };

  // output/Data.String.CodePoints/index.js
  var fromEnum2 = /* @__PURE__ */ fromEnum(boundedEnumChar);
  var map7 = /* @__PURE__ */ map(functorMaybe);
  var unfoldr2 = /* @__PURE__ */ unfoldr(unfoldableArray);
  var div2 = /* @__PURE__ */ div(euclideanRingInt);
  var mod2 = /* @__PURE__ */ mod(euclideanRingInt);
  var unsurrogate = function(lead) {
    return function(trail) {
      return (((lead - 55296 | 0) * 1024 | 0) + (trail - 56320 | 0) | 0) + 65536 | 0;
    };
  };
  var isTrail = function(cu) {
    return 56320 <= cu && cu <= 57343;
  };
  var isLead = function(cu) {
    return 55296 <= cu && cu <= 56319;
  };
  var uncons = function(s2) {
    var v2 = length(s2);
    if (v2 === 0) {
      return Nothing.value;
    }
    ;
    if (v2 === 1) {
      return new Just({
        head: fromEnum2(charAt(0)(s2)),
        tail: ""
      });
    }
    ;
    var cu1 = fromEnum2(charAt(1)(s2));
    var cu0 = fromEnum2(charAt(0)(s2));
    var $43 = isLead(cu0) && isTrail(cu1);
    if ($43) {
      return new Just({
        head: unsurrogate(cu0)(cu1),
        tail: drop(2)(s2)
      });
    }
    ;
    return new Just({
      head: cu0,
      tail: drop(1)(s2)
    });
  };
  var unconsButWithTuple = function(s2) {
    return map7(function(v2) {
      return new Tuple(v2.head, v2.tail);
    })(uncons(s2));
  };
  var toCodePointArrayFallback = function(s2) {
    return unfoldr2(unconsButWithTuple)(s2);
  };
  var unsafeCodePointAt0Fallback = function(s2) {
    var cu0 = fromEnum2(charAt(0)(s2));
    var $47 = isLead(cu0) && length(s2) > 1;
    if ($47) {
      var cu1 = fromEnum2(charAt(1)(s2));
      var $48 = isTrail(cu1);
      if ($48) {
        return unsurrogate(cu0)(cu1);
      }
      ;
      return cu0;
    }
    ;
    return cu0;
  };
  var unsafeCodePointAt0 = /* @__PURE__ */ _unsafeCodePointAt0(unsafeCodePointAt0Fallback);
  var toCodePointArray = /* @__PURE__ */ _toCodePointArray(toCodePointArrayFallback)(unsafeCodePointAt0);
  var length3 = function($74) {
    return length2(toCodePointArray($74));
  };
  var fromCharCode2 = /* @__PURE__ */ function() {
    var $75 = toEnumWithDefaults(boundedEnumChar)(bottom(boundedChar))(top(boundedChar));
    return function($76) {
      return singleton2($75($76));
    };
  }();
  var singletonFallback = function(v2) {
    if (v2 <= 65535) {
      return fromCharCode2(v2);
    }
    ;
    var lead = div2(v2 - 65536 | 0)(1024) + 55296 | 0;
    var trail = mod2(v2 - 65536 | 0)(1024) + 56320 | 0;
    return fromCharCode2(lead) + fromCharCode2(trail);
  };
  var fromCodePointArray = /* @__PURE__ */ _fromCodePointArray(singletonFallback);
  var singleton4 = /* @__PURE__ */ _singleton(singletonFallback);
  var takeFallback = function(v2) {
    return function(v1) {
      if (v2 < 1) {
        return "";
      }
      ;
      var v22 = uncons(v1);
      if (v22 instanceof Just) {
        return singleton4(v22.value0.head) + takeFallback(v2 - 1 | 0)(v22.value0.tail);
      }
      ;
      return v1;
    };
  };
  var take2 = /* @__PURE__ */ _take(takeFallback);

  // output/Foreign.Object/foreign.js
  function _copyST(m2) {
    return function() {
      var r2 = {};
      for (var k2 in m2) {
        if (hasOwnProperty.call(m2, k2)) {
          r2[k2] = m2[k2];
        }
      }
      return r2;
    };
  }
  var empty2 = {};
  function runST(f2) {
    return f2();
  }
  function _mapWithKey(m0, f2) {
    var m2 = {};
    for (var k2 in m0) {
      if (hasOwnProperty.call(m0, k2)) {
        m2[k2] = f2(k2)(m0[k2]);
      }
    }
    return m2;
  }
  function _lookup(no, yes, k2, m2) {
    return k2 in m2 ? yes(m2[k2]) : no;
  }
  function toArrayWithKey(f2) {
    return function(m2) {
      var r2 = [];
      for (var k2 in m2) {
        if (hasOwnProperty.call(m2, k2)) {
          r2.push(f2(k2)(m2[k2]));
        }
      }
      return r2;
    };
  }
  var keys = Object.keys || toArrayWithKey(function(k2) {
    return function() {
      return k2;
    };
  });

  // output/Data.FoldableWithIndex/index.js
  var foldlWithIndex = function(dict) {
    return dict.foldlWithIndex;
  };
  var foldWithIndexM = function(dictFoldableWithIndex) {
    var foldlWithIndex1 = foldlWithIndex(dictFoldableWithIndex);
    return function(dictMonad) {
      var bind8 = bind(dictMonad.Bind1());
      var pure19 = pure(dictMonad.Applicative0());
      return function(f2) {
        return function(a0) {
          return foldlWithIndex1(function(i2) {
            return function(ma) {
              return function(b2) {
                return bind8(ma)(flip(f2(i2))(b2));
              };
            };
          })(pure19(a0));
        };
      };
    };
  };

  // output/Foreign.Object.ST/foreign.js
  var newImpl = function() {
    return {};
  };
  function poke2(k2) {
    return function(v2) {
      return function(m2) {
        return function() {
          m2[k2] = v2;
          return m2;
        };
      };
    };
  }

  // output/Foreign.Object/index.js
  var $$void3 = /* @__PURE__ */ $$void(functorST);
  var toUnfoldable2 = function(dictUnfoldable) {
    var $89 = toUnfoldable(dictUnfoldable);
    var $90 = toArrayWithKey(Tuple.create);
    return function($91) {
      return $89($90($91));
    };
  };
  var thawST = _copyST;
  var mutate = function(f2) {
    return function(m2) {
      return runST(function __do() {
        var s2 = thawST(m2)();
        f2(s2)();
        return s2;
      });
    };
  };
  var mapWithKey = function(f2) {
    return function(m2) {
      return _mapWithKey(m2, f2);
    };
  };
  var lookup = /* @__PURE__ */ function() {
    return runFn4(_lookup)(Nothing.value)(Just.create);
  }();
  var insert = function(k2) {
    return function(v2) {
      return mutate(poke2(k2)(v2));
    };
  };
  var fromHomogeneous = function() {
    return unsafeCoerce;
  };
  var fromFoldable2 = function(dictFoldable) {
    var fromFoldable12 = fromFoldable(dictFoldable);
    return function(l2) {
      return runST(function __do() {
        var s2 = newImpl();
        foreach(fromFoldable12(l2))(function(v2) {
          return $$void3(poke2(v2.value0)(v2.value1)(s2));
        })();
        return s2;
      });
    };
  };

  // output/Flame.Html.Attribute.Internal/index.js
  var fromHomogeneous2 = /* @__PURE__ */ fromHomogeneous();
  var fromJust4 = /* @__PURE__ */ fromJust();
  var crashWith3 = /* @__PURE__ */ crashWith();
  var show22 = /* @__PURE__ */ show(showString);
  var map8 = /* @__PURE__ */ map(functorArray);
  var toUnfoldable3 = /* @__PURE__ */ toUnfoldable2(unfoldableArray);
  var fromFoldable3 = /* @__PURE__ */ fromFoldable2(foldableArray);
  var toClassListString = {
    to: /* @__PURE__ */ function() {
      var $46 = filter(function() {
        var $49 = not(heytingAlgebraBoolean);
        return function($50) {
          return $49($$null($50));
        };
      }());
      var $47 = split(" ");
      return function($48) {
        return $46($47($48));
      };
    }()
  };
  var toStyleList = function(dict) {
    return dict.toStyleList;
  };
  var to2 = function(dict) {
    return dict.to;
  };
  var style = function(dictToStyleList) {
    var toStyleList1 = toStyleList(dictToStyleList);
    return function(record) {
      return createStyle(toStyleList1(record));
    };
  };
  var id = /* @__PURE__ */ createProperty("id");
  var caseify = function(name$prime) {
    if (name$prime === toUpper(name$prime)) {
      return toLower(name$prime);
    }
    ;
    if (otherwise) {
      var v2 = fromJust4(uncons(name$prime));
      var replacer = function($133) {
        return $$const(function(v1) {
          return "-" + v1;
        }(toLower($133)));
      };
      var regex2 = function() {
        var v1 = regex("[A-Z]")(global);
        if (v1 instanceof Right) {
          return v1.value0;
        }
        ;
        if (v1 instanceof Left) {
          return crashWith3(show22(v1.value0));
        }
        ;
        throw new Error("Failed pattern match at Flame.Html.Attribute.Internal (line 90, column 40 - line 92, column 57): " + [v1.constructor.name]);
      }();
      var hyphenated = replace$prime(regex2)(replacer)(v2.tail);
      return toLower(singleton4(v2.head)) + hyphenated;
    }
    ;
    throw new Error("Failed pattern match at Flame.Html.Attribute.Internal (line 83, column 1 - line 83, column 26): " + [name$prime.constructor.name]);
  };
  var class$prime = function(dictToClassList) {
    var $134 = map8(caseify);
    var $135 = to2(dictToClassList);
    return function($136) {
      return createClass($134($135($136)));
    };
  };
  var toStyleListRecord = function() {
    return {
      toStyleList: function() {
        var toArray4 = function($137) {
          return toUnfoldable3(fromHomogeneous2($137));
        };
        var go2 = function(v2) {
          return new Tuple(caseify(v2.value0), v2.value1);
        };
        var $138 = map8(go2);
        return function($139) {
          return fromFoldable3($138(toArray4($139)));
        };
      }()
    };
  };

  // output/Flame.Html.Element/foreign.js
  var textNode = 1;
  var elementNode = 2;
  var managedNode = 6;
  var styleData2 = 1;
  var classData2 = 2;
  var propertyData2 = 3;
  var attributeData = 4;
  var keyData = 7;
  function createElementNode(tag) {
    return function(nodeData) {
      return function(potentialChildren) {
        let children2 = potentialChildren, text6 = void 0;
        if (potentialChildren.length === 1 && potentialChildren[0].nodeType == textNode) {
          children2 = void 0;
          text6 = potentialChildren[0].text;
        }
        return {
          nodeType: elementNode,
          node: void 0,
          tag,
          nodeData: fromNodeData(nodeData),
          children: children2,
          text: text6
        };
      };
    };
  }
  function createDatalessElementNode(tag) {
    return function(potentialChildren) {
      let children2 = potentialChildren, text6 = void 0;
      if (potentialChildren.length === 1 && potentialChildren[0].nodeType == textNode) {
        children2 = void 0;
        text6 = potentialChildren[0].text;
      }
      return {
        nodeType: elementNode,
        node: void 0,
        tag,
        nodeData: {},
        children: children2,
        text: text6
      };
    };
  }
  function createSingleElementNode(tag) {
    return function(nodeData) {
      return {
        nodeType: elementNode,
        node: void 0,
        tag,
        nodeData: fromNodeData(nodeData)
      };
    };
  }
  function text(value12) {
    return {
      nodeType: textNode,
      node: void 0,
      text: value12
    };
  }
  function createManagedNode(render2) {
    return function(nodeData) {
      return function(arg) {
        return {
          nodeType: managedNode,
          node: void 0,
          nodeData: fromNodeData(nodeData),
          createNode: render2.createNode,
          updateNode: render2.updateNode,
          arg
        };
      };
    };
  }
  function createDatalessManagedNode(render2) {
    return function(arg) {
      return {
        nodeType: managedNode,
        node: void 0,
        nodeData: {},
        createNode: render2.createNode,
        updateNode: render2.updateNode,
        arg
      };
    };
  }
  function fromNodeData(allData) {
    let nodeData = {};
    if (allData !== void 0)
      for (let data of allData) {
        let dataOne = data[1];
        switch (data[0]) {
          case styleData2:
            if (nodeData.styles === void 0)
              nodeData.styles = {};
            for (let key in dataOne)
              nodeData.styles[key] = dataOne[key];
            break;
          case classData2:
            if (nodeData.classes === void 0)
              nodeData.classes = [];
            nodeData.classes = nodeData.classes.concat(dataOne);
            break;
          case propertyData2:
            if (nodeData.properties === void 0)
              nodeData.properties = {};
            nodeData.properties[dataOne] = data[2];
            break;
          case attributeData:
            if (nodeData.attributes === void 0)
              nodeData.attributes = {};
            nodeData.attributes[dataOne] = data[2];
            break;
          case keyData:
            nodeData.key = dataOne;
            break;
          default:
            if (nodeData.events === void 0)
              nodeData.events = {};
            if (nodeData.events[dataOne] === void 0)
              nodeData.events[dataOne] = [];
            nodeData.events[dataOne].push(data[2]);
        }
      }
    return nodeData;
  }

  // output/Flame.Html.Element/index.js
  var toNodeStringNodeData = {
    toNode: function($776) {
      return singleton3(id($776));
    }
  };
  var toNodeNodeDataNodeData = {
    toNode: singleton3
  };
  var toNodeHtmlHtml = {
    toNode: singleton3
  };
  var toNode = function(dict) {
    return dict.toNode;
  };
  var toNodeArray = function(dictToNode) {
    return {
      toNode: concatMap(toNode(dictToNode))
    };
  };
  var managed_ = function(render2) {
    return function(arg) {
      return createDatalessManagedNode(render2)(arg);
    };
  };
  var managed = function(dictToNode) {
    var toNode1 = toNode(dictToNode);
    return function(render2) {
      return function(nodeData) {
        return function(arg) {
          return createManagedNode(render2)(toNode1(nodeData))(arg);
        };
      };
    };
  };
  var createElement_ = function(tag) {
    return function(dictToNode) {
      var toNode1 = toNode(dictToNode);
      return function(children2) {
        return createDatalessElementNode(tag)(toNode1(children2));
      };
    };
  };
  var section_ = function(dictToNode) {
    return createElement_("section")(dictToNode);
  };
  var createElement$prime = function(tag) {
    return function(dictToNode) {
      var toNode1 = toNode(dictToNode);
      return function(nodeData) {
        return createSingleElementNode(tag)(toNode1(nodeData));
      };
    };
  };
  var div$prime = function(dictToNode) {
    return createElement$prime("div")(dictToNode);
  };
  var createElement = function(tag) {
    return function(dictToNode) {
      var toNode1 = toNode(dictToNode);
      return function(dictToNode1) {
        var toNode22 = toNode(dictToNode1);
        return function(nodeData) {
          return function(children2) {
            return createElementNode(tag)(toNode1(nodeData))(toNode22(children2));
          };
        };
      };
    };
  };
  var div3 = function(dictToNode) {
    return function(dictToNode1) {
      return createElement("div")(dictToNode)(dictToNode1);
    };
  };
  var main = function(dictToNode) {
    return function(dictToNode1) {
      return createElement("main")(dictToNode)(dictToNode1);
    };
  };
  var button = function(dictToNode) {
    return function(dictToNode1) {
      return createElement("button")(dictToNode)(dictToNode1);
    };
  };

  // output/Flame.Renderer.String/foreign.js
  var reUnescapedHtml = /[&<>"']/g;
  var reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  // output/Data.NonEmpty/index.js
  var NonEmpty = /* @__PURE__ */ function() {
    function NonEmpty2(value0, value1) {
      this.value0 = value0;
      this.value1 = value1;
    }
    ;
    NonEmpty2.create = function(value0) {
      return function(value1) {
        return new NonEmpty2(value0, value1);
      };
    };
    return NonEmpty2;
  }();
  var singleton6 = function(dictPlus) {
    var empty7 = empty(dictPlus);
    return function(a2) {
      return new NonEmpty(a2, empty7);
    };
  };
  var showNonEmpty = function(dictShow) {
    var show11 = show(dictShow);
    return function(dictShow1) {
      var show17 = show(dictShow1);
      return {
        show: function(v2) {
          return "(NonEmpty " + (show11(v2.value0) + (" " + (show17(v2.value1) + ")")));
        }
      };
    };
  };
  var functorNonEmpty = function(dictFunctor) {
    var map27 = map(dictFunctor);
    return {
      map: function(f2) {
        return function(m2) {
          return new NonEmpty(f2(m2.value0), map27(f2)(m2.value1));
        };
      }
    };
  };
  var foldableNonEmpty = function(dictFoldable) {
    var foldMap3 = foldMap(dictFoldable);
    var foldl3 = foldl(dictFoldable);
    var foldr3 = foldr(dictFoldable);
    return {
      foldMap: function(dictMonoid) {
        var append12 = append(dictMonoid.Semigroup0());
        var foldMap12 = foldMap3(dictMonoid);
        return function(f2) {
          return function(v2) {
            return append12(f2(v2.value0))(foldMap12(f2)(v2.value1));
          };
        };
      },
      foldl: function(f2) {
        return function(b2) {
          return function(v2) {
            return foldl3(f2)(f2(b2)(v2.value0))(v2.value1);
          };
        };
      },
      foldr: function(f2) {
        return function(b2) {
          return function(v2) {
            return f2(v2.value0)(foldr3(f2)(b2)(v2.value1));
          };
        };
      }
    };
  };
  var eqNonEmpty = function(dictEq1) {
    var eq13 = eq1(dictEq1);
    return function(dictEq) {
      var eq3 = eq(dictEq);
      var eq11 = eq13(dictEq);
      return {
        eq: function(x2) {
          return function(y2) {
            return eq3(x2.value0)(y2.value0) && eq11(x2.value1)(y2.value1);
          };
        }
      };
    };
  };

  // output/Data.Array.NonEmpty/index.js
  var toArray = function(v2) {
    return v2;
  };
  var adaptAny = function(f2) {
    return function($128) {
      return f2(toArray($128));
    };
  };
  var catMaybes2 = /* @__PURE__ */ adaptAny(catMaybes);

  // output/Data.List.Types/index.js
  var Nil = /* @__PURE__ */ function() {
    function Nil2() {
    }
    ;
    Nil2.value = new Nil2();
    return Nil2;
  }();
  var Cons = /* @__PURE__ */ function() {
    function Cons2(value0, value1) {
      this.value0 = value0;
      this.value1 = value1;
    }
    ;
    Cons2.create = function(value0) {
      return function(value1) {
        return new Cons2(value0, value1);
      };
    };
    return Cons2;
  }();
  var NonEmptyList = function(x2) {
    return x2;
  };
  var toList = function(v2) {
    return new Cons(v2.value0, v2.value1);
  };
  var listMap = function(f2) {
    var chunkedRevMap = function($copy_v) {
      return function($copy_v1) {
        var $tco_var_v = $copy_v;
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(v2, v1) {
          if (v1 instanceof Cons && (v1.value1 instanceof Cons && v1.value1.value1 instanceof Cons)) {
            $tco_var_v = new Cons(v1, v2);
            $copy_v1 = v1.value1.value1.value1;
            return;
          }
          ;
          var unrolledMap = function(v22) {
            if (v22 instanceof Cons && (v22.value1 instanceof Cons && v22.value1.value1 instanceof Nil)) {
              return new Cons(f2(v22.value0), new Cons(f2(v22.value1.value0), Nil.value));
            }
            ;
            if (v22 instanceof Cons && v22.value1 instanceof Nil) {
              return new Cons(f2(v22.value0), Nil.value);
            }
            ;
            return Nil.value;
          };
          var reverseUnrolledMap = function($copy_v2) {
            return function($copy_v3) {
              var $tco_var_v2 = $copy_v2;
              var $tco_done1 = false;
              var $tco_result2;
              function $tco_loop2(v22, v3) {
                if (v22 instanceof Cons && (v22.value0 instanceof Cons && (v22.value0.value1 instanceof Cons && v22.value0.value1.value1 instanceof Cons))) {
                  $tco_var_v2 = v22.value1;
                  $copy_v3 = new Cons(f2(v22.value0.value0), new Cons(f2(v22.value0.value1.value0), new Cons(f2(v22.value0.value1.value1.value0), v3)));
                  return;
                }
                ;
                $tco_done1 = true;
                return v3;
              }
              ;
              while (!$tco_done1) {
                $tco_result2 = $tco_loop2($tco_var_v2, $copy_v3);
              }
              ;
              return $tco_result2;
            };
          };
          $tco_done = true;
          return reverseUnrolledMap(v2)(unrolledMap(v1));
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($tco_var_v, $copy_v1);
        }
        ;
        return $tco_result;
      };
    };
    return chunkedRevMap(Nil.value);
  };
  var functorList = {
    map: listMap
  };
  var map9 = /* @__PURE__ */ map(functorList);
  var functorNonEmptyList = /* @__PURE__ */ functorNonEmpty(functorList);
  var foldableList = {
    foldr: function(f2) {
      return function(b2) {
        var rev3 = function() {
          var go2 = function($copy_v) {
            return function($copy_v1) {
              var $tco_var_v = $copy_v;
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(v2, v1) {
                if (v1 instanceof Nil) {
                  $tco_done = true;
                  return v2;
                }
                ;
                if (v1 instanceof Cons) {
                  $tco_var_v = new Cons(v1.value0, v2);
                  $copy_v1 = v1.value1;
                  return;
                }
                ;
                throw new Error("Failed pattern match at Data.List.Types (line 107, column 7 - line 107, column 23): " + [v2.constructor.name, v1.constructor.name]);
              }
              ;
              while (!$tco_done) {
                $tco_result = $tco_loop($tco_var_v, $copy_v1);
              }
              ;
              return $tco_result;
            };
          };
          return go2(Nil.value);
        }();
        var $284 = foldl(foldableList)(flip(f2))(b2);
        return function($285) {
          return $284(rev3($285));
        };
      };
    },
    foldl: function(f2) {
      var go2 = function($copy_b) {
        return function($copy_v) {
          var $tco_var_b = $copy_b;
          var $tco_done1 = false;
          var $tco_result;
          function $tco_loop(b2, v2) {
            if (v2 instanceof Nil) {
              $tco_done1 = true;
              return b2;
            }
            ;
            if (v2 instanceof Cons) {
              $tco_var_b = f2(b2)(v2.value0);
              $copy_v = v2.value1;
              return;
            }
            ;
            throw new Error("Failed pattern match at Data.List.Types (line 111, column 12 - line 113, column 30): " + [v2.constructor.name]);
          }
          ;
          while (!$tco_done1) {
            $tco_result = $tco_loop($tco_var_b, $copy_v);
          }
          ;
          return $tco_result;
        };
      };
      return go2;
    },
    foldMap: function(dictMonoid) {
      var append22 = append(dictMonoid.Semigroup0());
      var mempty4 = mempty(dictMonoid);
      return function(f2) {
        return foldl(foldableList)(function(acc) {
          var $286 = append22(acc);
          return function($287) {
            return $286(f2($287));
          };
        })(mempty4);
      };
    }
  };
  var foldr2 = /* @__PURE__ */ foldr(foldableList);
  var intercalate3 = /* @__PURE__ */ intercalate(foldableList)(monoidString);
  var foldableNonEmptyList = /* @__PURE__ */ foldableNonEmpty(foldableList);
  var semigroupList = {
    append: function(xs) {
      return function(ys) {
        return foldr2(Cons.create)(ys)(xs);
      };
    }
  };
  var append1 = /* @__PURE__ */ append(semigroupList);
  var semigroupNonEmptyList = {
    append: function(v2) {
      return function(as$prime) {
        return new NonEmpty(v2.value0, append1(v2.value1)(toList(as$prime)));
      };
    }
  };
  var showList = function(dictShow) {
    var show11 = show(dictShow);
    return {
      show: function(v2) {
        if (v2 instanceof Nil) {
          return "Nil";
        }
        ;
        return "(" + (intercalate3(" : ")(map9(show11)(v2)) + " : Nil)");
      }
    };
  };
  var showNonEmptyList = function(dictShow) {
    var show11 = show(showNonEmpty(dictShow)(showList(dictShow)));
    return {
      show: function(v2) {
        return "(NonEmptyList " + (show11(v2) + ")");
      }
    };
  };
  var eq1List = {
    eq1: function(dictEq) {
      var eq3 = eq(dictEq);
      return function(xs) {
        return function(ys) {
          var go2 = function($copy_v) {
            return function($copy_v1) {
              return function($copy_v2) {
                var $tco_var_v = $copy_v;
                var $tco_var_v1 = $copy_v1;
                var $tco_done = false;
                var $tco_result;
                function $tco_loop(v2, v1, v22) {
                  if (!v22) {
                    $tco_done = true;
                    return false;
                  }
                  ;
                  if (v2 instanceof Nil && v1 instanceof Nil) {
                    $tco_done = true;
                    return v22;
                  }
                  ;
                  if (v2 instanceof Cons && v1 instanceof Cons) {
                    $tco_var_v = v2.value1;
                    $tco_var_v1 = v1.value1;
                    $copy_v2 = v22 && eq3(v1.value0)(v2.value0);
                    return;
                  }
                  ;
                  $tco_done = true;
                  return false;
                }
                ;
                while (!$tco_done) {
                  $tco_result = $tco_loop($tco_var_v, $tco_var_v1, $copy_v2);
                }
                ;
                return $tco_result;
              };
            };
          };
          return go2(xs)(ys)(true);
        };
      };
    }
  };
  var eq12 = /* @__PURE__ */ eq1(eq1List);
  var eqNonEmpty2 = /* @__PURE__ */ eqNonEmpty(eq1List);
  var eqList = function(dictEq) {
    return {
      eq: eq12(dictEq)
    };
  };
  var eqNonEmptyList = function(dictEq) {
    return eqNonEmpty2(dictEq);
  };
  var applyList = {
    apply: function(v2) {
      return function(v1) {
        if (v2 instanceof Nil) {
          return Nil.value;
        }
        ;
        if (v2 instanceof Cons) {
          return append1(map9(v2.value0)(v1))(apply(applyList)(v2.value1)(v1));
        }
        ;
        throw new Error("Failed pattern match at Data.List.Types (line 157, column 1 - line 159, column 48): " + [v2.constructor.name, v1.constructor.name]);
      };
    },
    Functor0: function() {
      return functorList;
    }
  };
  var apply2 = /* @__PURE__ */ apply(applyList);
  var applyNonEmptyList = {
    apply: function(v2) {
      return function(v1) {
        return new NonEmpty(v2.value0(v1.value0), append1(apply2(v2.value1)(new Cons(v1.value0, Nil.value)))(apply2(new Cons(v2.value0, v2.value1))(v1.value1)));
      };
    },
    Functor0: function() {
      return functorNonEmptyList;
    }
  };
  var altList = {
    alt: append1,
    Functor0: function() {
      return functorList;
    }
  };
  var plusList = /* @__PURE__ */ function() {
    return {
      empty: Nil.value,
      Alt0: function() {
        return altList;
      }
    };
  }();
  var applicativeNonEmptyList = {
    pure: /* @__PURE__ */ function() {
      var $315 = singleton6(plusList);
      return function($316) {
        return NonEmptyList($315($316));
      };
    }(),
    Apply0: function() {
      return applyNonEmptyList;
    }
  };

  // output/Data.List/index.js
  var fromFoldable4 = function(dictFoldable) {
    return foldr(dictFoldable)(Cons.create)(Nil.value);
  };

  // output/Data.List.NonEmpty/index.js
  var singleton7 = /* @__PURE__ */ function() {
    var $200 = singleton6(plusList);
    return function($201) {
      return NonEmptyList($200($201));
    };
  }();

  // output/Data.Map.Internal/index.js
  var $runtime_lazy3 = function(name16, moduleName, init6) {
    var state4 = 0;
    var val;
    return function(lineNumber) {
      if (state4 === 2) return val;
      if (state4 === 1) throw new ReferenceError(name16 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
      state4 = 1;
      val = init6();
      state4 = 2;
      return val;
    };
  };
  var Leaf = /* @__PURE__ */ function() {
    function Leaf2() {
    }
    ;
    Leaf2.value = new Leaf2();
    return Leaf2;
  }();
  var Node = /* @__PURE__ */ function() {
    function Node2(value0, value1, value22, value32, value42, value52) {
      this.value0 = value0;
      this.value1 = value1;
      this.value2 = value22;
      this.value3 = value32;
      this.value4 = value42;
      this.value5 = value52;
    }
    ;
    Node2.create = function(value0) {
      return function(value1) {
        return function(value22) {
          return function(value32) {
            return function(value42) {
              return function(value52) {
                return new Node2(value0, value1, value22, value32, value42, value52);
              };
            };
          };
        };
      };
    };
    return Node2;
  }();
  var IterLeaf = /* @__PURE__ */ function() {
    function IterLeaf2() {
    }
    ;
    IterLeaf2.value = new IterLeaf2();
    return IterLeaf2;
  }();
  var IterEmit = /* @__PURE__ */ function() {
    function IterEmit2(value0, value1, value22) {
      this.value0 = value0;
      this.value1 = value1;
      this.value2 = value22;
    }
    ;
    IterEmit2.create = function(value0) {
      return function(value1) {
        return function(value22) {
          return new IterEmit2(value0, value1, value22);
        };
      };
    };
    return IterEmit2;
  }();
  var IterNode = /* @__PURE__ */ function() {
    function IterNode2(value0, value1) {
      this.value0 = value0;
      this.value1 = value1;
    }
    ;
    IterNode2.create = function(value0) {
      return function(value1) {
        return new IterNode2(value0, value1);
      };
    };
    return IterNode2;
  }();
  var IterDone = /* @__PURE__ */ function() {
    function IterDone2() {
    }
    ;
    IterDone2.value = new IterDone2();
    return IterDone2;
  }();
  var IterNext = /* @__PURE__ */ function() {
    function IterNext2(value0, value1, value22) {
      this.value0 = value0;
      this.value1 = value1;
      this.value2 = value22;
    }
    ;
    IterNext2.create = function(value0) {
      return function(value1) {
        return function(value22) {
          return new IterNext2(value0, value1, value22);
        };
      };
    };
    return IterNext2;
  }();
  var Split = /* @__PURE__ */ function() {
    function Split2(value0, value1, value22) {
      this.value0 = value0;
      this.value1 = value1;
      this.value2 = value22;
    }
    ;
    Split2.create = function(value0) {
      return function(value1) {
        return function(value22) {
          return new Split2(value0, value1, value22);
        };
      };
    };
    return Split2;
  }();
  var SplitLast = /* @__PURE__ */ function() {
    function SplitLast2(value0, value1, value22) {
      this.value0 = value0;
      this.value1 = value1;
      this.value2 = value22;
    }
    ;
    SplitLast2.create = function(value0) {
      return function(value1) {
        return function(value22) {
          return new SplitLast2(value0, value1, value22);
        };
      };
    };
    return SplitLast2;
  }();
  var unsafeNode = function(k2, v2, l2, r2) {
    if (l2 instanceof Leaf) {
      if (r2 instanceof Leaf) {
        return new Node(1, 1, k2, v2, l2, r2);
      }
      ;
      if (r2 instanceof Node) {
        return new Node(1 + r2.value0 | 0, 1 + r2.value1 | 0, k2, v2, l2, r2);
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 702, column 5 - line 706, column 39): " + [r2.constructor.name]);
    }
    ;
    if (l2 instanceof Node) {
      if (r2 instanceof Leaf) {
        return new Node(1 + l2.value0 | 0, 1 + l2.value1 | 0, k2, v2, l2, r2);
      }
      ;
      if (r2 instanceof Node) {
        return new Node(1 + function() {
          var $280 = l2.value0 > r2.value0;
          if ($280) {
            return l2.value0;
          }
          ;
          return r2.value0;
        }() | 0, (1 + l2.value1 | 0) + r2.value1 | 0, k2, v2, l2, r2);
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 708, column 5 - line 712, column 68): " + [r2.constructor.name]);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 700, column 32 - line 712, column 68): " + [l2.constructor.name]);
  };
  var toMapIter = /* @__PURE__ */ function() {
    return flip(IterNode.create)(IterLeaf.value);
  }();
  var stepWith = function(f2) {
    return function(next) {
      return function(done) {
        var go2 = function($copy_v) {
          var $tco_done = false;
          var $tco_result;
          function $tco_loop(v2) {
            if (v2 instanceof IterLeaf) {
              $tco_done = true;
              return done(unit);
            }
            ;
            if (v2 instanceof IterEmit) {
              $tco_done = true;
              return next(v2.value0, v2.value1, v2.value2);
            }
            ;
            if (v2 instanceof IterNode) {
              $copy_v = f2(v2.value1)(v2.value0);
              return;
            }
            ;
            throw new Error("Failed pattern match at Data.Map.Internal (line 940, column 8 - line 946, column 20): " + [v2.constructor.name]);
          }
          ;
          while (!$tco_done) {
            $tco_result = $tco_loop($copy_v);
          }
          ;
          return $tco_result;
        };
        return go2;
      };
    };
  };
  var singleton8 = function(k2) {
    return function(v2) {
      return new Node(1, 1, k2, v2, Leaf.value, Leaf.value);
    };
  };
  var unsafeBalancedNode = /* @__PURE__ */ function() {
    var height8 = function(v2) {
      if (v2 instanceof Leaf) {
        return 0;
      }
      ;
      if (v2 instanceof Node) {
        return v2.value0;
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 757, column 12 - line 759, column 26): " + [v2.constructor.name]);
    };
    var rotateLeft = function(k2, v2, l2, rk, rv, rl, rr) {
      if (rl instanceof Node && rl.value0 > height8(rr)) {
        return unsafeNode(rl.value2, rl.value3, unsafeNode(k2, v2, l2, rl.value4), unsafeNode(rk, rv, rl.value5, rr));
      }
      ;
      return unsafeNode(rk, rv, unsafeNode(k2, v2, l2, rl), rr);
    };
    var rotateRight = function(k2, v2, lk, lv, ll, lr, r2) {
      if (lr instanceof Node && height8(ll) <= lr.value0) {
        return unsafeNode(lr.value2, lr.value3, unsafeNode(lk, lv, ll, lr.value4), unsafeNode(k2, v2, lr.value5, r2));
      }
      ;
      return unsafeNode(lk, lv, ll, unsafeNode(k2, v2, lr, r2));
    };
    return function(k2, v2, l2, r2) {
      if (l2 instanceof Leaf) {
        if (r2 instanceof Leaf) {
          return singleton8(k2)(v2);
        }
        ;
        if (r2 instanceof Node && r2.value0 > 1) {
          return rotateLeft(k2, v2, l2, r2.value2, r2.value3, r2.value4, r2.value5);
        }
        ;
        return unsafeNode(k2, v2, l2, r2);
      }
      ;
      if (l2 instanceof Node) {
        if (r2 instanceof Node) {
          if (r2.value0 > (l2.value0 + 1 | 0)) {
            return rotateLeft(k2, v2, l2, r2.value2, r2.value3, r2.value4, r2.value5);
          }
          ;
          if (l2.value0 > (r2.value0 + 1 | 0)) {
            return rotateRight(k2, v2, l2.value2, l2.value3, l2.value4, l2.value5, r2);
          }
          ;
        }
        ;
        if (r2 instanceof Leaf && l2.value0 > 1) {
          return rotateRight(k2, v2, l2.value2, l2.value3, l2.value4, l2.value5, r2);
        }
        ;
        return unsafeNode(k2, v2, l2, r2);
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 717, column 40 - line 738, column 34): " + [l2.constructor.name]);
    };
  }();
  var $lazy_unsafeSplit = /* @__PURE__ */ $runtime_lazy3("unsafeSplit", "Data.Map.Internal", function() {
    return function(comp, k2, m2) {
      if (m2 instanceof Leaf) {
        return new Split(Nothing.value, Leaf.value, Leaf.value);
      }
      ;
      if (m2 instanceof Node) {
        var v2 = comp(k2)(m2.value2);
        if (v2 instanceof LT) {
          var v1 = $lazy_unsafeSplit(793)(comp, k2, m2.value4);
          return new Split(v1.value0, v1.value1, unsafeBalancedNode(m2.value2, m2.value3, v1.value2, m2.value5));
        }
        ;
        if (v2 instanceof GT) {
          var v1 = $lazy_unsafeSplit(796)(comp, k2, m2.value5);
          return new Split(v1.value0, unsafeBalancedNode(m2.value2, m2.value3, m2.value4, v1.value1), v1.value2);
        }
        ;
        if (v2 instanceof EQ) {
          return new Split(new Just(m2.value3), m2.value4, m2.value5);
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 791, column 5 - line 799, column 30): " + [v2.constructor.name]);
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 787, column 34 - line 799, column 30): " + [m2.constructor.name]);
    };
  });
  var unsafeSplit = /* @__PURE__ */ $lazy_unsafeSplit(786);
  var $lazy_unsafeSplitLast = /* @__PURE__ */ $runtime_lazy3("unsafeSplitLast", "Data.Map.Internal", function() {
    return function(k2, v2, l2, r2) {
      if (r2 instanceof Leaf) {
        return new SplitLast(k2, v2, l2);
      }
      ;
      if (r2 instanceof Node) {
        var v1 = $lazy_unsafeSplitLast(779)(r2.value2, r2.value3, r2.value4, r2.value5);
        return new SplitLast(v1.value0, v1.value1, unsafeBalancedNode(k2, v2, l2, v1.value2));
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 776, column 37 - line 780, column 57): " + [r2.constructor.name]);
    };
  });
  var unsafeSplitLast = /* @__PURE__ */ $lazy_unsafeSplitLast(775);
  var unsafeJoinNodes = function(v2, v1) {
    if (v2 instanceof Leaf) {
      return v1;
    }
    ;
    if (v2 instanceof Node) {
      var v22 = unsafeSplitLast(v2.value2, v2.value3, v2.value4, v2.value5);
      return unsafeBalancedNode(v22.value0, v22.value1, v22.value2, v1);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 764, column 25 - line 768, column 38): " + [v2.constructor.name, v1.constructor.name]);
  };
  var $lazy_unsafeDifference = /* @__PURE__ */ $runtime_lazy3("unsafeDifference", "Data.Map.Internal", function() {
    return function(comp, l2, r2) {
      if (l2 instanceof Leaf) {
        return Leaf.value;
      }
      ;
      if (r2 instanceof Leaf) {
        return l2;
      }
      ;
      if (r2 instanceof Node) {
        var v2 = unsafeSplit(comp, r2.value2, l2);
        var l$prime = $lazy_unsafeDifference(841)(comp, v2.value1, r2.value4);
        var r$prime = $lazy_unsafeDifference(842)(comp, v2.value2, r2.value5);
        return unsafeJoinNodes(l$prime, r$prime);
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 836, column 39 - line 843, column 33): " + [l2.constructor.name, r2.constructor.name]);
    };
  });
  var unsafeDifference = /* @__PURE__ */ $lazy_unsafeDifference(835);
  var lookup2 = function(dictOrd) {
    var compare4 = compare(dictOrd);
    return function(k2) {
      var go2 = function($copy_v) {
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(v2) {
          if (v2 instanceof Leaf) {
            $tco_done = true;
            return Nothing.value;
          }
          ;
          if (v2 instanceof Node) {
            var v1 = compare4(k2)(v2.value2);
            if (v1 instanceof LT) {
              $copy_v = v2.value4;
              return;
            }
            ;
            if (v1 instanceof GT) {
              $copy_v = v2.value5;
              return;
            }
            ;
            if (v1 instanceof EQ) {
              $tco_done = true;
              return new Just(v2.value3);
            }
            ;
            throw new Error("Failed pattern match at Data.Map.Internal (line 283, column 7 - line 286, column 22): " + [v1.constructor.name]);
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 280, column 8 - line 286, column 22): " + [v2.constructor.name]);
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($copy_v);
        }
        ;
        return $tco_result;
      };
      return go2;
    };
  };
  var iterMapL = /* @__PURE__ */ function() {
    var go2 = function($copy_iter) {
      return function($copy_v) {
        var $tco_var_iter = $copy_iter;
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(iter, v2) {
          if (v2 instanceof Leaf) {
            $tco_done = true;
            return iter;
          }
          ;
          if (v2 instanceof Node) {
            if (v2.value5 instanceof Leaf) {
              $tco_var_iter = new IterEmit(v2.value2, v2.value3, iter);
              $copy_v = v2.value4;
              return;
            }
            ;
            $tco_var_iter = new IterEmit(v2.value2, v2.value3, new IterNode(v2.value5, iter));
            $copy_v = v2.value4;
            return;
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 951, column 13 - line 958, column 48): " + [v2.constructor.name]);
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($tco_var_iter, $copy_v);
        }
        ;
        return $tco_result;
      };
    };
    return go2;
  }();
  var stepAscCps = /* @__PURE__ */ stepWith(iterMapL);
  var stepAsc = /* @__PURE__ */ function() {
    return stepAscCps(function(k2, v2, next) {
      return new IterNext(k2, v2, next);
    })($$const(IterDone.value));
  }();
  var eqMapIter = function(dictEq) {
    var eq13 = eq(dictEq);
    return function(dictEq1) {
      var eq22 = eq(dictEq1);
      return {
        eq: /* @__PURE__ */ function() {
          var go2 = function($copy_a) {
            return function($copy_b) {
              var $tco_var_a = $copy_a;
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(a2, b2) {
                var v2 = stepAsc(a2);
                if (v2 instanceof IterNext) {
                  var v22 = stepAsc(b2);
                  if (v22 instanceof IterNext && (eq13(v2.value0)(v22.value0) && eq22(v2.value1)(v22.value1))) {
                    $tco_var_a = v2.value2;
                    $copy_b = v22.value2;
                    return;
                  }
                  ;
                  $tco_done = true;
                  return false;
                }
                ;
                if (v2 instanceof IterDone) {
                  $tco_done = true;
                  return true;
                }
                ;
                throw new Error("Failed pattern match at Data.Map.Internal (line 859, column 14 - line 868, column 13): " + [v2.constructor.name]);
              }
              ;
              while (!$tco_done) {
                $tco_result = $tco_loop($tco_var_a, $copy_b);
              }
              ;
              return $tco_result;
            };
          };
          return go2;
        }()
      };
    };
  };
  var stepUnfoldr = /* @__PURE__ */ function() {
    var step2 = function(k2, v2, next) {
      return new Just(new Tuple(new Tuple(k2, v2), next));
    };
    return stepAscCps(step2)(function(v2) {
      return Nothing.value;
    });
  }();
  var toUnfoldable4 = function(dictUnfoldable) {
    var $784 = unfoldr(dictUnfoldable)(stepUnfoldr);
    return function($785) {
      return $784(toMapIter($785));
    };
  };
  var toUnfoldable1 = /* @__PURE__ */ toUnfoldable4(unfoldableArray);
  var showMap = function(dictShow) {
    var showTuple2 = showTuple(dictShow);
    return function(dictShow1) {
      var show17 = show(showArray(showTuple2(dictShow1)));
      return {
        show: function(as) {
          return "(fromFoldable " + (show17(toUnfoldable1(as)) + ")");
        }
      };
    };
  };
  var insert3 = function(dictOrd) {
    var compare4 = compare(dictOrd);
    return function(k2) {
      return function(v2) {
        var go2 = function(v1) {
          if (v1 instanceof Leaf) {
            return singleton8(k2)(v2);
          }
          ;
          if (v1 instanceof Node) {
            var v22 = compare4(k2)(v1.value2);
            if (v22 instanceof LT) {
              return unsafeBalancedNode(v1.value2, v1.value3, go2(v1.value4), v1.value5);
            }
            ;
            if (v22 instanceof GT) {
              return unsafeBalancedNode(v1.value2, v1.value3, v1.value4, go2(v1.value5));
            }
            ;
            if (v22 instanceof EQ) {
              return new Node(v1.value0, v1.value1, k2, v2, v1.value4, v1.value5);
            }
            ;
            throw new Error("Failed pattern match at Data.Map.Internal (line 471, column 7 - line 474, column 35): " + [v22.constructor.name]);
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 468, column 8 - line 474, column 35): " + [v1.constructor.name]);
        };
        return go2;
      };
    };
  };
  var foldableMap = {
    foldr: function(f2) {
      return function(z) {
        var $lazy_go = $runtime_lazy3("go", "Data.Map.Internal", function() {
          return function(m$prime, z$prime) {
            if (m$prime instanceof Leaf) {
              return z$prime;
            }
            ;
            if (m$prime instanceof Node) {
              return $lazy_go(172)(m$prime.value4, f2(m$prime.value3)($lazy_go(172)(m$prime.value5, z$prime)));
            }
            ;
            throw new Error("Failed pattern match at Data.Map.Internal (line 169, column 26 - line 172, column 43): " + [m$prime.constructor.name]);
          };
        });
        var go2 = $lazy_go(169);
        return function(m2) {
          return go2(m2, z);
        };
      };
    },
    foldl: function(f2) {
      return function(z) {
        var $lazy_go = $runtime_lazy3("go", "Data.Map.Internal", function() {
          return function(z$prime, m$prime) {
            if (m$prime instanceof Leaf) {
              return z$prime;
            }
            ;
            if (m$prime instanceof Node) {
              return $lazy_go(178)(f2($lazy_go(178)(z$prime, m$prime.value4))(m$prime.value3), m$prime.value5);
            }
            ;
            throw new Error("Failed pattern match at Data.Map.Internal (line 175, column 26 - line 178, column 43): " + [m$prime.constructor.name]);
          };
        });
        var go2 = $lazy_go(175);
        return function(m2) {
          return go2(z, m2);
        };
      };
    },
    foldMap: function(dictMonoid) {
      var mempty4 = mempty(dictMonoid);
      var append12 = append(dictMonoid.Semigroup0());
      return function(f2) {
        var go2 = function(v2) {
          if (v2 instanceof Leaf) {
            return mempty4;
          }
          ;
          if (v2 instanceof Node) {
            return append12(go2(v2.value4))(append12(f2(v2.value3))(go2(v2.value5)));
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 181, column 10 - line 184, column 28): " + [v2.constructor.name]);
        };
        return go2;
      };
    }
  };
  var foldableWithIndexMap = {
    foldrWithIndex: function(f2) {
      return function(z) {
        var $lazy_go = $runtime_lazy3("go", "Data.Map.Internal", function() {
          return function(m$prime, z$prime) {
            if (m$prime instanceof Leaf) {
              return z$prime;
            }
            ;
            if (m$prime instanceof Node) {
              return $lazy_go(192)(m$prime.value4, f2(m$prime.value2)(m$prime.value3)($lazy_go(192)(m$prime.value5, z$prime)));
            }
            ;
            throw new Error("Failed pattern match at Data.Map.Internal (line 189, column 26 - line 192, column 45): " + [m$prime.constructor.name]);
          };
        });
        var go2 = $lazy_go(189);
        return function(m2) {
          return go2(m2, z);
        };
      };
    },
    foldlWithIndex: function(f2) {
      return function(z) {
        var $lazy_go = $runtime_lazy3("go", "Data.Map.Internal", function() {
          return function(z$prime, m$prime) {
            if (m$prime instanceof Leaf) {
              return z$prime;
            }
            ;
            if (m$prime instanceof Node) {
              return $lazy_go(198)(f2(m$prime.value2)($lazy_go(198)(z$prime, m$prime.value4))(m$prime.value3), m$prime.value5);
            }
            ;
            throw new Error("Failed pattern match at Data.Map.Internal (line 195, column 26 - line 198, column 45): " + [m$prime.constructor.name]);
          };
        });
        var go2 = $lazy_go(195);
        return function(m2) {
          return go2(z, m2);
        };
      };
    },
    foldMapWithIndex: function(dictMonoid) {
      var mempty4 = mempty(dictMonoid);
      var append12 = append(dictMonoid.Semigroup0());
      return function(f2) {
        var go2 = function(v2) {
          if (v2 instanceof Leaf) {
            return mempty4;
          }
          ;
          if (v2 instanceof Node) {
            return append12(go2(v2.value4))(append12(f2(v2.value2)(v2.value3))(go2(v2.value5)));
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 201, column 10 - line 204, column 30): " + [v2.constructor.name]);
        };
        return go2;
      };
    },
    Foldable0: function() {
      return foldableMap;
    }
  };
  var eqMap = function(dictEq) {
    var eqMapIter1 = eqMapIter(dictEq);
    return function(dictEq1) {
      var eq13 = eq(eqMapIter1(dictEq1));
      return {
        eq: function(xs) {
          return function(ys) {
            if (xs instanceof Leaf) {
              if (ys instanceof Leaf) {
                return true;
              }
              ;
              return false;
            }
            ;
            if (xs instanceof Node) {
              if (ys instanceof Node && xs.value1 === ys.value1) {
                return eq13(toMapIter(xs))(toMapIter(ys));
              }
              ;
              return false;
            }
            ;
            throw new Error("Failed pattern match at Data.Map.Internal (line 94, column 14 - line 105, column 16): " + [xs.constructor.name]);
          };
        }
      };
    };
  };
  var empty3 = /* @__PURE__ */ function() {
    return Leaf.value;
  }();
  var difference2 = function(dictOrd) {
    var compare4 = compare(dictOrd);
    return function(m1) {
      return function(m2) {
        return unsafeDifference(compare4, m1, m2);
      };
    };
  };

  // output/Data.String.NonEmpty.Internal/index.js
  var toString = function(v2) {
    return v2;
  };
  var nonEmptyNonEmpty = function(dictIsSymbol) {
    var reflectSymbol2 = reflectSymbol(dictIsSymbol);
    return {
      nes: function(p2) {
        return reflectSymbol2(p2);
      }
    };
  };
  var nes = function(dict) {
    return dict.nes;
  };

  // output/Flame.Internal.Equality/foreign.js
  function compareReference(a2) {
    return function(b2) {
      return a2 === b2;
    };
  }

  // output/Flame.Internal.Equality/index.js
  var modelHasChanged = function(old) {
    return function($$new3) {
      return !compareReference(old)($$new3);
    };
  };

  // output/Flame.Renderer.Internal.Dom/foreign.js
  var namespace = "http://www.w3.org/2000/svg";
  var eventPrefix = "__flame_";
  var eventPostfix = "updater";
  var textNode2 = 1;
  var elementNode2 = 2;
  var svgNode = 3;
  var fragmentNode = 4;
  var lazyNode = 5;
  var managedNode2 = 6;
  var nonBubblingEvents = ["focus", "blur", "scroll", "load", "unload"];
  function start_(eventWrapper, root, updater, html) {
    return new F(eventWrapper, root, updater, html, false);
  }
  function startFrom_(eventWrapper, root, updater, html) {
    return new F(eventWrapper, root, updater, html, true);
  }
  function resume_(f2, html) {
    f2.resume(html);
  }
  function F(eventWrapper, root, updater, html, isDry) {
    this.eventWrapper = eventWrapper;
    this.applicationEvents = /* @__PURE__ */ new Map();
    this.root = root;
    this.updater = updater;
    this.cachedHtml = html.node === void 0 ? html : shallowCopy(html);
    if (isDry)
      this.hydrate(this.root, this.cachedHtml);
    else
      this.createAllNodes(this.root, this.cachedHtml);
  }
  F.prototype.hydrate = function(parent2, html, referenceNode) {
    switch (html.nodeType) {
      case lazyNode:
        html.node = parent2;
        html.rendered = html.render(html.arg);
        html.render = void 0;
        this.hydrate(parent2, html.rendered);
        break;
      case textNode2:
        html.node = parent2;
        break;
      case managedNode2:
        this.createAllNodes(parent2, html, referenceNode);
        break;
      default:
        if (html.nodeType === fragmentNode)
          html.node = document.createDocumentFragment();
        else {
          html.node = parent2;
          if (html.nodeData.events !== void 0)
            this.createAllEvents(parent2, html);
        }
        let htmlChildrenLength;
        if (html.text === void 0 && html.children !== void 0 && (htmlChildrenLength = html.children.length) > 0) {
          let childNodes = parent2.childNodes;
          for (let i2 = 0, cni = 0; i2 < htmlChildrenLength; ++i2, ++cni) {
            let c2 = html.children[i2] = html.children[i2].node === void 0 ? html.children[i2] : shallowCopy(html.children[i2]);
            if (childNodes[cni] === void 0)
              this.createAllNodes(parent2, c2);
            else {
              if (c2.nodeType === fragmentNode) {
                let fragmentChildrenLength = c2.children.length;
                c2.node = document.createDocumentFragment();
                for (let j2 = 0; j2 < fragmentChildrenLength; ++j2) {
                  let cf = c2.children[j2] = c2.children[j2].node === void 0 ? c2.children[j2] : shallowCopy(c2.children[j2]);
                  this.hydrate(childNodes[cni++], cf);
                }
                cni--;
              } else if (c2.nodeType === managedNode2)
                this.hydrate(parent2, c2, childNodes[cni]);
              else
                this.hydrate(childNodes[cni], c2);
            }
          }
        }
    }
  };
  function shallowCopy(origin4) {
    switch (origin4.nodeType) {
      case textNode2:
        return {
          nodeType: textNode2,
          node: void 0,
          text: origin4.text
        };
      case fragmentNode:
        return {
          nodeType: fragmentNode,
          node: void 0,
          children: origin4.children
        };
      case lazyNode:
        return {
          nodeType: lazyNode,
          node: void 0,
          nodeData: origin4.nodeData,
          render: origin4.render,
          arg: origin4.arg,
          rendered: void 0,
          messageMapper: origin4.messageMapper
        };
      case managedNode2:
        return {
          nodeType: managedNode2,
          node: void 0,
          nodeData: origin4.nodeData,
          createNode: origin4.createNode,
          updateNode: origin4.updateNode,
          arg: origin4.arg,
          messageMapper: origin4.messageMapper
        };
      default:
        return {
          nodeType: origin4.nodeType,
          node: void 0,
          tag: origin4.tag,
          nodeData: origin4.nodeData,
          children: origin4.children,
          text: origin4.text,
          messageMapper: origin4.messageMapper
        };
    }
  }
  F.prototype.createAllNodes = function(parent2, html, referenceNode) {
    let node = this.createNode(html);
    if (html.text !== void 0)
      node.textContent = html.text;
    else {
      if (html.children !== void 0)
        this.createChildrenNodes(node, html.children);
      else if (html.rendered !== void 0) {
        if (html.messageMapper !== void 0)
          lazyMessageMap(html.messageMapper, html.rendered);
        if (html.rendered.text !== void 0) {
          node.textContent = html.rendered.text;
        } else if (html.rendered.children !== void 0)
          this.createChildrenNodes(node, html.rendered.children);
      }
    }
    parent2.insertBefore(node, referenceNode);
  };
  F.prototype.checkCreateAllNodes = function(parent2, html, referenceNode) {
    if (html.node !== void 0)
      html = shallowCopy(html);
    this.createAllNodes(parent2, html, referenceNode);
    return html;
  };
  F.prototype.createChildrenNodes = function(parent2, children2) {
    let childrenLength = children2.length;
    for (let i2 = 0; i2 < childrenLength; ++i2) {
      let html = children2[i2] = children2[i2].node === void 0 ? children2[i2] : shallowCopy(children2[i2]);
      this.checkCreateAllNodes(parent2, html, null);
    }
  };
  F.prototype.createNode = function(html) {
    switch (html.nodeType) {
      case lazyNode:
        html.rendered = html.render(html.arg);
        html.render = void 0;
        return html.node = this.createNode(html.rendered);
      case textNode2:
        return html.node = document.createTextNode(html.text);
      case elementNode2:
        return html.node = this.createElement(html);
      case svgNode:
        return html.node = this.createSvg(html);
      case fragmentNode:
        return html.node = document.createDocumentFragment();
      case managedNode2:
        return html.node = this.createManagedNode(html);
    }
  };
  F.prototype.createElement = function(html) {
    let element = document.createElement(html.tag);
    this.createNodeData(element, html, false);
    return element;
  };
  F.prototype.createSvg = function(html) {
    let svg2 = document.createElementNS(namespace, html.tag);
    this.createNodeData(svg2, html, true);
    return svg2;
  };
  F.prototype.createManagedNode = function(html) {
    let node = html.createNode(html.arg)();
    html.createNode = void 0;
    this.createNodeData(node, html, node instanceof SVGElement || node.nodeName.toLowerCase() === "svg");
    return node;
  };
  F.prototype.createNodeData = function(node, html, isSvg) {
    if (html.nodeData.styles !== void 0)
      createStyles(node, html.nodeData.styles);
    if (html.nodeData.classes !== void 0 && html.nodeData.classes.length > 0)
      createClasses(node, html.nodeData.classes, isSvg);
    if (html.nodeData.attributes !== void 0)
      createAttributes(node, html.nodeData.attributes);
    if (html.nodeData.properties !== void 0)
      for (let key in html.nodeData.properties)
        node[key] = html.nodeData.properties[key];
    if (html.nodeData.events !== void 0)
      this.createAllEvents(node, html);
  };
  function createStyles(node, styles) {
    for (let key in styles)
      node.style.setProperty(key, styles[key]);
  }
  function createClasses(node, classes, isSvg) {
    let joined = classes.join(" ");
    if (isSvg)
      node.setAttribute("class", joined);
    else
      node.className = joined;
  }
  function createAttributes(node, attributes) {
    for (let key in attributes)
      node.setAttribute(key, attributes[key]);
  }
  F.prototype.createAllEvents = function(node, html) {
    for (let key in html.nodeData.events)
      this.createEvent(node, key, html);
  };
  F.prototype.createEvent = function(node, name16, html) {
    let handlers2 = html.nodeData.events[name16], eventKey = eventPrefix + name16;
    if (nonBubblingEvents.includes(name16)) {
      let runNonBubblingEvent = this.runNonBubblingEvent(handlers2, html.messageMapper);
      node[eventKey] = runNonBubblingEvent;
      node.addEventListener(name16, runNonBubblingEvent, false);
    } else {
      node[eventKey] = handlers2;
      if (html.messageMapper !== void 0)
        node[eventKey + eventPostfix] = html.messageMapper;
      let synthetic = this.applicationEvents.get(name16);
      if (synthetic === void 0) {
        let runEvent = this.runEvent.bind(this);
        this.root.addEventListener(name16, runEvent, false);
        this.applicationEvents.set(name16, {
          count: 1,
          handler: runEvent
        });
      } else
        synthetic.count++;
    }
  };
  F.prototype.runNonBubblingEvent = function(handlers2, messageMapper2) {
    return function(event) {
      this.runHandlers(handlers2, messageMapper2, event);
    }.bind(this);
  };
  F.prototype.runEvent = function(event) {
    let node = event.target, eventKey = eventPrefix + event.type;
    while (node !== this.root) {
      let handlers2 = node[eventKey];
      if (handlers2 !== void 0) {
        this.runHandlers(handlers2, node[eventKey + eventPostfix], event);
        return;
      }
      node = node.parentNode;
    }
  };
  F.prototype.runHandlers = function(handlers2, messageMapper2, event) {
    let handlersLength = handlers2.length;
    for (let i2 = 0; i2 < handlersLength; ++i2) {
      let h2 = handlers2[i2], maybeMessage = typeof h2 === "function" ? h2(event)() : this.eventWrapper(h2);
      this.updater(messageMapper2 === void 0 ? maybeMessage : messageMapper2(maybeMessage))();
    }
    event.stopPropagation();
  };
  F.prototype.resume = function(updatedHtml) {
    this.cachedHtml = this.updateAllNodes(this.root, this.cachedHtml, updatedHtml);
  };
  F.prototype.updateAllNodes = function(parent2, currentHtml2, updatedHtml) {
    if (updatedHtml.node !== void 0)
      updatedHtml = shallowCopy(updatedHtml);
    if (currentHtml2.tag !== updatedHtml.tag || currentHtml2.nodeType !== updatedHtml.nodeType) {
      if (currentHtml2.nodeType === fragmentNode) {
        this.createAllNodes(parent2, updatedHtml, firstFragmentChildNode(currentHtml2.children));
        removeFragmentChildren(parent2, currentHtml2.children);
      } else {
        this.createAllNodes(parent2, updatedHtml, currentHtml2.node);
        parent2.removeChild(currentHtml2.node);
      }
    } else {
      updatedHtml.node = currentHtml2.node;
      switch (updatedHtml.nodeType) {
        case lazyNode:
          if (updatedHtml.arg !== currentHtml2.arg) {
            updatedHtml.rendered = updatedHtml.render(updatedHtml.arg);
            if (updatedHtml.messageMapper !== void 0)
              lazyMessageMap(updatedHtml.messageMapper, updatedHtml.rendered);
            this.updateAllNodes(parent2, currentHtml2.rendered, updatedHtml.rendered);
          } else
            updatedHtml.rendered = currentHtml2.rendered;
          updatedHtml.render = void 0;
          break;
        case managedNode2:
          let node = updatedHtml.updateNode(currentHtml2.node)(currentHtml2.arg)(updatedHtml.arg)(), isSvg = node instanceof SVGElement || node.nodeName.toLowerCase() === "svg";
          if (node !== currentHtml2.node || node.nodeType !== currentHtml2.node.nodeType || node.nodeName !== currentHtml2.node.nodeName) {
            this.createNodeData(node, updatedHtml, isSvg);
            parent2.insertBefore(node, currentHtml2.node);
            parent2.removeChild(currentHtml2.node);
          } else
            this.updateNodeData(node, currentHtml2.nodeData, updatedHtml, isSvg);
          updatedHtml.node = node;
          break;
        //text nodes can have only their textContent changed
        case textNode2:
          if (updatedHtml.text !== currentHtml2.text)
            updatedHtml.node.textContent = updatedHtml.text;
          break;
        //parent instead of currentHtml.node, as fragments nodes only count for their children
        case fragmentNode:
          this.updateChildrenNodes(parent2, currentHtml2, updatedHtml);
          break;
        //the usual case, element/svg to be patched
        default:
          this.updateNodeData(currentHtml2.node, currentHtml2.nodeData, updatedHtml, updatedHtml.nodeType == svgNode);
          if ((updatedHtml.text !== void 0 || updatedHtml.children === void 0 && currentHtml2.text != void 0) && !hasInnerHtml(updatedHtml.nodeData) && updatedHtml.text != currentHtml2.node.textContent)
            currentHtml2.node.textContent = updatedHtml.text;
          else
            this.updateChildrenNodes(currentHtml2.node, currentHtml2, updatedHtml);
      }
    }
    return updatedHtml;
  };
  function firstFragmentChildNode(children2) {
    let childrenLength = children2.length;
    for (let i2 = 0; i2 < childrenLength; ++i2) {
      if (children2[i2].nodeType === fragmentNode)
        return firstFragmentChildNode(children2[i2].children);
      return children2[i2].node;
    }
    return void 0;
  }
  function removeFragmentChildren(parent2, children2) {
    let childrenLength = children2.length;
    for (let i2 = 0; i2 < childrenLength; ++i2)
      if (children2[i2].nodeType === fragmentNode)
        removeFragmentChildren(children2[i2].children);
      else
        parent2.removeChild(children2[i2].node);
  }
  function clearNode(node) {
    node.textContent = "";
  }
  F.prototype.updateChildrenNodes = function(parent2, currentHtml2, updatedHtml) {
    let currentChildren = currentHtml2.children, updatedChildren = updatedHtml.children;
    if (currentChildren === void 0 || currentChildren.length === 0) {
      let updatedChildrenLength;
      if (updatedChildren !== void 0 && (updatedChildrenLength = updatedChildren.length) > 0) {
        if (currentHtml2.text !== void 0 || hasInnerHtml(currentHtml2.nodeData))
          clearNode(parent2);
        for (let i2 = 0; i2 < updatedChildrenLength; ++i2)
          updatedChildren[i2] = this.checkCreateAllNodes(parent2, updatedChildren[i2]);
      }
    } else if (updatedChildren === void 0 || updatedChildren.length === 0) {
      if (currentChildren !== void 0 && (currentChildren.length > 0 || currentHtml2.text !== void 0) && !hasInnerHtml(updatedHtml.nodeData))
        clearNode(parent2);
    } else if (currentChildren[0].nodeData !== void 0 && currentChildren[0].nodeData.key !== void 0 && updatedChildren[0].nodeData !== void 0 && updatedChildren[0].nodeData.key !== void 0)
      this.updateKeyedChildrenNodes(parent2, currentChildren, updatedChildren);
    else
      this.updateNonKeyedChildrenNodes(parent2, currentChildren, updatedChildren);
  };
  function hasInnerHtml(parentNodeData) {
    return parentNodeData !== void 0 && parentNodeData.properties !== void 0 && parentNodeData.properties.innerHTML !== void 0;
  }
  F.prototype.updateKeyedChildrenNodes = function(parent2, currentChildren, updatedChildren) {
    let currentStart = 0, updatedStart = 0, currentEnd = currentChildren.length - 1, updatedEnd = updatedChildren.length - 1;
    let afterNode, currentStartNode = currentChildren[currentStart].node, updatedStartNode = currentStartNode, currentEndNode = currentChildren[currentEnd].node;
    let loop2 = true;
    fixes: while (loop2) {
      loop2 = false;
      let currentHtml2 = currentChildren[currentStart], updatedHtml = updatedChildren[updatedStart];
      while (currentHtml2.nodeData.key === updatedHtml.nodeData.key) {
        updatedHtml = this.updateAllNodes(parent2, currentHtml2, updatedHtml);
        updatedStartNode = currentStartNode = currentHtml2.node.nextSibling;
        currentStart++;
        updatedStart++;
        if (currentEnd < currentStart || updatedEnd < updatedStart)
          break fixes;
        currentHtml2 = currentChildren[currentStart];
        updatedHtml = updatedChildren[updatedStart];
      }
      currentHtml2 = currentChildren[currentEnd];
      updatedHtml = updatedChildren[updatedEnd];
      while (currentHtml2.nodeData.key === updatedHtml.nodeData.key) {
        updatedHtml = this.updateAllNodes(parent2, currentHtml2, updatedHtml);
        afterNode = currentEndNode;
        currentEndNode = currentEndNode.previousSibling;
        currentEnd--;
        updatedEnd--;
        if (currentEnd < currentStart || updatedEnd < updatedStart)
          break fixes;
        currentHtml2 = currentChildren[currentEnd];
        updatedHtml = updatedChildren[updatedEnd];
      }
      currentHtml2 = currentChildren[currentEnd];
      updatedHtml = updatedChildren[updatedStart];
      while (currentHtml2.nodeData.key === updatedHtml.nodeData.key) {
        loop2 = true;
        updatedHtml = this.updateAllNodes(parent2, currentHtml2, updatedHtml);
        currentEndNode = currentHtml2.node.previousSibling;
        parent2.insertBefore(currentHtml2.node, updatedStartNode);
        updatedStart++;
        currentEnd--;
        if (currentEnd < currentStart || updatedEnd < updatedStart)
          break fixes;
        currentHtml2 = currentChildren[currentEnd];
        updatedHtml = updatedChildren[updatedStart];
      }
      currentHtml2 = currentChildren[currentStart];
      updatedHtml = updatedChildren[updatedEnd];
      while (currentHtml2.nodeData.key === updatedHtml.nodeData.key) {
        loop2 = true;
        updatedHtml = this.updateAllNodes(parent2, currentHtml2, updatedHtml);
        parent2.insertBefore(currentHtml2.node, afterNode);
        afterNode = currentHtml2.node;
        currentStart++;
        updatedEnd--;
        if (currentEnd < currentStart || updatedEnd < updatedStart)
          break fixes;
        currentHtml2 = currentChildren[currentStart];
        updatedHtml = updatedChildren[updatedEnd];
      }
    }
    if (updatedEnd < updatedStart)
      while (currentStart <= currentEnd) {
        parent2.removeChild(currentChildren[currentEnd].node);
        currentEnd--;
      }
    else if (currentEnd < currentStart)
      while (updatedStart <= updatedEnd) {
        updatedChildren[updatedStart] = this.checkCreateAllNodes(parent2, updatedChildren[updatedStart], afterNode);
        updatedStart++;
      }
    else {
      let P = new Int32Array(updatedEnd + 1 - updatedStart);
      let I = /* @__PURE__ */ new Map();
      for (let i2 = updatedStart; i2 <= updatedEnd; i2++) {
        P[i2] = -1;
        I.set(updatedChildren[i2].nodeData.key, i2);
      }
      let reusingNodes = updatedStart + updatedChildren.length - 1 - updatedEnd, toRemove = [];
      for (let i2 = currentStart; i2 <= currentEnd; i2++)
        if (I.has(currentChildren[i2].nodeData.key)) {
          P[I.get(currentChildren[i2].nodeData.key)] = i2;
          reusingNodes++;
        } else
          toRemove.push(i2);
      if (reusingNodes === 0) {
        parent2.textContent = "";
        for (let i2 = updatedStart; i2 <= updatedEnd; i2++)
          updatedChildren[i2] = this.checkCreateAllNodes(parent2, updatedChildren[i2]);
      } else {
        let toRemoveLength = toRemove.length;
        for (let i2 = 0; i2 < toRemoveLength; i2++)
          parent2.removeChild(currentChildren[toRemove[i2]].node);
        let longestSeq = longestSubsequence(P, updatedStart), seqIndex = longestSeq.length - 1;
        for (let i2 = updatedEnd; i2 >= updatedStart; i2--) {
          if (longestSeq[seqIndex] === i2) {
            currentHtml = currentChildren[P[longestSeq[seqIndex]]];
            updatedChildren[i2] = this.updateAllNodes(parent2, currentHtml, updatedChildren[i2]);
            afterNode = currentHtml.node;
            seqIndex--;
          } else {
            if (P[i2] === -1) {
              updatedChildren[i2] = this.checkCreateAllNodes(parent2, updatedChildren[i2], afterNode);
              afterNode = updatedChildren[i2].node;
            } else {
              currentHtml = currentChildren[P[i2]];
              updatedChildren[i2] = this.updateAllNodes(parent2, currentHtml, updatedChildren[i2]);
              parent2.insertBefore(currentHtml.node, afterNode);
              afterNode = currentHtml.node;
            }
          }
        }
      }
    }
  };
  function longestSubsequence(ns, updatedStart) {
    let seq = [], is = [], l2 = -1, i2, len, pre = new Int32Array(ns.length);
    for (i2 = updatedStart, len = ns.length; i2 < len; i2++) {
      let n2 = ns[i2];
      if (n2 < 0)
        continue;
      let j2 = findGreatestIndex(seq, n2);
      if (j2 !== -1)
        pre[i2] = is[j2];
      if (j2 === l2) {
        l2++;
        seq[l2] = n2;
        is[l2] = i2;
      } else if (n2 < seq[j2 + 1]) {
        seq[j2 + 1] = n2;
        is[j2 + 1] = i2;
      }
    }
    for (i2 = is[l2]; l2 >= 0; i2 = pre[i2], l2--)
      seq[l2] = i2;
    return seq;
  }
  function findGreatestIndex(seq, n2) {
    let lo = -1, hi = seq.length;
    if (hi > 0 && seq[hi - 1] <= n2)
      return hi - 1;
    while (hi - lo > 1) {
      let mid = Math.floor((lo + hi) / 2);
      if (seq[mid] > n2)
        hi = mid;
      else
        lo = mid;
    }
    return lo;
  }
  F.prototype.updateNonKeyedChildrenNodes = function(parent2, currentChildren, updatedChildren) {
    let currentChildrenLength = currentChildren.length, updatedChildrenLength = updatedChildren.length, commonLength = Math.min(currentChildrenLength, updatedChildrenLength);
    for (let i2 = 0; i2 < commonLength; ++i2)
      updatedChildren[i2] = this.updateAllNodes(parent2, currentChildren[i2], updatedChildren[i2]);
    if (currentChildrenLength < updatedChildrenLength)
      for (let i2 = commonLength; i2 < updatedChildrenLength; ++i2)
        updatedChildren[i2] = this.checkCreateAllNodes(parent2, updatedChildren[i2]);
    else if (currentChildrenLength > updatedChildrenLength)
      for (let i2 = commonLength; i2 < currentChildrenLength; ++i2)
        parent2.removeChild(currentChildren[i2].node);
  };
  F.prototype.updateNodeData = function(node, currentNodeData, updatedHtml, isSvg) {
    updateStyles(node, currentNodeData.styles, updatedHtml.nodeData.styles);
    updateAttributes(node, currentNodeData.attributes, updatedHtml.nodeData.attributes);
    updateClasses(node, currentNodeData.classes, updatedHtml.nodeData.classes, isSvg);
    updateProperties(node, currentNodeData.properties, updatedHtml.nodeData.properties);
    this.updateEvents(node, currentNodeData.events, updatedHtml);
  };
  function updateStyles(node, currentStyles, updatedStyles) {
    if (currentStyles === void 0) {
      if (updatedStyles !== void 0)
        createStyles(node, updatedStyles);
    } else if (updatedStyles === void 0) {
      if (currentStyles !== void 0)
        node.removeAttribute("style");
    } else {
      let matchCount = 0;
      for (let key in currentStyles) {
        let current = currentStyles[key], updated = updatedStyles[key], hasUpdated = updatedStyles[key] !== void 0;
        if (hasUpdated)
          matchCount++;
        if (current !== updated)
          if (hasUpdated)
            node.style.setProperty(key, updated);
          else
            node.style.removeProperty(key);
      }
      let newKeys = Object.keys(updatedStyles), newKeysLength = newKeys.length;
      for (let i2 = 0; matchCount < newKeysLength && i2 < newKeysLength; ++i2) {
        let key = newKeys[i2];
        if (currentStyles[key] === void 0) {
          let updated = updatedStyles[key];
          ++matchCount;
          node.style.setProperty(key, updated);
        }
      }
    }
  }
  function updateClasses(node, currentClasses, updatedClasses, isSvg) {
    let classUpdated = updatedClasses !== void 0 && updatedClasses.length > 0;
    if (currentClasses !== void 0 && currentClasses.length > 0 && !classUpdated)
      createClasses(node, [], isSvg);
    else if (classUpdated)
      createClasses(node, updatedClasses, isSvg);
  }
  function updateAttributes(node, currentAttributes, updatedAttributes) {
    if (currentAttributes === void 0) {
      if (updatedAttributes !== void 0)
        createAttributes(node, updatedAttributes);
    } else if (updatedAttributes === void 0) {
      if (currentAttributes !== void 0)
        for (let key in currentAttributes)
          node.removeAttribute(key);
    } else {
      let matchCount = 0;
      for (let key in currentAttributes) {
        let current = currentAttributes[key], updated = updatedAttributes[key], hasUpdated = updated !== void 0;
        if (hasUpdated)
          matchCount++;
        if (current !== updated)
          if (hasUpdated)
            node.setAttribute(key, updated);
          else
            node.removeAttribute(key);
      }
      let newKeys = Object.keys(updatedAttributes), newKeysLength = newKeys.length;
      for (let i2 = 0; matchCount < newKeysLength && i2 < newKeysLength; ++i2) {
        let key = newKeys[i2];
        if (currentAttributes[key] === void 0) {
          let updated = updatedAttributes[key];
          ++matchCount;
          node.setAttribute(key, updated);
        }
      }
    }
  }
  function updateProperties(node, currentProperties, updatedProperties) {
    let addAll = currentProperties === void 0, removeAll = updatedProperties === void 0;
    if (addAll) {
      if (!removeAll)
        for (let key in updatedProperties)
          node[key] = updatedProperties[key];
    } else if (removeAll) {
      if (!addAll)
        for (let key in currentProperties)
          node.removeAttribute(key);
    } else {
      let matchCount = 0;
      for (let key in currentProperties) {
        let current = currentProperties[key], updated = updatedProperties[key], hasUpdated = updated !== void 0;
        if (hasUpdated)
          matchCount++;
        if (current !== updated)
          if (hasUpdated)
            node[key] = updated;
          else
            node.removeAttribute(key);
      }
      let newKeys = Object.keys(updatedProperties), newKeysLength = newKeys.length;
      for (let i2 = 0; matchCount < newKeysLength && i2 < newKeysLength; ++i2) {
        let key = newKeys[i2];
        if (currentProperties[key] === void 0) {
          let updated = updatedProperties[key];
          ++matchCount;
          node[key] = updated;
        }
      }
    }
  }
  F.prototype.updateEvents = function(node, currentEvents, updatedHtml) {
    let updatedEvents = updatedHtml.nodeData.events;
    if (currentEvents === void 0) {
      if (updatedEvents !== void 0)
        this.createAllEvents(node, updatedHtml);
    } else if (updatedEvents === void 0) {
      if (currentEvents !== void 0)
        for (let key in currentEvents)
          this.removeEvent(node, key);
    } else {
      let matchCount = 0;
      for (let key in currentEvents) {
        let current = currentEvents[key], updated = updatedEvents[key], hasUpdated = false;
        if (updated === void 0)
          this.removeEvent(node, key);
        else {
          let currentLength = current.length, updatedLength = updated.length;
          if (currentLength != updatedLength)
            hasUpdated = true;
          else {
            for (let i2 = 0; i2 < currentLength; ++i2)
              if (current[i2] != updated[i2]) {
                hasUpdated = true;
                break;
              }
          }
        }
        if (hasUpdated) {
          matchCount++;
          this.removeEvent(node, key);
          this.createEvent(node, key, updatedHtml);
        }
      }
      let newKeys = Object.keys(updatedEvents), newKeysLength = newKeys.length;
      for (let i2 = 0; matchCount < newKeysLength && i2 < newKeysLength; ++i2) {
        let key = newKeys[i2];
        if (currentEvents[key] === void 0) {
          ++matchCount;
          this.createEvent(node, key, updatedHtml);
        }
      }
    }
  };
  F.prototype.removeEvent = function(node, name16) {
    let eventKey = eventPrefix + name16;
    if (nonBubblingEvents.includes(name16)) {
      let runNonBubblingEvent = node[eventKey];
      node.removeEventListener(name16, runNonBubblingEvent, false);
    } else {
      let count2 = --this.applicationEvents.get(name16).count;
      if (count2 === 0) {
        this.root.removeEventListener(name16, this.applicationEvents.get(name16).handler, false);
        this.applicationEvents.delete(name16);
      }
    }
    node[eventKey + eventPostfix] = void 0;
    node[eventKey] = void 0;
  };
  function lazyMessageMap(mapper, html) {
    html.messageMapper = mapper;
    if (html.children !== void 0 && html.children.length > 0)
      for (let i2 = 0; i2 < html.children.length; ++i2)
        lazyMessageMap(mapper, html.children[i2]);
  }

  // output/Flame.Renderer.Internal.Dom/index.js
  var pure4 = /* @__PURE__ */ pure(applicativeEffect);
  var resume = /* @__PURE__ */ runEffectFn2(resume_);
  var maybeUpdater = function(updater) {
    return function(v2) {
      if (v2 instanceof Just) {
        return updater(v2.value0);
      }
      ;
      return pure4(unit);
    };
  };
  var start = function(parent2) {
    return function(updater) {
      return runEffectFn4(start_)(Just.create)(parent2)(maybeUpdater(updater));
    };
  };
  var startFrom = function(parent2) {
    return function(updater) {
      return runEffectFn4(startFrom_)(Just.create)(parent2)(maybeUpdater(updater));
    };
  };

  // output/Flame.Subscription.Internal.Listener/foreign.js
  var applicationIds = /* @__PURE__ */ new Set();
  function checkApplicationId_(id5) {
    if (applicationIds.has(id5))
      throw `Error mounting application: id ${id5} already registered!`;
    applicationIds.add(id5);
  }

  // output/Flame.Types/index.js
  var Window = /* @__PURE__ */ function() {
    function Window2() {
    }
    ;
    Window2.value = new Window2();
    return Window2;
  }();
  var Document = /* @__PURE__ */ function() {
    function Document2() {
    }
    ;
    Document2.value = new Document2();
    return Document2;
  }();
  var Custom = /* @__PURE__ */ function() {
    function Custom2() {
    }
    ;
    Custom2.value = new Custom2();
    return Custom2;
  }();

  // output/Foreign/foreign.js
  function typeOf(value12) {
    return typeof value12;
  }
  function tagOf(value12) {
    return Object.prototype.toString.call(value12).slice(8, -1);
  }
  function isNull2(value12) {
    return value12 === null;
  }
  function isUndefined(value12) {
    return value12 === void 0;
  }
  var isArray = Array.isArray || function(value12) {
    return Object.prototype.toString.call(value12) === "[object Array]";
  };

  // output/Foreign/index.js
  var show4 = /* @__PURE__ */ show(showString);
  var show1 = /* @__PURE__ */ show(showInt);
  var pure5 = /* @__PURE__ */ pure(applicativeEither);
  var ForeignError = /* @__PURE__ */ function() {
    function ForeignError2(value0) {
      this.value0 = value0;
    }
    ;
    ForeignError2.create = function(value0) {
      return new ForeignError2(value0);
    };
    return ForeignError2;
  }();
  var TypeMismatch2 = /* @__PURE__ */ function() {
    function TypeMismatch3(value0, value1) {
      this.value0 = value0;
      this.value1 = value1;
    }
    ;
    TypeMismatch3.create = function(value0) {
      return function(value1) {
        return new TypeMismatch3(value0, value1);
      };
    };
    return TypeMismatch3;
  }();
  var ErrorAtIndex = /* @__PURE__ */ function() {
    function ErrorAtIndex2(value0, value1) {
      this.value0 = value0;
      this.value1 = value1;
    }
    ;
    ErrorAtIndex2.create = function(value0) {
      return function(value1) {
        return new ErrorAtIndex2(value0, value1);
      };
    };
    return ErrorAtIndex2;
  }();
  var ErrorAtProperty = /* @__PURE__ */ function() {
    function ErrorAtProperty2(value0, value1) {
      this.value0 = value0;
      this.value1 = value1;
    }
    ;
    ErrorAtProperty2.create = function(value0) {
      return function(value1) {
        return new ErrorAtProperty2(value0, value1);
      };
    };
    return ErrorAtProperty2;
  }();
  var unsafeFromForeign = unsafeCoerce;
  var showForeignError = {
    show: function(v2) {
      if (v2 instanceof ForeignError) {
        return "(ForeignError " + (show4(v2.value0) + ")");
      }
      ;
      if (v2 instanceof ErrorAtIndex) {
        return "(ErrorAtIndex " + (show1(v2.value0) + (" " + (show(showForeignError)(v2.value1) + ")")));
      }
      ;
      if (v2 instanceof ErrorAtProperty) {
        return "(ErrorAtProperty " + (show4(v2.value0) + (" " + (show(showForeignError)(v2.value1) + ")")));
      }
      ;
      if (v2 instanceof TypeMismatch2) {
        return "(TypeMismatch " + (show4(v2.value0) + (" " + (show4(v2.value1) + ")")));
      }
      ;
      throw new Error("Failed pattern match at Foreign (line 69, column 1 - line 73, column 89): " + [v2.constructor.name]);
    }
  };
  var fail = function(dictMonad) {
    var $153 = throwError(monadThrowExceptT(dictMonad));
    return function($154) {
      return $153(singleton7($154));
    };
  };
  var readArray = function(dictMonad) {
    var pure19 = pure(applicativeExceptT(dictMonad));
    var fail1 = fail(dictMonad);
    return function(value12) {
      if (isArray(value12)) {
        return pure19(unsafeFromForeign(value12));
      }
      ;
      if (otherwise) {
        return fail1(new TypeMismatch2("array", tagOf(value12)));
      }
      ;
      throw new Error("Failed pattern match at Foreign (line 164, column 1 - line 164, column 99): " + [value12.constructor.name]);
    };
  };
  var unsafeReadTagged = function(dictMonad) {
    var pure19 = pure(applicativeExceptT(dictMonad));
    var fail1 = fail(dictMonad);
    return function(tag) {
      return function(value12) {
        if (tagOf(value12) === tag) {
          return pure19(unsafeFromForeign(value12));
        }
        ;
        if (otherwise) {
          return fail1(new TypeMismatch2(tag, tagOf(value12)));
        }
        ;
        throw new Error("Failed pattern match at Foreign (line 123, column 1 - line 123, column 104): " + [tag.constructor.name, value12.constructor.name]);
      };
    };
  };
  var readNumber = function(dictMonad) {
    return unsafeReadTagged(dictMonad)("Number");
  };
  var readInt = function(dictMonad) {
    var map27 = map(dictMonad.Bind1().Apply0().Functor0());
    var readNumber1 = readNumber(dictMonad);
    return function(value12) {
      var error5 = new Left(singleton7(new TypeMismatch2("Int", tagOf(value12))));
      var fromNumber3 = function() {
        var $155 = maybe(error5)(pure5);
        return function($156) {
          return $155(fromNumber($156));
        };
      }();
      return mapExceptT(map27(either($$const(error5))(fromNumber3)))(readNumber1(value12));
    };
  };
  var readString = function(dictMonad) {
    return unsafeReadTagged(dictMonad)("String");
  };
  var eqForeignError = {
    eq: function(x2) {
      return function(y2) {
        if (x2 instanceof ForeignError && y2 instanceof ForeignError) {
          return x2.value0 === y2.value0;
        }
        ;
        if (x2 instanceof TypeMismatch2 && y2 instanceof TypeMismatch2) {
          return x2.value0 === y2.value0 && x2.value1 === y2.value1;
        }
        ;
        if (x2 instanceof ErrorAtIndex && y2 instanceof ErrorAtIndex) {
          return x2.value0 === y2.value0 && eq(eqForeignError)(x2.value1)(y2.value1);
        }
        ;
        if (x2 instanceof ErrorAtProperty && y2 instanceof ErrorAtProperty) {
          return x2.value0 === y2.value0 && eq(eqForeignError)(x2.value1)(y2.value1);
        }
        ;
        return false;
      };
    }
  };

  // output/Flame.Subscription.Internal.Listener/index.js
  var createSubscription = function(updater) {
    return function(v2) {
      if (v2.value0 instanceof Window) {
        return createWindowListener(v2.value1.value0)(function($13) {
          return updater(v2.value1.value1.value0($13));
        });
      }
      ;
      if (v2.value0 instanceof Document) {
        return createDocumentListener(v2.value1.value0)(function($14) {
          return updater(v2.value1.value1.value0($14));
        });
      }
      ;
      if (v2.value0 instanceof Custom) {
        return createCustomListener(v2.value1.value0)(function($15) {
          return updater(v2.value1.value1.value0($15));
        });
      }
      ;
      throw new Error("Failed pattern match at Flame.Subscription.Internal.Listener (line 31, column 83 - line 34, column 75): " + [v2.value0.constructor.name]);
    };
  };
  var checkApplicationId = /* @__PURE__ */ runEffectFn1(checkApplicationId_);
  var createMessageListener = function(appId2) {
    return function(updater) {
      return function __do() {
        checkApplicationId(appId2)();
        return createCustomListener(appId2)(function($16) {
          return updater(unsafeFromForeign($16));
        })();
      };
    };
  };

  // output/Flame.Application.EffectList/index.js
  var when2 = /* @__PURE__ */ when(applicativeEffect);
  var for_2 = /* @__PURE__ */ for_(applicativeEffect)(foldableArray);
  var pure6 = /* @__PURE__ */ pure(applicativeEffect);
  var traverse_2 = /* @__PURE__ */ traverse_(applicativeEffect)(foldableArray);
  var map10 = /* @__PURE__ */ map(functorMaybe);
  var showId = function(dictShow) {
    var show11 = show(dictShow);
    return function(v2) {
      return show11(v2);
    };
  };
  var run3 = function(parent2) {
    return function(isResumed) {
      return function(appId2) {
        return function(v2) {
          return function __do() {
            var modelState = $$new(v2.init.value0)();
            var renderingState = $$new(21)();
            var render2 = function(model) {
              return function __do2() {
                var rendering2 = read(renderingState)();
                resume(rendering2)(v2.view(model))();
                return write(model)(modelState)();
              };
            };
            var runUpdate = function(message2) {
              return function __do2() {
                var currentModel = read(modelState)();
                var v1 = v2.update(currentModel)(message2);
                when2(modelHasChanged(currentModel)(v1.value0))(render2(v1.value0))();
                return runMessages(v1.value1)();
              };
            };
            var runMessages = function(affs) {
              return for_2(affs)(runAff_(function(v1) {
                if (v1 instanceof Left) {
                  return log(message(v1.value0));
                }
                ;
                if (v1 instanceof Right && v1.value0 instanceof Just) {
                  return runUpdate(v1.value0.value0);
                }
                ;
                return pure6(unit);
              }));
            };
            var rendering = function() {
              if (isResumed) {
                return startFrom(parent2)(runUpdate)(v2.view(v2.init.value0))();
              }
              ;
              return start(parent2)(runUpdate)(v2.view(v2.init.value0))();
            }();
            write(rendering)(renderingState)();
            runMessages(v2.init.value1)();
            (function() {
              if (appId2 instanceof Nothing) {
                return unit;
              }
              ;
              if (appId2 instanceof Just) {
                return createMessageListener(appId2.value0)(runUpdate)();
              }
              ;
              throw new Error("Failed pattern match at Flame.Application.EffectList (line 142, column 7 - line 144, column 62): " + [appId2.constructor.name]);
            })();
            return traverse_2(createSubscription(runUpdate))(v2.subscribe)();
          };
        };
      };
    };
  };
  var mountWith = function(dictShow) {
    var showId1 = showId(dictShow);
    return function(v2) {
      return function(appId2) {
        return function(application) {
          return function __do() {
            var maybeElement = querySelector(v2)();
            if (maybeElement instanceof Just) {
              return run3(maybeElement.value0)(false)(map10(showId1)(appId2))(application)();
            }
            ;
            if (maybeElement instanceof Nothing) {
              return $$throw("Error mounting application")();
            }
            ;
            throw new Error("Failed pattern match at Flame.Application.EffectList (line 101, column 7 - line 103, column 62): " + [maybeElement.constructor.name]);
          };
        };
      };
    };
  };
  var mount = function(dictShow) {
    var mountWith2 = mountWith(dictShow);
    return function(selector) {
      return function(appId2) {
        return mountWith2(selector)(new Just(appId2));
      };
    };
  };

  // output/Control.Monad.Gen.Class/index.js
  var chooseInt = function(dict) {
    return dict.chooseInt;
  };

  // output/Control.Monad.State.Trans/index.js
  var functorStateT = function(dictFunctor) {
    var map27 = map(dictFunctor);
    return {
      map: function(f2) {
        return function(v2) {
          return function(s2) {
            return map27(function(v1) {
              return new Tuple(f2(v1.value0), v1.value1);
            })(v2(s2));
          };
        };
      }
    };
  };
  var monadStateT = function(dictMonad) {
    return {
      Applicative0: function() {
        return applicativeStateT(dictMonad);
      },
      Bind1: function() {
        return bindStateT(dictMonad);
      }
    };
  };
  var bindStateT = function(dictMonad) {
    var bind8 = bind(dictMonad.Bind1());
    return {
      bind: function(v2) {
        return function(f2) {
          return function(s2) {
            return bind8(v2(s2))(function(v1) {
              var v3 = f2(v1.value0);
              return v3(v1.value1);
            });
          };
        };
      },
      Apply0: function() {
        return applyStateT(dictMonad);
      }
    };
  };
  var applyStateT = function(dictMonad) {
    var functorStateT1 = functorStateT(dictMonad.Bind1().Apply0().Functor0());
    return {
      apply: ap(monadStateT(dictMonad)),
      Functor0: function() {
        return functorStateT1;
      }
    };
  };
  var applicativeStateT = function(dictMonad) {
    var pure19 = pure(dictMonad.Applicative0());
    return {
      pure: function(a2) {
        return function(s2) {
          return pure19(new Tuple(a2, s2));
        };
      },
      Apply0: function() {
        return applyStateT(dictMonad);
      }
    };
  };
  var monadStateStateT = function(dictMonad) {
    var pure19 = pure(dictMonad.Applicative0());
    var monadStateT1 = monadStateT(dictMonad);
    return {
      state: function(f2) {
        return function($206) {
          return pure19(f2($206));
        };
      },
      Monad0: function() {
        return monadStateT1;
      }
    };
  };

  // output/Control.Monad.State/index.js
  var unwrap2 = /* @__PURE__ */ unwrap();
  var runState = function(v2) {
    return function($18) {
      return unwrap2(v2($18));
    };
  };
  var evalState = function(v2) {
    return function(s2) {
      var v1 = v2(s2);
      return v1.value0;
    };
  };

  // output/Random.LCG/index.js
  var mod3 = /* @__PURE__ */ mod(euclideanRingInt);
  var fromJust5 = /* @__PURE__ */ fromJust();
  var unSeed = function(v2) {
    return v2;
  };
  var seedMin = 1;
  var lcgM = 2147483647;
  var seedMax = /* @__PURE__ */ function() {
    return lcgM - 1 | 0;
  }();
  var mkSeed = function(x2) {
    var ensureBetween = function(min6) {
      return function(max7) {
        return function(n2) {
          var rangeSize = max7 - min6 | 0;
          var n$prime = mod3(n2)(rangeSize);
          var $25 = n$prime < min6;
          if ($25) {
            return n$prime + max7 | 0;
          }
          ;
          return n$prime;
        };
      };
    };
    return ensureBetween(seedMin)(seedMax)(x2);
  };
  var lcgC = 0;
  var lcgA = 48271;
  var lcgPerturb = function(d2) {
    return function(v2) {
      return fromJust5(fromNumber(remainder(toNumber(lcgA) * toNumber(v2) + toNumber(d2))(toNumber(lcgM))));
    };
  };
  var lcgNext = /* @__PURE__ */ lcgPerturb(lcgC);

  // output/Test.QuickCheck.Gen/index.js
  var monadStateStateT2 = /* @__PURE__ */ monadStateStateT(monadIdentity);
  var state2 = /* @__PURE__ */ state(monadStateStateT2);
  var map11 = /* @__PURE__ */ map(functorTuple);
  var bindStateT2 = /* @__PURE__ */ bindStateT(monadIdentity);
  var functorStateT2 = /* @__PURE__ */ functorStateT(functorIdentity);
  var mul2 = /* @__PURE__ */ mul(semiringNumber);
  var min3 = /* @__PURE__ */ min(ordNumber);
  var max3 = /* @__PURE__ */ max(ordNumber);
  var add2 = /* @__PURE__ */ add(semiringNumber);
  var unGen = function(v2) {
    return v2;
  };
  var runGen = function($103) {
    return runState(unGen($103));
  };
  var stateful = function(f2) {
    return state2(function(s2) {
      return runGen(f2(s2))(s2);
    });
  };
  var sized2 = function(f2) {
    return stateful(function(s2) {
      return f2(s2.size);
    });
  };
  var resize2 = function(sz) {
    return function(g2) {
      return state2(function(v2) {
        return map11(function(v1) {
          return {
            newSeed: v1.newSeed,
            size: v2.size
          };
        })(runGen(g2)({
          newSeed: v2.newSeed,
          size: sz
        }));
      });
    };
  };
  var monadGen = /* @__PURE__ */ monadStateT(monadIdentity);
  var lcgStep = /* @__PURE__ */ function() {
    var f2 = function(s2) {
      return new Tuple(unSeed(s2.newSeed), function() {
        var $94 = {};
        for (var $95 in s2) {
          if ({}.hasOwnProperty.call(s2, $95)) {
            $94[$95] = s2[$95];
          }
          ;
        }
        ;
        $94.newSeed = lcgNext(s2.newSeed);
        return $94;
      }());
    };
    return state2(f2);
  }();
  var functorGen = functorStateT2;
  var map22 = /* @__PURE__ */ map(functorGen);
  var uniform = /* @__PURE__ */ map22(function(n2) {
    return toNumber(n2) / toNumber(lcgM);
  })(lcgStep);
  var evalGen = function($104) {
    return evalState(unGen($104));
  };
  var choose = function(a2) {
    return function(b2) {
      var unscale = function(v2) {
        return v2 * 2;
      };
      var scale = function(v2) {
        return v2 * 0.5;
      };
      var min$prime = scale(min3(a2)(b2));
      var max$prime = scale(max3(a2)(b2));
      return map22(function() {
        var $105 = add2(min$prime);
        var $106 = mul2(max$prime - min$prime);
        return function($107) {
          return unscale($105($106($107)));
        };
      }())(uniform);
    };
  };
  var bindGen = bindStateT2;
  var applyGen = /* @__PURE__ */ applyStateT(monadIdentity);
  var apply3 = /* @__PURE__ */ apply(applyGen);
  var chooseInt$prime = function(a2) {
    return function(b2) {
      var numB = toNumber(b2);
      var numA = toNumber(a2);
      var clamp = function(x2) {
        return numA + remainder(x2)(numB - numA + 1);
      };
      var choose31BitPosNumber = map22(toNumber)(lcgStep);
      var choose32BitPosNumber = apply3(map22(add2)(choose31BitPosNumber))(map22(mul2(2))(choose31BitPosNumber));
      return map22(function($109) {
        return floor2(clamp($109));
      })(choose32BitPosNumber);
    };
  };
  var chooseInt2 = function(a2) {
    return function(b2) {
      var $101 = a2 <= b2;
      if ($101) {
        return chooseInt$prime(a2)(b2);
      }
      ;
      return chooseInt$prime(b2)(a2);
    };
  };
  var monadGenGen = {
    chooseInt: chooseInt2,
    chooseFloat: choose,
    chooseBool: /* @__PURE__ */ map22(function(v2) {
      return v2 < 0.5;
    })(uniform),
    resize: function(f2) {
      return function(g2) {
        return sized2(function(s2) {
          return resize2(f2(s2))(g2);
        });
      };
    },
    sized: sized2,
    Monad0: function() {
      return monadGen;
    }
  };
  var applicativeGen = /* @__PURE__ */ applicativeStateT(monadIdentity);

  // output/Test.QuickCheck.Arbitrary/index.js
  var arbitrary = function(dict) {
    return dict.arbitrary;
  };

  // output/Yoga.JSON/foreign.js
  function reviver(key, value12) {
    if (key === "big") {
      return BigInt(value12);
    }
    return value12;
  }
  var _parseJSON = (payload) => JSON.parse(payload, reviver);

  // output/Control.Monad.Except/index.js
  var unwrap3 = /* @__PURE__ */ unwrap();
  var withExcept = /* @__PURE__ */ withExceptT(functorIdentity);
  var runExcept = function($3) {
    return unwrap3(runExceptT($3));
  };

  // output/Foreign.Index/foreign.js
  function unsafeReadPropImpl(f2, s2, key, value12) {
    return value12 == null ? f2 : s2(value12[key]);
  }
  function unsafeHasOwnProperty(prop, value12) {
    return Object.prototype.hasOwnProperty.call(value12, prop);
  }
  function unsafeHasProperty(prop, value12) {
    return prop in value12;
  }

  // output/Foreign.Index/index.js
  var unsafeReadProp = function(dictMonad) {
    var fail6 = fail(dictMonad);
    var pure19 = pure(applicativeExceptT(dictMonad));
    return function(k2) {
      return function(value12) {
        return unsafeReadPropImpl(fail6(new TypeMismatch2("object", typeOf(value12))), pure19, k2, value12);
      };
    };
  };
  var readProp = function(dictMonad) {
    return unsafeReadProp(dictMonad);
  };
  var ix = function(dict) {
    return dict.ix;
  };
  var index4 = function(dict) {
    return dict.index;
  };
  var indexableForeign = function(dictMonad) {
    return {
      ix: function(dictIndex) {
        return index4(dictIndex);
      }
    };
  };
  var hasPropertyImpl = function(v2) {
    return function(v1) {
      if (isNull2(v1)) {
        return false;
      }
      ;
      if (isUndefined(v1)) {
        return false;
      }
      ;
      if (typeOf(v1) === "object" || typeOf(v1) === "function") {
        return unsafeHasProperty(v2, v1);
      }
      ;
      return false;
    };
  };
  var hasOwnPropertyImpl = function(v2) {
    return function(v1) {
      if (isNull2(v1)) {
        return false;
      }
      ;
      if (isUndefined(v1)) {
        return false;
      }
      ;
      if (typeOf(v1) === "object" || typeOf(v1) === "function") {
        return unsafeHasOwnProperty(v2, v1);
      }
      ;
      return false;
    };
  };
  var indexString = function(dictMonad) {
    return {
      index: flip(readProp(dictMonad)),
      hasProperty: hasPropertyImpl,
      hasOwnProperty: hasOwnPropertyImpl,
      errorAt: ErrorAtProperty.create
    };
  };

  // output/Record.Builder/foreign.js
  function copyRecord(rec) {
    var copy = {};
    for (var key in rec) {
      if ({}.hasOwnProperty.call(rec, key)) {
        copy[key] = rec[key];
      }
    }
    return copy;
  }
  function unsafeInsert(l2) {
    return function(a2) {
      return function(rec) {
        rec[l2] = a2;
        return rec;
      };
    };
  }

  // output/Record.Builder/index.js
  var semigroupoidBuilder = semigroupoidFn;
  var insert5 = function() {
    return function() {
      return function(dictIsSymbol) {
        var reflectSymbol2 = reflectSymbol(dictIsSymbol);
        return function(l2) {
          return function(a2) {
            return function(r1) {
              return unsafeInsert(reflectSymbol2(l2))(a2)(r1);
            };
          };
        };
      };
    };
  };
  var categoryBuilder = categoryFn;
  var build = function(v2) {
    return function(r1) {
      return v2(copyRecord(r1));
    };
  };

  // output/Yoga.JSON/index.js
  var identity7 = /* @__PURE__ */ identity(categoryBuilder);
  var fail2 = /* @__PURE__ */ fail(monadIdentity);
  var readString2 = /* @__PURE__ */ readString(monadIdentity);
  var bindExceptT2 = /* @__PURE__ */ bindExceptT(monadIdentity);
  var pure7 = /* @__PURE__ */ pure(applicativeNonEmptyList);
  var except2 = /* @__PURE__ */ except(applicativeIdentity);
  var readInt2 = /* @__PURE__ */ readInt(monadIdentity);
  var applicativeExceptT2 = /* @__PURE__ */ applicativeExceptT(monadIdentity);
  var pure1 = /* @__PURE__ */ pure(applicativeExceptT2);
  var compose1 = /* @__PURE__ */ compose(semigroupoidBuilder);
  var insert6 = /* @__PURE__ */ insert5()();
  var append2 = /* @__PURE__ */ append(semigroupNonEmptyList);
  var functorExceptT2 = /* @__PURE__ */ functorExceptT(functorIdentity);
  var map1 = /* @__PURE__ */ map(functorExceptT2);
  var map23 = /* @__PURE__ */ map(functorNonEmptyList);
  var bindFlipped3 = /* @__PURE__ */ bindFlipped(bindExceptT2);
  var lmap2 = /* @__PURE__ */ lmap(bifunctorEither);
  var toUnfoldable7 = /* @__PURE__ */ toUnfoldable2(unfoldableArray);
  var composeKleisliFlipped2 = /* @__PURE__ */ composeKleisliFlipped(bindExceptT2);
  var readProp2 = /* @__PURE__ */ readProp(monadIdentity);
  var mapWithIndex3 = /* @__PURE__ */ mapWithIndex(functorWithIndexArray);
  var readArray2 = /* @__PURE__ */ readArray(monadIdentity);
  var readForeignString = {
    readImpl: readString2
  };
  var readForeignInt = {
    readImpl: readInt2
  };
  var readForeignForeign = {
    readImpl: pure1
  };
  var readForeignFieldsNilRowRo = {
    getFields: function(v2) {
      return function(v1) {
        return pure1(identity7);
      };
    }
  };
  var sequenceCombining = function(dictMonoid) {
    var append22 = append(dictMonoid.Semigroup0());
    var mempty4 = mempty(dictMonoid);
    return function(dictFoldable) {
      var foldl3 = foldl(dictFoldable);
      return function(dictApplicative) {
        var pure23 = pure(dictApplicative);
        var fn = function(acc) {
          return function(elem3) {
            var v2 = runExcept(elem3);
            if (acc instanceof Left && v2 instanceof Left) {
              return new Left(append2(acc.value0)(v2.value0));
            }
            ;
            if (acc instanceof Left && v2 instanceof Right) {
              return new Left(acc.value0);
            }
            ;
            if (acc instanceof Right && v2 instanceof Right) {
              return new Right(append22(acc.value0)(pure23(v2.value0)));
            }
            ;
            if (acc instanceof Right && v2 instanceof Left) {
              return new Left(v2.value0);
            }
            ;
            throw new Error("Failed pattern match at Yoga.JSON (line 653, column 5 - line 657, column 37): " + [acc.constructor.name, v2.constructor.name]);
          };
        };
        var $505 = foldl3(fn)(new Right(mempty4));
        return function($506) {
          return except2($505($506));
        };
      };
    };
  };
  var sequenceCombining1 = /* @__PURE__ */ sequenceCombining(monoidArray)(foldableArray)(applicativeArray);
  var readImpl = function(dict) {
    return dict.readImpl;
  };
  var readForeignObject = function(dictReadForeign) {
    var readImpl5 = readImpl(dictReadForeign);
    return {
      readImpl: function() {
        var readProp1 = function(key) {
          return function(value12) {
            return except2(lmap2(map23(ErrorAtProperty.create(key)))(runExcept(readImpl5(value12))));
          };
        };
        var readObject$prime = function(value12) {
          if (tagOf(value12) === "Object") {
            return pure1(unsafeFromForeign(value12));
          }
          ;
          if (otherwise) {
            return fail2(new TypeMismatch2("Object", tagOf(value12)));
          }
          ;
          throw new Error("Failed pattern match at Yoga.JSON (line 285, column 5 - line 285, column 47): " + [value12.constructor.name]);
        };
        var gatherErrors = function() {
          var fn = function(acc) {
            return function(v2) {
              var v22 = runExcept(v2.value1);
              if (acc instanceof Left && v22 instanceof Left) {
                return new Left(append2(acc.value0)(v22.value0));
              }
              ;
              if (acc instanceof Left && v22 instanceof Right) {
                return new Left(acc.value0);
              }
              ;
              if (acc instanceof Right && v22 instanceof Right) {
                return new Right(insert(v2.value0)(v22.value0)(acc.value0));
              }
              ;
              if (acc instanceof Right && v22 instanceof Left) {
                return new Left(v22.value0);
              }
              ;
              throw new Error("Failed pattern match at Yoga.JSON (line 276, column 9 - line 280, column 41): " + [acc.constructor.name, v22.constructor.name]);
            };
          };
          var $524 = foldl2(fn)(new Right(empty2));
          return function($525) {
            return except2($524(toUnfoldable7($525)));
          };
        }();
        return composeKleisliFlipped2(function() {
          var $526 = mapWithKey(readProp1);
          return function($527) {
            return gatherErrors($526($527));
          };
        }())(readObject$prime);
      }()
    };
  };
  var readAtIdx = function(dictReadForeign) {
    var readImpl5 = readImpl(dictReadForeign);
    return function(i2) {
      return function(f2) {
        return withExcept(map23(ErrorAtIndex.create(i2)))(readImpl5(f2));
      };
    };
  };
  var readForeignArray = function(dictReadForeign) {
    return {
      readImpl: composeKleisliFlipped2(function() {
        var $542 = mapWithIndex3(readAtIdx(dictReadForeign));
        return function($543) {
          return sequenceCombining1($542($543));
        };
      }())(readArray2)
    };
  };
  var read$prime = function(dictReadForeign) {
    return readImpl(dictReadForeign);
  };
  var parseJSON = /* @__PURE__ */ function() {
    var $548 = lmap2(function($551) {
      return pure7(ForeignError.create(message($551)));
    });
    var $549 = runEffectFn1(_parseJSON);
    return function($550) {
      return ExceptT(Identity($548(unsafePerformEffect($$try($549($550))))));
    };
  }();
  var readJSON$prime = function(dictReadForeign) {
    return composeKleisliFlipped2(readImpl(dictReadForeign))(parseJSON);
  };
  var getFields = function(dict) {
    return dict.getFields;
  };
  var readForeignFieldsCons = function(dictIsSymbol) {
    var reflectSymbol2 = reflectSymbol(dictIsSymbol);
    var insert42 = insert6(dictIsSymbol);
    return function(dictReadForeign) {
      var readImpl5 = readImpl(dictReadForeign);
      return function(dictReadForeignFields) {
        var getFields1 = getFields(dictReadForeignFields);
        return function() {
          return function() {
            return {
              getFields: function(v2) {
                return function(obj) {
                  var rest = getFields1($$Proxy.value)(obj);
                  var name16 = reflectSymbol2($$Proxy.value);
                  var enrichErrorWithPropName = withExcept(map23(ErrorAtProperty.create(name16)));
                  var value12 = enrichErrorWithPropName(bindFlipped3(readImpl5)(readProp2(name16)(obj)));
                  var first = map1(insert42($$Proxy.value))(value12);
                  return except2(function() {
                    var v1 = runExcept(rest);
                    var v22 = runExcept(first);
                    if (v22 instanceof Right && v1 instanceof Right) {
                      return new Right(compose1(v22.value0)(v1.value0));
                    }
                    ;
                    if (v22 instanceof Left && v1 instanceof Left) {
                      return new Left(append2(v22.value0)(v1.value0));
                    }
                    ;
                    if (v22 instanceof Right && v1 instanceof Left) {
                      return new Left(v1.value0);
                    }
                    ;
                    if (v22 instanceof Left && v1 instanceof Right) {
                      return new Left(v22.value0);
                    }
                    ;
                    throw new Error("Failed pattern match at Yoga.JSON (line 360, column 5 - line 364, column 33): " + [v22.constructor.name, v1.constructor.name]);
                  }());
                };
              }
            };
          };
        };
      };
    };
  };
  var readForeignRecord = function() {
    return function(dictReadForeignFields) {
      var getFields1 = getFields(dictReadForeignFields);
      return {
        readImpl: function(o2) {
          return map1(flip(build)({}))(getFields1($$Proxy.value)(o2));
        }
      };
    };
  };

  // output/Scriptzzz.Core/index.js
  var xIsSymbol = {
    reflectSymbol: function() {
      return "x";
    }
  };
  var yIsSymbol = {
    reflectSymbol: function() {
      return "y";
    }
  };
  var bindExceptT3 = /* @__PURE__ */ bindExceptT(monadIdentity);
  var bind2 = /* @__PURE__ */ bind(bindExceptT3);
  var readArray3 = /* @__PURE__ */ readArray(monadIdentity);
  var readInt3 = /* @__PURE__ */ readInt(monadIdentity);
  var discard2 = /* @__PURE__ */ discard(discardUnit)(bindExceptT3);
  var applicativeExceptT3 = /* @__PURE__ */ applicativeExceptT(monadIdentity);
  var when3 = /* @__PURE__ */ when(applicativeExceptT3);
  var fail3 = /* @__PURE__ */ fail(monadIdentity);
  var show5 = /* @__PURE__ */ show(showInt);
  var pure8 = /* @__PURE__ */ pure(applicativeExceptT3);
  var map12 = /* @__PURE__ */ map(/* @__PURE__ */ functorExceptT(functorIdentity));
  var read$prime2 = /* @__PURE__ */ read$prime(/* @__PURE__ */ readForeignRecord()(/* @__PURE__ */ readForeignFieldsCons(xIsSymbol)(readForeignInt)(/* @__PURE__ */ readForeignFieldsCons(yIsSymbol)(readForeignInt)(readForeignFieldsNilRowRo)()())()()));
  var bind12 = /* @__PURE__ */ bind(bindGen);
  var chooseInt3 = /* @__PURE__ */ chooseInt(monadGenGen);
  var pure12 = /* @__PURE__ */ pure(applicativeGen);
  var Timestamp = function(x2) {
    return x2;
  };
  var Script = function(x2) {
    return x2;
  };
  var Position = function(x2) {
    return x2;
  };
  var showTimestamp = showInstant;
  var showScript = showString;
  var showPosition = /* @__PURE__ */ showRecord()()(/* @__PURE__ */ showRecordFieldsCons(xIsSymbol)(/* @__PURE__ */ showRecordFieldsConsNil(yIsSymbol)(showInt))(showInt));
  var showId2 = showString;
  var readForeignPosition = function(dictPos) {
    var toInt2 = toInt(dictPos.Nat0());
    return function(dictPos1) {
      var toInt1 = toInt(dictPos1.Nat0());
      return {
        readImpl: function(f2) {
          var readFromArray = function(fs) {
            return bind2(readArray3(fs))(function(values) {
              if (values.length === 2) {
                return bind2(readInt3(values[0]))(function(x2) {
                  return bind2(readInt3(values[1]))(function(y2) {
                    return discard2(when3(x2 >= toInt1($$undefined))(fail3(new ForeignError("X coordinate too large: " + show5(x2)))))(function() {
                      return discard2(when3(y2 >= toInt2($$undefined))(fail3(new ForeignError("Y coordinate too large: " + show5(y2)))))(function() {
                        return pure8({
                          x: x2,
                          y: y2
                        });
                      });
                    });
                  });
                });
              }
              ;
              return fail3(new ForeignError("Step tuple has a length different from 2: " + show5(length2(values))));
            });
          };
          return map12(Position)(function() {
            var $153 = isArray(f2);
            if ($153) {
              return readFromArray(f2);
            }
            ;
            return read$prime2(f2);
          }());
        }
      };
    };
  };
  var ordId = ordString;
  var monoidScript = monoidString;
  var makeId1 = function(dictIsSymbol) {
    var reflectSymbol2 = reflectSymbol(dictIsSymbol);
    return {
      makeId: function(p2) {
        return reflectSymbol2(p2);
      }
    };
  };
  var eqTimestamp = eqDateTime;
  var eqScript = eqString;
  var eqPosition = /* @__PURE__ */ eqRec()(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons(eqRowNil)()(yIsSymbol)(eqInt))()(xIsSymbol)(eqInt));
  var eqId = eqString;
  var arbitraryPosition = function(dictPos) {
    var toInt2 = toInt(dictPos.Nat0());
    return function(dictPos1) {
      return {
        arbitrary: bind12(chooseInt3(0)(toInt(dictPos1.Nat0())($$undefined) - 1 | 0))(function(x2) {
          return bind12(chooseInt3(0)(toInt2($$undefined) - 1 | 0))(function(y2) {
            return pure12({
              x: x2,
              y: y2
            });
          });
        })
      };
    };
  };
  var timestamp = Timestamp;
  var scriptToString = function(v2) {
    return v2;
  };
  var parseId = function(v2) {
    if (v2 === "") {
      return new Left("Cannot create empty ID");
    }
    ;
    return new Right(v2);
  };
  var makeScript = Script;
  var makeId = function(dict) {
    return dict.makeId;
  };
  var idToString = function(v2) {
    return v2;
  };

  // output/Scriptzzz.App.Command/index.js
  var map13 = /* @__PURE__ */ map(functorMaybe);
  var withUpdateAnimation = function(dictPos) {
    return function(dictPos1) {
      return function(v2) {
        return function(updateAnimationParameters) {
          return {
            executeScript: v2.executeScript,
            logDebug: v2.logDebug,
            logError: v2.logError,
            updateAnimation: new Just(updateAnimationParameters)
          };
        };
      };
    };
  };
  var withLogError = function(dictPos) {
    return function(dictPos1) {
      return function(v2) {
        return function(logParameters) {
          return {
            executeScript: v2.executeScript,
            logDebug: v2.logDebug,
            updateAnimation: v2.updateAnimation,
            logError: new Just(logParameters)
          };
        };
      };
    };
  };
  var withLogDebug = function(dictPos) {
    return function(dictPos1) {
      return function(v2) {
        return function(logParameters) {
          return {
            executeScript: v2.executeScript,
            logError: v2.logError,
            updateAnimation: v2.updateAnimation,
            logDebug: new Just(logParameters)
          };
        };
      };
    };
  };
  var withExecuteScript = function(dictPos) {
    return function(dictPos1) {
      return function(v2) {
        return function(executeScriptParameters) {
          return {
            logDebug: v2.logDebug,
            logError: v2.logError,
            updateAnimation: v2.updateAnimation,
            executeScript: new Just(executeScriptParameters)
          };
        };
      };
    };
  };
  var runCommand = function(dictMonadEffect) {
    var Monad0 = dictMonadEffect.Monad0();
    var Bind1 = Monad0.Bind1();
    var bind8 = bind(Bind1);
    var map110 = map(Bind1.Apply0().Functor0());
    var liftEffect5 = liftEffect(dictMonadEffect);
    var pure19 = pure(Monad0.Applicative0());
    return function(dictMonadError) {
      var $$try4 = $$try2(dictMonadError);
      return function(execute) {
        return function(handleResult) {
          return map13(function(params) {
            return bind8(map110(timestamp)(liftEffect5(now)))(function(startTime) {
              return bind8($$try4(execute(params)))(function(commandExecutionResult) {
                return bind8(map110(timestamp)(liftEffect5(now)))(function(finishTime) {
                  return pure19(handleResult({
                    commandExecutionResult,
                    commandParameters: params,
                    finishTime,
                    startTime
                  }));
                });
              });
            });
          });
        };
      };
    };
  };
  var runCommands = function(dictMonadEffect) {
    var runCommand1 = runCommand(dictMonadEffect);
    return function(dictMonadError) {
      var runCommand2 = runCommand1(dictMonadError);
      return function(dictPos) {
        return function(dictPos1) {
          return function(executors) {
            return function(handlers2) {
              return function(v2) {
                return catMaybes([runCommand2(executors.executeScript)(handlers2.executeScript)(v2.executeScript), runCommand2(executors.logDebug)(handlers2.logDebug)(v2.logDebug), runCommand2(executors.logError)(handlers2.logError)(v2.logError), runCommand2(executors.updateAnimation)(handlers2.updateAnimation)(v2.updateAnimation)]);
              };
            };
          };
        };
      };
    };
  };
  var none = function(dictPos) {
    return function(dictPos1) {
      return {
        executeScript: Nothing.value,
        logDebug: Nothing.value,
        logError: Nothing.value,
        updateAnimation: Nothing.value
      };
    };
  };

  // output/Scriptzzz.App.Controller.Handler/index.js
  var success = function(v2) {
    return new Right(new Tuple(v2.newModel, v2.commands));
  };
  var failure = /* @__PURE__ */ function() {
    return Left.create;
  }();

  // output/Data.Eq.Generic/index.js
  var genericEqNoArguments = {
    "genericEq'": function(v2) {
      return function(v1) {
        return true;
      };
    }
  };
  var genericEqArgument = function(dictEq) {
    var eq3 = eq(dictEq);
    return {
      "genericEq'": function(v2) {
        return function(v1) {
          return eq3(v2)(v1);
        };
      }
    };
  };
  var genericEq$prime = function(dict) {
    return dict["genericEq'"];
  };
  var genericEqConstructor = function(dictGenericEq) {
    var genericEq$prime1 = genericEq$prime(dictGenericEq);
    return {
      "genericEq'": function(v2) {
        return function(v1) {
          return genericEq$prime1(v2)(v1);
        };
      }
    };
  };
  var genericEqSum = function(dictGenericEq) {
    var genericEq$prime1 = genericEq$prime(dictGenericEq);
    return function(dictGenericEq1) {
      var genericEq$prime2 = genericEq$prime(dictGenericEq1);
      return {
        "genericEq'": function(v2) {
          return function(v1) {
            if (v2 instanceof Inl && v1 instanceof Inl) {
              return genericEq$prime1(v2.value0)(v1.value0);
            }
            ;
            if (v2 instanceof Inr && v1 instanceof Inr) {
              return genericEq$prime2(v2.value0)(v1.value0);
            }
            ;
            return false;
          };
        }
      };
    };
  };
  var genericEq = function(dictGeneric) {
    var from3 = from(dictGeneric);
    return function(dictGenericEq) {
      var genericEq$prime1 = genericEq$prime(dictGenericEq);
      return function(x2) {
        return function(y2) {
          return genericEq$prime1(from3(x2))(from3(y2));
        };
      };
    };
  };

  // output/Data.Show.Generic/foreign.js
  var intercalate4 = function(separator) {
    return function(xs) {
      return xs.join(separator);
    };
  };

  // output/Data.Show.Generic/index.js
  var append3 = /* @__PURE__ */ append(semigroupArray);
  var genericShowArgsNoArguments = {
    genericShowArgs: function(v2) {
      return [];
    }
  };
  var genericShowArgsArgument = function(dictShow) {
    var show11 = show(dictShow);
    return {
      genericShowArgs: function(v2) {
        return [show11(v2)];
      }
    };
  };
  var genericShowArgs = function(dict) {
    return dict.genericShowArgs;
  };
  var genericShowConstructor = function(dictGenericShowArgs) {
    var genericShowArgs1 = genericShowArgs(dictGenericShowArgs);
    return function(dictIsSymbol) {
      var reflectSymbol2 = reflectSymbol(dictIsSymbol);
      return {
        "genericShow'": function(v2) {
          var ctor = reflectSymbol2($$Proxy.value);
          var v1 = genericShowArgs1(v2);
          if (v1.length === 0) {
            return ctor;
          }
          ;
          return "(" + (intercalate4(" ")(append3([ctor])(v1)) + ")");
        }
      };
    };
  };
  var genericShow$prime = function(dict) {
    return dict["genericShow'"];
  };
  var genericShowSum = function(dictGenericShow) {
    var genericShow$prime1 = genericShow$prime(dictGenericShow);
    return function(dictGenericShow1) {
      var genericShow$prime2 = genericShow$prime(dictGenericShow1);
      return {
        "genericShow'": function(v2) {
          if (v2 instanceof Inl) {
            return genericShow$prime1(v2.value0);
          }
          ;
          if (v2 instanceof Inr) {
            return genericShow$prime2(v2.value0);
          }
          ;
          throw new Error("Failed pattern match at Data.Show.Generic (line 26, column 1 - line 28, column 40): " + [v2.constructor.name]);
        }
      };
    };
  };
  var genericShow = function(dictGeneric) {
    var from3 = from(dictGeneric);
    return function(dictGenericShow) {
      var genericShow$prime1 = genericShow$prime(dictGenericShow);
      return function(x2) {
        return genericShow$prime1(from3(x2));
      };
    };
  };

  // output/Data.Natural/index.js
  var natToInt = function(v2) {
    return v2;
  };
  var showNatural = {
    show: /* @__PURE__ */ function() {
      var $17 = show(showInt);
      return function($18) {
        return $17(natToInt($18));
      };
    }()
  };
  var intToNat = function(v2) {
    if (v2 >= 0) {
      return v2;
    }
    ;
    return 0;
  };
  var eqNatural = {
    eq: function(l2) {
      return function(r2) {
        return natToInt(l2) === natToInt(r2);
      };
    }
  };
  var binaryViaInt = function(f2) {
    return function(l2) {
      return function(r2) {
        return intToNat(f2(natToInt(l2))(natToInt(r2)));
      };
    };
  };
  var semiringNatural = {
    one: /* @__PURE__ */ intToNat(1),
    mul: /* @__PURE__ */ binaryViaInt(/* @__PURE__ */ mul(semiringInt)),
    zero: /* @__PURE__ */ intToNat(0),
    add: /* @__PURE__ */ binaryViaInt(/* @__PURE__ */ add(semiringInt))
  };

  // output/Data.CodePoint.Unicode.Internal/index.js
  var unsafeIndex3 = /* @__PURE__ */ unsafeIndex();
  var NUMCAT_LU = /* @__PURE__ */ function() {
    function NUMCAT_LU2() {
    }
    ;
    NUMCAT_LU2.value = new NUMCAT_LU2();
    return NUMCAT_LU2;
  }();
  var NUMCAT_LL = /* @__PURE__ */ function() {
    function NUMCAT_LL2() {
    }
    ;
    NUMCAT_LL2.value = new NUMCAT_LL2();
    return NUMCAT_LL2;
  }();
  var NUMCAT_LT = /* @__PURE__ */ function() {
    function NUMCAT_LT2() {
    }
    ;
    NUMCAT_LT2.value = new NUMCAT_LT2();
    return NUMCAT_LT2;
  }();
  var NUMCAT_MN = /* @__PURE__ */ function() {
    function NUMCAT_MN2() {
    }
    ;
    NUMCAT_MN2.value = new NUMCAT_MN2();
    return NUMCAT_MN2;
  }();
  var NUMCAT_NL = /* @__PURE__ */ function() {
    function NUMCAT_NL2() {
    }
    ;
    NUMCAT_NL2.value = new NUMCAT_NL2();
    return NUMCAT_NL2;
  }();
  var NUMCAT_SO = /* @__PURE__ */ function() {
    function NUMCAT_SO2() {
    }
    ;
    NUMCAT_SO2.value = new NUMCAT_SO2();
    return NUMCAT_SO2;
  }();
  var NUMCAT_CN = /* @__PURE__ */ function() {
    function NUMCAT_CN2() {
    }
    ;
    NUMCAT_CN2.value = new NUMCAT_CN2();
    return NUMCAT_CN2;
  }();
  var numConvBlocks = 1332;
  var gencatSO = 8192;
  var rule170 = /* @__PURE__ */ function() {
    return {
      category: gencatSO,
      unicodeCat: NUMCAT_SO.value,
      possible: 1,
      updist: 0,
      lowdist: 26,
      titledist: 0
    };
  }();
  var rule171 = /* @__PURE__ */ function() {
    return {
      category: gencatSO,
      unicodeCat: NUMCAT_SO.value,
      possible: 1,
      updist: -26 | 0,
      lowdist: 0,
      titledist: -26 | 0
    };
  }();
  var gencatNL = 16777216;
  var rule168 = /* @__PURE__ */ function() {
    return {
      category: gencatNL,
      unicodeCat: NUMCAT_NL.value,
      possible: 1,
      updist: 0,
      lowdist: 16,
      titledist: 0
    };
  }();
  var rule169 = /* @__PURE__ */ function() {
    return {
      category: gencatNL,
      unicodeCat: NUMCAT_NL.value,
      possible: 1,
      updist: -16 | 0,
      lowdist: 0,
      titledist: -16 | 0
    };
  }();
  var gencatMN = 2097152;
  var rule93 = /* @__PURE__ */ function() {
    return {
      category: gencatMN,
      unicodeCat: NUMCAT_MN.value,
      possible: 1,
      updist: 84,
      lowdist: 0,
      titledist: 84
    };
  }();
  var gencatLU = 512;
  var nullrule = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_CN.value,
      possible: 0,
      updist: 0,
      lowdist: 0,
      titledist: 0
    };
  }();
  var rule104 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 8,
      titledist: 0
    };
  }();
  var rule115 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -60 | 0,
      titledist: 0
    };
  }();
  var rule117 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -7 | 0,
      titledist: 0
    };
  }();
  var rule118 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 80,
      titledist: 0
    };
  }();
  var rule120 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 15,
      titledist: 0
    };
  }();
  var rule122 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 48,
      titledist: 0
    };
  }();
  var rule125 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 7264,
      titledist: 0
    };
  }();
  var rule127 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 38864,
      titledist: 0
    };
  }();
  var rule137 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -3008 | 0,
      titledist: 0
    };
  }();
  var rule142 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -7615 | 0,
      titledist: 0
    };
  }();
  var rule144 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -8 | 0,
      titledist: 0
    };
  }();
  var rule153 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -74 | 0,
      titledist: 0
    };
  }();
  var rule156 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -86 | 0,
      titledist: 0
    };
  }();
  var rule157 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -100 | 0,
      titledist: 0
    };
  }();
  var rule158 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -112 | 0,
      titledist: 0
    };
  }();
  var rule159 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -128 | 0,
      titledist: 0
    };
  }();
  var rule160 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -126 | 0,
      titledist: 0
    };
  }();
  var rule163 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -7517 | 0,
      titledist: 0
    };
  }();
  var rule164 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -8383 | 0,
      titledist: 0
    };
  }();
  var rule165 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -8262 | 0,
      titledist: 0
    };
  }();
  var rule166 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 28,
      titledist: 0
    };
  }();
  var rule172 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -10743 | 0,
      titledist: 0
    };
  }();
  var rule173 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -3814 | 0,
      titledist: 0
    };
  }();
  var rule174 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -10727 | 0,
      titledist: 0
    };
  }();
  var rule177 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -10780 | 0,
      titledist: 0
    };
  }();
  var rule178 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -10749 | 0,
      titledist: 0
    };
  }();
  var rule179 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -10783 | 0,
      titledist: 0
    };
  }();
  var rule180 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -10782 | 0,
      titledist: 0
    };
  }();
  var rule181 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -10815 | 0,
      titledist: 0
    };
  }();
  var rule183 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -35332 | 0,
      titledist: 0
    };
  }();
  var rule184 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -42280 | 0,
      titledist: 0
    };
  }();
  var rule186 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -42308 | 0,
      titledist: 0
    };
  }();
  var rule187 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -42319 | 0,
      titledist: 0
    };
  }();
  var rule188 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -42315 | 0,
      titledist: 0
    };
  }();
  var rule189 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -42305 | 0,
      titledist: 0
    };
  }();
  var rule190 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -42258 | 0,
      titledist: 0
    };
  }();
  var rule191 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -42282 | 0,
      titledist: 0
    };
  }();
  var rule192 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -42261 | 0,
      titledist: 0
    };
  }();
  var rule193 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 928,
      titledist: 0
    };
  }();
  var rule194 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -48 | 0,
      titledist: 0
    };
  }();
  var rule195 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -42307 | 0,
      titledist: 0
    };
  }();
  var rule196 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -35384 | 0,
      titledist: 0
    };
  }();
  var rule201 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 40,
      titledist: 0
    };
  }();
  var rule203 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 34,
      titledist: 0
    };
  }();
  var rule22 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 1,
      titledist: 0
    };
  }();
  var rule24 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -199 | 0,
      titledist: 0
    };
  }();
  var rule26 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -121 | 0,
      titledist: 0
    };
  }();
  var rule29 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 210,
      titledist: 0
    };
  }();
  var rule30 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 206,
      titledist: 0
    };
  }();
  var rule31 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 205,
      titledist: 0
    };
  }();
  var rule32 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 79,
      titledist: 0
    };
  }();
  var rule33 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 202,
      titledist: 0
    };
  }();
  var rule34 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 203,
      titledist: 0
    };
  }();
  var rule35 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 207,
      titledist: 0
    };
  }();
  var rule37 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 211,
      titledist: 0
    };
  }();
  var rule38 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 209,
      titledist: 0
    };
  }();
  var rule40 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 213,
      titledist: 0
    };
  }();
  var rule42 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 214,
      titledist: 0
    };
  }();
  var rule43 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 218,
      titledist: 0
    };
  }();
  var rule44 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 217,
      titledist: 0
    };
  }();
  var rule45 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 219,
      titledist: 0
    };
  }();
  var rule47 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 2,
      titledist: 1
    };
  }();
  var rule51 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -97 | 0,
      titledist: 0
    };
  }();
  var rule52 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -56 | 0,
      titledist: 0
    };
  }();
  var rule53 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -130 | 0,
      titledist: 0
    };
  }();
  var rule54 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 10795,
      titledist: 0
    };
  }();
  var rule55 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -163 | 0,
      titledist: 0
    };
  }();
  var rule56 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 10792,
      titledist: 0
    };
  }();
  var rule58 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: -195 | 0,
      titledist: 0
    };
  }();
  var rule59 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 69,
      titledist: 0
    };
  }();
  var rule60 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 71,
      titledist: 0
    };
  }();
  var rule9 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 32,
      titledist: 0
    };
  }();
  var rule94 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 116,
      titledist: 0
    };
  }();
  var rule95 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 38,
      titledist: 0
    };
  }();
  var rule96 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 37,
      titledist: 0
    };
  }();
  var rule97 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 64,
      titledist: 0
    };
  }();
  var rule98 = /* @__PURE__ */ function() {
    return {
      category: gencatLU,
      unicodeCat: NUMCAT_LU.value,
      possible: 1,
      updist: 0,
      lowdist: 63,
      titledist: 0
    };
  }();
  var gencatLT = 524288;
  var rule151 = /* @__PURE__ */ function() {
    return {
      category: gencatLT,
      unicodeCat: NUMCAT_LT.value,
      possible: 1,
      updist: 0,
      lowdist: -8 | 0,
      titledist: 0
    };
  }();
  var rule154 = /* @__PURE__ */ function() {
    return {
      category: gencatLT,
      unicodeCat: NUMCAT_LT.value,
      possible: 1,
      updist: 0,
      lowdist: -9 | 0,
      titledist: 0
    };
  }();
  var rule48 = /* @__PURE__ */ function() {
    return {
      category: gencatLT,
      unicodeCat: NUMCAT_LT.value,
      possible: 1,
      updist: -1 | 0,
      lowdist: 1,
      titledist: 0
    };
  }();
  var gencatLL = 4096;
  var rule100 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -37 | 0,
      lowdist: 0,
      titledist: -37 | 0
    };
  }();
  var rule101 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -31 | 0,
      lowdist: 0,
      titledist: -31 | 0
    };
  }();
  var rule102 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -64 | 0,
      lowdist: 0,
      titledist: -64 | 0
    };
  }();
  var rule103 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -63 | 0,
      lowdist: 0,
      titledist: -63 | 0
    };
  }();
  var rule105 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -62 | 0,
      lowdist: 0,
      titledist: -62 | 0
    };
  }();
  var rule106 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -57 | 0,
      lowdist: 0,
      titledist: -57 | 0
    };
  }();
  var rule108 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -47 | 0,
      lowdist: 0,
      titledist: -47 | 0
    };
  }();
  var rule109 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -54 | 0,
      lowdist: 0,
      titledist: -54 | 0
    };
  }();
  var rule110 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -8 | 0,
      lowdist: 0,
      titledist: -8 | 0
    };
  }();
  var rule111 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -86 | 0,
      lowdist: 0,
      titledist: -86 | 0
    };
  }();
  var rule112 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -80 | 0,
      lowdist: 0,
      titledist: -80 | 0
    };
  }();
  var rule113 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 7,
      lowdist: 0,
      titledist: 7
    };
  }();
  var rule114 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -116 | 0,
      lowdist: 0,
      titledist: -116 | 0
    };
  }();
  var rule116 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -96 | 0,
      lowdist: 0,
      titledist: -96 | 0
    };
  }();
  var rule12 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -32 | 0,
      lowdist: 0,
      titledist: -32 | 0
    };
  }();
  var rule121 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -15 | 0,
      lowdist: 0,
      titledist: -15 | 0
    };
  }();
  var rule123 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -48 | 0,
      lowdist: 0,
      titledist: -48 | 0
    };
  }();
  var rule126 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 3008,
      lowdist: 0,
      titledist: 0
    };
  }();
  var rule129 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -6254 | 0,
      lowdist: 0,
      titledist: -6254 | 0
    };
  }();
  var rule130 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -6253 | 0,
      lowdist: 0,
      titledist: -6253 | 0
    };
  }();
  var rule131 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -6244 | 0,
      lowdist: 0,
      titledist: -6244 | 0
    };
  }();
  var rule132 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -6242 | 0,
      lowdist: 0,
      titledist: -6242 | 0
    };
  }();
  var rule133 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -6243 | 0,
      lowdist: 0,
      titledist: -6243 | 0
    };
  }();
  var rule134 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -6236 | 0,
      lowdist: 0,
      titledist: -6236 | 0
    };
  }();
  var rule135 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -6181 | 0,
      lowdist: 0,
      titledist: -6181 | 0
    };
  }();
  var rule136 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 35266,
      lowdist: 0,
      titledist: 35266
    };
  }();
  var rule138 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 35332,
      lowdist: 0,
      titledist: 35332
    };
  }();
  var rule139 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 3814,
      lowdist: 0,
      titledist: 3814
    };
  }();
  var rule140 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 35384,
      lowdist: 0,
      titledist: 35384
    };
  }();
  var rule141 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -59 | 0,
      lowdist: 0,
      titledist: -59 | 0
    };
  }();
  var rule143 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 8,
      lowdist: 0,
      titledist: 8
    };
  }();
  var rule145 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 74,
      lowdist: 0,
      titledist: 74
    };
  }();
  var rule146 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 86,
      lowdist: 0,
      titledist: 86
    };
  }();
  var rule147 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 100,
      lowdist: 0,
      titledist: 100
    };
  }();
  var rule148 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 128,
      lowdist: 0,
      titledist: 128
    };
  }();
  var rule149 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 112,
      lowdist: 0,
      titledist: 112
    };
  }();
  var rule150 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 126,
      lowdist: 0,
      titledist: 126
    };
  }();
  var rule152 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 9,
      lowdist: 0,
      titledist: 9
    };
  }();
  var rule155 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -7205 | 0,
      lowdist: 0,
      titledist: -7205 | 0
    };
  }();
  var rule167 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -28 | 0,
      lowdist: 0,
      titledist: -28 | 0
    };
  }();
  var rule175 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -10795 | 0,
      lowdist: 0,
      titledist: -10795 | 0
    };
  }();
  var rule176 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -10792 | 0,
      lowdist: 0,
      titledist: -10792 | 0
    };
  }();
  var rule18 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 743,
      lowdist: 0,
      titledist: 743
    };
  }();
  var rule182 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -7264 | 0,
      lowdist: 0,
      titledist: -7264 | 0
    };
  }();
  var rule185 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 48,
      lowdist: 0,
      titledist: 48
    };
  }();
  var rule197 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -928 | 0,
      lowdist: 0,
      titledist: -928 | 0
    };
  }();
  var rule198 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -38864 | 0,
      lowdist: 0,
      titledist: -38864 | 0
    };
  }();
  var rule202 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -40 | 0,
      lowdist: 0,
      titledist: -40 | 0
    };
  }();
  var rule204 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -34 | 0,
      lowdist: 0,
      titledist: -34 | 0
    };
  }();
  var rule21 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 121,
      lowdist: 0,
      titledist: 121
    };
  }();
  var rule23 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -1 | 0,
      lowdist: 0,
      titledist: -1 | 0
    };
  }();
  var rule25 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -232 | 0,
      lowdist: 0,
      titledist: -232 | 0
    };
  }();
  var rule27 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -300 | 0,
      lowdist: 0,
      titledist: -300 | 0
    };
  }();
  var rule28 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 195,
      lowdist: 0,
      titledist: 195
    };
  }();
  var rule36 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 97,
      lowdist: 0,
      titledist: 97
    };
  }();
  var rule39 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 163,
      lowdist: 0,
      titledist: 163
    };
  }();
  var rule41 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 130,
      lowdist: 0,
      titledist: 130
    };
  }();
  var rule46 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 56,
      lowdist: 0,
      titledist: 56
    };
  }();
  var rule49 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -2 | 0,
      lowdist: 0,
      titledist: -1 | 0
    };
  }();
  var rule50 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -79 | 0,
      lowdist: 0,
      titledist: -79 | 0
    };
  }();
  var rule57 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 10815,
      lowdist: 0,
      titledist: 10815
    };
  }();
  var rule61 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 10783,
      lowdist: 0,
      titledist: 10783
    };
  }();
  var rule62 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 10780,
      lowdist: 0,
      titledist: 10780
    };
  }();
  var rule63 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 10782,
      lowdist: 0,
      titledist: 10782
    };
  }();
  var rule64 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -210 | 0,
      lowdist: 0,
      titledist: -210 | 0
    };
  }();
  var rule65 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -206 | 0,
      lowdist: 0,
      titledist: -206 | 0
    };
  }();
  var rule66 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -205 | 0,
      lowdist: 0,
      titledist: -205 | 0
    };
  }();
  var rule67 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -202 | 0,
      lowdist: 0,
      titledist: -202 | 0
    };
  }();
  var rule68 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -203 | 0,
      lowdist: 0,
      titledist: -203 | 0
    };
  }();
  var rule69 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 42319,
      lowdist: 0,
      titledist: 42319
    };
  }();
  var rule70 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 42315,
      lowdist: 0,
      titledist: 42315
    };
  }();
  var rule71 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -207 | 0,
      lowdist: 0,
      titledist: -207 | 0
    };
  }();
  var rule72 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 42280,
      lowdist: 0,
      titledist: 42280
    };
  }();
  var rule73 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 42308,
      lowdist: 0,
      titledist: 42308
    };
  }();
  var rule74 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -209 | 0,
      lowdist: 0,
      titledist: -209 | 0
    };
  }();
  var rule75 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -211 | 0,
      lowdist: 0,
      titledist: -211 | 0
    };
  }();
  var rule76 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 10743,
      lowdist: 0,
      titledist: 10743
    };
  }();
  var rule77 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 42305,
      lowdist: 0,
      titledist: 42305
    };
  }();
  var rule78 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 10749,
      lowdist: 0,
      titledist: 10749
    };
  }();
  var rule79 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -213 | 0,
      lowdist: 0,
      titledist: -213 | 0
    };
  }();
  var rule80 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -214 | 0,
      lowdist: 0,
      titledist: -214 | 0
    };
  }();
  var rule81 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 10727,
      lowdist: 0,
      titledist: 10727
    };
  }();
  var rule82 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -218 | 0,
      lowdist: 0,
      titledist: -218 | 0
    };
  }();
  var rule83 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 42307,
      lowdist: 0,
      titledist: 42307
    };
  }();
  var rule84 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 42282,
      lowdist: 0,
      titledist: 42282
    };
  }();
  var rule85 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -69 | 0,
      lowdist: 0,
      titledist: -69 | 0
    };
  }();
  var rule86 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -217 | 0,
      lowdist: 0,
      titledist: -217 | 0
    };
  }();
  var rule87 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -71 | 0,
      lowdist: 0,
      titledist: -71 | 0
    };
  }();
  var rule88 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -219 | 0,
      lowdist: 0,
      titledist: -219 | 0
    };
  }();
  var rule89 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 42261,
      lowdist: 0,
      titledist: 42261
    };
  }();
  var rule90 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: 42258,
      lowdist: 0,
      titledist: 42258
    };
  }();
  var rule99 = /* @__PURE__ */ function() {
    return {
      category: gencatLL,
      unicodeCat: NUMCAT_LL.value,
      possible: 1,
      updist: -38 | 0,
      lowdist: 0,
      titledist: -38 | 0
    };
  }();
  var convchars = [{
    start: 65,
    length: 26,
    convRule: rule9
  }, {
    start: 97,
    length: 26,
    convRule: rule12
  }, {
    start: 181,
    length: 1,
    convRule: rule18
  }, {
    start: 192,
    length: 23,
    convRule: rule9
  }, {
    start: 216,
    length: 7,
    convRule: rule9
  }, {
    start: 224,
    length: 23,
    convRule: rule12
  }, {
    start: 248,
    length: 7,
    convRule: rule12
  }, {
    start: 255,
    length: 1,
    convRule: rule21
  }, {
    start: 256,
    length: 1,
    convRule: rule22
  }, {
    start: 257,
    length: 1,
    convRule: rule23
  }, {
    start: 258,
    length: 1,
    convRule: rule22
  }, {
    start: 259,
    length: 1,
    convRule: rule23
  }, {
    start: 260,
    length: 1,
    convRule: rule22
  }, {
    start: 261,
    length: 1,
    convRule: rule23
  }, {
    start: 262,
    length: 1,
    convRule: rule22
  }, {
    start: 263,
    length: 1,
    convRule: rule23
  }, {
    start: 264,
    length: 1,
    convRule: rule22
  }, {
    start: 265,
    length: 1,
    convRule: rule23
  }, {
    start: 266,
    length: 1,
    convRule: rule22
  }, {
    start: 267,
    length: 1,
    convRule: rule23
  }, {
    start: 268,
    length: 1,
    convRule: rule22
  }, {
    start: 269,
    length: 1,
    convRule: rule23
  }, {
    start: 270,
    length: 1,
    convRule: rule22
  }, {
    start: 271,
    length: 1,
    convRule: rule23
  }, {
    start: 272,
    length: 1,
    convRule: rule22
  }, {
    start: 273,
    length: 1,
    convRule: rule23
  }, {
    start: 274,
    length: 1,
    convRule: rule22
  }, {
    start: 275,
    length: 1,
    convRule: rule23
  }, {
    start: 276,
    length: 1,
    convRule: rule22
  }, {
    start: 277,
    length: 1,
    convRule: rule23
  }, {
    start: 278,
    length: 1,
    convRule: rule22
  }, {
    start: 279,
    length: 1,
    convRule: rule23
  }, {
    start: 280,
    length: 1,
    convRule: rule22
  }, {
    start: 281,
    length: 1,
    convRule: rule23
  }, {
    start: 282,
    length: 1,
    convRule: rule22
  }, {
    start: 283,
    length: 1,
    convRule: rule23
  }, {
    start: 284,
    length: 1,
    convRule: rule22
  }, {
    start: 285,
    length: 1,
    convRule: rule23
  }, {
    start: 286,
    length: 1,
    convRule: rule22
  }, {
    start: 287,
    length: 1,
    convRule: rule23
  }, {
    start: 288,
    length: 1,
    convRule: rule22
  }, {
    start: 289,
    length: 1,
    convRule: rule23
  }, {
    start: 290,
    length: 1,
    convRule: rule22
  }, {
    start: 291,
    length: 1,
    convRule: rule23
  }, {
    start: 292,
    length: 1,
    convRule: rule22
  }, {
    start: 293,
    length: 1,
    convRule: rule23
  }, {
    start: 294,
    length: 1,
    convRule: rule22
  }, {
    start: 295,
    length: 1,
    convRule: rule23
  }, {
    start: 296,
    length: 1,
    convRule: rule22
  }, {
    start: 297,
    length: 1,
    convRule: rule23
  }, {
    start: 298,
    length: 1,
    convRule: rule22
  }, {
    start: 299,
    length: 1,
    convRule: rule23
  }, {
    start: 300,
    length: 1,
    convRule: rule22
  }, {
    start: 301,
    length: 1,
    convRule: rule23
  }, {
    start: 302,
    length: 1,
    convRule: rule22
  }, {
    start: 303,
    length: 1,
    convRule: rule23
  }, {
    start: 304,
    length: 1,
    convRule: rule24
  }, {
    start: 305,
    length: 1,
    convRule: rule25
  }, {
    start: 306,
    length: 1,
    convRule: rule22
  }, {
    start: 307,
    length: 1,
    convRule: rule23
  }, {
    start: 308,
    length: 1,
    convRule: rule22
  }, {
    start: 309,
    length: 1,
    convRule: rule23
  }, {
    start: 310,
    length: 1,
    convRule: rule22
  }, {
    start: 311,
    length: 1,
    convRule: rule23
  }, {
    start: 313,
    length: 1,
    convRule: rule22
  }, {
    start: 314,
    length: 1,
    convRule: rule23
  }, {
    start: 315,
    length: 1,
    convRule: rule22
  }, {
    start: 316,
    length: 1,
    convRule: rule23
  }, {
    start: 317,
    length: 1,
    convRule: rule22
  }, {
    start: 318,
    length: 1,
    convRule: rule23
  }, {
    start: 319,
    length: 1,
    convRule: rule22
  }, {
    start: 320,
    length: 1,
    convRule: rule23
  }, {
    start: 321,
    length: 1,
    convRule: rule22
  }, {
    start: 322,
    length: 1,
    convRule: rule23
  }, {
    start: 323,
    length: 1,
    convRule: rule22
  }, {
    start: 324,
    length: 1,
    convRule: rule23
  }, {
    start: 325,
    length: 1,
    convRule: rule22
  }, {
    start: 326,
    length: 1,
    convRule: rule23
  }, {
    start: 327,
    length: 1,
    convRule: rule22
  }, {
    start: 328,
    length: 1,
    convRule: rule23
  }, {
    start: 330,
    length: 1,
    convRule: rule22
  }, {
    start: 331,
    length: 1,
    convRule: rule23
  }, {
    start: 332,
    length: 1,
    convRule: rule22
  }, {
    start: 333,
    length: 1,
    convRule: rule23
  }, {
    start: 334,
    length: 1,
    convRule: rule22
  }, {
    start: 335,
    length: 1,
    convRule: rule23
  }, {
    start: 336,
    length: 1,
    convRule: rule22
  }, {
    start: 337,
    length: 1,
    convRule: rule23
  }, {
    start: 338,
    length: 1,
    convRule: rule22
  }, {
    start: 339,
    length: 1,
    convRule: rule23
  }, {
    start: 340,
    length: 1,
    convRule: rule22
  }, {
    start: 341,
    length: 1,
    convRule: rule23
  }, {
    start: 342,
    length: 1,
    convRule: rule22
  }, {
    start: 343,
    length: 1,
    convRule: rule23
  }, {
    start: 344,
    length: 1,
    convRule: rule22
  }, {
    start: 345,
    length: 1,
    convRule: rule23
  }, {
    start: 346,
    length: 1,
    convRule: rule22
  }, {
    start: 347,
    length: 1,
    convRule: rule23
  }, {
    start: 348,
    length: 1,
    convRule: rule22
  }, {
    start: 349,
    length: 1,
    convRule: rule23
  }, {
    start: 350,
    length: 1,
    convRule: rule22
  }, {
    start: 351,
    length: 1,
    convRule: rule23
  }, {
    start: 352,
    length: 1,
    convRule: rule22
  }, {
    start: 353,
    length: 1,
    convRule: rule23
  }, {
    start: 354,
    length: 1,
    convRule: rule22
  }, {
    start: 355,
    length: 1,
    convRule: rule23
  }, {
    start: 356,
    length: 1,
    convRule: rule22
  }, {
    start: 357,
    length: 1,
    convRule: rule23
  }, {
    start: 358,
    length: 1,
    convRule: rule22
  }, {
    start: 359,
    length: 1,
    convRule: rule23
  }, {
    start: 360,
    length: 1,
    convRule: rule22
  }, {
    start: 361,
    length: 1,
    convRule: rule23
  }, {
    start: 362,
    length: 1,
    convRule: rule22
  }, {
    start: 363,
    length: 1,
    convRule: rule23
  }, {
    start: 364,
    length: 1,
    convRule: rule22
  }, {
    start: 365,
    length: 1,
    convRule: rule23
  }, {
    start: 366,
    length: 1,
    convRule: rule22
  }, {
    start: 367,
    length: 1,
    convRule: rule23
  }, {
    start: 368,
    length: 1,
    convRule: rule22
  }, {
    start: 369,
    length: 1,
    convRule: rule23
  }, {
    start: 370,
    length: 1,
    convRule: rule22
  }, {
    start: 371,
    length: 1,
    convRule: rule23
  }, {
    start: 372,
    length: 1,
    convRule: rule22
  }, {
    start: 373,
    length: 1,
    convRule: rule23
  }, {
    start: 374,
    length: 1,
    convRule: rule22
  }, {
    start: 375,
    length: 1,
    convRule: rule23
  }, {
    start: 376,
    length: 1,
    convRule: rule26
  }, {
    start: 377,
    length: 1,
    convRule: rule22
  }, {
    start: 378,
    length: 1,
    convRule: rule23
  }, {
    start: 379,
    length: 1,
    convRule: rule22
  }, {
    start: 380,
    length: 1,
    convRule: rule23
  }, {
    start: 381,
    length: 1,
    convRule: rule22
  }, {
    start: 382,
    length: 1,
    convRule: rule23
  }, {
    start: 383,
    length: 1,
    convRule: rule27
  }, {
    start: 384,
    length: 1,
    convRule: rule28
  }, {
    start: 385,
    length: 1,
    convRule: rule29
  }, {
    start: 386,
    length: 1,
    convRule: rule22
  }, {
    start: 387,
    length: 1,
    convRule: rule23
  }, {
    start: 388,
    length: 1,
    convRule: rule22
  }, {
    start: 389,
    length: 1,
    convRule: rule23
  }, {
    start: 390,
    length: 1,
    convRule: rule30
  }, {
    start: 391,
    length: 1,
    convRule: rule22
  }, {
    start: 392,
    length: 1,
    convRule: rule23
  }, {
    start: 393,
    length: 2,
    convRule: rule31
  }, {
    start: 395,
    length: 1,
    convRule: rule22
  }, {
    start: 396,
    length: 1,
    convRule: rule23
  }, {
    start: 398,
    length: 1,
    convRule: rule32
  }, {
    start: 399,
    length: 1,
    convRule: rule33
  }, {
    start: 400,
    length: 1,
    convRule: rule34
  }, {
    start: 401,
    length: 1,
    convRule: rule22
  }, {
    start: 402,
    length: 1,
    convRule: rule23
  }, {
    start: 403,
    length: 1,
    convRule: rule31
  }, {
    start: 404,
    length: 1,
    convRule: rule35
  }, {
    start: 405,
    length: 1,
    convRule: rule36
  }, {
    start: 406,
    length: 1,
    convRule: rule37
  }, {
    start: 407,
    length: 1,
    convRule: rule38
  }, {
    start: 408,
    length: 1,
    convRule: rule22
  }, {
    start: 409,
    length: 1,
    convRule: rule23
  }, {
    start: 410,
    length: 1,
    convRule: rule39
  }, {
    start: 412,
    length: 1,
    convRule: rule37
  }, {
    start: 413,
    length: 1,
    convRule: rule40
  }, {
    start: 414,
    length: 1,
    convRule: rule41
  }, {
    start: 415,
    length: 1,
    convRule: rule42
  }, {
    start: 416,
    length: 1,
    convRule: rule22
  }, {
    start: 417,
    length: 1,
    convRule: rule23
  }, {
    start: 418,
    length: 1,
    convRule: rule22
  }, {
    start: 419,
    length: 1,
    convRule: rule23
  }, {
    start: 420,
    length: 1,
    convRule: rule22
  }, {
    start: 421,
    length: 1,
    convRule: rule23
  }, {
    start: 422,
    length: 1,
    convRule: rule43
  }, {
    start: 423,
    length: 1,
    convRule: rule22
  }, {
    start: 424,
    length: 1,
    convRule: rule23
  }, {
    start: 425,
    length: 1,
    convRule: rule43
  }, {
    start: 428,
    length: 1,
    convRule: rule22
  }, {
    start: 429,
    length: 1,
    convRule: rule23
  }, {
    start: 430,
    length: 1,
    convRule: rule43
  }, {
    start: 431,
    length: 1,
    convRule: rule22
  }, {
    start: 432,
    length: 1,
    convRule: rule23
  }, {
    start: 433,
    length: 2,
    convRule: rule44
  }, {
    start: 435,
    length: 1,
    convRule: rule22
  }, {
    start: 436,
    length: 1,
    convRule: rule23
  }, {
    start: 437,
    length: 1,
    convRule: rule22
  }, {
    start: 438,
    length: 1,
    convRule: rule23
  }, {
    start: 439,
    length: 1,
    convRule: rule45
  }, {
    start: 440,
    length: 1,
    convRule: rule22
  }, {
    start: 441,
    length: 1,
    convRule: rule23
  }, {
    start: 444,
    length: 1,
    convRule: rule22
  }, {
    start: 445,
    length: 1,
    convRule: rule23
  }, {
    start: 447,
    length: 1,
    convRule: rule46
  }, {
    start: 452,
    length: 1,
    convRule: rule47
  }, {
    start: 453,
    length: 1,
    convRule: rule48
  }, {
    start: 454,
    length: 1,
    convRule: rule49
  }, {
    start: 455,
    length: 1,
    convRule: rule47
  }, {
    start: 456,
    length: 1,
    convRule: rule48
  }, {
    start: 457,
    length: 1,
    convRule: rule49
  }, {
    start: 458,
    length: 1,
    convRule: rule47
  }, {
    start: 459,
    length: 1,
    convRule: rule48
  }, {
    start: 460,
    length: 1,
    convRule: rule49
  }, {
    start: 461,
    length: 1,
    convRule: rule22
  }, {
    start: 462,
    length: 1,
    convRule: rule23
  }, {
    start: 463,
    length: 1,
    convRule: rule22
  }, {
    start: 464,
    length: 1,
    convRule: rule23
  }, {
    start: 465,
    length: 1,
    convRule: rule22
  }, {
    start: 466,
    length: 1,
    convRule: rule23
  }, {
    start: 467,
    length: 1,
    convRule: rule22
  }, {
    start: 468,
    length: 1,
    convRule: rule23
  }, {
    start: 469,
    length: 1,
    convRule: rule22
  }, {
    start: 470,
    length: 1,
    convRule: rule23
  }, {
    start: 471,
    length: 1,
    convRule: rule22
  }, {
    start: 472,
    length: 1,
    convRule: rule23
  }, {
    start: 473,
    length: 1,
    convRule: rule22
  }, {
    start: 474,
    length: 1,
    convRule: rule23
  }, {
    start: 475,
    length: 1,
    convRule: rule22
  }, {
    start: 476,
    length: 1,
    convRule: rule23
  }, {
    start: 477,
    length: 1,
    convRule: rule50
  }, {
    start: 478,
    length: 1,
    convRule: rule22
  }, {
    start: 479,
    length: 1,
    convRule: rule23
  }, {
    start: 480,
    length: 1,
    convRule: rule22
  }, {
    start: 481,
    length: 1,
    convRule: rule23
  }, {
    start: 482,
    length: 1,
    convRule: rule22
  }, {
    start: 483,
    length: 1,
    convRule: rule23
  }, {
    start: 484,
    length: 1,
    convRule: rule22
  }, {
    start: 485,
    length: 1,
    convRule: rule23
  }, {
    start: 486,
    length: 1,
    convRule: rule22
  }, {
    start: 487,
    length: 1,
    convRule: rule23
  }, {
    start: 488,
    length: 1,
    convRule: rule22
  }, {
    start: 489,
    length: 1,
    convRule: rule23
  }, {
    start: 490,
    length: 1,
    convRule: rule22
  }, {
    start: 491,
    length: 1,
    convRule: rule23
  }, {
    start: 492,
    length: 1,
    convRule: rule22
  }, {
    start: 493,
    length: 1,
    convRule: rule23
  }, {
    start: 494,
    length: 1,
    convRule: rule22
  }, {
    start: 495,
    length: 1,
    convRule: rule23
  }, {
    start: 497,
    length: 1,
    convRule: rule47
  }, {
    start: 498,
    length: 1,
    convRule: rule48
  }, {
    start: 499,
    length: 1,
    convRule: rule49
  }, {
    start: 500,
    length: 1,
    convRule: rule22
  }, {
    start: 501,
    length: 1,
    convRule: rule23
  }, {
    start: 502,
    length: 1,
    convRule: rule51
  }, {
    start: 503,
    length: 1,
    convRule: rule52
  }, {
    start: 504,
    length: 1,
    convRule: rule22
  }, {
    start: 505,
    length: 1,
    convRule: rule23
  }, {
    start: 506,
    length: 1,
    convRule: rule22
  }, {
    start: 507,
    length: 1,
    convRule: rule23
  }, {
    start: 508,
    length: 1,
    convRule: rule22
  }, {
    start: 509,
    length: 1,
    convRule: rule23
  }, {
    start: 510,
    length: 1,
    convRule: rule22
  }, {
    start: 511,
    length: 1,
    convRule: rule23
  }, {
    start: 512,
    length: 1,
    convRule: rule22
  }, {
    start: 513,
    length: 1,
    convRule: rule23
  }, {
    start: 514,
    length: 1,
    convRule: rule22
  }, {
    start: 515,
    length: 1,
    convRule: rule23
  }, {
    start: 516,
    length: 1,
    convRule: rule22
  }, {
    start: 517,
    length: 1,
    convRule: rule23
  }, {
    start: 518,
    length: 1,
    convRule: rule22
  }, {
    start: 519,
    length: 1,
    convRule: rule23
  }, {
    start: 520,
    length: 1,
    convRule: rule22
  }, {
    start: 521,
    length: 1,
    convRule: rule23
  }, {
    start: 522,
    length: 1,
    convRule: rule22
  }, {
    start: 523,
    length: 1,
    convRule: rule23
  }, {
    start: 524,
    length: 1,
    convRule: rule22
  }, {
    start: 525,
    length: 1,
    convRule: rule23
  }, {
    start: 526,
    length: 1,
    convRule: rule22
  }, {
    start: 527,
    length: 1,
    convRule: rule23
  }, {
    start: 528,
    length: 1,
    convRule: rule22
  }, {
    start: 529,
    length: 1,
    convRule: rule23
  }, {
    start: 530,
    length: 1,
    convRule: rule22
  }, {
    start: 531,
    length: 1,
    convRule: rule23
  }, {
    start: 532,
    length: 1,
    convRule: rule22
  }, {
    start: 533,
    length: 1,
    convRule: rule23
  }, {
    start: 534,
    length: 1,
    convRule: rule22
  }, {
    start: 535,
    length: 1,
    convRule: rule23
  }, {
    start: 536,
    length: 1,
    convRule: rule22
  }, {
    start: 537,
    length: 1,
    convRule: rule23
  }, {
    start: 538,
    length: 1,
    convRule: rule22
  }, {
    start: 539,
    length: 1,
    convRule: rule23
  }, {
    start: 540,
    length: 1,
    convRule: rule22
  }, {
    start: 541,
    length: 1,
    convRule: rule23
  }, {
    start: 542,
    length: 1,
    convRule: rule22
  }, {
    start: 543,
    length: 1,
    convRule: rule23
  }, {
    start: 544,
    length: 1,
    convRule: rule53
  }, {
    start: 546,
    length: 1,
    convRule: rule22
  }, {
    start: 547,
    length: 1,
    convRule: rule23
  }, {
    start: 548,
    length: 1,
    convRule: rule22
  }, {
    start: 549,
    length: 1,
    convRule: rule23
  }, {
    start: 550,
    length: 1,
    convRule: rule22
  }, {
    start: 551,
    length: 1,
    convRule: rule23
  }, {
    start: 552,
    length: 1,
    convRule: rule22
  }, {
    start: 553,
    length: 1,
    convRule: rule23
  }, {
    start: 554,
    length: 1,
    convRule: rule22
  }, {
    start: 555,
    length: 1,
    convRule: rule23
  }, {
    start: 556,
    length: 1,
    convRule: rule22
  }, {
    start: 557,
    length: 1,
    convRule: rule23
  }, {
    start: 558,
    length: 1,
    convRule: rule22
  }, {
    start: 559,
    length: 1,
    convRule: rule23
  }, {
    start: 560,
    length: 1,
    convRule: rule22
  }, {
    start: 561,
    length: 1,
    convRule: rule23
  }, {
    start: 562,
    length: 1,
    convRule: rule22
  }, {
    start: 563,
    length: 1,
    convRule: rule23
  }, {
    start: 570,
    length: 1,
    convRule: rule54
  }, {
    start: 571,
    length: 1,
    convRule: rule22
  }, {
    start: 572,
    length: 1,
    convRule: rule23
  }, {
    start: 573,
    length: 1,
    convRule: rule55
  }, {
    start: 574,
    length: 1,
    convRule: rule56
  }, {
    start: 575,
    length: 2,
    convRule: rule57
  }, {
    start: 577,
    length: 1,
    convRule: rule22
  }, {
    start: 578,
    length: 1,
    convRule: rule23
  }, {
    start: 579,
    length: 1,
    convRule: rule58
  }, {
    start: 580,
    length: 1,
    convRule: rule59
  }, {
    start: 581,
    length: 1,
    convRule: rule60
  }, {
    start: 582,
    length: 1,
    convRule: rule22
  }, {
    start: 583,
    length: 1,
    convRule: rule23
  }, {
    start: 584,
    length: 1,
    convRule: rule22
  }, {
    start: 585,
    length: 1,
    convRule: rule23
  }, {
    start: 586,
    length: 1,
    convRule: rule22
  }, {
    start: 587,
    length: 1,
    convRule: rule23
  }, {
    start: 588,
    length: 1,
    convRule: rule22
  }, {
    start: 589,
    length: 1,
    convRule: rule23
  }, {
    start: 590,
    length: 1,
    convRule: rule22
  }, {
    start: 591,
    length: 1,
    convRule: rule23
  }, {
    start: 592,
    length: 1,
    convRule: rule61
  }, {
    start: 593,
    length: 1,
    convRule: rule62
  }, {
    start: 594,
    length: 1,
    convRule: rule63
  }, {
    start: 595,
    length: 1,
    convRule: rule64
  }, {
    start: 596,
    length: 1,
    convRule: rule65
  }, {
    start: 598,
    length: 2,
    convRule: rule66
  }, {
    start: 601,
    length: 1,
    convRule: rule67
  }, {
    start: 603,
    length: 1,
    convRule: rule68
  }, {
    start: 604,
    length: 1,
    convRule: rule69
  }, {
    start: 608,
    length: 1,
    convRule: rule66
  }, {
    start: 609,
    length: 1,
    convRule: rule70
  }, {
    start: 611,
    length: 1,
    convRule: rule71
  }, {
    start: 613,
    length: 1,
    convRule: rule72
  }, {
    start: 614,
    length: 1,
    convRule: rule73
  }, {
    start: 616,
    length: 1,
    convRule: rule74
  }, {
    start: 617,
    length: 1,
    convRule: rule75
  }, {
    start: 618,
    length: 1,
    convRule: rule73
  }, {
    start: 619,
    length: 1,
    convRule: rule76
  }, {
    start: 620,
    length: 1,
    convRule: rule77
  }, {
    start: 623,
    length: 1,
    convRule: rule75
  }, {
    start: 625,
    length: 1,
    convRule: rule78
  }, {
    start: 626,
    length: 1,
    convRule: rule79
  }, {
    start: 629,
    length: 1,
    convRule: rule80
  }, {
    start: 637,
    length: 1,
    convRule: rule81
  }, {
    start: 640,
    length: 1,
    convRule: rule82
  }, {
    start: 642,
    length: 1,
    convRule: rule83
  }, {
    start: 643,
    length: 1,
    convRule: rule82
  }, {
    start: 647,
    length: 1,
    convRule: rule84
  }, {
    start: 648,
    length: 1,
    convRule: rule82
  }, {
    start: 649,
    length: 1,
    convRule: rule85
  }, {
    start: 650,
    length: 2,
    convRule: rule86
  }, {
    start: 652,
    length: 1,
    convRule: rule87
  }, {
    start: 658,
    length: 1,
    convRule: rule88
  }, {
    start: 669,
    length: 1,
    convRule: rule89
  }, {
    start: 670,
    length: 1,
    convRule: rule90
  }, {
    start: 837,
    length: 1,
    convRule: rule93
  }, {
    start: 880,
    length: 1,
    convRule: rule22
  }, {
    start: 881,
    length: 1,
    convRule: rule23
  }, {
    start: 882,
    length: 1,
    convRule: rule22
  }, {
    start: 883,
    length: 1,
    convRule: rule23
  }, {
    start: 886,
    length: 1,
    convRule: rule22
  }, {
    start: 887,
    length: 1,
    convRule: rule23
  }, {
    start: 891,
    length: 3,
    convRule: rule41
  }, {
    start: 895,
    length: 1,
    convRule: rule94
  }, {
    start: 902,
    length: 1,
    convRule: rule95
  }, {
    start: 904,
    length: 3,
    convRule: rule96
  }, {
    start: 908,
    length: 1,
    convRule: rule97
  }, {
    start: 910,
    length: 2,
    convRule: rule98
  }, {
    start: 913,
    length: 17,
    convRule: rule9
  }, {
    start: 931,
    length: 9,
    convRule: rule9
  }, {
    start: 940,
    length: 1,
    convRule: rule99
  }, {
    start: 941,
    length: 3,
    convRule: rule100
  }, {
    start: 945,
    length: 17,
    convRule: rule12
  }, {
    start: 962,
    length: 1,
    convRule: rule101
  }, {
    start: 963,
    length: 9,
    convRule: rule12
  }, {
    start: 972,
    length: 1,
    convRule: rule102
  }, {
    start: 973,
    length: 2,
    convRule: rule103
  }, {
    start: 975,
    length: 1,
    convRule: rule104
  }, {
    start: 976,
    length: 1,
    convRule: rule105
  }, {
    start: 977,
    length: 1,
    convRule: rule106
  }, {
    start: 981,
    length: 1,
    convRule: rule108
  }, {
    start: 982,
    length: 1,
    convRule: rule109
  }, {
    start: 983,
    length: 1,
    convRule: rule110
  }, {
    start: 984,
    length: 1,
    convRule: rule22
  }, {
    start: 985,
    length: 1,
    convRule: rule23
  }, {
    start: 986,
    length: 1,
    convRule: rule22
  }, {
    start: 987,
    length: 1,
    convRule: rule23
  }, {
    start: 988,
    length: 1,
    convRule: rule22
  }, {
    start: 989,
    length: 1,
    convRule: rule23
  }, {
    start: 990,
    length: 1,
    convRule: rule22
  }, {
    start: 991,
    length: 1,
    convRule: rule23
  }, {
    start: 992,
    length: 1,
    convRule: rule22
  }, {
    start: 993,
    length: 1,
    convRule: rule23
  }, {
    start: 994,
    length: 1,
    convRule: rule22
  }, {
    start: 995,
    length: 1,
    convRule: rule23
  }, {
    start: 996,
    length: 1,
    convRule: rule22
  }, {
    start: 997,
    length: 1,
    convRule: rule23
  }, {
    start: 998,
    length: 1,
    convRule: rule22
  }, {
    start: 999,
    length: 1,
    convRule: rule23
  }, {
    start: 1e3,
    length: 1,
    convRule: rule22
  }, {
    start: 1001,
    length: 1,
    convRule: rule23
  }, {
    start: 1002,
    length: 1,
    convRule: rule22
  }, {
    start: 1003,
    length: 1,
    convRule: rule23
  }, {
    start: 1004,
    length: 1,
    convRule: rule22
  }, {
    start: 1005,
    length: 1,
    convRule: rule23
  }, {
    start: 1006,
    length: 1,
    convRule: rule22
  }, {
    start: 1007,
    length: 1,
    convRule: rule23
  }, {
    start: 1008,
    length: 1,
    convRule: rule111
  }, {
    start: 1009,
    length: 1,
    convRule: rule112
  }, {
    start: 1010,
    length: 1,
    convRule: rule113
  }, {
    start: 1011,
    length: 1,
    convRule: rule114
  }, {
    start: 1012,
    length: 1,
    convRule: rule115
  }, {
    start: 1013,
    length: 1,
    convRule: rule116
  }, {
    start: 1015,
    length: 1,
    convRule: rule22
  }, {
    start: 1016,
    length: 1,
    convRule: rule23
  }, {
    start: 1017,
    length: 1,
    convRule: rule117
  }, {
    start: 1018,
    length: 1,
    convRule: rule22
  }, {
    start: 1019,
    length: 1,
    convRule: rule23
  }, {
    start: 1021,
    length: 3,
    convRule: rule53
  }, {
    start: 1024,
    length: 16,
    convRule: rule118
  }, {
    start: 1040,
    length: 32,
    convRule: rule9
  }, {
    start: 1072,
    length: 32,
    convRule: rule12
  }, {
    start: 1104,
    length: 16,
    convRule: rule112
  }, {
    start: 1120,
    length: 1,
    convRule: rule22
  }, {
    start: 1121,
    length: 1,
    convRule: rule23
  }, {
    start: 1122,
    length: 1,
    convRule: rule22
  }, {
    start: 1123,
    length: 1,
    convRule: rule23
  }, {
    start: 1124,
    length: 1,
    convRule: rule22
  }, {
    start: 1125,
    length: 1,
    convRule: rule23
  }, {
    start: 1126,
    length: 1,
    convRule: rule22
  }, {
    start: 1127,
    length: 1,
    convRule: rule23
  }, {
    start: 1128,
    length: 1,
    convRule: rule22
  }, {
    start: 1129,
    length: 1,
    convRule: rule23
  }, {
    start: 1130,
    length: 1,
    convRule: rule22
  }, {
    start: 1131,
    length: 1,
    convRule: rule23
  }, {
    start: 1132,
    length: 1,
    convRule: rule22
  }, {
    start: 1133,
    length: 1,
    convRule: rule23
  }, {
    start: 1134,
    length: 1,
    convRule: rule22
  }, {
    start: 1135,
    length: 1,
    convRule: rule23
  }, {
    start: 1136,
    length: 1,
    convRule: rule22
  }, {
    start: 1137,
    length: 1,
    convRule: rule23
  }, {
    start: 1138,
    length: 1,
    convRule: rule22
  }, {
    start: 1139,
    length: 1,
    convRule: rule23
  }, {
    start: 1140,
    length: 1,
    convRule: rule22
  }, {
    start: 1141,
    length: 1,
    convRule: rule23
  }, {
    start: 1142,
    length: 1,
    convRule: rule22
  }, {
    start: 1143,
    length: 1,
    convRule: rule23
  }, {
    start: 1144,
    length: 1,
    convRule: rule22
  }, {
    start: 1145,
    length: 1,
    convRule: rule23
  }, {
    start: 1146,
    length: 1,
    convRule: rule22
  }, {
    start: 1147,
    length: 1,
    convRule: rule23
  }, {
    start: 1148,
    length: 1,
    convRule: rule22
  }, {
    start: 1149,
    length: 1,
    convRule: rule23
  }, {
    start: 1150,
    length: 1,
    convRule: rule22
  }, {
    start: 1151,
    length: 1,
    convRule: rule23
  }, {
    start: 1152,
    length: 1,
    convRule: rule22
  }, {
    start: 1153,
    length: 1,
    convRule: rule23
  }, {
    start: 1162,
    length: 1,
    convRule: rule22
  }, {
    start: 1163,
    length: 1,
    convRule: rule23
  }, {
    start: 1164,
    length: 1,
    convRule: rule22
  }, {
    start: 1165,
    length: 1,
    convRule: rule23
  }, {
    start: 1166,
    length: 1,
    convRule: rule22
  }, {
    start: 1167,
    length: 1,
    convRule: rule23
  }, {
    start: 1168,
    length: 1,
    convRule: rule22
  }, {
    start: 1169,
    length: 1,
    convRule: rule23
  }, {
    start: 1170,
    length: 1,
    convRule: rule22
  }, {
    start: 1171,
    length: 1,
    convRule: rule23
  }, {
    start: 1172,
    length: 1,
    convRule: rule22
  }, {
    start: 1173,
    length: 1,
    convRule: rule23
  }, {
    start: 1174,
    length: 1,
    convRule: rule22
  }, {
    start: 1175,
    length: 1,
    convRule: rule23
  }, {
    start: 1176,
    length: 1,
    convRule: rule22
  }, {
    start: 1177,
    length: 1,
    convRule: rule23
  }, {
    start: 1178,
    length: 1,
    convRule: rule22
  }, {
    start: 1179,
    length: 1,
    convRule: rule23
  }, {
    start: 1180,
    length: 1,
    convRule: rule22
  }, {
    start: 1181,
    length: 1,
    convRule: rule23
  }, {
    start: 1182,
    length: 1,
    convRule: rule22
  }, {
    start: 1183,
    length: 1,
    convRule: rule23
  }, {
    start: 1184,
    length: 1,
    convRule: rule22
  }, {
    start: 1185,
    length: 1,
    convRule: rule23
  }, {
    start: 1186,
    length: 1,
    convRule: rule22
  }, {
    start: 1187,
    length: 1,
    convRule: rule23
  }, {
    start: 1188,
    length: 1,
    convRule: rule22
  }, {
    start: 1189,
    length: 1,
    convRule: rule23
  }, {
    start: 1190,
    length: 1,
    convRule: rule22
  }, {
    start: 1191,
    length: 1,
    convRule: rule23
  }, {
    start: 1192,
    length: 1,
    convRule: rule22
  }, {
    start: 1193,
    length: 1,
    convRule: rule23
  }, {
    start: 1194,
    length: 1,
    convRule: rule22
  }, {
    start: 1195,
    length: 1,
    convRule: rule23
  }, {
    start: 1196,
    length: 1,
    convRule: rule22
  }, {
    start: 1197,
    length: 1,
    convRule: rule23
  }, {
    start: 1198,
    length: 1,
    convRule: rule22
  }, {
    start: 1199,
    length: 1,
    convRule: rule23
  }, {
    start: 1200,
    length: 1,
    convRule: rule22
  }, {
    start: 1201,
    length: 1,
    convRule: rule23
  }, {
    start: 1202,
    length: 1,
    convRule: rule22
  }, {
    start: 1203,
    length: 1,
    convRule: rule23
  }, {
    start: 1204,
    length: 1,
    convRule: rule22
  }, {
    start: 1205,
    length: 1,
    convRule: rule23
  }, {
    start: 1206,
    length: 1,
    convRule: rule22
  }, {
    start: 1207,
    length: 1,
    convRule: rule23
  }, {
    start: 1208,
    length: 1,
    convRule: rule22
  }, {
    start: 1209,
    length: 1,
    convRule: rule23
  }, {
    start: 1210,
    length: 1,
    convRule: rule22
  }, {
    start: 1211,
    length: 1,
    convRule: rule23
  }, {
    start: 1212,
    length: 1,
    convRule: rule22
  }, {
    start: 1213,
    length: 1,
    convRule: rule23
  }, {
    start: 1214,
    length: 1,
    convRule: rule22
  }, {
    start: 1215,
    length: 1,
    convRule: rule23
  }, {
    start: 1216,
    length: 1,
    convRule: rule120
  }, {
    start: 1217,
    length: 1,
    convRule: rule22
  }, {
    start: 1218,
    length: 1,
    convRule: rule23
  }, {
    start: 1219,
    length: 1,
    convRule: rule22
  }, {
    start: 1220,
    length: 1,
    convRule: rule23
  }, {
    start: 1221,
    length: 1,
    convRule: rule22
  }, {
    start: 1222,
    length: 1,
    convRule: rule23
  }, {
    start: 1223,
    length: 1,
    convRule: rule22
  }, {
    start: 1224,
    length: 1,
    convRule: rule23
  }, {
    start: 1225,
    length: 1,
    convRule: rule22
  }, {
    start: 1226,
    length: 1,
    convRule: rule23
  }, {
    start: 1227,
    length: 1,
    convRule: rule22
  }, {
    start: 1228,
    length: 1,
    convRule: rule23
  }, {
    start: 1229,
    length: 1,
    convRule: rule22
  }, {
    start: 1230,
    length: 1,
    convRule: rule23
  }, {
    start: 1231,
    length: 1,
    convRule: rule121
  }, {
    start: 1232,
    length: 1,
    convRule: rule22
  }, {
    start: 1233,
    length: 1,
    convRule: rule23
  }, {
    start: 1234,
    length: 1,
    convRule: rule22
  }, {
    start: 1235,
    length: 1,
    convRule: rule23
  }, {
    start: 1236,
    length: 1,
    convRule: rule22
  }, {
    start: 1237,
    length: 1,
    convRule: rule23
  }, {
    start: 1238,
    length: 1,
    convRule: rule22
  }, {
    start: 1239,
    length: 1,
    convRule: rule23
  }, {
    start: 1240,
    length: 1,
    convRule: rule22
  }, {
    start: 1241,
    length: 1,
    convRule: rule23
  }, {
    start: 1242,
    length: 1,
    convRule: rule22
  }, {
    start: 1243,
    length: 1,
    convRule: rule23
  }, {
    start: 1244,
    length: 1,
    convRule: rule22
  }, {
    start: 1245,
    length: 1,
    convRule: rule23
  }, {
    start: 1246,
    length: 1,
    convRule: rule22
  }, {
    start: 1247,
    length: 1,
    convRule: rule23
  }, {
    start: 1248,
    length: 1,
    convRule: rule22
  }, {
    start: 1249,
    length: 1,
    convRule: rule23
  }, {
    start: 1250,
    length: 1,
    convRule: rule22
  }, {
    start: 1251,
    length: 1,
    convRule: rule23
  }, {
    start: 1252,
    length: 1,
    convRule: rule22
  }, {
    start: 1253,
    length: 1,
    convRule: rule23
  }, {
    start: 1254,
    length: 1,
    convRule: rule22
  }, {
    start: 1255,
    length: 1,
    convRule: rule23
  }, {
    start: 1256,
    length: 1,
    convRule: rule22
  }, {
    start: 1257,
    length: 1,
    convRule: rule23
  }, {
    start: 1258,
    length: 1,
    convRule: rule22
  }, {
    start: 1259,
    length: 1,
    convRule: rule23
  }, {
    start: 1260,
    length: 1,
    convRule: rule22
  }, {
    start: 1261,
    length: 1,
    convRule: rule23
  }, {
    start: 1262,
    length: 1,
    convRule: rule22
  }, {
    start: 1263,
    length: 1,
    convRule: rule23
  }, {
    start: 1264,
    length: 1,
    convRule: rule22
  }, {
    start: 1265,
    length: 1,
    convRule: rule23
  }, {
    start: 1266,
    length: 1,
    convRule: rule22
  }, {
    start: 1267,
    length: 1,
    convRule: rule23
  }, {
    start: 1268,
    length: 1,
    convRule: rule22
  }, {
    start: 1269,
    length: 1,
    convRule: rule23
  }, {
    start: 1270,
    length: 1,
    convRule: rule22
  }, {
    start: 1271,
    length: 1,
    convRule: rule23
  }, {
    start: 1272,
    length: 1,
    convRule: rule22
  }, {
    start: 1273,
    length: 1,
    convRule: rule23
  }, {
    start: 1274,
    length: 1,
    convRule: rule22
  }, {
    start: 1275,
    length: 1,
    convRule: rule23
  }, {
    start: 1276,
    length: 1,
    convRule: rule22
  }, {
    start: 1277,
    length: 1,
    convRule: rule23
  }, {
    start: 1278,
    length: 1,
    convRule: rule22
  }, {
    start: 1279,
    length: 1,
    convRule: rule23
  }, {
    start: 1280,
    length: 1,
    convRule: rule22
  }, {
    start: 1281,
    length: 1,
    convRule: rule23
  }, {
    start: 1282,
    length: 1,
    convRule: rule22
  }, {
    start: 1283,
    length: 1,
    convRule: rule23
  }, {
    start: 1284,
    length: 1,
    convRule: rule22
  }, {
    start: 1285,
    length: 1,
    convRule: rule23
  }, {
    start: 1286,
    length: 1,
    convRule: rule22
  }, {
    start: 1287,
    length: 1,
    convRule: rule23
  }, {
    start: 1288,
    length: 1,
    convRule: rule22
  }, {
    start: 1289,
    length: 1,
    convRule: rule23
  }, {
    start: 1290,
    length: 1,
    convRule: rule22
  }, {
    start: 1291,
    length: 1,
    convRule: rule23
  }, {
    start: 1292,
    length: 1,
    convRule: rule22
  }, {
    start: 1293,
    length: 1,
    convRule: rule23
  }, {
    start: 1294,
    length: 1,
    convRule: rule22
  }, {
    start: 1295,
    length: 1,
    convRule: rule23
  }, {
    start: 1296,
    length: 1,
    convRule: rule22
  }, {
    start: 1297,
    length: 1,
    convRule: rule23
  }, {
    start: 1298,
    length: 1,
    convRule: rule22
  }, {
    start: 1299,
    length: 1,
    convRule: rule23
  }, {
    start: 1300,
    length: 1,
    convRule: rule22
  }, {
    start: 1301,
    length: 1,
    convRule: rule23
  }, {
    start: 1302,
    length: 1,
    convRule: rule22
  }, {
    start: 1303,
    length: 1,
    convRule: rule23
  }, {
    start: 1304,
    length: 1,
    convRule: rule22
  }, {
    start: 1305,
    length: 1,
    convRule: rule23
  }, {
    start: 1306,
    length: 1,
    convRule: rule22
  }, {
    start: 1307,
    length: 1,
    convRule: rule23
  }, {
    start: 1308,
    length: 1,
    convRule: rule22
  }, {
    start: 1309,
    length: 1,
    convRule: rule23
  }, {
    start: 1310,
    length: 1,
    convRule: rule22
  }, {
    start: 1311,
    length: 1,
    convRule: rule23
  }, {
    start: 1312,
    length: 1,
    convRule: rule22
  }, {
    start: 1313,
    length: 1,
    convRule: rule23
  }, {
    start: 1314,
    length: 1,
    convRule: rule22
  }, {
    start: 1315,
    length: 1,
    convRule: rule23
  }, {
    start: 1316,
    length: 1,
    convRule: rule22
  }, {
    start: 1317,
    length: 1,
    convRule: rule23
  }, {
    start: 1318,
    length: 1,
    convRule: rule22
  }, {
    start: 1319,
    length: 1,
    convRule: rule23
  }, {
    start: 1320,
    length: 1,
    convRule: rule22
  }, {
    start: 1321,
    length: 1,
    convRule: rule23
  }, {
    start: 1322,
    length: 1,
    convRule: rule22
  }, {
    start: 1323,
    length: 1,
    convRule: rule23
  }, {
    start: 1324,
    length: 1,
    convRule: rule22
  }, {
    start: 1325,
    length: 1,
    convRule: rule23
  }, {
    start: 1326,
    length: 1,
    convRule: rule22
  }, {
    start: 1327,
    length: 1,
    convRule: rule23
  }, {
    start: 1329,
    length: 38,
    convRule: rule122
  }, {
    start: 1377,
    length: 38,
    convRule: rule123
  }, {
    start: 4256,
    length: 38,
    convRule: rule125
  }, {
    start: 4295,
    length: 1,
    convRule: rule125
  }, {
    start: 4301,
    length: 1,
    convRule: rule125
  }, {
    start: 4304,
    length: 43,
    convRule: rule126
  }, {
    start: 4349,
    length: 3,
    convRule: rule126
  }, {
    start: 5024,
    length: 80,
    convRule: rule127
  }, {
    start: 5104,
    length: 6,
    convRule: rule104
  }, {
    start: 5112,
    length: 6,
    convRule: rule110
  }, {
    start: 7296,
    length: 1,
    convRule: rule129
  }, {
    start: 7297,
    length: 1,
    convRule: rule130
  }, {
    start: 7298,
    length: 1,
    convRule: rule131
  }, {
    start: 7299,
    length: 2,
    convRule: rule132
  }, {
    start: 7301,
    length: 1,
    convRule: rule133
  }, {
    start: 7302,
    length: 1,
    convRule: rule134
  }, {
    start: 7303,
    length: 1,
    convRule: rule135
  }, {
    start: 7304,
    length: 1,
    convRule: rule136
  }, {
    start: 7312,
    length: 43,
    convRule: rule137
  }, {
    start: 7357,
    length: 3,
    convRule: rule137
  }, {
    start: 7545,
    length: 1,
    convRule: rule138
  }, {
    start: 7549,
    length: 1,
    convRule: rule139
  }, {
    start: 7566,
    length: 1,
    convRule: rule140
  }, {
    start: 7680,
    length: 1,
    convRule: rule22
  }, {
    start: 7681,
    length: 1,
    convRule: rule23
  }, {
    start: 7682,
    length: 1,
    convRule: rule22
  }, {
    start: 7683,
    length: 1,
    convRule: rule23
  }, {
    start: 7684,
    length: 1,
    convRule: rule22
  }, {
    start: 7685,
    length: 1,
    convRule: rule23
  }, {
    start: 7686,
    length: 1,
    convRule: rule22
  }, {
    start: 7687,
    length: 1,
    convRule: rule23
  }, {
    start: 7688,
    length: 1,
    convRule: rule22
  }, {
    start: 7689,
    length: 1,
    convRule: rule23
  }, {
    start: 7690,
    length: 1,
    convRule: rule22
  }, {
    start: 7691,
    length: 1,
    convRule: rule23
  }, {
    start: 7692,
    length: 1,
    convRule: rule22
  }, {
    start: 7693,
    length: 1,
    convRule: rule23
  }, {
    start: 7694,
    length: 1,
    convRule: rule22
  }, {
    start: 7695,
    length: 1,
    convRule: rule23
  }, {
    start: 7696,
    length: 1,
    convRule: rule22
  }, {
    start: 7697,
    length: 1,
    convRule: rule23
  }, {
    start: 7698,
    length: 1,
    convRule: rule22
  }, {
    start: 7699,
    length: 1,
    convRule: rule23
  }, {
    start: 7700,
    length: 1,
    convRule: rule22
  }, {
    start: 7701,
    length: 1,
    convRule: rule23
  }, {
    start: 7702,
    length: 1,
    convRule: rule22
  }, {
    start: 7703,
    length: 1,
    convRule: rule23
  }, {
    start: 7704,
    length: 1,
    convRule: rule22
  }, {
    start: 7705,
    length: 1,
    convRule: rule23
  }, {
    start: 7706,
    length: 1,
    convRule: rule22
  }, {
    start: 7707,
    length: 1,
    convRule: rule23
  }, {
    start: 7708,
    length: 1,
    convRule: rule22
  }, {
    start: 7709,
    length: 1,
    convRule: rule23
  }, {
    start: 7710,
    length: 1,
    convRule: rule22
  }, {
    start: 7711,
    length: 1,
    convRule: rule23
  }, {
    start: 7712,
    length: 1,
    convRule: rule22
  }, {
    start: 7713,
    length: 1,
    convRule: rule23
  }, {
    start: 7714,
    length: 1,
    convRule: rule22
  }, {
    start: 7715,
    length: 1,
    convRule: rule23
  }, {
    start: 7716,
    length: 1,
    convRule: rule22
  }, {
    start: 7717,
    length: 1,
    convRule: rule23
  }, {
    start: 7718,
    length: 1,
    convRule: rule22
  }, {
    start: 7719,
    length: 1,
    convRule: rule23
  }, {
    start: 7720,
    length: 1,
    convRule: rule22
  }, {
    start: 7721,
    length: 1,
    convRule: rule23
  }, {
    start: 7722,
    length: 1,
    convRule: rule22
  }, {
    start: 7723,
    length: 1,
    convRule: rule23
  }, {
    start: 7724,
    length: 1,
    convRule: rule22
  }, {
    start: 7725,
    length: 1,
    convRule: rule23
  }, {
    start: 7726,
    length: 1,
    convRule: rule22
  }, {
    start: 7727,
    length: 1,
    convRule: rule23
  }, {
    start: 7728,
    length: 1,
    convRule: rule22
  }, {
    start: 7729,
    length: 1,
    convRule: rule23
  }, {
    start: 7730,
    length: 1,
    convRule: rule22
  }, {
    start: 7731,
    length: 1,
    convRule: rule23
  }, {
    start: 7732,
    length: 1,
    convRule: rule22
  }, {
    start: 7733,
    length: 1,
    convRule: rule23
  }, {
    start: 7734,
    length: 1,
    convRule: rule22
  }, {
    start: 7735,
    length: 1,
    convRule: rule23
  }, {
    start: 7736,
    length: 1,
    convRule: rule22
  }, {
    start: 7737,
    length: 1,
    convRule: rule23
  }, {
    start: 7738,
    length: 1,
    convRule: rule22
  }, {
    start: 7739,
    length: 1,
    convRule: rule23
  }, {
    start: 7740,
    length: 1,
    convRule: rule22
  }, {
    start: 7741,
    length: 1,
    convRule: rule23
  }, {
    start: 7742,
    length: 1,
    convRule: rule22
  }, {
    start: 7743,
    length: 1,
    convRule: rule23
  }, {
    start: 7744,
    length: 1,
    convRule: rule22
  }, {
    start: 7745,
    length: 1,
    convRule: rule23
  }, {
    start: 7746,
    length: 1,
    convRule: rule22
  }, {
    start: 7747,
    length: 1,
    convRule: rule23
  }, {
    start: 7748,
    length: 1,
    convRule: rule22
  }, {
    start: 7749,
    length: 1,
    convRule: rule23
  }, {
    start: 7750,
    length: 1,
    convRule: rule22
  }, {
    start: 7751,
    length: 1,
    convRule: rule23
  }, {
    start: 7752,
    length: 1,
    convRule: rule22
  }, {
    start: 7753,
    length: 1,
    convRule: rule23
  }, {
    start: 7754,
    length: 1,
    convRule: rule22
  }, {
    start: 7755,
    length: 1,
    convRule: rule23
  }, {
    start: 7756,
    length: 1,
    convRule: rule22
  }, {
    start: 7757,
    length: 1,
    convRule: rule23
  }, {
    start: 7758,
    length: 1,
    convRule: rule22
  }, {
    start: 7759,
    length: 1,
    convRule: rule23
  }, {
    start: 7760,
    length: 1,
    convRule: rule22
  }, {
    start: 7761,
    length: 1,
    convRule: rule23
  }, {
    start: 7762,
    length: 1,
    convRule: rule22
  }, {
    start: 7763,
    length: 1,
    convRule: rule23
  }, {
    start: 7764,
    length: 1,
    convRule: rule22
  }, {
    start: 7765,
    length: 1,
    convRule: rule23
  }, {
    start: 7766,
    length: 1,
    convRule: rule22
  }, {
    start: 7767,
    length: 1,
    convRule: rule23
  }, {
    start: 7768,
    length: 1,
    convRule: rule22
  }, {
    start: 7769,
    length: 1,
    convRule: rule23
  }, {
    start: 7770,
    length: 1,
    convRule: rule22
  }, {
    start: 7771,
    length: 1,
    convRule: rule23
  }, {
    start: 7772,
    length: 1,
    convRule: rule22
  }, {
    start: 7773,
    length: 1,
    convRule: rule23
  }, {
    start: 7774,
    length: 1,
    convRule: rule22
  }, {
    start: 7775,
    length: 1,
    convRule: rule23
  }, {
    start: 7776,
    length: 1,
    convRule: rule22
  }, {
    start: 7777,
    length: 1,
    convRule: rule23
  }, {
    start: 7778,
    length: 1,
    convRule: rule22
  }, {
    start: 7779,
    length: 1,
    convRule: rule23
  }, {
    start: 7780,
    length: 1,
    convRule: rule22
  }, {
    start: 7781,
    length: 1,
    convRule: rule23
  }, {
    start: 7782,
    length: 1,
    convRule: rule22
  }, {
    start: 7783,
    length: 1,
    convRule: rule23
  }, {
    start: 7784,
    length: 1,
    convRule: rule22
  }, {
    start: 7785,
    length: 1,
    convRule: rule23
  }, {
    start: 7786,
    length: 1,
    convRule: rule22
  }, {
    start: 7787,
    length: 1,
    convRule: rule23
  }, {
    start: 7788,
    length: 1,
    convRule: rule22
  }, {
    start: 7789,
    length: 1,
    convRule: rule23
  }, {
    start: 7790,
    length: 1,
    convRule: rule22
  }, {
    start: 7791,
    length: 1,
    convRule: rule23
  }, {
    start: 7792,
    length: 1,
    convRule: rule22
  }, {
    start: 7793,
    length: 1,
    convRule: rule23
  }, {
    start: 7794,
    length: 1,
    convRule: rule22
  }, {
    start: 7795,
    length: 1,
    convRule: rule23
  }, {
    start: 7796,
    length: 1,
    convRule: rule22
  }, {
    start: 7797,
    length: 1,
    convRule: rule23
  }, {
    start: 7798,
    length: 1,
    convRule: rule22
  }, {
    start: 7799,
    length: 1,
    convRule: rule23
  }, {
    start: 7800,
    length: 1,
    convRule: rule22
  }, {
    start: 7801,
    length: 1,
    convRule: rule23
  }, {
    start: 7802,
    length: 1,
    convRule: rule22
  }, {
    start: 7803,
    length: 1,
    convRule: rule23
  }, {
    start: 7804,
    length: 1,
    convRule: rule22
  }, {
    start: 7805,
    length: 1,
    convRule: rule23
  }, {
    start: 7806,
    length: 1,
    convRule: rule22
  }, {
    start: 7807,
    length: 1,
    convRule: rule23
  }, {
    start: 7808,
    length: 1,
    convRule: rule22
  }, {
    start: 7809,
    length: 1,
    convRule: rule23
  }, {
    start: 7810,
    length: 1,
    convRule: rule22
  }, {
    start: 7811,
    length: 1,
    convRule: rule23
  }, {
    start: 7812,
    length: 1,
    convRule: rule22
  }, {
    start: 7813,
    length: 1,
    convRule: rule23
  }, {
    start: 7814,
    length: 1,
    convRule: rule22
  }, {
    start: 7815,
    length: 1,
    convRule: rule23
  }, {
    start: 7816,
    length: 1,
    convRule: rule22
  }, {
    start: 7817,
    length: 1,
    convRule: rule23
  }, {
    start: 7818,
    length: 1,
    convRule: rule22
  }, {
    start: 7819,
    length: 1,
    convRule: rule23
  }, {
    start: 7820,
    length: 1,
    convRule: rule22
  }, {
    start: 7821,
    length: 1,
    convRule: rule23
  }, {
    start: 7822,
    length: 1,
    convRule: rule22
  }, {
    start: 7823,
    length: 1,
    convRule: rule23
  }, {
    start: 7824,
    length: 1,
    convRule: rule22
  }, {
    start: 7825,
    length: 1,
    convRule: rule23
  }, {
    start: 7826,
    length: 1,
    convRule: rule22
  }, {
    start: 7827,
    length: 1,
    convRule: rule23
  }, {
    start: 7828,
    length: 1,
    convRule: rule22
  }, {
    start: 7829,
    length: 1,
    convRule: rule23
  }, {
    start: 7835,
    length: 1,
    convRule: rule141
  }, {
    start: 7838,
    length: 1,
    convRule: rule142
  }, {
    start: 7840,
    length: 1,
    convRule: rule22
  }, {
    start: 7841,
    length: 1,
    convRule: rule23
  }, {
    start: 7842,
    length: 1,
    convRule: rule22
  }, {
    start: 7843,
    length: 1,
    convRule: rule23
  }, {
    start: 7844,
    length: 1,
    convRule: rule22
  }, {
    start: 7845,
    length: 1,
    convRule: rule23
  }, {
    start: 7846,
    length: 1,
    convRule: rule22
  }, {
    start: 7847,
    length: 1,
    convRule: rule23
  }, {
    start: 7848,
    length: 1,
    convRule: rule22
  }, {
    start: 7849,
    length: 1,
    convRule: rule23
  }, {
    start: 7850,
    length: 1,
    convRule: rule22
  }, {
    start: 7851,
    length: 1,
    convRule: rule23
  }, {
    start: 7852,
    length: 1,
    convRule: rule22
  }, {
    start: 7853,
    length: 1,
    convRule: rule23
  }, {
    start: 7854,
    length: 1,
    convRule: rule22
  }, {
    start: 7855,
    length: 1,
    convRule: rule23
  }, {
    start: 7856,
    length: 1,
    convRule: rule22
  }, {
    start: 7857,
    length: 1,
    convRule: rule23
  }, {
    start: 7858,
    length: 1,
    convRule: rule22
  }, {
    start: 7859,
    length: 1,
    convRule: rule23
  }, {
    start: 7860,
    length: 1,
    convRule: rule22
  }, {
    start: 7861,
    length: 1,
    convRule: rule23
  }, {
    start: 7862,
    length: 1,
    convRule: rule22
  }, {
    start: 7863,
    length: 1,
    convRule: rule23
  }, {
    start: 7864,
    length: 1,
    convRule: rule22
  }, {
    start: 7865,
    length: 1,
    convRule: rule23
  }, {
    start: 7866,
    length: 1,
    convRule: rule22
  }, {
    start: 7867,
    length: 1,
    convRule: rule23
  }, {
    start: 7868,
    length: 1,
    convRule: rule22
  }, {
    start: 7869,
    length: 1,
    convRule: rule23
  }, {
    start: 7870,
    length: 1,
    convRule: rule22
  }, {
    start: 7871,
    length: 1,
    convRule: rule23
  }, {
    start: 7872,
    length: 1,
    convRule: rule22
  }, {
    start: 7873,
    length: 1,
    convRule: rule23
  }, {
    start: 7874,
    length: 1,
    convRule: rule22
  }, {
    start: 7875,
    length: 1,
    convRule: rule23
  }, {
    start: 7876,
    length: 1,
    convRule: rule22
  }, {
    start: 7877,
    length: 1,
    convRule: rule23
  }, {
    start: 7878,
    length: 1,
    convRule: rule22
  }, {
    start: 7879,
    length: 1,
    convRule: rule23
  }, {
    start: 7880,
    length: 1,
    convRule: rule22
  }, {
    start: 7881,
    length: 1,
    convRule: rule23
  }, {
    start: 7882,
    length: 1,
    convRule: rule22
  }, {
    start: 7883,
    length: 1,
    convRule: rule23
  }, {
    start: 7884,
    length: 1,
    convRule: rule22
  }, {
    start: 7885,
    length: 1,
    convRule: rule23
  }, {
    start: 7886,
    length: 1,
    convRule: rule22
  }, {
    start: 7887,
    length: 1,
    convRule: rule23
  }, {
    start: 7888,
    length: 1,
    convRule: rule22
  }, {
    start: 7889,
    length: 1,
    convRule: rule23
  }, {
    start: 7890,
    length: 1,
    convRule: rule22
  }, {
    start: 7891,
    length: 1,
    convRule: rule23
  }, {
    start: 7892,
    length: 1,
    convRule: rule22
  }, {
    start: 7893,
    length: 1,
    convRule: rule23
  }, {
    start: 7894,
    length: 1,
    convRule: rule22
  }, {
    start: 7895,
    length: 1,
    convRule: rule23
  }, {
    start: 7896,
    length: 1,
    convRule: rule22
  }, {
    start: 7897,
    length: 1,
    convRule: rule23
  }, {
    start: 7898,
    length: 1,
    convRule: rule22
  }, {
    start: 7899,
    length: 1,
    convRule: rule23
  }, {
    start: 7900,
    length: 1,
    convRule: rule22
  }, {
    start: 7901,
    length: 1,
    convRule: rule23
  }, {
    start: 7902,
    length: 1,
    convRule: rule22
  }, {
    start: 7903,
    length: 1,
    convRule: rule23
  }, {
    start: 7904,
    length: 1,
    convRule: rule22
  }, {
    start: 7905,
    length: 1,
    convRule: rule23
  }, {
    start: 7906,
    length: 1,
    convRule: rule22
  }, {
    start: 7907,
    length: 1,
    convRule: rule23
  }, {
    start: 7908,
    length: 1,
    convRule: rule22
  }, {
    start: 7909,
    length: 1,
    convRule: rule23
  }, {
    start: 7910,
    length: 1,
    convRule: rule22
  }, {
    start: 7911,
    length: 1,
    convRule: rule23
  }, {
    start: 7912,
    length: 1,
    convRule: rule22
  }, {
    start: 7913,
    length: 1,
    convRule: rule23
  }, {
    start: 7914,
    length: 1,
    convRule: rule22
  }, {
    start: 7915,
    length: 1,
    convRule: rule23
  }, {
    start: 7916,
    length: 1,
    convRule: rule22
  }, {
    start: 7917,
    length: 1,
    convRule: rule23
  }, {
    start: 7918,
    length: 1,
    convRule: rule22
  }, {
    start: 7919,
    length: 1,
    convRule: rule23
  }, {
    start: 7920,
    length: 1,
    convRule: rule22
  }, {
    start: 7921,
    length: 1,
    convRule: rule23
  }, {
    start: 7922,
    length: 1,
    convRule: rule22
  }, {
    start: 7923,
    length: 1,
    convRule: rule23
  }, {
    start: 7924,
    length: 1,
    convRule: rule22
  }, {
    start: 7925,
    length: 1,
    convRule: rule23
  }, {
    start: 7926,
    length: 1,
    convRule: rule22
  }, {
    start: 7927,
    length: 1,
    convRule: rule23
  }, {
    start: 7928,
    length: 1,
    convRule: rule22
  }, {
    start: 7929,
    length: 1,
    convRule: rule23
  }, {
    start: 7930,
    length: 1,
    convRule: rule22
  }, {
    start: 7931,
    length: 1,
    convRule: rule23
  }, {
    start: 7932,
    length: 1,
    convRule: rule22
  }, {
    start: 7933,
    length: 1,
    convRule: rule23
  }, {
    start: 7934,
    length: 1,
    convRule: rule22
  }, {
    start: 7935,
    length: 1,
    convRule: rule23
  }, {
    start: 7936,
    length: 8,
    convRule: rule143
  }, {
    start: 7944,
    length: 8,
    convRule: rule144
  }, {
    start: 7952,
    length: 6,
    convRule: rule143
  }, {
    start: 7960,
    length: 6,
    convRule: rule144
  }, {
    start: 7968,
    length: 8,
    convRule: rule143
  }, {
    start: 7976,
    length: 8,
    convRule: rule144
  }, {
    start: 7984,
    length: 8,
    convRule: rule143
  }, {
    start: 7992,
    length: 8,
    convRule: rule144
  }, {
    start: 8e3,
    length: 6,
    convRule: rule143
  }, {
    start: 8008,
    length: 6,
    convRule: rule144
  }, {
    start: 8017,
    length: 1,
    convRule: rule143
  }, {
    start: 8019,
    length: 1,
    convRule: rule143
  }, {
    start: 8021,
    length: 1,
    convRule: rule143
  }, {
    start: 8023,
    length: 1,
    convRule: rule143
  }, {
    start: 8025,
    length: 1,
    convRule: rule144
  }, {
    start: 8027,
    length: 1,
    convRule: rule144
  }, {
    start: 8029,
    length: 1,
    convRule: rule144
  }, {
    start: 8031,
    length: 1,
    convRule: rule144
  }, {
    start: 8032,
    length: 8,
    convRule: rule143
  }, {
    start: 8040,
    length: 8,
    convRule: rule144
  }, {
    start: 8048,
    length: 2,
    convRule: rule145
  }, {
    start: 8050,
    length: 4,
    convRule: rule146
  }, {
    start: 8054,
    length: 2,
    convRule: rule147
  }, {
    start: 8056,
    length: 2,
    convRule: rule148
  }, {
    start: 8058,
    length: 2,
    convRule: rule149
  }, {
    start: 8060,
    length: 2,
    convRule: rule150
  }, {
    start: 8064,
    length: 8,
    convRule: rule143
  }, {
    start: 8072,
    length: 8,
    convRule: rule151
  }, {
    start: 8080,
    length: 8,
    convRule: rule143
  }, {
    start: 8088,
    length: 8,
    convRule: rule151
  }, {
    start: 8096,
    length: 8,
    convRule: rule143
  }, {
    start: 8104,
    length: 8,
    convRule: rule151
  }, {
    start: 8112,
    length: 2,
    convRule: rule143
  }, {
    start: 8115,
    length: 1,
    convRule: rule152
  }, {
    start: 8120,
    length: 2,
    convRule: rule144
  }, {
    start: 8122,
    length: 2,
    convRule: rule153
  }, {
    start: 8124,
    length: 1,
    convRule: rule154
  }, {
    start: 8126,
    length: 1,
    convRule: rule155
  }, {
    start: 8131,
    length: 1,
    convRule: rule152
  }, {
    start: 8136,
    length: 4,
    convRule: rule156
  }, {
    start: 8140,
    length: 1,
    convRule: rule154
  }, {
    start: 8144,
    length: 2,
    convRule: rule143
  }, {
    start: 8152,
    length: 2,
    convRule: rule144
  }, {
    start: 8154,
    length: 2,
    convRule: rule157
  }, {
    start: 8160,
    length: 2,
    convRule: rule143
  }, {
    start: 8165,
    length: 1,
    convRule: rule113
  }, {
    start: 8168,
    length: 2,
    convRule: rule144
  }, {
    start: 8170,
    length: 2,
    convRule: rule158
  }, {
    start: 8172,
    length: 1,
    convRule: rule117
  }, {
    start: 8179,
    length: 1,
    convRule: rule152
  }, {
    start: 8184,
    length: 2,
    convRule: rule159
  }, {
    start: 8186,
    length: 2,
    convRule: rule160
  }, {
    start: 8188,
    length: 1,
    convRule: rule154
  }, {
    start: 8486,
    length: 1,
    convRule: rule163
  }, {
    start: 8490,
    length: 1,
    convRule: rule164
  }, {
    start: 8491,
    length: 1,
    convRule: rule165
  }, {
    start: 8498,
    length: 1,
    convRule: rule166
  }, {
    start: 8526,
    length: 1,
    convRule: rule167
  }, {
    start: 8544,
    length: 16,
    convRule: rule168
  }, {
    start: 8560,
    length: 16,
    convRule: rule169
  }, {
    start: 8579,
    length: 1,
    convRule: rule22
  }, {
    start: 8580,
    length: 1,
    convRule: rule23
  }, {
    start: 9398,
    length: 26,
    convRule: rule170
  }, {
    start: 9424,
    length: 26,
    convRule: rule171
  }, {
    start: 11264,
    length: 47,
    convRule: rule122
  }, {
    start: 11312,
    length: 47,
    convRule: rule123
  }, {
    start: 11360,
    length: 1,
    convRule: rule22
  }, {
    start: 11361,
    length: 1,
    convRule: rule23
  }, {
    start: 11362,
    length: 1,
    convRule: rule172
  }, {
    start: 11363,
    length: 1,
    convRule: rule173
  }, {
    start: 11364,
    length: 1,
    convRule: rule174
  }, {
    start: 11365,
    length: 1,
    convRule: rule175
  }, {
    start: 11366,
    length: 1,
    convRule: rule176
  }, {
    start: 11367,
    length: 1,
    convRule: rule22
  }, {
    start: 11368,
    length: 1,
    convRule: rule23
  }, {
    start: 11369,
    length: 1,
    convRule: rule22
  }, {
    start: 11370,
    length: 1,
    convRule: rule23
  }, {
    start: 11371,
    length: 1,
    convRule: rule22
  }, {
    start: 11372,
    length: 1,
    convRule: rule23
  }, {
    start: 11373,
    length: 1,
    convRule: rule177
  }, {
    start: 11374,
    length: 1,
    convRule: rule178
  }, {
    start: 11375,
    length: 1,
    convRule: rule179
  }, {
    start: 11376,
    length: 1,
    convRule: rule180
  }, {
    start: 11378,
    length: 1,
    convRule: rule22
  }, {
    start: 11379,
    length: 1,
    convRule: rule23
  }, {
    start: 11381,
    length: 1,
    convRule: rule22
  }, {
    start: 11382,
    length: 1,
    convRule: rule23
  }, {
    start: 11390,
    length: 2,
    convRule: rule181
  }, {
    start: 11392,
    length: 1,
    convRule: rule22
  }, {
    start: 11393,
    length: 1,
    convRule: rule23
  }, {
    start: 11394,
    length: 1,
    convRule: rule22
  }, {
    start: 11395,
    length: 1,
    convRule: rule23
  }, {
    start: 11396,
    length: 1,
    convRule: rule22
  }, {
    start: 11397,
    length: 1,
    convRule: rule23
  }, {
    start: 11398,
    length: 1,
    convRule: rule22
  }, {
    start: 11399,
    length: 1,
    convRule: rule23
  }, {
    start: 11400,
    length: 1,
    convRule: rule22
  }, {
    start: 11401,
    length: 1,
    convRule: rule23
  }, {
    start: 11402,
    length: 1,
    convRule: rule22
  }, {
    start: 11403,
    length: 1,
    convRule: rule23
  }, {
    start: 11404,
    length: 1,
    convRule: rule22
  }, {
    start: 11405,
    length: 1,
    convRule: rule23
  }, {
    start: 11406,
    length: 1,
    convRule: rule22
  }, {
    start: 11407,
    length: 1,
    convRule: rule23
  }, {
    start: 11408,
    length: 1,
    convRule: rule22
  }, {
    start: 11409,
    length: 1,
    convRule: rule23
  }, {
    start: 11410,
    length: 1,
    convRule: rule22
  }, {
    start: 11411,
    length: 1,
    convRule: rule23
  }, {
    start: 11412,
    length: 1,
    convRule: rule22
  }, {
    start: 11413,
    length: 1,
    convRule: rule23
  }, {
    start: 11414,
    length: 1,
    convRule: rule22
  }, {
    start: 11415,
    length: 1,
    convRule: rule23
  }, {
    start: 11416,
    length: 1,
    convRule: rule22
  }, {
    start: 11417,
    length: 1,
    convRule: rule23
  }, {
    start: 11418,
    length: 1,
    convRule: rule22
  }, {
    start: 11419,
    length: 1,
    convRule: rule23
  }, {
    start: 11420,
    length: 1,
    convRule: rule22
  }, {
    start: 11421,
    length: 1,
    convRule: rule23
  }, {
    start: 11422,
    length: 1,
    convRule: rule22
  }, {
    start: 11423,
    length: 1,
    convRule: rule23
  }, {
    start: 11424,
    length: 1,
    convRule: rule22
  }, {
    start: 11425,
    length: 1,
    convRule: rule23
  }, {
    start: 11426,
    length: 1,
    convRule: rule22
  }, {
    start: 11427,
    length: 1,
    convRule: rule23
  }, {
    start: 11428,
    length: 1,
    convRule: rule22
  }, {
    start: 11429,
    length: 1,
    convRule: rule23
  }, {
    start: 11430,
    length: 1,
    convRule: rule22
  }, {
    start: 11431,
    length: 1,
    convRule: rule23
  }, {
    start: 11432,
    length: 1,
    convRule: rule22
  }, {
    start: 11433,
    length: 1,
    convRule: rule23
  }, {
    start: 11434,
    length: 1,
    convRule: rule22
  }, {
    start: 11435,
    length: 1,
    convRule: rule23
  }, {
    start: 11436,
    length: 1,
    convRule: rule22
  }, {
    start: 11437,
    length: 1,
    convRule: rule23
  }, {
    start: 11438,
    length: 1,
    convRule: rule22
  }, {
    start: 11439,
    length: 1,
    convRule: rule23
  }, {
    start: 11440,
    length: 1,
    convRule: rule22
  }, {
    start: 11441,
    length: 1,
    convRule: rule23
  }, {
    start: 11442,
    length: 1,
    convRule: rule22
  }, {
    start: 11443,
    length: 1,
    convRule: rule23
  }, {
    start: 11444,
    length: 1,
    convRule: rule22
  }, {
    start: 11445,
    length: 1,
    convRule: rule23
  }, {
    start: 11446,
    length: 1,
    convRule: rule22
  }, {
    start: 11447,
    length: 1,
    convRule: rule23
  }, {
    start: 11448,
    length: 1,
    convRule: rule22
  }, {
    start: 11449,
    length: 1,
    convRule: rule23
  }, {
    start: 11450,
    length: 1,
    convRule: rule22
  }, {
    start: 11451,
    length: 1,
    convRule: rule23
  }, {
    start: 11452,
    length: 1,
    convRule: rule22
  }, {
    start: 11453,
    length: 1,
    convRule: rule23
  }, {
    start: 11454,
    length: 1,
    convRule: rule22
  }, {
    start: 11455,
    length: 1,
    convRule: rule23
  }, {
    start: 11456,
    length: 1,
    convRule: rule22
  }, {
    start: 11457,
    length: 1,
    convRule: rule23
  }, {
    start: 11458,
    length: 1,
    convRule: rule22
  }, {
    start: 11459,
    length: 1,
    convRule: rule23
  }, {
    start: 11460,
    length: 1,
    convRule: rule22
  }, {
    start: 11461,
    length: 1,
    convRule: rule23
  }, {
    start: 11462,
    length: 1,
    convRule: rule22
  }, {
    start: 11463,
    length: 1,
    convRule: rule23
  }, {
    start: 11464,
    length: 1,
    convRule: rule22
  }, {
    start: 11465,
    length: 1,
    convRule: rule23
  }, {
    start: 11466,
    length: 1,
    convRule: rule22
  }, {
    start: 11467,
    length: 1,
    convRule: rule23
  }, {
    start: 11468,
    length: 1,
    convRule: rule22
  }, {
    start: 11469,
    length: 1,
    convRule: rule23
  }, {
    start: 11470,
    length: 1,
    convRule: rule22
  }, {
    start: 11471,
    length: 1,
    convRule: rule23
  }, {
    start: 11472,
    length: 1,
    convRule: rule22
  }, {
    start: 11473,
    length: 1,
    convRule: rule23
  }, {
    start: 11474,
    length: 1,
    convRule: rule22
  }, {
    start: 11475,
    length: 1,
    convRule: rule23
  }, {
    start: 11476,
    length: 1,
    convRule: rule22
  }, {
    start: 11477,
    length: 1,
    convRule: rule23
  }, {
    start: 11478,
    length: 1,
    convRule: rule22
  }, {
    start: 11479,
    length: 1,
    convRule: rule23
  }, {
    start: 11480,
    length: 1,
    convRule: rule22
  }, {
    start: 11481,
    length: 1,
    convRule: rule23
  }, {
    start: 11482,
    length: 1,
    convRule: rule22
  }, {
    start: 11483,
    length: 1,
    convRule: rule23
  }, {
    start: 11484,
    length: 1,
    convRule: rule22
  }, {
    start: 11485,
    length: 1,
    convRule: rule23
  }, {
    start: 11486,
    length: 1,
    convRule: rule22
  }, {
    start: 11487,
    length: 1,
    convRule: rule23
  }, {
    start: 11488,
    length: 1,
    convRule: rule22
  }, {
    start: 11489,
    length: 1,
    convRule: rule23
  }, {
    start: 11490,
    length: 1,
    convRule: rule22
  }, {
    start: 11491,
    length: 1,
    convRule: rule23
  }, {
    start: 11499,
    length: 1,
    convRule: rule22
  }, {
    start: 11500,
    length: 1,
    convRule: rule23
  }, {
    start: 11501,
    length: 1,
    convRule: rule22
  }, {
    start: 11502,
    length: 1,
    convRule: rule23
  }, {
    start: 11506,
    length: 1,
    convRule: rule22
  }, {
    start: 11507,
    length: 1,
    convRule: rule23
  }, {
    start: 11520,
    length: 38,
    convRule: rule182
  }, {
    start: 11559,
    length: 1,
    convRule: rule182
  }, {
    start: 11565,
    length: 1,
    convRule: rule182
  }, {
    start: 42560,
    length: 1,
    convRule: rule22
  }, {
    start: 42561,
    length: 1,
    convRule: rule23
  }, {
    start: 42562,
    length: 1,
    convRule: rule22
  }, {
    start: 42563,
    length: 1,
    convRule: rule23
  }, {
    start: 42564,
    length: 1,
    convRule: rule22
  }, {
    start: 42565,
    length: 1,
    convRule: rule23
  }, {
    start: 42566,
    length: 1,
    convRule: rule22
  }, {
    start: 42567,
    length: 1,
    convRule: rule23
  }, {
    start: 42568,
    length: 1,
    convRule: rule22
  }, {
    start: 42569,
    length: 1,
    convRule: rule23
  }, {
    start: 42570,
    length: 1,
    convRule: rule22
  }, {
    start: 42571,
    length: 1,
    convRule: rule23
  }, {
    start: 42572,
    length: 1,
    convRule: rule22
  }, {
    start: 42573,
    length: 1,
    convRule: rule23
  }, {
    start: 42574,
    length: 1,
    convRule: rule22
  }, {
    start: 42575,
    length: 1,
    convRule: rule23
  }, {
    start: 42576,
    length: 1,
    convRule: rule22
  }, {
    start: 42577,
    length: 1,
    convRule: rule23
  }, {
    start: 42578,
    length: 1,
    convRule: rule22
  }, {
    start: 42579,
    length: 1,
    convRule: rule23
  }, {
    start: 42580,
    length: 1,
    convRule: rule22
  }, {
    start: 42581,
    length: 1,
    convRule: rule23
  }, {
    start: 42582,
    length: 1,
    convRule: rule22
  }, {
    start: 42583,
    length: 1,
    convRule: rule23
  }, {
    start: 42584,
    length: 1,
    convRule: rule22
  }, {
    start: 42585,
    length: 1,
    convRule: rule23
  }, {
    start: 42586,
    length: 1,
    convRule: rule22
  }, {
    start: 42587,
    length: 1,
    convRule: rule23
  }, {
    start: 42588,
    length: 1,
    convRule: rule22
  }, {
    start: 42589,
    length: 1,
    convRule: rule23
  }, {
    start: 42590,
    length: 1,
    convRule: rule22
  }, {
    start: 42591,
    length: 1,
    convRule: rule23
  }, {
    start: 42592,
    length: 1,
    convRule: rule22
  }, {
    start: 42593,
    length: 1,
    convRule: rule23
  }, {
    start: 42594,
    length: 1,
    convRule: rule22
  }, {
    start: 42595,
    length: 1,
    convRule: rule23
  }, {
    start: 42596,
    length: 1,
    convRule: rule22
  }, {
    start: 42597,
    length: 1,
    convRule: rule23
  }, {
    start: 42598,
    length: 1,
    convRule: rule22
  }, {
    start: 42599,
    length: 1,
    convRule: rule23
  }, {
    start: 42600,
    length: 1,
    convRule: rule22
  }, {
    start: 42601,
    length: 1,
    convRule: rule23
  }, {
    start: 42602,
    length: 1,
    convRule: rule22
  }, {
    start: 42603,
    length: 1,
    convRule: rule23
  }, {
    start: 42604,
    length: 1,
    convRule: rule22
  }, {
    start: 42605,
    length: 1,
    convRule: rule23
  }, {
    start: 42624,
    length: 1,
    convRule: rule22
  }, {
    start: 42625,
    length: 1,
    convRule: rule23
  }, {
    start: 42626,
    length: 1,
    convRule: rule22
  }, {
    start: 42627,
    length: 1,
    convRule: rule23
  }, {
    start: 42628,
    length: 1,
    convRule: rule22
  }, {
    start: 42629,
    length: 1,
    convRule: rule23
  }, {
    start: 42630,
    length: 1,
    convRule: rule22
  }, {
    start: 42631,
    length: 1,
    convRule: rule23
  }, {
    start: 42632,
    length: 1,
    convRule: rule22
  }, {
    start: 42633,
    length: 1,
    convRule: rule23
  }, {
    start: 42634,
    length: 1,
    convRule: rule22
  }, {
    start: 42635,
    length: 1,
    convRule: rule23
  }, {
    start: 42636,
    length: 1,
    convRule: rule22
  }, {
    start: 42637,
    length: 1,
    convRule: rule23
  }, {
    start: 42638,
    length: 1,
    convRule: rule22
  }, {
    start: 42639,
    length: 1,
    convRule: rule23
  }, {
    start: 42640,
    length: 1,
    convRule: rule22
  }, {
    start: 42641,
    length: 1,
    convRule: rule23
  }, {
    start: 42642,
    length: 1,
    convRule: rule22
  }, {
    start: 42643,
    length: 1,
    convRule: rule23
  }, {
    start: 42644,
    length: 1,
    convRule: rule22
  }, {
    start: 42645,
    length: 1,
    convRule: rule23
  }, {
    start: 42646,
    length: 1,
    convRule: rule22
  }, {
    start: 42647,
    length: 1,
    convRule: rule23
  }, {
    start: 42648,
    length: 1,
    convRule: rule22
  }, {
    start: 42649,
    length: 1,
    convRule: rule23
  }, {
    start: 42650,
    length: 1,
    convRule: rule22
  }, {
    start: 42651,
    length: 1,
    convRule: rule23
  }, {
    start: 42786,
    length: 1,
    convRule: rule22
  }, {
    start: 42787,
    length: 1,
    convRule: rule23
  }, {
    start: 42788,
    length: 1,
    convRule: rule22
  }, {
    start: 42789,
    length: 1,
    convRule: rule23
  }, {
    start: 42790,
    length: 1,
    convRule: rule22
  }, {
    start: 42791,
    length: 1,
    convRule: rule23
  }, {
    start: 42792,
    length: 1,
    convRule: rule22
  }, {
    start: 42793,
    length: 1,
    convRule: rule23
  }, {
    start: 42794,
    length: 1,
    convRule: rule22
  }, {
    start: 42795,
    length: 1,
    convRule: rule23
  }, {
    start: 42796,
    length: 1,
    convRule: rule22
  }, {
    start: 42797,
    length: 1,
    convRule: rule23
  }, {
    start: 42798,
    length: 1,
    convRule: rule22
  }, {
    start: 42799,
    length: 1,
    convRule: rule23
  }, {
    start: 42802,
    length: 1,
    convRule: rule22
  }, {
    start: 42803,
    length: 1,
    convRule: rule23
  }, {
    start: 42804,
    length: 1,
    convRule: rule22
  }, {
    start: 42805,
    length: 1,
    convRule: rule23
  }, {
    start: 42806,
    length: 1,
    convRule: rule22
  }, {
    start: 42807,
    length: 1,
    convRule: rule23
  }, {
    start: 42808,
    length: 1,
    convRule: rule22
  }, {
    start: 42809,
    length: 1,
    convRule: rule23
  }, {
    start: 42810,
    length: 1,
    convRule: rule22
  }, {
    start: 42811,
    length: 1,
    convRule: rule23
  }, {
    start: 42812,
    length: 1,
    convRule: rule22
  }, {
    start: 42813,
    length: 1,
    convRule: rule23
  }, {
    start: 42814,
    length: 1,
    convRule: rule22
  }, {
    start: 42815,
    length: 1,
    convRule: rule23
  }, {
    start: 42816,
    length: 1,
    convRule: rule22
  }, {
    start: 42817,
    length: 1,
    convRule: rule23
  }, {
    start: 42818,
    length: 1,
    convRule: rule22
  }, {
    start: 42819,
    length: 1,
    convRule: rule23
  }, {
    start: 42820,
    length: 1,
    convRule: rule22
  }, {
    start: 42821,
    length: 1,
    convRule: rule23
  }, {
    start: 42822,
    length: 1,
    convRule: rule22
  }, {
    start: 42823,
    length: 1,
    convRule: rule23
  }, {
    start: 42824,
    length: 1,
    convRule: rule22
  }, {
    start: 42825,
    length: 1,
    convRule: rule23
  }, {
    start: 42826,
    length: 1,
    convRule: rule22
  }, {
    start: 42827,
    length: 1,
    convRule: rule23
  }, {
    start: 42828,
    length: 1,
    convRule: rule22
  }, {
    start: 42829,
    length: 1,
    convRule: rule23
  }, {
    start: 42830,
    length: 1,
    convRule: rule22
  }, {
    start: 42831,
    length: 1,
    convRule: rule23
  }, {
    start: 42832,
    length: 1,
    convRule: rule22
  }, {
    start: 42833,
    length: 1,
    convRule: rule23
  }, {
    start: 42834,
    length: 1,
    convRule: rule22
  }, {
    start: 42835,
    length: 1,
    convRule: rule23
  }, {
    start: 42836,
    length: 1,
    convRule: rule22
  }, {
    start: 42837,
    length: 1,
    convRule: rule23
  }, {
    start: 42838,
    length: 1,
    convRule: rule22
  }, {
    start: 42839,
    length: 1,
    convRule: rule23
  }, {
    start: 42840,
    length: 1,
    convRule: rule22
  }, {
    start: 42841,
    length: 1,
    convRule: rule23
  }, {
    start: 42842,
    length: 1,
    convRule: rule22
  }, {
    start: 42843,
    length: 1,
    convRule: rule23
  }, {
    start: 42844,
    length: 1,
    convRule: rule22
  }, {
    start: 42845,
    length: 1,
    convRule: rule23
  }, {
    start: 42846,
    length: 1,
    convRule: rule22
  }, {
    start: 42847,
    length: 1,
    convRule: rule23
  }, {
    start: 42848,
    length: 1,
    convRule: rule22
  }, {
    start: 42849,
    length: 1,
    convRule: rule23
  }, {
    start: 42850,
    length: 1,
    convRule: rule22
  }, {
    start: 42851,
    length: 1,
    convRule: rule23
  }, {
    start: 42852,
    length: 1,
    convRule: rule22
  }, {
    start: 42853,
    length: 1,
    convRule: rule23
  }, {
    start: 42854,
    length: 1,
    convRule: rule22
  }, {
    start: 42855,
    length: 1,
    convRule: rule23
  }, {
    start: 42856,
    length: 1,
    convRule: rule22
  }, {
    start: 42857,
    length: 1,
    convRule: rule23
  }, {
    start: 42858,
    length: 1,
    convRule: rule22
  }, {
    start: 42859,
    length: 1,
    convRule: rule23
  }, {
    start: 42860,
    length: 1,
    convRule: rule22
  }, {
    start: 42861,
    length: 1,
    convRule: rule23
  }, {
    start: 42862,
    length: 1,
    convRule: rule22
  }, {
    start: 42863,
    length: 1,
    convRule: rule23
  }, {
    start: 42873,
    length: 1,
    convRule: rule22
  }, {
    start: 42874,
    length: 1,
    convRule: rule23
  }, {
    start: 42875,
    length: 1,
    convRule: rule22
  }, {
    start: 42876,
    length: 1,
    convRule: rule23
  }, {
    start: 42877,
    length: 1,
    convRule: rule183
  }, {
    start: 42878,
    length: 1,
    convRule: rule22
  }, {
    start: 42879,
    length: 1,
    convRule: rule23
  }, {
    start: 42880,
    length: 1,
    convRule: rule22
  }, {
    start: 42881,
    length: 1,
    convRule: rule23
  }, {
    start: 42882,
    length: 1,
    convRule: rule22
  }, {
    start: 42883,
    length: 1,
    convRule: rule23
  }, {
    start: 42884,
    length: 1,
    convRule: rule22
  }, {
    start: 42885,
    length: 1,
    convRule: rule23
  }, {
    start: 42886,
    length: 1,
    convRule: rule22
  }, {
    start: 42887,
    length: 1,
    convRule: rule23
  }, {
    start: 42891,
    length: 1,
    convRule: rule22
  }, {
    start: 42892,
    length: 1,
    convRule: rule23
  }, {
    start: 42893,
    length: 1,
    convRule: rule184
  }, {
    start: 42896,
    length: 1,
    convRule: rule22
  }, {
    start: 42897,
    length: 1,
    convRule: rule23
  }, {
    start: 42898,
    length: 1,
    convRule: rule22
  }, {
    start: 42899,
    length: 1,
    convRule: rule23
  }, {
    start: 42900,
    length: 1,
    convRule: rule185
  }, {
    start: 42902,
    length: 1,
    convRule: rule22
  }, {
    start: 42903,
    length: 1,
    convRule: rule23
  }, {
    start: 42904,
    length: 1,
    convRule: rule22
  }, {
    start: 42905,
    length: 1,
    convRule: rule23
  }, {
    start: 42906,
    length: 1,
    convRule: rule22
  }, {
    start: 42907,
    length: 1,
    convRule: rule23
  }, {
    start: 42908,
    length: 1,
    convRule: rule22
  }, {
    start: 42909,
    length: 1,
    convRule: rule23
  }, {
    start: 42910,
    length: 1,
    convRule: rule22
  }, {
    start: 42911,
    length: 1,
    convRule: rule23
  }, {
    start: 42912,
    length: 1,
    convRule: rule22
  }, {
    start: 42913,
    length: 1,
    convRule: rule23
  }, {
    start: 42914,
    length: 1,
    convRule: rule22
  }, {
    start: 42915,
    length: 1,
    convRule: rule23
  }, {
    start: 42916,
    length: 1,
    convRule: rule22
  }, {
    start: 42917,
    length: 1,
    convRule: rule23
  }, {
    start: 42918,
    length: 1,
    convRule: rule22
  }, {
    start: 42919,
    length: 1,
    convRule: rule23
  }, {
    start: 42920,
    length: 1,
    convRule: rule22
  }, {
    start: 42921,
    length: 1,
    convRule: rule23
  }, {
    start: 42922,
    length: 1,
    convRule: rule186
  }, {
    start: 42923,
    length: 1,
    convRule: rule187
  }, {
    start: 42924,
    length: 1,
    convRule: rule188
  }, {
    start: 42925,
    length: 1,
    convRule: rule189
  }, {
    start: 42926,
    length: 1,
    convRule: rule186
  }, {
    start: 42928,
    length: 1,
    convRule: rule190
  }, {
    start: 42929,
    length: 1,
    convRule: rule191
  }, {
    start: 42930,
    length: 1,
    convRule: rule192
  }, {
    start: 42931,
    length: 1,
    convRule: rule193
  }, {
    start: 42932,
    length: 1,
    convRule: rule22
  }, {
    start: 42933,
    length: 1,
    convRule: rule23
  }, {
    start: 42934,
    length: 1,
    convRule: rule22
  }, {
    start: 42935,
    length: 1,
    convRule: rule23
  }, {
    start: 42936,
    length: 1,
    convRule: rule22
  }, {
    start: 42937,
    length: 1,
    convRule: rule23
  }, {
    start: 42938,
    length: 1,
    convRule: rule22
  }, {
    start: 42939,
    length: 1,
    convRule: rule23
  }, {
    start: 42940,
    length: 1,
    convRule: rule22
  }, {
    start: 42941,
    length: 1,
    convRule: rule23
  }, {
    start: 42942,
    length: 1,
    convRule: rule22
  }, {
    start: 42943,
    length: 1,
    convRule: rule23
  }, {
    start: 42946,
    length: 1,
    convRule: rule22
  }, {
    start: 42947,
    length: 1,
    convRule: rule23
  }, {
    start: 42948,
    length: 1,
    convRule: rule194
  }, {
    start: 42949,
    length: 1,
    convRule: rule195
  }, {
    start: 42950,
    length: 1,
    convRule: rule196
  }, {
    start: 42951,
    length: 1,
    convRule: rule22
  }, {
    start: 42952,
    length: 1,
    convRule: rule23
  }, {
    start: 42953,
    length: 1,
    convRule: rule22
  }, {
    start: 42954,
    length: 1,
    convRule: rule23
  }, {
    start: 42997,
    length: 1,
    convRule: rule22
  }, {
    start: 42998,
    length: 1,
    convRule: rule23
  }, {
    start: 43859,
    length: 1,
    convRule: rule197
  }, {
    start: 43888,
    length: 80,
    convRule: rule198
  }, {
    start: 65313,
    length: 26,
    convRule: rule9
  }, {
    start: 65345,
    length: 26,
    convRule: rule12
  }, {
    start: 66560,
    length: 40,
    convRule: rule201
  }, {
    start: 66600,
    length: 40,
    convRule: rule202
  }, {
    start: 66736,
    length: 36,
    convRule: rule201
  }, {
    start: 66776,
    length: 36,
    convRule: rule202
  }, {
    start: 68736,
    length: 51,
    convRule: rule97
  }, {
    start: 68800,
    length: 51,
    convRule: rule102
  }, {
    start: 71840,
    length: 32,
    convRule: rule9
  }, {
    start: 71872,
    length: 32,
    convRule: rule12
  }, {
    start: 93760,
    length: 32,
    convRule: rule9
  }, {
    start: 93792,
    length: 32,
    convRule: rule12
  }, {
    start: 125184,
    length: 34,
    convRule: rule203
  }, {
    start: 125218,
    length: 34,
    convRule: rule204
  }];
  var bsearch = function(a2) {
    return function(array) {
      return function(size5) {
        return function(compare4) {
          var go2 = function($copy_i) {
            return function($copy_k) {
              var $tco_var_i = $copy_i;
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(i2, k2) {
                if (i2 > k2 || i2 >= length2(array)) {
                  $tco_done = true;
                  return Nothing.value;
                }
                ;
                if (otherwise) {
                  var j2 = floor2(toNumber(i2 + k2 | 0) / 2);
                  var b2 = unsafeIndex3(array)(j2);
                  var v2 = compare4(a2)(b2);
                  if (v2 instanceof EQ) {
                    $tco_done = true;
                    return new Just(b2);
                  }
                  ;
                  if (v2 instanceof GT) {
                    $tco_var_i = j2 + 1 | 0;
                    $copy_k = k2;
                    return;
                  }
                  ;
                  $tco_var_i = i2;
                  $copy_k = j2 - 1 | 0;
                  return;
                }
                ;
                throw new Error("Failed pattern match at Data.CodePoint.Unicode.Internal (line 5622, column 3 - line 5632, column 30): " + [i2.constructor.name, k2.constructor.name]);
              }
              ;
              while (!$tco_done) {
                $tco_result = $tco_loop($tco_var_i, $copy_k);
              }
              ;
              return $tco_result;
            };
          };
          return go2(0)(size5);
        };
      };
    };
  };
  var blkCmp = function(v2) {
    return function(v1) {
      if (v2.start >= v1.start && v2.start < (v1.start + v1.length | 0)) {
        return EQ.value;
      }
      ;
      if (v2.start > v1.start) {
        return GT.value;
      }
      ;
      if (otherwise) {
        return LT.value;
      }
      ;
      throw new Error("Failed pattern match at Data.CodePoint.Unicode.Internal (line 5598, column 1 - line 5598, column 45): " + [v2.constructor.name, v1.constructor.name]);
    };
  };
  var getRule = function(blocks) {
    return function(unichar) {
      return function(size5) {
        var key = {
          start: unichar,
          length: 1,
          convRule: nullrule
        };
        var maybeCharBlock = bsearch(key)(blocks)(size5)(blkCmp);
        if (maybeCharBlock instanceof Nothing) {
          return Nothing.value;
        }
        ;
        if (maybeCharBlock instanceof Just) {
          return new Just(maybeCharBlock.value0.convRule);
        }
        ;
        throw new Error("Failed pattern match at Data.CodePoint.Unicode.Internal (line 5612, column 5 - line 5614, column 60): " + [maybeCharBlock.constructor.name]);
      };
    };
  };
  var caseConv = function(f2) {
    return function($$char) {
      var maybeConversionRule = getRule(convchars)($$char)(numConvBlocks);
      if (maybeConversionRule instanceof Nothing) {
        return $$char;
      }
      ;
      if (maybeConversionRule instanceof Just) {
        return $$char + f2(maybeConversionRule.value0) | 0;
      }
      ;
      throw new Error("Failed pattern match at Data.CodePoint.Unicode.Internal (line 5727, column 5 - line 5729, column 53): " + [maybeConversionRule.constructor.name]);
    };
  };
  var uTowlower = /* @__PURE__ */ caseConv(function(v2) {
    return v2.lowdist;
  });

  // output/Data.CodePoint.Unicode.Internal.Casing/index.js
  var compare2 = /* @__PURE__ */ compare(ordInt);
  var zeroRec = function(code) {
    return {
      code,
      lower: [],
      title: [],
      upper: [],
      fold: 0,
      foldFull: []
    };
  };
  var rules = [{
    code: 65,
    lower: [],
    title: [],
    upper: [],
    fold: 97,
    foldFull: [97]
  }, {
    code: 66,
    lower: [],
    title: [],
    upper: [],
    fold: 98,
    foldFull: [98]
  }, {
    code: 67,
    lower: [],
    title: [],
    upper: [],
    fold: 99,
    foldFull: [99]
  }, {
    code: 68,
    lower: [],
    title: [],
    upper: [],
    fold: 100,
    foldFull: [100]
  }, {
    code: 69,
    lower: [],
    title: [],
    upper: [],
    fold: 101,
    foldFull: [101]
  }, {
    code: 70,
    lower: [],
    title: [],
    upper: [],
    fold: 102,
    foldFull: [102]
  }, {
    code: 71,
    lower: [],
    title: [],
    upper: [],
    fold: 103,
    foldFull: [103]
  }, {
    code: 72,
    lower: [],
    title: [],
    upper: [],
    fold: 104,
    foldFull: [104]
  }, {
    code: 73,
    lower: [],
    title: [],
    upper: [],
    fold: 105,
    foldFull: [105]
  }, {
    code: 74,
    lower: [],
    title: [],
    upper: [],
    fold: 106,
    foldFull: [106]
  }, {
    code: 75,
    lower: [],
    title: [],
    upper: [],
    fold: 107,
    foldFull: [107]
  }, {
    code: 76,
    lower: [],
    title: [],
    upper: [],
    fold: 108,
    foldFull: [108]
  }, {
    code: 77,
    lower: [],
    title: [],
    upper: [],
    fold: 109,
    foldFull: [109]
  }, {
    code: 78,
    lower: [],
    title: [],
    upper: [],
    fold: 110,
    foldFull: [110]
  }, {
    code: 79,
    lower: [],
    title: [],
    upper: [],
    fold: 111,
    foldFull: [111]
  }, {
    code: 80,
    lower: [],
    title: [],
    upper: [],
    fold: 112,
    foldFull: [112]
  }, {
    code: 81,
    lower: [],
    title: [],
    upper: [],
    fold: 113,
    foldFull: [113]
  }, {
    code: 82,
    lower: [],
    title: [],
    upper: [],
    fold: 114,
    foldFull: [114]
  }, {
    code: 83,
    lower: [],
    title: [],
    upper: [],
    fold: 115,
    foldFull: [115]
  }, {
    code: 84,
    lower: [],
    title: [],
    upper: [],
    fold: 116,
    foldFull: [116]
  }, {
    code: 85,
    lower: [],
    title: [],
    upper: [],
    fold: 117,
    foldFull: [117]
  }, {
    code: 86,
    lower: [],
    title: [],
    upper: [],
    fold: 118,
    foldFull: [118]
  }, {
    code: 87,
    lower: [],
    title: [],
    upper: [],
    fold: 119,
    foldFull: [119]
  }, {
    code: 88,
    lower: [],
    title: [],
    upper: [],
    fold: 120,
    foldFull: [120]
  }, {
    code: 89,
    lower: [],
    title: [],
    upper: [],
    fold: 121,
    foldFull: [121]
  }, {
    code: 90,
    lower: [],
    title: [],
    upper: [],
    fold: 122,
    foldFull: [122]
  }, {
    code: 181,
    lower: [],
    title: [],
    upper: [],
    fold: 956,
    foldFull: [956]
  }, {
    code: 192,
    lower: [],
    title: [],
    upper: [],
    fold: 224,
    foldFull: [224]
  }, {
    code: 193,
    lower: [],
    title: [],
    upper: [],
    fold: 225,
    foldFull: [225]
  }, {
    code: 194,
    lower: [],
    title: [],
    upper: [],
    fold: 226,
    foldFull: [226]
  }, {
    code: 195,
    lower: [],
    title: [],
    upper: [],
    fold: 227,
    foldFull: [227]
  }, {
    code: 196,
    lower: [],
    title: [],
    upper: [],
    fold: 228,
    foldFull: [228]
  }, {
    code: 197,
    lower: [],
    title: [],
    upper: [],
    fold: 229,
    foldFull: [229]
  }, {
    code: 198,
    lower: [],
    title: [],
    upper: [],
    fold: 230,
    foldFull: [230]
  }, {
    code: 199,
    lower: [],
    title: [],
    upper: [],
    fold: 231,
    foldFull: [231]
  }, {
    code: 200,
    lower: [],
    title: [],
    upper: [],
    fold: 232,
    foldFull: [232]
  }, {
    code: 201,
    lower: [],
    title: [],
    upper: [],
    fold: 233,
    foldFull: [233]
  }, {
    code: 202,
    lower: [],
    title: [],
    upper: [],
    fold: 234,
    foldFull: [234]
  }, {
    code: 203,
    lower: [],
    title: [],
    upper: [],
    fold: 235,
    foldFull: [235]
  }, {
    code: 204,
    lower: [],
    title: [],
    upper: [],
    fold: 236,
    foldFull: [236]
  }, {
    code: 205,
    lower: [],
    title: [],
    upper: [],
    fold: 237,
    foldFull: [237]
  }, {
    code: 206,
    lower: [],
    title: [],
    upper: [],
    fold: 238,
    foldFull: [238]
  }, {
    code: 207,
    lower: [],
    title: [],
    upper: [],
    fold: 239,
    foldFull: [239]
  }, {
    code: 208,
    lower: [],
    title: [],
    upper: [],
    fold: 240,
    foldFull: [240]
  }, {
    code: 209,
    lower: [],
    title: [],
    upper: [],
    fold: 241,
    foldFull: [241]
  }, {
    code: 210,
    lower: [],
    title: [],
    upper: [],
    fold: 242,
    foldFull: [242]
  }, {
    code: 211,
    lower: [],
    title: [],
    upper: [],
    fold: 243,
    foldFull: [243]
  }, {
    code: 212,
    lower: [],
    title: [],
    upper: [],
    fold: 244,
    foldFull: [244]
  }, {
    code: 213,
    lower: [],
    title: [],
    upper: [],
    fold: 245,
    foldFull: [245]
  }, {
    code: 214,
    lower: [],
    title: [],
    upper: [],
    fold: 246,
    foldFull: [246]
  }, {
    code: 216,
    lower: [],
    title: [],
    upper: [],
    fold: 248,
    foldFull: [248]
  }, {
    code: 217,
    lower: [],
    title: [],
    upper: [],
    fold: 249,
    foldFull: [249]
  }, {
    code: 218,
    lower: [],
    title: [],
    upper: [],
    fold: 250,
    foldFull: [250]
  }, {
    code: 219,
    lower: [],
    title: [],
    upper: [],
    fold: 251,
    foldFull: [251]
  }, {
    code: 220,
    lower: [],
    title: [],
    upper: [],
    fold: 252,
    foldFull: [252]
  }, {
    code: 221,
    lower: [],
    title: [],
    upper: [],
    fold: 253,
    foldFull: [253]
  }, {
    code: 222,
    lower: [],
    title: [],
    upper: [],
    fold: 254,
    foldFull: [254]
  }, {
    code: 223,
    lower: [223],
    title: [83, 115],
    upper: [83, 83],
    fold: 0,
    foldFull: [115, 115]
  }, {
    code: 223,
    lower: [223],
    title: [83, 115],
    upper: [83, 83],
    fold: 0,
    foldFull: [115, 115]
  }, {
    code: 256,
    lower: [],
    title: [],
    upper: [],
    fold: 257,
    foldFull: [257]
  }, {
    code: 258,
    lower: [],
    title: [],
    upper: [],
    fold: 259,
    foldFull: [259]
  }, {
    code: 260,
    lower: [],
    title: [],
    upper: [],
    fold: 261,
    foldFull: [261]
  }, {
    code: 262,
    lower: [],
    title: [],
    upper: [],
    fold: 263,
    foldFull: [263]
  }, {
    code: 264,
    lower: [],
    title: [],
    upper: [],
    fold: 265,
    foldFull: [265]
  }, {
    code: 266,
    lower: [],
    title: [],
    upper: [],
    fold: 267,
    foldFull: [267]
  }, {
    code: 268,
    lower: [],
    title: [],
    upper: [],
    fold: 269,
    foldFull: [269]
  }, {
    code: 270,
    lower: [],
    title: [],
    upper: [],
    fold: 271,
    foldFull: [271]
  }, {
    code: 272,
    lower: [],
    title: [],
    upper: [],
    fold: 273,
    foldFull: [273]
  }, {
    code: 274,
    lower: [],
    title: [],
    upper: [],
    fold: 275,
    foldFull: [275]
  }, {
    code: 276,
    lower: [],
    title: [],
    upper: [],
    fold: 277,
    foldFull: [277]
  }, {
    code: 278,
    lower: [],
    title: [],
    upper: [],
    fold: 279,
    foldFull: [279]
  }, {
    code: 280,
    lower: [],
    title: [],
    upper: [],
    fold: 281,
    foldFull: [281]
  }, {
    code: 282,
    lower: [],
    title: [],
    upper: [],
    fold: 283,
    foldFull: [283]
  }, {
    code: 284,
    lower: [],
    title: [],
    upper: [],
    fold: 285,
    foldFull: [285]
  }, {
    code: 286,
    lower: [],
    title: [],
    upper: [],
    fold: 287,
    foldFull: [287]
  }, {
    code: 288,
    lower: [],
    title: [],
    upper: [],
    fold: 289,
    foldFull: [289]
  }, {
    code: 290,
    lower: [],
    title: [],
    upper: [],
    fold: 291,
    foldFull: [291]
  }, {
    code: 292,
    lower: [],
    title: [],
    upper: [],
    fold: 293,
    foldFull: [293]
  }, {
    code: 294,
    lower: [],
    title: [],
    upper: [],
    fold: 295,
    foldFull: [295]
  }, {
    code: 296,
    lower: [],
    title: [],
    upper: [],
    fold: 297,
    foldFull: [297]
  }, {
    code: 298,
    lower: [],
    title: [],
    upper: [],
    fold: 299,
    foldFull: [299]
  }, {
    code: 300,
    lower: [],
    title: [],
    upper: [],
    fold: 301,
    foldFull: [301]
  }, {
    code: 302,
    lower: [],
    title: [],
    upper: [],
    fold: 303,
    foldFull: [303]
  }, {
    code: 304,
    lower: [105, 775],
    title: [304],
    upper: [304],
    fold: 0,
    foldFull: [105, 775]
  }, {
    code: 304,
    lower: [105, 775],
    title: [304],
    upper: [304],
    fold: 0,
    foldFull: [105, 775]
  }, {
    code: 306,
    lower: [],
    title: [],
    upper: [],
    fold: 307,
    foldFull: [307]
  }, {
    code: 308,
    lower: [],
    title: [],
    upper: [],
    fold: 309,
    foldFull: [309]
  }, {
    code: 310,
    lower: [],
    title: [],
    upper: [],
    fold: 311,
    foldFull: [311]
  }, {
    code: 313,
    lower: [],
    title: [],
    upper: [],
    fold: 314,
    foldFull: [314]
  }, {
    code: 315,
    lower: [],
    title: [],
    upper: [],
    fold: 316,
    foldFull: [316]
  }, {
    code: 317,
    lower: [],
    title: [],
    upper: [],
    fold: 318,
    foldFull: [318]
  }, {
    code: 319,
    lower: [],
    title: [],
    upper: [],
    fold: 320,
    foldFull: [320]
  }, {
    code: 321,
    lower: [],
    title: [],
    upper: [],
    fold: 322,
    foldFull: [322]
  }, {
    code: 323,
    lower: [],
    title: [],
    upper: [],
    fold: 324,
    foldFull: [324]
  }, {
    code: 325,
    lower: [],
    title: [],
    upper: [],
    fold: 326,
    foldFull: [326]
  }, {
    code: 327,
    lower: [],
    title: [],
    upper: [],
    fold: 328,
    foldFull: [328]
  }, {
    code: 329,
    lower: [329],
    title: [700, 78],
    upper: [700, 78],
    fold: 0,
    foldFull: [700, 110]
  }, {
    code: 329,
    lower: [329],
    title: [700, 78],
    upper: [700, 78],
    fold: 0,
    foldFull: [700, 110]
  }, {
    code: 330,
    lower: [],
    title: [],
    upper: [],
    fold: 331,
    foldFull: [331]
  }, {
    code: 332,
    lower: [],
    title: [],
    upper: [],
    fold: 333,
    foldFull: [333]
  }, {
    code: 334,
    lower: [],
    title: [],
    upper: [],
    fold: 335,
    foldFull: [335]
  }, {
    code: 336,
    lower: [],
    title: [],
    upper: [],
    fold: 337,
    foldFull: [337]
  }, {
    code: 338,
    lower: [],
    title: [],
    upper: [],
    fold: 339,
    foldFull: [339]
  }, {
    code: 340,
    lower: [],
    title: [],
    upper: [],
    fold: 341,
    foldFull: [341]
  }, {
    code: 342,
    lower: [],
    title: [],
    upper: [],
    fold: 343,
    foldFull: [343]
  }, {
    code: 344,
    lower: [],
    title: [],
    upper: [],
    fold: 345,
    foldFull: [345]
  }, {
    code: 346,
    lower: [],
    title: [],
    upper: [],
    fold: 347,
    foldFull: [347]
  }, {
    code: 348,
    lower: [],
    title: [],
    upper: [],
    fold: 349,
    foldFull: [349]
  }, {
    code: 350,
    lower: [],
    title: [],
    upper: [],
    fold: 351,
    foldFull: [351]
  }, {
    code: 352,
    lower: [],
    title: [],
    upper: [],
    fold: 353,
    foldFull: [353]
  }, {
    code: 354,
    lower: [],
    title: [],
    upper: [],
    fold: 355,
    foldFull: [355]
  }, {
    code: 356,
    lower: [],
    title: [],
    upper: [],
    fold: 357,
    foldFull: [357]
  }, {
    code: 358,
    lower: [],
    title: [],
    upper: [],
    fold: 359,
    foldFull: [359]
  }, {
    code: 360,
    lower: [],
    title: [],
    upper: [],
    fold: 361,
    foldFull: [361]
  }, {
    code: 362,
    lower: [],
    title: [],
    upper: [],
    fold: 363,
    foldFull: [363]
  }, {
    code: 364,
    lower: [],
    title: [],
    upper: [],
    fold: 365,
    foldFull: [365]
  }, {
    code: 366,
    lower: [],
    title: [],
    upper: [],
    fold: 367,
    foldFull: [367]
  }, {
    code: 368,
    lower: [],
    title: [],
    upper: [],
    fold: 369,
    foldFull: [369]
  }, {
    code: 370,
    lower: [],
    title: [],
    upper: [],
    fold: 371,
    foldFull: [371]
  }, {
    code: 372,
    lower: [],
    title: [],
    upper: [],
    fold: 373,
    foldFull: [373]
  }, {
    code: 374,
    lower: [],
    title: [],
    upper: [],
    fold: 375,
    foldFull: [375]
  }, {
    code: 376,
    lower: [],
    title: [],
    upper: [],
    fold: 255,
    foldFull: [255]
  }, {
    code: 377,
    lower: [],
    title: [],
    upper: [],
    fold: 378,
    foldFull: [378]
  }, {
    code: 379,
    lower: [],
    title: [],
    upper: [],
    fold: 380,
    foldFull: [380]
  }, {
    code: 381,
    lower: [],
    title: [],
    upper: [],
    fold: 382,
    foldFull: [382]
  }, {
    code: 383,
    lower: [],
    title: [],
    upper: [],
    fold: 115,
    foldFull: [115]
  }, {
    code: 385,
    lower: [],
    title: [],
    upper: [],
    fold: 595,
    foldFull: [595]
  }, {
    code: 386,
    lower: [],
    title: [],
    upper: [],
    fold: 387,
    foldFull: [387]
  }, {
    code: 388,
    lower: [],
    title: [],
    upper: [],
    fold: 389,
    foldFull: [389]
  }, {
    code: 390,
    lower: [],
    title: [],
    upper: [],
    fold: 596,
    foldFull: [596]
  }, {
    code: 391,
    lower: [],
    title: [],
    upper: [],
    fold: 392,
    foldFull: [392]
  }, {
    code: 393,
    lower: [],
    title: [],
    upper: [],
    fold: 598,
    foldFull: [598]
  }, {
    code: 394,
    lower: [],
    title: [],
    upper: [],
    fold: 599,
    foldFull: [599]
  }, {
    code: 395,
    lower: [],
    title: [],
    upper: [],
    fold: 396,
    foldFull: [396]
  }, {
    code: 398,
    lower: [],
    title: [],
    upper: [],
    fold: 477,
    foldFull: [477]
  }, {
    code: 399,
    lower: [],
    title: [],
    upper: [],
    fold: 601,
    foldFull: [601]
  }, {
    code: 400,
    lower: [],
    title: [],
    upper: [],
    fold: 603,
    foldFull: [603]
  }, {
    code: 401,
    lower: [],
    title: [],
    upper: [],
    fold: 402,
    foldFull: [402]
  }, {
    code: 403,
    lower: [],
    title: [],
    upper: [],
    fold: 608,
    foldFull: [608]
  }, {
    code: 404,
    lower: [],
    title: [],
    upper: [],
    fold: 611,
    foldFull: [611]
  }, {
    code: 406,
    lower: [],
    title: [],
    upper: [],
    fold: 617,
    foldFull: [617]
  }, {
    code: 407,
    lower: [],
    title: [],
    upper: [],
    fold: 616,
    foldFull: [616]
  }, {
    code: 408,
    lower: [],
    title: [],
    upper: [],
    fold: 409,
    foldFull: [409]
  }, {
    code: 412,
    lower: [],
    title: [],
    upper: [],
    fold: 623,
    foldFull: [623]
  }, {
    code: 413,
    lower: [],
    title: [],
    upper: [],
    fold: 626,
    foldFull: [626]
  }, {
    code: 415,
    lower: [],
    title: [],
    upper: [],
    fold: 629,
    foldFull: [629]
  }, {
    code: 416,
    lower: [],
    title: [],
    upper: [],
    fold: 417,
    foldFull: [417]
  }, {
    code: 418,
    lower: [],
    title: [],
    upper: [],
    fold: 419,
    foldFull: [419]
  }, {
    code: 420,
    lower: [],
    title: [],
    upper: [],
    fold: 421,
    foldFull: [421]
  }, {
    code: 422,
    lower: [],
    title: [],
    upper: [],
    fold: 640,
    foldFull: [640]
  }, {
    code: 423,
    lower: [],
    title: [],
    upper: [],
    fold: 424,
    foldFull: [424]
  }, {
    code: 425,
    lower: [],
    title: [],
    upper: [],
    fold: 643,
    foldFull: [643]
  }, {
    code: 428,
    lower: [],
    title: [],
    upper: [],
    fold: 429,
    foldFull: [429]
  }, {
    code: 430,
    lower: [],
    title: [],
    upper: [],
    fold: 648,
    foldFull: [648]
  }, {
    code: 431,
    lower: [],
    title: [],
    upper: [],
    fold: 432,
    foldFull: [432]
  }, {
    code: 433,
    lower: [],
    title: [],
    upper: [],
    fold: 650,
    foldFull: [650]
  }, {
    code: 434,
    lower: [],
    title: [],
    upper: [],
    fold: 651,
    foldFull: [651]
  }, {
    code: 435,
    lower: [],
    title: [],
    upper: [],
    fold: 436,
    foldFull: [436]
  }, {
    code: 437,
    lower: [],
    title: [],
    upper: [],
    fold: 438,
    foldFull: [438]
  }, {
    code: 439,
    lower: [],
    title: [],
    upper: [],
    fold: 658,
    foldFull: [658]
  }, {
    code: 440,
    lower: [],
    title: [],
    upper: [],
    fold: 441,
    foldFull: [441]
  }, {
    code: 444,
    lower: [],
    title: [],
    upper: [],
    fold: 445,
    foldFull: [445]
  }, {
    code: 452,
    lower: [],
    title: [],
    upper: [],
    fold: 454,
    foldFull: [454]
  }, {
    code: 453,
    lower: [],
    title: [],
    upper: [],
    fold: 454,
    foldFull: [454]
  }, {
    code: 455,
    lower: [],
    title: [],
    upper: [],
    fold: 457,
    foldFull: [457]
  }, {
    code: 456,
    lower: [],
    title: [],
    upper: [],
    fold: 457,
    foldFull: [457]
  }, {
    code: 458,
    lower: [],
    title: [],
    upper: [],
    fold: 460,
    foldFull: [460]
  }, {
    code: 459,
    lower: [],
    title: [],
    upper: [],
    fold: 460,
    foldFull: [460]
  }, {
    code: 461,
    lower: [],
    title: [],
    upper: [],
    fold: 462,
    foldFull: [462]
  }, {
    code: 463,
    lower: [],
    title: [],
    upper: [],
    fold: 464,
    foldFull: [464]
  }, {
    code: 465,
    lower: [],
    title: [],
    upper: [],
    fold: 466,
    foldFull: [466]
  }, {
    code: 467,
    lower: [],
    title: [],
    upper: [],
    fold: 468,
    foldFull: [468]
  }, {
    code: 469,
    lower: [],
    title: [],
    upper: [],
    fold: 470,
    foldFull: [470]
  }, {
    code: 471,
    lower: [],
    title: [],
    upper: [],
    fold: 472,
    foldFull: [472]
  }, {
    code: 473,
    lower: [],
    title: [],
    upper: [],
    fold: 474,
    foldFull: [474]
  }, {
    code: 475,
    lower: [],
    title: [],
    upper: [],
    fold: 476,
    foldFull: [476]
  }, {
    code: 478,
    lower: [],
    title: [],
    upper: [],
    fold: 479,
    foldFull: [479]
  }, {
    code: 480,
    lower: [],
    title: [],
    upper: [],
    fold: 481,
    foldFull: [481]
  }, {
    code: 482,
    lower: [],
    title: [],
    upper: [],
    fold: 483,
    foldFull: [483]
  }, {
    code: 484,
    lower: [],
    title: [],
    upper: [],
    fold: 485,
    foldFull: [485]
  }, {
    code: 486,
    lower: [],
    title: [],
    upper: [],
    fold: 487,
    foldFull: [487]
  }, {
    code: 488,
    lower: [],
    title: [],
    upper: [],
    fold: 489,
    foldFull: [489]
  }, {
    code: 490,
    lower: [],
    title: [],
    upper: [],
    fold: 491,
    foldFull: [491]
  }, {
    code: 492,
    lower: [],
    title: [],
    upper: [],
    fold: 493,
    foldFull: [493]
  }, {
    code: 494,
    lower: [],
    title: [],
    upper: [],
    fold: 495,
    foldFull: [495]
  }, {
    code: 496,
    lower: [496],
    title: [74, 780],
    upper: [74, 780],
    fold: 0,
    foldFull: [106, 780]
  }, {
    code: 496,
    lower: [496],
    title: [74, 780],
    upper: [74, 780],
    fold: 0,
    foldFull: [106, 780]
  }, {
    code: 497,
    lower: [],
    title: [],
    upper: [],
    fold: 499,
    foldFull: [499]
  }, {
    code: 498,
    lower: [],
    title: [],
    upper: [],
    fold: 499,
    foldFull: [499]
  }, {
    code: 500,
    lower: [],
    title: [],
    upper: [],
    fold: 501,
    foldFull: [501]
  }, {
    code: 502,
    lower: [],
    title: [],
    upper: [],
    fold: 405,
    foldFull: [405]
  }, {
    code: 503,
    lower: [],
    title: [],
    upper: [],
    fold: 447,
    foldFull: [447]
  }, {
    code: 504,
    lower: [],
    title: [],
    upper: [],
    fold: 505,
    foldFull: [505]
  }, {
    code: 506,
    lower: [],
    title: [],
    upper: [],
    fold: 507,
    foldFull: [507]
  }, {
    code: 508,
    lower: [],
    title: [],
    upper: [],
    fold: 509,
    foldFull: [509]
  }, {
    code: 510,
    lower: [],
    title: [],
    upper: [],
    fold: 511,
    foldFull: [511]
  }, {
    code: 512,
    lower: [],
    title: [],
    upper: [],
    fold: 513,
    foldFull: [513]
  }, {
    code: 514,
    lower: [],
    title: [],
    upper: [],
    fold: 515,
    foldFull: [515]
  }, {
    code: 516,
    lower: [],
    title: [],
    upper: [],
    fold: 517,
    foldFull: [517]
  }, {
    code: 518,
    lower: [],
    title: [],
    upper: [],
    fold: 519,
    foldFull: [519]
  }, {
    code: 520,
    lower: [],
    title: [],
    upper: [],
    fold: 521,
    foldFull: [521]
  }, {
    code: 522,
    lower: [],
    title: [],
    upper: [],
    fold: 523,
    foldFull: [523]
  }, {
    code: 524,
    lower: [],
    title: [],
    upper: [],
    fold: 525,
    foldFull: [525]
  }, {
    code: 526,
    lower: [],
    title: [],
    upper: [],
    fold: 527,
    foldFull: [527]
  }, {
    code: 528,
    lower: [],
    title: [],
    upper: [],
    fold: 529,
    foldFull: [529]
  }, {
    code: 530,
    lower: [],
    title: [],
    upper: [],
    fold: 531,
    foldFull: [531]
  }, {
    code: 532,
    lower: [],
    title: [],
    upper: [],
    fold: 533,
    foldFull: [533]
  }, {
    code: 534,
    lower: [],
    title: [],
    upper: [],
    fold: 535,
    foldFull: [535]
  }, {
    code: 536,
    lower: [],
    title: [],
    upper: [],
    fold: 537,
    foldFull: [537]
  }, {
    code: 538,
    lower: [],
    title: [],
    upper: [],
    fold: 539,
    foldFull: [539]
  }, {
    code: 540,
    lower: [],
    title: [],
    upper: [],
    fold: 541,
    foldFull: [541]
  }, {
    code: 542,
    lower: [],
    title: [],
    upper: [],
    fold: 543,
    foldFull: [543]
  }, {
    code: 544,
    lower: [],
    title: [],
    upper: [],
    fold: 414,
    foldFull: [414]
  }, {
    code: 546,
    lower: [],
    title: [],
    upper: [],
    fold: 547,
    foldFull: [547]
  }, {
    code: 548,
    lower: [],
    title: [],
    upper: [],
    fold: 549,
    foldFull: [549]
  }, {
    code: 550,
    lower: [],
    title: [],
    upper: [],
    fold: 551,
    foldFull: [551]
  }, {
    code: 552,
    lower: [],
    title: [],
    upper: [],
    fold: 553,
    foldFull: [553]
  }, {
    code: 554,
    lower: [],
    title: [],
    upper: [],
    fold: 555,
    foldFull: [555]
  }, {
    code: 556,
    lower: [],
    title: [],
    upper: [],
    fold: 557,
    foldFull: [557]
  }, {
    code: 558,
    lower: [],
    title: [],
    upper: [],
    fold: 559,
    foldFull: [559]
  }, {
    code: 560,
    lower: [],
    title: [],
    upper: [],
    fold: 561,
    foldFull: [561]
  }, {
    code: 562,
    lower: [],
    title: [],
    upper: [],
    fold: 563,
    foldFull: [563]
  }, {
    code: 570,
    lower: [],
    title: [],
    upper: [],
    fold: 11365,
    foldFull: [11365]
  }, {
    code: 571,
    lower: [],
    title: [],
    upper: [],
    fold: 572,
    foldFull: [572]
  }, {
    code: 573,
    lower: [],
    title: [],
    upper: [],
    fold: 410,
    foldFull: [410]
  }, {
    code: 574,
    lower: [],
    title: [],
    upper: [],
    fold: 11366,
    foldFull: [11366]
  }, {
    code: 577,
    lower: [],
    title: [],
    upper: [],
    fold: 578,
    foldFull: [578]
  }, {
    code: 579,
    lower: [],
    title: [],
    upper: [],
    fold: 384,
    foldFull: [384]
  }, {
    code: 580,
    lower: [],
    title: [],
    upper: [],
    fold: 649,
    foldFull: [649]
  }, {
    code: 581,
    lower: [],
    title: [],
    upper: [],
    fold: 652,
    foldFull: [652]
  }, {
    code: 582,
    lower: [],
    title: [],
    upper: [],
    fold: 583,
    foldFull: [583]
  }, {
    code: 584,
    lower: [],
    title: [],
    upper: [],
    fold: 585,
    foldFull: [585]
  }, {
    code: 586,
    lower: [],
    title: [],
    upper: [],
    fold: 587,
    foldFull: [587]
  }, {
    code: 588,
    lower: [],
    title: [],
    upper: [],
    fold: 589,
    foldFull: [589]
  }, {
    code: 590,
    lower: [],
    title: [],
    upper: [],
    fold: 591,
    foldFull: [591]
  }, {
    code: 837,
    lower: [],
    title: [],
    upper: [],
    fold: 953,
    foldFull: [953]
  }, {
    code: 880,
    lower: [],
    title: [],
    upper: [],
    fold: 881,
    foldFull: [881]
  }, {
    code: 882,
    lower: [],
    title: [],
    upper: [],
    fold: 883,
    foldFull: [883]
  }, {
    code: 886,
    lower: [],
    title: [],
    upper: [],
    fold: 887,
    foldFull: [887]
  }, {
    code: 895,
    lower: [],
    title: [],
    upper: [],
    fold: 1011,
    foldFull: [1011]
  }, {
    code: 902,
    lower: [],
    title: [],
    upper: [],
    fold: 940,
    foldFull: [940]
  }, {
    code: 904,
    lower: [],
    title: [],
    upper: [],
    fold: 941,
    foldFull: [941]
  }, {
    code: 905,
    lower: [],
    title: [],
    upper: [],
    fold: 942,
    foldFull: [942]
  }, {
    code: 906,
    lower: [],
    title: [],
    upper: [],
    fold: 943,
    foldFull: [943]
  }, {
    code: 908,
    lower: [],
    title: [],
    upper: [],
    fold: 972,
    foldFull: [972]
  }, {
    code: 910,
    lower: [],
    title: [],
    upper: [],
    fold: 973,
    foldFull: [973]
  }, {
    code: 911,
    lower: [],
    title: [],
    upper: [],
    fold: 974,
    foldFull: [974]
  }, {
    code: 912,
    lower: [912],
    title: [921, 776, 769],
    upper: [921, 776, 769],
    fold: 0,
    foldFull: [953, 776, 769]
  }, {
    code: 912,
    lower: [912],
    title: [921, 776, 769],
    upper: [921, 776, 769],
    fold: 0,
    foldFull: [953, 776, 769]
  }, {
    code: 913,
    lower: [],
    title: [],
    upper: [],
    fold: 945,
    foldFull: [945]
  }, {
    code: 914,
    lower: [],
    title: [],
    upper: [],
    fold: 946,
    foldFull: [946]
  }, {
    code: 915,
    lower: [],
    title: [],
    upper: [],
    fold: 947,
    foldFull: [947]
  }, {
    code: 916,
    lower: [],
    title: [],
    upper: [],
    fold: 948,
    foldFull: [948]
  }, {
    code: 917,
    lower: [],
    title: [],
    upper: [],
    fold: 949,
    foldFull: [949]
  }, {
    code: 918,
    lower: [],
    title: [],
    upper: [],
    fold: 950,
    foldFull: [950]
  }, {
    code: 919,
    lower: [],
    title: [],
    upper: [],
    fold: 951,
    foldFull: [951]
  }, {
    code: 920,
    lower: [],
    title: [],
    upper: [],
    fold: 952,
    foldFull: [952]
  }, {
    code: 921,
    lower: [],
    title: [],
    upper: [],
    fold: 953,
    foldFull: [953]
  }, {
    code: 922,
    lower: [],
    title: [],
    upper: [],
    fold: 954,
    foldFull: [954]
  }, {
    code: 923,
    lower: [],
    title: [],
    upper: [],
    fold: 955,
    foldFull: [955]
  }, {
    code: 924,
    lower: [],
    title: [],
    upper: [],
    fold: 956,
    foldFull: [956]
  }, {
    code: 925,
    lower: [],
    title: [],
    upper: [],
    fold: 957,
    foldFull: [957]
  }, {
    code: 926,
    lower: [],
    title: [],
    upper: [],
    fold: 958,
    foldFull: [958]
  }, {
    code: 927,
    lower: [],
    title: [],
    upper: [],
    fold: 959,
    foldFull: [959]
  }, {
    code: 928,
    lower: [],
    title: [],
    upper: [],
    fold: 960,
    foldFull: [960]
  }, {
    code: 929,
    lower: [],
    title: [],
    upper: [],
    fold: 961,
    foldFull: [961]
  }, {
    code: 931,
    lower: [],
    title: [],
    upper: [],
    fold: 963,
    foldFull: [963]
  }, {
    code: 932,
    lower: [],
    title: [],
    upper: [],
    fold: 964,
    foldFull: [964]
  }, {
    code: 933,
    lower: [],
    title: [],
    upper: [],
    fold: 965,
    foldFull: [965]
  }, {
    code: 934,
    lower: [],
    title: [],
    upper: [],
    fold: 966,
    foldFull: [966]
  }, {
    code: 935,
    lower: [],
    title: [],
    upper: [],
    fold: 967,
    foldFull: [967]
  }, {
    code: 936,
    lower: [],
    title: [],
    upper: [],
    fold: 968,
    foldFull: [968]
  }, {
    code: 937,
    lower: [],
    title: [],
    upper: [],
    fold: 969,
    foldFull: [969]
  }, {
    code: 938,
    lower: [],
    title: [],
    upper: [],
    fold: 970,
    foldFull: [970]
  }, {
    code: 939,
    lower: [],
    title: [],
    upper: [],
    fold: 971,
    foldFull: [971]
  }, {
    code: 944,
    lower: [944],
    title: [933, 776, 769],
    upper: [933, 776, 769],
    fold: 0,
    foldFull: [965, 776, 769]
  }, {
    code: 944,
    lower: [944],
    title: [933, 776, 769],
    upper: [933, 776, 769],
    fold: 0,
    foldFull: [965, 776, 769]
  }, {
    code: 962,
    lower: [],
    title: [],
    upper: [],
    fold: 963,
    foldFull: [963]
  }, {
    code: 975,
    lower: [],
    title: [],
    upper: [],
    fold: 983,
    foldFull: [983]
  }, {
    code: 976,
    lower: [],
    title: [],
    upper: [],
    fold: 946,
    foldFull: [946]
  }, {
    code: 977,
    lower: [],
    title: [],
    upper: [],
    fold: 952,
    foldFull: [952]
  }, {
    code: 981,
    lower: [],
    title: [],
    upper: [],
    fold: 966,
    foldFull: [966]
  }, {
    code: 982,
    lower: [],
    title: [],
    upper: [],
    fold: 960,
    foldFull: [960]
  }, {
    code: 984,
    lower: [],
    title: [],
    upper: [],
    fold: 985,
    foldFull: [985]
  }, {
    code: 986,
    lower: [],
    title: [],
    upper: [],
    fold: 987,
    foldFull: [987]
  }, {
    code: 988,
    lower: [],
    title: [],
    upper: [],
    fold: 989,
    foldFull: [989]
  }, {
    code: 990,
    lower: [],
    title: [],
    upper: [],
    fold: 991,
    foldFull: [991]
  }, {
    code: 992,
    lower: [],
    title: [],
    upper: [],
    fold: 993,
    foldFull: [993]
  }, {
    code: 994,
    lower: [],
    title: [],
    upper: [],
    fold: 995,
    foldFull: [995]
  }, {
    code: 996,
    lower: [],
    title: [],
    upper: [],
    fold: 997,
    foldFull: [997]
  }, {
    code: 998,
    lower: [],
    title: [],
    upper: [],
    fold: 999,
    foldFull: [999]
  }, {
    code: 1e3,
    lower: [],
    title: [],
    upper: [],
    fold: 1001,
    foldFull: [1001]
  }, {
    code: 1002,
    lower: [],
    title: [],
    upper: [],
    fold: 1003,
    foldFull: [1003]
  }, {
    code: 1004,
    lower: [],
    title: [],
    upper: [],
    fold: 1005,
    foldFull: [1005]
  }, {
    code: 1006,
    lower: [],
    title: [],
    upper: [],
    fold: 1007,
    foldFull: [1007]
  }, {
    code: 1008,
    lower: [],
    title: [],
    upper: [],
    fold: 954,
    foldFull: [954]
  }, {
    code: 1009,
    lower: [],
    title: [],
    upper: [],
    fold: 961,
    foldFull: [961]
  }, {
    code: 1012,
    lower: [],
    title: [],
    upper: [],
    fold: 952,
    foldFull: [952]
  }, {
    code: 1013,
    lower: [],
    title: [],
    upper: [],
    fold: 949,
    foldFull: [949]
  }, {
    code: 1015,
    lower: [],
    title: [],
    upper: [],
    fold: 1016,
    foldFull: [1016]
  }, {
    code: 1017,
    lower: [],
    title: [],
    upper: [],
    fold: 1010,
    foldFull: [1010]
  }, {
    code: 1018,
    lower: [],
    title: [],
    upper: [],
    fold: 1019,
    foldFull: [1019]
  }, {
    code: 1021,
    lower: [],
    title: [],
    upper: [],
    fold: 891,
    foldFull: [891]
  }, {
    code: 1022,
    lower: [],
    title: [],
    upper: [],
    fold: 892,
    foldFull: [892]
  }, {
    code: 1023,
    lower: [],
    title: [],
    upper: [],
    fold: 893,
    foldFull: [893]
  }, {
    code: 1024,
    lower: [],
    title: [],
    upper: [],
    fold: 1104,
    foldFull: [1104]
  }, {
    code: 1025,
    lower: [],
    title: [],
    upper: [],
    fold: 1105,
    foldFull: [1105]
  }, {
    code: 1026,
    lower: [],
    title: [],
    upper: [],
    fold: 1106,
    foldFull: [1106]
  }, {
    code: 1027,
    lower: [],
    title: [],
    upper: [],
    fold: 1107,
    foldFull: [1107]
  }, {
    code: 1028,
    lower: [],
    title: [],
    upper: [],
    fold: 1108,
    foldFull: [1108]
  }, {
    code: 1029,
    lower: [],
    title: [],
    upper: [],
    fold: 1109,
    foldFull: [1109]
  }, {
    code: 1030,
    lower: [],
    title: [],
    upper: [],
    fold: 1110,
    foldFull: [1110]
  }, {
    code: 1031,
    lower: [],
    title: [],
    upper: [],
    fold: 1111,
    foldFull: [1111]
  }, {
    code: 1032,
    lower: [],
    title: [],
    upper: [],
    fold: 1112,
    foldFull: [1112]
  }, {
    code: 1033,
    lower: [],
    title: [],
    upper: [],
    fold: 1113,
    foldFull: [1113]
  }, {
    code: 1034,
    lower: [],
    title: [],
    upper: [],
    fold: 1114,
    foldFull: [1114]
  }, {
    code: 1035,
    lower: [],
    title: [],
    upper: [],
    fold: 1115,
    foldFull: [1115]
  }, {
    code: 1036,
    lower: [],
    title: [],
    upper: [],
    fold: 1116,
    foldFull: [1116]
  }, {
    code: 1037,
    lower: [],
    title: [],
    upper: [],
    fold: 1117,
    foldFull: [1117]
  }, {
    code: 1038,
    lower: [],
    title: [],
    upper: [],
    fold: 1118,
    foldFull: [1118]
  }, {
    code: 1039,
    lower: [],
    title: [],
    upper: [],
    fold: 1119,
    foldFull: [1119]
  }, {
    code: 1040,
    lower: [],
    title: [],
    upper: [],
    fold: 1072,
    foldFull: [1072]
  }, {
    code: 1041,
    lower: [],
    title: [],
    upper: [],
    fold: 1073,
    foldFull: [1073]
  }, {
    code: 1042,
    lower: [],
    title: [],
    upper: [],
    fold: 1074,
    foldFull: [1074]
  }, {
    code: 1043,
    lower: [],
    title: [],
    upper: [],
    fold: 1075,
    foldFull: [1075]
  }, {
    code: 1044,
    lower: [],
    title: [],
    upper: [],
    fold: 1076,
    foldFull: [1076]
  }, {
    code: 1045,
    lower: [],
    title: [],
    upper: [],
    fold: 1077,
    foldFull: [1077]
  }, {
    code: 1046,
    lower: [],
    title: [],
    upper: [],
    fold: 1078,
    foldFull: [1078]
  }, {
    code: 1047,
    lower: [],
    title: [],
    upper: [],
    fold: 1079,
    foldFull: [1079]
  }, {
    code: 1048,
    lower: [],
    title: [],
    upper: [],
    fold: 1080,
    foldFull: [1080]
  }, {
    code: 1049,
    lower: [],
    title: [],
    upper: [],
    fold: 1081,
    foldFull: [1081]
  }, {
    code: 1050,
    lower: [],
    title: [],
    upper: [],
    fold: 1082,
    foldFull: [1082]
  }, {
    code: 1051,
    lower: [],
    title: [],
    upper: [],
    fold: 1083,
    foldFull: [1083]
  }, {
    code: 1052,
    lower: [],
    title: [],
    upper: [],
    fold: 1084,
    foldFull: [1084]
  }, {
    code: 1053,
    lower: [],
    title: [],
    upper: [],
    fold: 1085,
    foldFull: [1085]
  }, {
    code: 1054,
    lower: [],
    title: [],
    upper: [],
    fold: 1086,
    foldFull: [1086]
  }, {
    code: 1055,
    lower: [],
    title: [],
    upper: [],
    fold: 1087,
    foldFull: [1087]
  }, {
    code: 1056,
    lower: [],
    title: [],
    upper: [],
    fold: 1088,
    foldFull: [1088]
  }, {
    code: 1057,
    lower: [],
    title: [],
    upper: [],
    fold: 1089,
    foldFull: [1089]
  }, {
    code: 1058,
    lower: [],
    title: [],
    upper: [],
    fold: 1090,
    foldFull: [1090]
  }, {
    code: 1059,
    lower: [],
    title: [],
    upper: [],
    fold: 1091,
    foldFull: [1091]
  }, {
    code: 1060,
    lower: [],
    title: [],
    upper: [],
    fold: 1092,
    foldFull: [1092]
  }, {
    code: 1061,
    lower: [],
    title: [],
    upper: [],
    fold: 1093,
    foldFull: [1093]
  }, {
    code: 1062,
    lower: [],
    title: [],
    upper: [],
    fold: 1094,
    foldFull: [1094]
  }, {
    code: 1063,
    lower: [],
    title: [],
    upper: [],
    fold: 1095,
    foldFull: [1095]
  }, {
    code: 1064,
    lower: [],
    title: [],
    upper: [],
    fold: 1096,
    foldFull: [1096]
  }, {
    code: 1065,
    lower: [],
    title: [],
    upper: [],
    fold: 1097,
    foldFull: [1097]
  }, {
    code: 1066,
    lower: [],
    title: [],
    upper: [],
    fold: 1098,
    foldFull: [1098]
  }, {
    code: 1067,
    lower: [],
    title: [],
    upper: [],
    fold: 1099,
    foldFull: [1099]
  }, {
    code: 1068,
    lower: [],
    title: [],
    upper: [],
    fold: 1100,
    foldFull: [1100]
  }, {
    code: 1069,
    lower: [],
    title: [],
    upper: [],
    fold: 1101,
    foldFull: [1101]
  }, {
    code: 1070,
    lower: [],
    title: [],
    upper: [],
    fold: 1102,
    foldFull: [1102]
  }, {
    code: 1071,
    lower: [],
    title: [],
    upper: [],
    fold: 1103,
    foldFull: [1103]
  }, {
    code: 1120,
    lower: [],
    title: [],
    upper: [],
    fold: 1121,
    foldFull: [1121]
  }, {
    code: 1122,
    lower: [],
    title: [],
    upper: [],
    fold: 1123,
    foldFull: [1123]
  }, {
    code: 1124,
    lower: [],
    title: [],
    upper: [],
    fold: 1125,
    foldFull: [1125]
  }, {
    code: 1126,
    lower: [],
    title: [],
    upper: [],
    fold: 1127,
    foldFull: [1127]
  }, {
    code: 1128,
    lower: [],
    title: [],
    upper: [],
    fold: 1129,
    foldFull: [1129]
  }, {
    code: 1130,
    lower: [],
    title: [],
    upper: [],
    fold: 1131,
    foldFull: [1131]
  }, {
    code: 1132,
    lower: [],
    title: [],
    upper: [],
    fold: 1133,
    foldFull: [1133]
  }, {
    code: 1134,
    lower: [],
    title: [],
    upper: [],
    fold: 1135,
    foldFull: [1135]
  }, {
    code: 1136,
    lower: [],
    title: [],
    upper: [],
    fold: 1137,
    foldFull: [1137]
  }, {
    code: 1138,
    lower: [],
    title: [],
    upper: [],
    fold: 1139,
    foldFull: [1139]
  }, {
    code: 1140,
    lower: [],
    title: [],
    upper: [],
    fold: 1141,
    foldFull: [1141]
  }, {
    code: 1142,
    lower: [],
    title: [],
    upper: [],
    fold: 1143,
    foldFull: [1143]
  }, {
    code: 1144,
    lower: [],
    title: [],
    upper: [],
    fold: 1145,
    foldFull: [1145]
  }, {
    code: 1146,
    lower: [],
    title: [],
    upper: [],
    fold: 1147,
    foldFull: [1147]
  }, {
    code: 1148,
    lower: [],
    title: [],
    upper: [],
    fold: 1149,
    foldFull: [1149]
  }, {
    code: 1150,
    lower: [],
    title: [],
    upper: [],
    fold: 1151,
    foldFull: [1151]
  }, {
    code: 1152,
    lower: [],
    title: [],
    upper: [],
    fold: 1153,
    foldFull: [1153]
  }, {
    code: 1162,
    lower: [],
    title: [],
    upper: [],
    fold: 1163,
    foldFull: [1163]
  }, {
    code: 1164,
    lower: [],
    title: [],
    upper: [],
    fold: 1165,
    foldFull: [1165]
  }, {
    code: 1166,
    lower: [],
    title: [],
    upper: [],
    fold: 1167,
    foldFull: [1167]
  }, {
    code: 1168,
    lower: [],
    title: [],
    upper: [],
    fold: 1169,
    foldFull: [1169]
  }, {
    code: 1170,
    lower: [],
    title: [],
    upper: [],
    fold: 1171,
    foldFull: [1171]
  }, {
    code: 1172,
    lower: [],
    title: [],
    upper: [],
    fold: 1173,
    foldFull: [1173]
  }, {
    code: 1174,
    lower: [],
    title: [],
    upper: [],
    fold: 1175,
    foldFull: [1175]
  }, {
    code: 1176,
    lower: [],
    title: [],
    upper: [],
    fold: 1177,
    foldFull: [1177]
  }, {
    code: 1178,
    lower: [],
    title: [],
    upper: [],
    fold: 1179,
    foldFull: [1179]
  }, {
    code: 1180,
    lower: [],
    title: [],
    upper: [],
    fold: 1181,
    foldFull: [1181]
  }, {
    code: 1182,
    lower: [],
    title: [],
    upper: [],
    fold: 1183,
    foldFull: [1183]
  }, {
    code: 1184,
    lower: [],
    title: [],
    upper: [],
    fold: 1185,
    foldFull: [1185]
  }, {
    code: 1186,
    lower: [],
    title: [],
    upper: [],
    fold: 1187,
    foldFull: [1187]
  }, {
    code: 1188,
    lower: [],
    title: [],
    upper: [],
    fold: 1189,
    foldFull: [1189]
  }, {
    code: 1190,
    lower: [],
    title: [],
    upper: [],
    fold: 1191,
    foldFull: [1191]
  }, {
    code: 1192,
    lower: [],
    title: [],
    upper: [],
    fold: 1193,
    foldFull: [1193]
  }, {
    code: 1194,
    lower: [],
    title: [],
    upper: [],
    fold: 1195,
    foldFull: [1195]
  }, {
    code: 1196,
    lower: [],
    title: [],
    upper: [],
    fold: 1197,
    foldFull: [1197]
  }, {
    code: 1198,
    lower: [],
    title: [],
    upper: [],
    fold: 1199,
    foldFull: [1199]
  }, {
    code: 1200,
    lower: [],
    title: [],
    upper: [],
    fold: 1201,
    foldFull: [1201]
  }, {
    code: 1202,
    lower: [],
    title: [],
    upper: [],
    fold: 1203,
    foldFull: [1203]
  }, {
    code: 1204,
    lower: [],
    title: [],
    upper: [],
    fold: 1205,
    foldFull: [1205]
  }, {
    code: 1206,
    lower: [],
    title: [],
    upper: [],
    fold: 1207,
    foldFull: [1207]
  }, {
    code: 1208,
    lower: [],
    title: [],
    upper: [],
    fold: 1209,
    foldFull: [1209]
  }, {
    code: 1210,
    lower: [],
    title: [],
    upper: [],
    fold: 1211,
    foldFull: [1211]
  }, {
    code: 1212,
    lower: [],
    title: [],
    upper: [],
    fold: 1213,
    foldFull: [1213]
  }, {
    code: 1214,
    lower: [],
    title: [],
    upper: [],
    fold: 1215,
    foldFull: [1215]
  }, {
    code: 1216,
    lower: [],
    title: [],
    upper: [],
    fold: 1231,
    foldFull: [1231]
  }, {
    code: 1217,
    lower: [],
    title: [],
    upper: [],
    fold: 1218,
    foldFull: [1218]
  }, {
    code: 1219,
    lower: [],
    title: [],
    upper: [],
    fold: 1220,
    foldFull: [1220]
  }, {
    code: 1221,
    lower: [],
    title: [],
    upper: [],
    fold: 1222,
    foldFull: [1222]
  }, {
    code: 1223,
    lower: [],
    title: [],
    upper: [],
    fold: 1224,
    foldFull: [1224]
  }, {
    code: 1225,
    lower: [],
    title: [],
    upper: [],
    fold: 1226,
    foldFull: [1226]
  }, {
    code: 1227,
    lower: [],
    title: [],
    upper: [],
    fold: 1228,
    foldFull: [1228]
  }, {
    code: 1229,
    lower: [],
    title: [],
    upper: [],
    fold: 1230,
    foldFull: [1230]
  }, {
    code: 1232,
    lower: [],
    title: [],
    upper: [],
    fold: 1233,
    foldFull: [1233]
  }, {
    code: 1234,
    lower: [],
    title: [],
    upper: [],
    fold: 1235,
    foldFull: [1235]
  }, {
    code: 1236,
    lower: [],
    title: [],
    upper: [],
    fold: 1237,
    foldFull: [1237]
  }, {
    code: 1238,
    lower: [],
    title: [],
    upper: [],
    fold: 1239,
    foldFull: [1239]
  }, {
    code: 1240,
    lower: [],
    title: [],
    upper: [],
    fold: 1241,
    foldFull: [1241]
  }, {
    code: 1242,
    lower: [],
    title: [],
    upper: [],
    fold: 1243,
    foldFull: [1243]
  }, {
    code: 1244,
    lower: [],
    title: [],
    upper: [],
    fold: 1245,
    foldFull: [1245]
  }, {
    code: 1246,
    lower: [],
    title: [],
    upper: [],
    fold: 1247,
    foldFull: [1247]
  }, {
    code: 1248,
    lower: [],
    title: [],
    upper: [],
    fold: 1249,
    foldFull: [1249]
  }, {
    code: 1250,
    lower: [],
    title: [],
    upper: [],
    fold: 1251,
    foldFull: [1251]
  }, {
    code: 1252,
    lower: [],
    title: [],
    upper: [],
    fold: 1253,
    foldFull: [1253]
  }, {
    code: 1254,
    lower: [],
    title: [],
    upper: [],
    fold: 1255,
    foldFull: [1255]
  }, {
    code: 1256,
    lower: [],
    title: [],
    upper: [],
    fold: 1257,
    foldFull: [1257]
  }, {
    code: 1258,
    lower: [],
    title: [],
    upper: [],
    fold: 1259,
    foldFull: [1259]
  }, {
    code: 1260,
    lower: [],
    title: [],
    upper: [],
    fold: 1261,
    foldFull: [1261]
  }, {
    code: 1262,
    lower: [],
    title: [],
    upper: [],
    fold: 1263,
    foldFull: [1263]
  }, {
    code: 1264,
    lower: [],
    title: [],
    upper: [],
    fold: 1265,
    foldFull: [1265]
  }, {
    code: 1266,
    lower: [],
    title: [],
    upper: [],
    fold: 1267,
    foldFull: [1267]
  }, {
    code: 1268,
    lower: [],
    title: [],
    upper: [],
    fold: 1269,
    foldFull: [1269]
  }, {
    code: 1270,
    lower: [],
    title: [],
    upper: [],
    fold: 1271,
    foldFull: [1271]
  }, {
    code: 1272,
    lower: [],
    title: [],
    upper: [],
    fold: 1273,
    foldFull: [1273]
  }, {
    code: 1274,
    lower: [],
    title: [],
    upper: [],
    fold: 1275,
    foldFull: [1275]
  }, {
    code: 1276,
    lower: [],
    title: [],
    upper: [],
    fold: 1277,
    foldFull: [1277]
  }, {
    code: 1278,
    lower: [],
    title: [],
    upper: [],
    fold: 1279,
    foldFull: [1279]
  }, {
    code: 1280,
    lower: [],
    title: [],
    upper: [],
    fold: 1281,
    foldFull: [1281]
  }, {
    code: 1282,
    lower: [],
    title: [],
    upper: [],
    fold: 1283,
    foldFull: [1283]
  }, {
    code: 1284,
    lower: [],
    title: [],
    upper: [],
    fold: 1285,
    foldFull: [1285]
  }, {
    code: 1286,
    lower: [],
    title: [],
    upper: [],
    fold: 1287,
    foldFull: [1287]
  }, {
    code: 1288,
    lower: [],
    title: [],
    upper: [],
    fold: 1289,
    foldFull: [1289]
  }, {
    code: 1290,
    lower: [],
    title: [],
    upper: [],
    fold: 1291,
    foldFull: [1291]
  }, {
    code: 1292,
    lower: [],
    title: [],
    upper: [],
    fold: 1293,
    foldFull: [1293]
  }, {
    code: 1294,
    lower: [],
    title: [],
    upper: [],
    fold: 1295,
    foldFull: [1295]
  }, {
    code: 1296,
    lower: [],
    title: [],
    upper: [],
    fold: 1297,
    foldFull: [1297]
  }, {
    code: 1298,
    lower: [],
    title: [],
    upper: [],
    fold: 1299,
    foldFull: [1299]
  }, {
    code: 1300,
    lower: [],
    title: [],
    upper: [],
    fold: 1301,
    foldFull: [1301]
  }, {
    code: 1302,
    lower: [],
    title: [],
    upper: [],
    fold: 1303,
    foldFull: [1303]
  }, {
    code: 1304,
    lower: [],
    title: [],
    upper: [],
    fold: 1305,
    foldFull: [1305]
  }, {
    code: 1306,
    lower: [],
    title: [],
    upper: [],
    fold: 1307,
    foldFull: [1307]
  }, {
    code: 1308,
    lower: [],
    title: [],
    upper: [],
    fold: 1309,
    foldFull: [1309]
  }, {
    code: 1310,
    lower: [],
    title: [],
    upper: [],
    fold: 1311,
    foldFull: [1311]
  }, {
    code: 1312,
    lower: [],
    title: [],
    upper: [],
    fold: 1313,
    foldFull: [1313]
  }, {
    code: 1314,
    lower: [],
    title: [],
    upper: [],
    fold: 1315,
    foldFull: [1315]
  }, {
    code: 1316,
    lower: [],
    title: [],
    upper: [],
    fold: 1317,
    foldFull: [1317]
  }, {
    code: 1318,
    lower: [],
    title: [],
    upper: [],
    fold: 1319,
    foldFull: [1319]
  }, {
    code: 1320,
    lower: [],
    title: [],
    upper: [],
    fold: 1321,
    foldFull: [1321]
  }, {
    code: 1322,
    lower: [],
    title: [],
    upper: [],
    fold: 1323,
    foldFull: [1323]
  }, {
    code: 1324,
    lower: [],
    title: [],
    upper: [],
    fold: 1325,
    foldFull: [1325]
  }, {
    code: 1326,
    lower: [],
    title: [],
    upper: [],
    fold: 1327,
    foldFull: [1327]
  }, {
    code: 1329,
    lower: [],
    title: [],
    upper: [],
    fold: 1377,
    foldFull: [1377]
  }, {
    code: 1330,
    lower: [],
    title: [],
    upper: [],
    fold: 1378,
    foldFull: [1378]
  }, {
    code: 1331,
    lower: [],
    title: [],
    upper: [],
    fold: 1379,
    foldFull: [1379]
  }, {
    code: 1332,
    lower: [],
    title: [],
    upper: [],
    fold: 1380,
    foldFull: [1380]
  }, {
    code: 1333,
    lower: [],
    title: [],
    upper: [],
    fold: 1381,
    foldFull: [1381]
  }, {
    code: 1334,
    lower: [],
    title: [],
    upper: [],
    fold: 1382,
    foldFull: [1382]
  }, {
    code: 1335,
    lower: [],
    title: [],
    upper: [],
    fold: 1383,
    foldFull: [1383]
  }, {
    code: 1336,
    lower: [],
    title: [],
    upper: [],
    fold: 1384,
    foldFull: [1384]
  }, {
    code: 1337,
    lower: [],
    title: [],
    upper: [],
    fold: 1385,
    foldFull: [1385]
  }, {
    code: 1338,
    lower: [],
    title: [],
    upper: [],
    fold: 1386,
    foldFull: [1386]
  }, {
    code: 1339,
    lower: [],
    title: [],
    upper: [],
    fold: 1387,
    foldFull: [1387]
  }, {
    code: 1340,
    lower: [],
    title: [],
    upper: [],
    fold: 1388,
    foldFull: [1388]
  }, {
    code: 1341,
    lower: [],
    title: [],
    upper: [],
    fold: 1389,
    foldFull: [1389]
  }, {
    code: 1342,
    lower: [],
    title: [],
    upper: [],
    fold: 1390,
    foldFull: [1390]
  }, {
    code: 1343,
    lower: [],
    title: [],
    upper: [],
    fold: 1391,
    foldFull: [1391]
  }, {
    code: 1344,
    lower: [],
    title: [],
    upper: [],
    fold: 1392,
    foldFull: [1392]
  }, {
    code: 1345,
    lower: [],
    title: [],
    upper: [],
    fold: 1393,
    foldFull: [1393]
  }, {
    code: 1346,
    lower: [],
    title: [],
    upper: [],
    fold: 1394,
    foldFull: [1394]
  }, {
    code: 1347,
    lower: [],
    title: [],
    upper: [],
    fold: 1395,
    foldFull: [1395]
  }, {
    code: 1348,
    lower: [],
    title: [],
    upper: [],
    fold: 1396,
    foldFull: [1396]
  }, {
    code: 1349,
    lower: [],
    title: [],
    upper: [],
    fold: 1397,
    foldFull: [1397]
  }, {
    code: 1350,
    lower: [],
    title: [],
    upper: [],
    fold: 1398,
    foldFull: [1398]
  }, {
    code: 1351,
    lower: [],
    title: [],
    upper: [],
    fold: 1399,
    foldFull: [1399]
  }, {
    code: 1352,
    lower: [],
    title: [],
    upper: [],
    fold: 1400,
    foldFull: [1400]
  }, {
    code: 1353,
    lower: [],
    title: [],
    upper: [],
    fold: 1401,
    foldFull: [1401]
  }, {
    code: 1354,
    lower: [],
    title: [],
    upper: [],
    fold: 1402,
    foldFull: [1402]
  }, {
    code: 1355,
    lower: [],
    title: [],
    upper: [],
    fold: 1403,
    foldFull: [1403]
  }, {
    code: 1356,
    lower: [],
    title: [],
    upper: [],
    fold: 1404,
    foldFull: [1404]
  }, {
    code: 1357,
    lower: [],
    title: [],
    upper: [],
    fold: 1405,
    foldFull: [1405]
  }, {
    code: 1358,
    lower: [],
    title: [],
    upper: [],
    fold: 1406,
    foldFull: [1406]
  }, {
    code: 1359,
    lower: [],
    title: [],
    upper: [],
    fold: 1407,
    foldFull: [1407]
  }, {
    code: 1360,
    lower: [],
    title: [],
    upper: [],
    fold: 1408,
    foldFull: [1408]
  }, {
    code: 1361,
    lower: [],
    title: [],
    upper: [],
    fold: 1409,
    foldFull: [1409]
  }, {
    code: 1362,
    lower: [],
    title: [],
    upper: [],
    fold: 1410,
    foldFull: [1410]
  }, {
    code: 1363,
    lower: [],
    title: [],
    upper: [],
    fold: 1411,
    foldFull: [1411]
  }, {
    code: 1364,
    lower: [],
    title: [],
    upper: [],
    fold: 1412,
    foldFull: [1412]
  }, {
    code: 1365,
    lower: [],
    title: [],
    upper: [],
    fold: 1413,
    foldFull: [1413]
  }, {
    code: 1366,
    lower: [],
    title: [],
    upper: [],
    fold: 1414,
    foldFull: [1414]
  }, {
    code: 1415,
    lower: [1415],
    title: [1333, 1410],
    upper: [1333, 1362],
    fold: 0,
    foldFull: [1381, 1410]
  }, {
    code: 1415,
    lower: [1415],
    title: [1333, 1410],
    upper: [1333, 1362],
    fold: 0,
    foldFull: [1381, 1410]
  }, {
    code: 4256,
    lower: [],
    title: [],
    upper: [],
    fold: 11520,
    foldFull: [11520]
  }, {
    code: 4257,
    lower: [],
    title: [],
    upper: [],
    fold: 11521,
    foldFull: [11521]
  }, {
    code: 4258,
    lower: [],
    title: [],
    upper: [],
    fold: 11522,
    foldFull: [11522]
  }, {
    code: 4259,
    lower: [],
    title: [],
    upper: [],
    fold: 11523,
    foldFull: [11523]
  }, {
    code: 4260,
    lower: [],
    title: [],
    upper: [],
    fold: 11524,
    foldFull: [11524]
  }, {
    code: 4261,
    lower: [],
    title: [],
    upper: [],
    fold: 11525,
    foldFull: [11525]
  }, {
    code: 4262,
    lower: [],
    title: [],
    upper: [],
    fold: 11526,
    foldFull: [11526]
  }, {
    code: 4263,
    lower: [],
    title: [],
    upper: [],
    fold: 11527,
    foldFull: [11527]
  }, {
    code: 4264,
    lower: [],
    title: [],
    upper: [],
    fold: 11528,
    foldFull: [11528]
  }, {
    code: 4265,
    lower: [],
    title: [],
    upper: [],
    fold: 11529,
    foldFull: [11529]
  }, {
    code: 4266,
    lower: [],
    title: [],
    upper: [],
    fold: 11530,
    foldFull: [11530]
  }, {
    code: 4267,
    lower: [],
    title: [],
    upper: [],
    fold: 11531,
    foldFull: [11531]
  }, {
    code: 4268,
    lower: [],
    title: [],
    upper: [],
    fold: 11532,
    foldFull: [11532]
  }, {
    code: 4269,
    lower: [],
    title: [],
    upper: [],
    fold: 11533,
    foldFull: [11533]
  }, {
    code: 4270,
    lower: [],
    title: [],
    upper: [],
    fold: 11534,
    foldFull: [11534]
  }, {
    code: 4271,
    lower: [],
    title: [],
    upper: [],
    fold: 11535,
    foldFull: [11535]
  }, {
    code: 4272,
    lower: [],
    title: [],
    upper: [],
    fold: 11536,
    foldFull: [11536]
  }, {
    code: 4273,
    lower: [],
    title: [],
    upper: [],
    fold: 11537,
    foldFull: [11537]
  }, {
    code: 4274,
    lower: [],
    title: [],
    upper: [],
    fold: 11538,
    foldFull: [11538]
  }, {
    code: 4275,
    lower: [],
    title: [],
    upper: [],
    fold: 11539,
    foldFull: [11539]
  }, {
    code: 4276,
    lower: [],
    title: [],
    upper: [],
    fold: 11540,
    foldFull: [11540]
  }, {
    code: 4277,
    lower: [],
    title: [],
    upper: [],
    fold: 11541,
    foldFull: [11541]
  }, {
    code: 4278,
    lower: [],
    title: [],
    upper: [],
    fold: 11542,
    foldFull: [11542]
  }, {
    code: 4279,
    lower: [],
    title: [],
    upper: [],
    fold: 11543,
    foldFull: [11543]
  }, {
    code: 4280,
    lower: [],
    title: [],
    upper: [],
    fold: 11544,
    foldFull: [11544]
  }, {
    code: 4281,
    lower: [],
    title: [],
    upper: [],
    fold: 11545,
    foldFull: [11545]
  }, {
    code: 4282,
    lower: [],
    title: [],
    upper: [],
    fold: 11546,
    foldFull: [11546]
  }, {
    code: 4283,
    lower: [],
    title: [],
    upper: [],
    fold: 11547,
    foldFull: [11547]
  }, {
    code: 4284,
    lower: [],
    title: [],
    upper: [],
    fold: 11548,
    foldFull: [11548]
  }, {
    code: 4285,
    lower: [],
    title: [],
    upper: [],
    fold: 11549,
    foldFull: [11549]
  }, {
    code: 4286,
    lower: [],
    title: [],
    upper: [],
    fold: 11550,
    foldFull: [11550]
  }, {
    code: 4287,
    lower: [],
    title: [],
    upper: [],
    fold: 11551,
    foldFull: [11551]
  }, {
    code: 4288,
    lower: [],
    title: [],
    upper: [],
    fold: 11552,
    foldFull: [11552]
  }, {
    code: 4289,
    lower: [],
    title: [],
    upper: [],
    fold: 11553,
    foldFull: [11553]
  }, {
    code: 4290,
    lower: [],
    title: [],
    upper: [],
    fold: 11554,
    foldFull: [11554]
  }, {
    code: 4291,
    lower: [],
    title: [],
    upper: [],
    fold: 11555,
    foldFull: [11555]
  }, {
    code: 4292,
    lower: [],
    title: [],
    upper: [],
    fold: 11556,
    foldFull: [11556]
  }, {
    code: 4293,
    lower: [],
    title: [],
    upper: [],
    fold: 11557,
    foldFull: [11557]
  }, {
    code: 4295,
    lower: [],
    title: [],
    upper: [],
    fold: 11559,
    foldFull: [11559]
  }, {
    code: 4301,
    lower: [],
    title: [],
    upper: [],
    fold: 11565,
    foldFull: [11565]
  }, {
    code: 5112,
    lower: [],
    title: [],
    upper: [],
    fold: 5104,
    foldFull: [5104]
  }, {
    code: 5113,
    lower: [],
    title: [],
    upper: [],
    fold: 5105,
    foldFull: [5105]
  }, {
    code: 5114,
    lower: [],
    title: [],
    upper: [],
    fold: 5106,
    foldFull: [5106]
  }, {
    code: 5115,
    lower: [],
    title: [],
    upper: [],
    fold: 5107,
    foldFull: [5107]
  }, {
    code: 5116,
    lower: [],
    title: [],
    upper: [],
    fold: 5108,
    foldFull: [5108]
  }, {
    code: 5117,
    lower: [],
    title: [],
    upper: [],
    fold: 5109,
    foldFull: [5109]
  }, {
    code: 7296,
    lower: [],
    title: [],
    upper: [],
    fold: 1074,
    foldFull: [1074]
  }, {
    code: 7297,
    lower: [],
    title: [],
    upper: [],
    fold: 1076,
    foldFull: [1076]
  }, {
    code: 7298,
    lower: [],
    title: [],
    upper: [],
    fold: 1086,
    foldFull: [1086]
  }, {
    code: 7299,
    lower: [],
    title: [],
    upper: [],
    fold: 1089,
    foldFull: [1089]
  }, {
    code: 7300,
    lower: [],
    title: [],
    upper: [],
    fold: 1090,
    foldFull: [1090]
  }, {
    code: 7301,
    lower: [],
    title: [],
    upper: [],
    fold: 1090,
    foldFull: [1090]
  }, {
    code: 7302,
    lower: [],
    title: [],
    upper: [],
    fold: 1098,
    foldFull: [1098]
  }, {
    code: 7303,
    lower: [],
    title: [],
    upper: [],
    fold: 1123,
    foldFull: [1123]
  }, {
    code: 7304,
    lower: [],
    title: [],
    upper: [],
    fold: 42571,
    foldFull: [42571]
  }, {
    code: 7312,
    lower: [],
    title: [],
    upper: [],
    fold: 4304,
    foldFull: [4304]
  }, {
    code: 7313,
    lower: [],
    title: [],
    upper: [],
    fold: 4305,
    foldFull: [4305]
  }, {
    code: 7314,
    lower: [],
    title: [],
    upper: [],
    fold: 4306,
    foldFull: [4306]
  }, {
    code: 7315,
    lower: [],
    title: [],
    upper: [],
    fold: 4307,
    foldFull: [4307]
  }, {
    code: 7316,
    lower: [],
    title: [],
    upper: [],
    fold: 4308,
    foldFull: [4308]
  }, {
    code: 7317,
    lower: [],
    title: [],
    upper: [],
    fold: 4309,
    foldFull: [4309]
  }, {
    code: 7318,
    lower: [],
    title: [],
    upper: [],
    fold: 4310,
    foldFull: [4310]
  }, {
    code: 7319,
    lower: [],
    title: [],
    upper: [],
    fold: 4311,
    foldFull: [4311]
  }, {
    code: 7320,
    lower: [],
    title: [],
    upper: [],
    fold: 4312,
    foldFull: [4312]
  }, {
    code: 7321,
    lower: [],
    title: [],
    upper: [],
    fold: 4313,
    foldFull: [4313]
  }, {
    code: 7322,
    lower: [],
    title: [],
    upper: [],
    fold: 4314,
    foldFull: [4314]
  }, {
    code: 7323,
    lower: [],
    title: [],
    upper: [],
    fold: 4315,
    foldFull: [4315]
  }, {
    code: 7324,
    lower: [],
    title: [],
    upper: [],
    fold: 4316,
    foldFull: [4316]
  }, {
    code: 7325,
    lower: [],
    title: [],
    upper: [],
    fold: 4317,
    foldFull: [4317]
  }, {
    code: 7326,
    lower: [],
    title: [],
    upper: [],
    fold: 4318,
    foldFull: [4318]
  }, {
    code: 7327,
    lower: [],
    title: [],
    upper: [],
    fold: 4319,
    foldFull: [4319]
  }, {
    code: 7328,
    lower: [],
    title: [],
    upper: [],
    fold: 4320,
    foldFull: [4320]
  }, {
    code: 7329,
    lower: [],
    title: [],
    upper: [],
    fold: 4321,
    foldFull: [4321]
  }, {
    code: 7330,
    lower: [],
    title: [],
    upper: [],
    fold: 4322,
    foldFull: [4322]
  }, {
    code: 7331,
    lower: [],
    title: [],
    upper: [],
    fold: 4323,
    foldFull: [4323]
  }, {
    code: 7332,
    lower: [],
    title: [],
    upper: [],
    fold: 4324,
    foldFull: [4324]
  }, {
    code: 7333,
    lower: [],
    title: [],
    upper: [],
    fold: 4325,
    foldFull: [4325]
  }, {
    code: 7334,
    lower: [],
    title: [],
    upper: [],
    fold: 4326,
    foldFull: [4326]
  }, {
    code: 7335,
    lower: [],
    title: [],
    upper: [],
    fold: 4327,
    foldFull: [4327]
  }, {
    code: 7336,
    lower: [],
    title: [],
    upper: [],
    fold: 4328,
    foldFull: [4328]
  }, {
    code: 7337,
    lower: [],
    title: [],
    upper: [],
    fold: 4329,
    foldFull: [4329]
  }, {
    code: 7338,
    lower: [],
    title: [],
    upper: [],
    fold: 4330,
    foldFull: [4330]
  }, {
    code: 7339,
    lower: [],
    title: [],
    upper: [],
    fold: 4331,
    foldFull: [4331]
  }, {
    code: 7340,
    lower: [],
    title: [],
    upper: [],
    fold: 4332,
    foldFull: [4332]
  }, {
    code: 7341,
    lower: [],
    title: [],
    upper: [],
    fold: 4333,
    foldFull: [4333]
  }, {
    code: 7342,
    lower: [],
    title: [],
    upper: [],
    fold: 4334,
    foldFull: [4334]
  }, {
    code: 7343,
    lower: [],
    title: [],
    upper: [],
    fold: 4335,
    foldFull: [4335]
  }, {
    code: 7344,
    lower: [],
    title: [],
    upper: [],
    fold: 4336,
    foldFull: [4336]
  }, {
    code: 7345,
    lower: [],
    title: [],
    upper: [],
    fold: 4337,
    foldFull: [4337]
  }, {
    code: 7346,
    lower: [],
    title: [],
    upper: [],
    fold: 4338,
    foldFull: [4338]
  }, {
    code: 7347,
    lower: [],
    title: [],
    upper: [],
    fold: 4339,
    foldFull: [4339]
  }, {
    code: 7348,
    lower: [],
    title: [],
    upper: [],
    fold: 4340,
    foldFull: [4340]
  }, {
    code: 7349,
    lower: [],
    title: [],
    upper: [],
    fold: 4341,
    foldFull: [4341]
  }, {
    code: 7350,
    lower: [],
    title: [],
    upper: [],
    fold: 4342,
    foldFull: [4342]
  }, {
    code: 7351,
    lower: [],
    title: [],
    upper: [],
    fold: 4343,
    foldFull: [4343]
  }, {
    code: 7352,
    lower: [],
    title: [],
    upper: [],
    fold: 4344,
    foldFull: [4344]
  }, {
    code: 7353,
    lower: [],
    title: [],
    upper: [],
    fold: 4345,
    foldFull: [4345]
  }, {
    code: 7354,
    lower: [],
    title: [],
    upper: [],
    fold: 4346,
    foldFull: [4346]
  }, {
    code: 7357,
    lower: [],
    title: [],
    upper: [],
    fold: 4349,
    foldFull: [4349]
  }, {
    code: 7358,
    lower: [],
    title: [],
    upper: [],
    fold: 4350,
    foldFull: [4350]
  }, {
    code: 7359,
    lower: [],
    title: [],
    upper: [],
    fold: 4351,
    foldFull: [4351]
  }, {
    code: 7680,
    lower: [],
    title: [],
    upper: [],
    fold: 7681,
    foldFull: [7681]
  }, {
    code: 7682,
    lower: [],
    title: [],
    upper: [],
    fold: 7683,
    foldFull: [7683]
  }, {
    code: 7684,
    lower: [],
    title: [],
    upper: [],
    fold: 7685,
    foldFull: [7685]
  }, {
    code: 7686,
    lower: [],
    title: [],
    upper: [],
    fold: 7687,
    foldFull: [7687]
  }, {
    code: 7688,
    lower: [],
    title: [],
    upper: [],
    fold: 7689,
    foldFull: [7689]
  }, {
    code: 7690,
    lower: [],
    title: [],
    upper: [],
    fold: 7691,
    foldFull: [7691]
  }, {
    code: 7692,
    lower: [],
    title: [],
    upper: [],
    fold: 7693,
    foldFull: [7693]
  }, {
    code: 7694,
    lower: [],
    title: [],
    upper: [],
    fold: 7695,
    foldFull: [7695]
  }, {
    code: 7696,
    lower: [],
    title: [],
    upper: [],
    fold: 7697,
    foldFull: [7697]
  }, {
    code: 7698,
    lower: [],
    title: [],
    upper: [],
    fold: 7699,
    foldFull: [7699]
  }, {
    code: 7700,
    lower: [],
    title: [],
    upper: [],
    fold: 7701,
    foldFull: [7701]
  }, {
    code: 7702,
    lower: [],
    title: [],
    upper: [],
    fold: 7703,
    foldFull: [7703]
  }, {
    code: 7704,
    lower: [],
    title: [],
    upper: [],
    fold: 7705,
    foldFull: [7705]
  }, {
    code: 7706,
    lower: [],
    title: [],
    upper: [],
    fold: 7707,
    foldFull: [7707]
  }, {
    code: 7708,
    lower: [],
    title: [],
    upper: [],
    fold: 7709,
    foldFull: [7709]
  }, {
    code: 7710,
    lower: [],
    title: [],
    upper: [],
    fold: 7711,
    foldFull: [7711]
  }, {
    code: 7712,
    lower: [],
    title: [],
    upper: [],
    fold: 7713,
    foldFull: [7713]
  }, {
    code: 7714,
    lower: [],
    title: [],
    upper: [],
    fold: 7715,
    foldFull: [7715]
  }, {
    code: 7716,
    lower: [],
    title: [],
    upper: [],
    fold: 7717,
    foldFull: [7717]
  }, {
    code: 7718,
    lower: [],
    title: [],
    upper: [],
    fold: 7719,
    foldFull: [7719]
  }, {
    code: 7720,
    lower: [],
    title: [],
    upper: [],
    fold: 7721,
    foldFull: [7721]
  }, {
    code: 7722,
    lower: [],
    title: [],
    upper: [],
    fold: 7723,
    foldFull: [7723]
  }, {
    code: 7724,
    lower: [],
    title: [],
    upper: [],
    fold: 7725,
    foldFull: [7725]
  }, {
    code: 7726,
    lower: [],
    title: [],
    upper: [],
    fold: 7727,
    foldFull: [7727]
  }, {
    code: 7728,
    lower: [],
    title: [],
    upper: [],
    fold: 7729,
    foldFull: [7729]
  }, {
    code: 7730,
    lower: [],
    title: [],
    upper: [],
    fold: 7731,
    foldFull: [7731]
  }, {
    code: 7732,
    lower: [],
    title: [],
    upper: [],
    fold: 7733,
    foldFull: [7733]
  }, {
    code: 7734,
    lower: [],
    title: [],
    upper: [],
    fold: 7735,
    foldFull: [7735]
  }, {
    code: 7736,
    lower: [],
    title: [],
    upper: [],
    fold: 7737,
    foldFull: [7737]
  }, {
    code: 7738,
    lower: [],
    title: [],
    upper: [],
    fold: 7739,
    foldFull: [7739]
  }, {
    code: 7740,
    lower: [],
    title: [],
    upper: [],
    fold: 7741,
    foldFull: [7741]
  }, {
    code: 7742,
    lower: [],
    title: [],
    upper: [],
    fold: 7743,
    foldFull: [7743]
  }, {
    code: 7744,
    lower: [],
    title: [],
    upper: [],
    fold: 7745,
    foldFull: [7745]
  }, {
    code: 7746,
    lower: [],
    title: [],
    upper: [],
    fold: 7747,
    foldFull: [7747]
  }, {
    code: 7748,
    lower: [],
    title: [],
    upper: [],
    fold: 7749,
    foldFull: [7749]
  }, {
    code: 7750,
    lower: [],
    title: [],
    upper: [],
    fold: 7751,
    foldFull: [7751]
  }, {
    code: 7752,
    lower: [],
    title: [],
    upper: [],
    fold: 7753,
    foldFull: [7753]
  }, {
    code: 7754,
    lower: [],
    title: [],
    upper: [],
    fold: 7755,
    foldFull: [7755]
  }, {
    code: 7756,
    lower: [],
    title: [],
    upper: [],
    fold: 7757,
    foldFull: [7757]
  }, {
    code: 7758,
    lower: [],
    title: [],
    upper: [],
    fold: 7759,
    foldFull: [7759]
  }, {
    code: 7760,
    lower: [],
    title: [],
    upper: [],
    fold: 7761,
    foldFull: [7761]
  }, {
    code: 7762,
    lower: [],
    title: [],
    upper: [],
    fold: 7763,
    foldFull: [7763]
  }, {
    code: 7764,
    lower: [],
    title: [],
    upper: [],
    fold: 7765,
    foldFull: [7765]
  }, {
    code: 7766,
    lower: [],
    title: [],
    upper: [],
    fold: 7767,
    foldFull: [7767]
  }, {
    code: 7768,
    lower: [],
    title: [],
    upper: [],
    fold: 7769,
    foldFull: [7769]
  }, {
    code: 7770,
    lower: [],
    title: [],
    upper: [],
    fold: 7771,
    foldFull: [7771]
  }, {
    code: 7772,
    lower: [],
    title: [],
    upper: [],
    fold: 7773,
    foldFull: [7773]
  }, {
    code: 7774,
    lower: [],
    title: [],
    upper: [],
    fold: 7775,
    foldFull: [7775]
  }, {
    code: 7776,
    lower: [],
    title: [],
    upper: [],
    fold: 7777,
    foldFull: [7777]
  }, {
    code: 7778,
    lower: [],
    title: [],
    upper: [],
    fold: 7779,
    foldFull: [7779]
  }, {
    code: 7780,
    lower: [],
    title: [],
    upper: [],
    fold: 7781,
    foldFull: [7781]
  }, {
    code: 7782,
    lower: [],
    title: [],
    upper: [],
    fold: 7783,
    foldFull: [7783]
  }, {
    code: 7784,
    lower: [],
    title: [],
    upper: [],
    fold: 7785,
    foldFull: [7785]
  }, {
    code: 7786,
    lower: [],
    title: [],
    upper: [],
    fold: 7787,
    foldFull: [7787]
  }, {
    code: 7788,
    lower: [],
    title: [],
    upper: [],
    fold: 7789,
    foldFull: [7789]
  }, {
    code: 7790,
    lower: [],
    title: [],
    upper: [],
    fold: 7791,
    foldFull: [7791]
  }, {
    code: 7792,
    lower: [],
    title: [],
    upper: [],
    fold: 7793,
    foldFull: [7793]
  }, {
    code: 7794,
    lower: [],
    title: [],
    upper: [],
    fold: 7795,
    foldFull: [7795]
  }, {
    code: 7796,
    lower: [],
    title: [],
    upper: [],
    fold: 7797,
    foldFull: [7797]
  }, {
    code: 7798,
    lower: [],
    title: [],
    upper: [],
    fold: 7799,
    foldFull: [7799]
  }, {
    code: 7800,
    lower: [],
    title: [],
    upper: [],
    fold: 7801,
    foldFull: [7801]
  }, {
    code: 7802,
    lower: [],
    title: [],
    upper: [],
    fold: 7803,
    foldFull: [7803]
  }, {
    code: 7804,
    lower: [],
    title: [],
    upper: [],
    fold: 7805,
    foldFull: [7805]
  }, {
    code: 7806,
    lower: [],
    title: [],
    upper: [],
    fold: 7807,
    foldFull: [7807]
  }, {
    code: 7808,
    lower: [],
    title: [],
    upper: [],
    fold: 7809,
    foldFull: [7809]
  }, {
    code: 7810,
    lower: [],
    title: [],
    upper: [],
    fold: 7811,
    foldFull: [7811]
  }, {
    code: 7812,
    lower: [],
    title: [],
    upper: [],
    fold: 7813,
    foldFull: [7813]
  }, {
    code: 7814,
    lower: [],
    title: [],
    upper: [],
    fold: 7815,
    foldFull: [7815]
  }, {
    code: 7816,
    lower: [],
    title: [],
    upper: [],
    fold: 7817,
    foldFull: [7817]
  }, {
    code: 7818,
    lower: [],
    title: [],
    upper: [],
    fold: 7819,
    foldFull: [7819]
  }, {
    code: 7820,
    lower: [],
    title: [],
    upper: [],
    fold: 7821,
    foldFull: [7821]
  }, {
    code: 7822,
    lower: [],
    title: [],
    upper: [],
    fold: 7823,
    foldFull: [7823]
  }, {
    code: 7824,
    lower: [],
    title: [],
    upper: [],
    fold: 7825,
    foldFull: [7825]
  }, {
    code: 7826,
    lower: [],
    title: [],
    upper: [],
    fold: 7827,
    foldFull: [7827]
  }, {
    code: 7828,
    lower: [],
    title: [],
    upper: [],
    fold: 7829,
    foldFull: [7829]
  }, {
    code: 7830,
    lower: [7830],
    title: [72, 817],
    upper: [72, 817],
    fold: 0,
    foldFull: [104, 817]
  }, {
    code: 7830,
    lower: [7830],
    title: [72, 817],
    upper: [72, 817],
    fold: 0,
    foldFull: [104, 817]
  }, {
    code: 7831,
    lower: [7831],
    title: [84, 776],
    upper: [84, 776],
    fold: 0,
    foldFull: [116, 776]
  }, {
    code: 7831,
    lower: [7831],
    title: [84, 776],
    upper: [84, 776],
    fold: 0,
    foldFull: [116, 776]
  }, {
    code: 7832,
    lower: [7832],
    title: [87, 778],
    upper: [87, 778],
    fold: 0,
    foldFull: [119, 778]
  }, {
    code: 7832,
    lower: [7832],
    title: [87, 778],
    upper: [87, 778],
    fold: 0,
    foldFull: [119, 778]
  }, {
    code: 7833,
    lower: [7833],
    title: [89, 778],
    upper: [89, 778],
    fold: 0,
    foldFull: [121, 778]
  }, {
    code: 7833,
    lower: [7833],
    title: [89, 778],
    upper: [89, 778],
    fold: 0,
    foldFull: [121, 778]
  }, {
    code: 7834,
    lower: [7834],
    title: [65, 702],
    upper: [65, 702],
    fold: 0,
    foldFull: [97, 702]
  }, {
    code: 7834,
    lower: [7834],
    title: [65, 702],
    upper: [65, 702],
    fold: 0,
    foldFull: [97, 702]
  }, {
    code: 7835,
    lower: [],
    title: [],
    upper: [],
    fold: 7777,
    foldFull: [7777]
  }, {
    code: 7838,
    lower: [],
    title: [],
    upper: [],
    fold: 223,
    foldFull: [115, 115]
  }, {
    code: 7840,
    lower: [],
    title: [],
    upper: [],
    fold: 7841,
    foldFull: [7841]
  }, {
    code: 7842,
    lower: [],
    title: [],
    upper: [],
    fold: 7843,
    foldFull: [7843]
  }, {
    code: 7844,
    lower: [],
    title: [],
    upper: [],
    fold: 7845,
    foldFull: [7845]
  }, {
    code: 7846,
    lower: [],
    title: [],
    upper: [],
    fold: 7847,
    foldFull: [7847]
  }, {
    code: 7848,
    lower: [],
    title: [],
    upper: [],
    fold: 7849,
    foldFull: [7849]
  }, {
    code: 7850,
    lower: [],
    title: [],
    upper: [],
    fold: 7851,
    foldFull: [7851]
  }, {
    code: 7852,
    lower: [],
    title: [],
    upper: [],
    fold: 7853,
    foldFull: [7853]
  }, {
    code: 7854,
    lower: [],
    title: [],
    upper: [],
    fold: 7855,
    foldFull: [7855]
  }, {
    code: 7856,
    lower: [],
    title: [],
    upper: [],
    fold: 7857,
    foldFull: [7857]
  }, {
    code: 7858,
    lower: [],
    title: [],
    upper: [],
    fold: 7859,
    foldFull: [7859]
  }, {
    code: 7860,
    lower: [],
    title: [],
    upper: [],
    fold: 7861,
    foldFull: [7861]
  }, {
    code: 7862,
    lower: [],
    title: [],
    upper: [],
    fold: 7863,
    foldFull: [7863]
  }, {
    code: 7864,
    lower: [],
    title: [],
    upper: [],
    fold: 7865,
    foldFull: [7865]
  }, {
    code: 7866,
    lower: [],
    title: [],
    upper: [],
    fold: 7867,
    foldFull: [7867]
  }, {
    code: 7868,
    lower: [],
    title: [],
    upper: [],
    fold: 7869,
    foldFull: [7869]
  }, {
    code: 7870,
    lower: [],
    title: [],
    upper: [],
    fold: 7871,
    foldFull: [7871]
  }, {
    code: 7872,
    lower: [],
    title: [],
    upper: [],
    fold: 7873,
    foldFull: [7873]
  }, {
    code: 7874,
    lower: [],
    title: [],
    upper: [],
    fold: 7875,
    foldFull: [7875]
  }, {
    code: 7876,
    lower: [],
    title: [],
    upper: [],
    fold: 7877,
    foldFull: [7877]
  }, {
    code: 7878,
    lower: [],
    title: [],
    upper: [],
    fold: 7879,
    foldFull: [7879]
  }, {
    code: 7880,
    lower: [],
    title: [],
    upper: [],
    fold: 7881,
    foldFull: [7881]
  }, {
    code: 7882,
    lower: [],
    title: [],
    upper: [],
    fold: 7883,
    foldFull: [7883]
  }, {
    code: 7884,
    lower: [],
    title: [],
    upper: [],
    fold: 7885,
    foldFull: [7885]
  }, {
    code: 7886,
    lower: [],
    title: [],
    upper: [],
    fold: 7887,
    foldFull: [7887]
  }, {
    code: 7888,
    lower: [],
    title: [],
    upper: [],
    fold: 7889,
    foldFull: [7889]
  }, {
    code: 7890,
    lower: [],
    title: [],
    upper: [],
    fold: 7891,
    foldFull: [7891]
  }, {
    code: 7892,
    lower: [],
    title: [],
    upper: [],
    fold: 7893,
    foldFull: [7893]
  }, {
    code: 7894,
    lower: [],
    title: [],
    upper: [],
    fold: 7895,
    foldFull: [7895]
  }, {
    code: 7896,
    lower: [],
    title: [],
    upper: [],
    fold: 7897,
    foldFull: [7897]
  }, {
    code: 7898,
    lower: [],
    title: [],
    upper: [],
    fold: 7899,
    foldFull: [7899]
  }, {
    code: 7900,
    lower: [],
    title: [],
    upper: [],
    fold: 7901,
    foldFull: [7901]
  }, {
    code: 7902,
    lower: [],
    title: [],
    upper: [],
    fold: 7903,
    foldFull: [7903]
  }, {
    code: 7904,
    lower: [],
    title: [],
    upper: [],
    fold: 7905,
    foldFull: [7905]
  }, {
    code: 7906,
    lower: [],
    title: [],
    upper: [],
    fold: 7907,
    foldFull: [7907]
  }, {
    code: 7908,
    lower: [],
    title: [],
    upper: [],
    fold: 7909,
    foldFull: [7909]
  }, {
    code: 7910,
    lower: [],
    title: [],
    upper: [],
    fold: 7911,
    foldFull: [7911]
  }, {
    code: 7912,
    lower: [],
    title: [],
    upper: [],
    fold: 7913,
    foldFull: [7913]
  }, {
    code: 7914,
    lower: [],
    title: [],
    upper: [],
    fold: 7915,
    foldFull: [7915]
  }, {
    code: 7916,
    lower: [],
    title: [],
    upper: [],
    fold: 7917,
    foldFull: [7917]
  }, {
    code: 7918,
    lower: [],
    title: [],
    upper: [],
    fold: 7919,
    foldFull: [7919]
  }, {
    code: 7920,
    lower: [],
    title: [],
    upper: [],
    fold: 7921,
    foldFull: [7921]
  }, {
    code: 7922,
    lower: [],
    title: [],
    upper: [],
    fold: 7923,
    foldFull: [7923]
  }, {
    code: 7924,
    lower: [],
    title: [],
    upper: [],
    fold: 7925,
    foldFull: [7925]
  }, {
    code: 7926,
    lower: [],
    title: [],
    upper: [],
    fold: 7927,
    foldFull: [7927]
  }, {
    code: 7928,
    lower: [],
    title: [],
    upper: [],
    fold: 7929,
    foldFull: [7929]
  }, {
    code: 7930,
    lower: [],
    title: [],
    upper: [],
    fold: 7931,
    foldFull: [7931]
  }, {
    code: 7932,
    lower: [],
    title: [],
    upper: [],
    fold: 7933,
    foldFull: [7933]
  }, {
    code: 7934,
    lower: [],
    title: [],
    upper: [],
    fold: 7935,
    foldFull: [7935]
  }, {
    code: 7944,
    lower: [],
    title: [],
    upper: [],
    fold: 7936,
    foldFull: [7936]
  }, {
    code: 7945,
    lower: [],
    title: [],
    upper: [],
    fold: 7937,
    foldFull: [7937]
  }, {
    code: 7946,
    lower: [],
    title: [],
    upper: [],
    fold: 7938,
    foldFull: [7938]
  }, {
    code: 7947,
    lower: [],
    title: [],
    upper: [],
    fold: 7939,
    foldFull: [7939]
  }, {
    code: 7948,
    lower: [],
    title: [],
    upper: [],
    fold: 7940,
    foldFull: [7940]
  }, {
    code: 7949,
    lower: [],
    title: [],
    upper: [],
    fold: 7941,
    foldFull: [7941]
  }, {
    code: 7950,
    lower: [],
    title: [],
    upper: [],
    fold: 7942,
    foldFull: [7942]
  }, {
    code: 7951,
    lower: [],
    title: [],
    upper: [],
    fold: 7943,
    foldFull: [7943]
  }, {
    code: 7960,
    lower: [],
    title: [],
    upper: [],
    fold: 7952,
    foldFull: [7952]
  }, {
    code: 7961,
    lower: [],
    title: [],
    upper: [],
    fold: 7953,
    foldFull: [7953]
  }, {
    code: 7962,
    lower: [],
    title: [],
    upper: [],
    fold: 7954,
    foldFull: [7954]
  }, {
    code: 7963,
    lower: [],
    title: [],
    upper: [],
    fold: 7955,
    foldFull: [7955]
  }, {
    code: 7964,
    lower: [],
    title: [],
    upper: [],
    fold: 7956,
    foldFull: [7956]
  }, {
    code: 7965,
    lower: [],
    title: [],
    upper: [],
    fold: 7957,
    foldFull: [7957]
  }, {
    code: 7976,
    lower: [],
    title: [],
    upper: [],
    fold: 7968,
    foldFull: [7968]
  }, {
    code: 7977,
    lower: [],
    title: [],
    upper: [],
    fold: 7969,
    foldFull: [7969]
  }, {
    code: 7978,
    lower: [],
    title: [],
    upper: [],
    fold: 7970,
    foldFull: [7970]
  }, {
    code: 7979,
    lower: [],
    title: [],
    upper: [],
    fold: 7971,
    foldFull: [7971]
  }, {
    code: 7980,
    lower: [],
    title: [],
    upper: [],
    fold: 7972,
    foldFull: [7972]
  }, {
    code: 7981,
    lower: [],
    title: [],
    upper: [],
    fold: 7973,
    foldFull: [7973]
  }, {
    code: 7982,
    lower: [],
    title: [],
    upper: [],
    fold: 7974,
    foldFull: [7974]
  }, {
    code: 7983,
    lower: [],
    title: [],
    upper: [],
    fold: 7975,
    foldFull: [7975]
  }, {
    code: 7992,
    lower: [],
    title: [],
    upper: [],
    fold: 7984,
    foldFull: [7984]
  }, {
    code: 7993,
    lower: [],
    title: [],
    upper: [],
    fold: 7985,
    foldFull: [7985]
  }, {
    code: 7994,
    lower: [],
    title: [],
    upper: [],
    fold: 7986,
    foldFull: [7986]
  }, {
    code: 7995,
    lower: [],
    title: [],
    upper: [],
    fold: 7987,
    foldFull: [7987]
  }, {
    code: 7996,
    lower: [],
    title: [],
    upper: [],
    fold: 7988,
    foldFull: [7988]
  }, {
    code: 7997,
    lower: [],
    title: [],
    upper: [],
    fold: 7989,
    foldFull: [7989]
  }, {
    code: 7998,
    lower: [],
    title: [],
    upper: [],
    fold: 7990,
    foldFull: [7990]
  }, {
    code: 7999,
    lower: [],
    title: [],
    upper: [],
    fold: 7991,
    foldFull: [7991]
  }, {
    code: 8008,
    lower: [],
    title: [],
    upper: [],
    fold: 8e3,
    foldFull: [8e3]
  }, {
    code: 8009,
    lower: [],
    title: [],
    upper: [],
    fold: 8001,
    foldFull: [8001]
  }, {
    code: 8010,
    lower: [],
    title: [],
    upper: [],
    fold: 8002,
    foldFull: [8002]
  }, {
    code: 8011,
    lower: [],
    title: [],
    upper: [],
    fold: 8003,
    foldFull: [8003]
  }, {
    code: 8012,
    lower: [],
    title: [],
    upper: [],
    fold: 8004,
    foldFull: [8004]
  }, {
    code: 8013,
    lower: [],
    title: [],
    upper: [],
    fold: 8005,
    foldFull: [8005]
  }, {
    code: 8016,
    lower: [8016],
    title: [933, 787],
    upper: [933, 787],
    fold: 0,
    foldFull: [965, 787]
  }, {
    code: 8016,
    lower: [8016],
    title: [933, 787],
    upper: [933, 787],
    fold: 0,
    foldFull: [965, 787]
  }, {
    code: 8018,
    lower: [8018],
    title: [933, 787, 768],
    upper: [933, 787, 768],
    fold: 0,
    foldFull: [965, 787, 768]
  }, {
    code: 8018,
    lower: [8018],
    title: [933, 787, 768],
    upper: [933, 787, 768],
    fold: 0,
    foldFull: [965, 787, 768]
  }, {
    code: 8020,
    lower: [8020],
    title: [933, 787, 769],
    upper: [933, 787, 769],
    fold: 0,
    foldFull: [965, 787, 769]
  }, {
    code: 8020,
    lower: [8020],
    title: [933, 787, 769],
    upper: [933, 787, 769],
    fold: 0,
    foldFull: [965, 787, 769]
  }, {
    code: 8022,
    lower: [8022],
    title: [933, 787, 834],
    upper: [933, 787, 834],
    fold: 0,
    foldFull: [965, 787, 834]
  }, {
    code: 8022,
    lower: [8022],
    title: [933, 787, 834],
    upper: [933, 787, 834],
    fold: 0,
    foldFull: [965, 787, 834]
  }, {
    code: 8025,
    lower: [],
    title: [],
    upper: [],
    fold: 8017,
    foldFull: [8017]
  }, {
    code: 8027,
    lower: [],
    title: [],
    upper: [],
    fold: 8019,
    foldFull: [8019]
  }, {
    code: 8029,
    lower: [],
    title: [],
    upper: [],
    fold: 8021,
    foldFull: [8021]
  }, {
    code: 8031,
    lower: [],
    title: [],
    upper: [],
    fold: 8023,
    foldFull: [8023]
  }, {
    code: 8040,
    lower: [],
    title: [],
    upper: [],
    fold: 8032,
    foldFull: [8032]
  }, {
    code: 8041,
    lower: [],
    title: [],
    upper: [],
    fold: 8033,
    foldFull: [8033]
  }, {
    code: 8042,
    lower: [],
    title: [],
    upper: [],
    fold: 8034,
    foldFull: [8034]
  }, {
    code: 8043,
    lower: [],
    title: [],
    upper: [],
    fold: 8035,
    foldFull: [8035]
  }, {
    code: 8044,
    lower: [],
    title: [],
    upper: [],
    fold: 8036,
    foldFull: [8036]
  }, {
    code: 8045,
    lower: [],
    title: [],
    upper: [],
    fold: 8037,
    foldFull: [8037]
  }, {
    code: 8046,
    lower: [],
    title: [],
    upper: [],
    fold: 8038,
    foldFull: [8038]
  }, {
    code: 8047,
    lower: [],
    title: [],
    upper: [],
    fold: 8039,
    foldFull: [8039]
  }, {
    code: 8064,
    lower: [8064],
    title: [8072],
    upper: [7944, 921],
    fold: 0,
    foldFull: [7936, 953]
  }, {
    code: 8064,
    lower: [8064],
    title: [8072],
    upper: [7944, 921],
    fold: 0,
    foldFull: [7936, 953]
  }, {
    code: 8065,
    lower: [8065],
    title: [8073],
    upper: [7945, 921],
    fold: 0,
    foldFull: [7937, 953]
  }, {
    code: 8065,
    lower: [8065],
    title: [8073],
    upper: [7945, 921],
    fold: 0,
    foldFull: [7937, 953]
  }, {
    code: 8066,
    lower: [8066],
    title: [8074],
    upper: [7946, 921],
    fold: 0,
    foldFull: [7938, 953]
  }, {
    code: 8066,
    lower: [8066],
    title: [8074],
    upper: [7946, 921],
    fold: 0,
    foldFull: [7938, 953]
  }, {
    code: 8067,
    lower: [8067],
    title: [8075],
    upper: [7947, 921],
    fold: 0,
    foldFull: [7939, 953]
  }, {
    code: 8067,
    lower: [8067],
    title: [8075],
    upper: [7947, 921],
    fold: 0,
    foldFull: [7939, 953]
  }, {
    code: 8068,
    lower: [8068],
    title: [8076],
    upper: [7948, 921],
    fold: 0,
    foldFull: [7940, 953]
  }, {
    code: 8068,
    lower: [8068],
    title: [8076],
    upper: [7948, 921],
    fold: 0,
    foldFull: [7940, 953]
  }, {
    code: 8069,
    lower: [8069],
    title: [8077],
    upper: [7949, 921],
    fold: 0,
    foldFull: [7941, 953]
  }, {
    code: 8069,
    lower: [8069],
    title: [8077],
    upper: [7949, 921],
    fold: 0,
    foldFull: [7941, 953]
  }, {
    code: 8070,
    lower: [8070],
    title: [8078],
    upper: [7950, 921],
    fold: 0,
    foldFull: [7942, 953]
  }, {
    code: 8070,
    lower: [8070],
    title: [8078],
    upper: [7950, 921],
    fold: 0,
    foldFull: [7942, 953]
  }, {
    code: 8071,
    lower: [8071],
    title: [8079],
    upper: [7951, 921],
    fold: 0,
    foldFull: [7943, 953]
  }, {
    code: 8071,
    lower: [8071],
    title: [8079],
    upper: [7951, 921],
    fold: 0,
    foldFull: [7943, 953]
  }, {
    code: 8072,
    lower: [8064],
    title: [8072],
    upper: [7944, 921],
    fold: 8064,
    foldFull: [7936, 953]
  }, {
    code: 8072,
    lower: [8064],
    title: [8072],
    upper: [7944, 921],
    fold: 8064,
    foldFull: [7936, 953]
  }, {
    code: 8073,
    lower: [8065],
    title: [8073],
    upper: [7945, 921],
    fold: 8065,
    foldFull: [7937, 953]
  }, {
    code: 8073,
    lower: [8065],
    title: [8073],
    upper: [7945, 921],
    fold: 8065,
    foldFull: [7937, 953]
  }, {
    code: 8074,
    lower: [8066],
    title: [8074],
    upper: [7946, 921],
    fold: 8066,
    foldFull: [7938, 953]
  }, {
    code: 8074,
    lower: [8066],
    title: [8074],
    upper: [7946, 921],
    fold: 8066,
    foldFull: [7938, 953]
  }, {
    code: 8075,
    lower: [8067],
    title: [8075],
    upper: [7947, 921],
    fold: 8067,
    foldFull: [7939, 953]
  }, {
    code: 8075,
    lower: [8067],
    title: [8075],
    upper: [7947, 921],
    fold: 8067,
    foldFull: [7939, 953]
  }, {
    code: 8076,
    lower: [8068],
    title: [8076],
    upper: [7948, 921],
    fold: 8068,
    foldFull: [7940, 953]
  }, {
    code: 8076,
    lower: [8068],
    title: [8076],
    upper: [7948, 921],
    fold: 8068,
    foldFull: [7940, 953]
  }, {
    code: 8077,
    lower: [8069],
    title: [8077],
    upper: [7949, 921],
    fold: 8069,
    foldFull: [7941, 953]
  }, {
    code: 8077,
    lower: [8069],
    title: [8077],
    upper: [7949, 921],
    fold: 8069,
    foldFull: [7941, 953]
  }, {
    code: 8078,
    lower: [8070],
    title: [8078],
    upper: [7950, 921],
    fold: 8070,
    foldFull: [7942, 953]
  }, {
    code: 8078,
    lower: [8070],
    title: [8078],
    upper: [7950, 921],
    fold: 8070,
    foldFull: [7942, 953]
  }, {
    code: 8079,
    lower: [8071],
    title: [8079],
    upper: [7951, 921],
    fold: 8071,
    foldFull: [7943, 953]
  }, {
    code: 8079,
    lower: [8071],
    title: [8079],
    upper: [7951, 921],
    fold: 8071,
    foldFull: [7943, 953]
  }, {
    code: 8080,
    lower: [8080],
    title: [8088],
    upper: [7976, 921],
    fold: 0,
    foldFull: [7968, 953]
  }, {
    code: 8080,
    lower: [8080],
    title: [8088],
    upper: [7976, 921],
    fold: 0,
    foldFull: [7968, 953]
  }, {
    code: 8081,
    lower: [8081],
    title: [8089],
    upper: [7977, 921],
    fold: 0,
    foldFull: [7969, 953]
  }, {
    code: 8081,
    lower: [8081],
    title: [8089],
    upper: [7977, 921],
    fold: 0,
    foldFull: [7969, 953]
  }, {
    code: 8082,
    lower: [8082],
    title: [8090],
    upper: [7978, 921],
    fold: 0,
    foldFull: [7970, 953]
  }, {
    code: 8082,
    lower: [8082],
    title: [8090],
    upper: [7978, 921],
    fold: 0,
    foldFull: [7970, 953]
  }, {
    code: 8083,
    lower: [8083],
    title: [8091],
    upper: [7979, 921],
    fold: 0,
    foldFull: [7971, 953]
  }, {
    code: 8083,
    lower: [8083],
    title: [8091],
    upper: [7979, 921],
    fold: 0,
    foldFull: [7971, 953]
  }, {
    code: 8084,
    lower: [8084],
    title: [8092],
    upper: [7980, 921],
    fold: 0,
    foldFull: [7972, 953]
  }, {
    code: 8084,
    lower: [8084],
    title: [8092],
    upper: [7980, 921],
    fold: 0,
    foldFull: [7972, 953]
  }, {
    code: 8085,
    lower: [8085],
    title: [8093],
    upper: [7981, 921],
    fold: 0,
    foldFull: [7973, 953]
  }, {
    code: 8085,
    lower: [8085],
    title: [8093],
    upper: [7981, 921],
    fold: 0,
    foldFull: [7973, 953]
  }, {
    code: 8086,
    lower: [8086],
    title: [8094],
    upper: [7982, 921],
    fold: 0,
    foldFull: [7974, 953]
  }, {
    code: 8086,
    lower: [8086],
    title: [8094],
    upper: [7982, 921],
    fold: 0,
    foldFull: [7974, 953]
  }, {
    code: 8087,
    lower: [8087],
    title: [8095],
    upper: [7983, 921],
    fold: 0,
    foldFull: [7975, 953]
  }, {
    code: 8087,
    lower: [8087],
    title: [8095],
    upper: [7983, 921],
    fold: 0,
    foldFull: [7975, 953]
  }, {
    code: 8088,
    lower: [8080],
    title: [8088],
    upper: [7976, 921],
    fold: 8080,
    foldFull: [7968, 953]
  }, {
    code: 8088,
    lower: [8080],
    title: [8088],
    upper: [7976, 921],
    fold: 8080,
    foldFull: [7968, 953]
  }, {
    code: 8089,
    lower: [8081],
    title: [8089],
    upper: [7977, 921],
    fold: 8081,
    foldFull: [7969, 953]
  }, {
    code: 8089,
    lower: [8081],
    title: [8089],
    upper: [7977, 921],
    fold: 8081,
    foldFull: [7969, 953]
  }, {
    code: 8090,
    lower: [8082],
    title: [8090],
    upper: [7978, 921],
    fold: 8082,
    foldFull: [7970, 953]
  }, {
    code: 8090,
    lower: [8082],
    title: [8090],
    upper: [7978, 921],
    fold: 8082,
    foldFull: [7970, 953]
  }, {
    code: 8091,
    lower: [8083],
    title: [8091],
    upper: [7979, 921],
    fold: 8083,
    foldFull: [7971, 953]
  }, {
    code: 8091,
    lower: [8083],
    title: [8091],
    upper: [7979, 921],
    fold: 8083,
    foldFull: [7971, 953]
  }, {
    code: 8092,
    lower: [8084],
    title: [8092],
    upper: [7980, 921],
    fold: 8084,
    foldFull: [7972, 953]
  }, {
    code: 8092,
    lower: [8084],
    title: [8092],
    upper: [7980, 921],
    fold: 8084,
    foldFull: [7972, 953]
  }, {
    code: 8093,
    lower: [8085],
    title: [8093],
    upper: [7981, 921],
    fold: 8085,
    foldFull: [7973, 953]
  }, {
    code: 8093,
    lower: [8085],
    title: [8093],
    upper: [7981, 921],
    fold: 8085,
    foldFull: [7973, 953]
  }, {
    code: 8094,
    lower: [8086],
    title: [8094],
    upper: [7982, 921],
    fold: 8086,
    foldFull: [7974, 953]
  }, {
    code: 8094,
    lower: [8086],
    title: [8094],
    upper: [7982, 921],
    fold: 8086,
    foldFull: [7974, 953]
  }, {
    code: 8095,
    lower: [8087],
    title: [8095],
    upper: [7983, 921],
    fold: 8087,
    foldFull: [7975, 953]
  }, {
    code: 8095,
    lower: [8087],
    title: [8095],
    upper: [7983, 921],
    fold: 8087,
    foldFull: [7975, 953]
  }, {
    code: 8096,
    lower: [8096],
    title: [8104],
    upper: [8040, 921],
    fold: 0,
    foldFull: [8032, 953]
  }, {
    code: 8096,
    lower: [8096],
    title: [8104],
    upper: [8040, 921],
    fold: 0,
    foldFull: [8032, 953]
  }, {
    code: 8097,
    lower: [8097],
    title: [8105],
    upper: [8041, 921],
    fold: 0,
    foldFull: [8033, 953]
  }, {
    code: 8097,
    lower: [8097],
    title: [8105],
    upper: [8041, 921],
    fold: 0,
    foldFull: [8033, 953]
  }, {
    code: 8098,
    lower: [8098],
    title: [8106],
    upper: [8042, 921],
    fold: 0,
    foldFull: [8034, 953]
  }, {
    code: 8098,
    lower: [8098],
    title: [8106],
    upper: [8042, 921],
    fold: 0,
    foldFull: [8034, 953]
  }, {
    code: 8099,
    lower: [8099],
    title: [8107],
    upper: [8043, 921],
    fold: 0,
    foldFull: [8035, 953]
  }, {
    code: 8099,
    lower: [8099],
    title: [8107],
    upper: [8043, 921],
    fold: 0,
    foldFull: [8035, 953]
  }, {
    code: 8100,
    lower: [8100],
    title: [8108],
    upper: [8044, 921],
    fold: 0,
    foldFull: [8036, 953]
  }, {
    code: 8100,
    lower: [8100],
    title: [8108],
    upper: [8044, 921],
    fold: 0,
    foldFull: [8036, 953]
  }, {
    code: 8101,
    lower: [8101],
    title: [8109],
    upper: [8045, 921],
    fold: 0,
    foldFull: [8037, 953]
  }, {
    code: 8101,
    lower: [8101],
    title: [8109],
    upper: [8045, 921],
    fold: 0,
    foldFull: [8037, 953]
  }, {
    code: 8102,
    lower: [8102],
    title: [8110],
    upper: [8046, 921],
    fold: 0,
    foldFull: [8038, 953]
  }, {
    code: 8102,
    lower: [8102],
    title: [8110],
    upper: [8046, 921],
    fold: 0,
    foldFull: [8038, 953]
  }, {
    code: 8103,
    lower: [8103],
    title: [8111],
    upper: [8047, 921],
    fold: 0,
    foldFull: [8039, 953]
  }, {
    code: 8103,
    lower: [8103],
    title: [8111],
    upper: [8047, 921],
    fold: 0,
    foldFull: [8039, 953]
  }, {
    code: 8104,
    lower: [8096],
    title: [8104],
    upper: [8040, 921],
    fold: 8096,
    foldFull: [8032, 953]
  }, {
    code: 8104,
    lower: [8096],
    title: [8104],
    upper: [8040, 921],
    fold: 8096,
    foldFull: [8032, 953]
  }, {
    code: 8105,
    lower: [8097],
    title: [8105],
    upper: [8041, 921],
    fold: 8097,
    foldFull: [8033, 953]
  }, {
    code: 8105,
    lower: [8097],
    title: [8105],
    upper: [8041, 921],
    fold: 8097,
    foldFull: [8033, 953]
  }, {
    code: 8106,
    lower: [8098],
    title: [8106],
    upper: [8042, 921],
    fold: 8098,
    foldFull: [8034, 953]
  }, {
    code: 8106,
    lower: [8098],
    title: [8106],
    upper: [8042, 921],
    fold: 8098,
    foldFull: [8034, 953]
  }, {
    code: 8107,
    lower: [8099],
    title: [8107],
    upper: [8043, 921],
    fold: 8099,
    foldFull: [8035, 953]
  }, {
    code: 8107,
    lower: [8099],
    title: [8107],
    upper: [8043, 921],
    fold: 8099,
    foldFull: [8035, 953]
  }, {
    code: 8108,
    lower: [8100],
    title: [8108],
    upper: [8044, 921],
    fold: 8100,
    foldFull: [8036, 953]
  }, {
    code: 8108,
    lower: [8100],
    title: [8108],
    upper: [8044, 921],
    fold: 8100,
    foldFull: [8036, 953]
  }, {
    code: 8109,
    lower: [8101],
    title: [8109],
    upper: [8045, 921],
    fold: 8101,
    foldFull: [8037, 953]
  }, {
    code: 8109,
    lower: [8101],
    title: [8109],
    upper: [8045, 921],
    fold: 8101,
    foldFull: [8037, 953]
  }, {
    code: 8110,
    lower: [8102],
    title: [8110],
    upper: [8046, 921],
    fold: 8102,
    foldFull: [8038, 953]
  }, {
    code: 8110,
    lower: [8102],
    title: [8110],
    upper: [8046, 921],
    fold: 8102,
    foldFull: [8038, 953]
  }, {
    code: 8111,
    lower: [8103],
    title: [8111],
    upper: [8047, 921],
    fold: 8103,
    foldFull: [8039, 953]
  }, {
    code: 8111,
    lower: [8103],
    title: [8111],
    upper: [8047, 921],
    fold: 8103,
    foldFull: [8039, 953]
  }, {
    code: 8114,
    lower: [8114],
    title: [8122, 837],
    upper: [8122, 921],
    fold: 0,
    foldFull: [8048, 953]
  }, {
    code: 8114,
    lower: [8114],
    title: [8122, 837],
    upper: [8122, 921],
    fold: 0,
    foldFull: [8048, 953]
  }, {
    code: 8115,
    lower: [8115],
    title: [8124],
    upper: [913, 921],
    fold: 0,
    foldFull: [945, 953]
  }, {
    code: 8115,
    lower: [8115],
    title: [8124],
    upper: [913, 921],
    fold: 0,
    foldFull: [945, 953]
  }, {
    code: 8116,
    lower: [8116],
    title: [902, 837],
    upper: [902, 921],
    fold: 0,
    foldFull: [940, 953]
  }, {
    code: 8116,
    lower: [8116],
    title: [902, 837],
    upper: [902, 921],
    fold: 0,
    foldFull: [940, 953]
  }, {
    code: 8118,
    lower: [8118],
    title: [913, 834],
    upper: [913, 834],
    fold: 0,
    foldFull: [945, 834]
  }, {
    code: 8118,
    lower: [8118],
    title: [913, 834],
    upper: [913, 834],
    fold: 0,
    foldFull: [945, 834]
  }, {
    code: 8119,
    lower: [8119],
    title: [913, 834, 837],
    upper: [913, 834, 921],
    fold: 0,
    foldFull: [945, 834, 953]
  }, {
    code: 8119,
    lower: [8119],
    title: [913, 834, 837],
    upper: [913, 834, 921],
    fold: 0,
    foldFull: [945, 834, 953]
  }, {
    code: 8120,
    lower: [],
    title: [],
    upper: [],
    fold: 8112,
    foldFull: [8112]
  }, {
    code: 8121,
    lower: [],
    title: [],
    upper: [],
    fold: 8113,
    foldFull: [8113]
  }, {
    code: 8122,
    lower: [],
    title: [],
    upper: [],
    fold: 8048,
    foldFull: [8048]
  }, {
    code: 8123,
    lower: [],
    title: [],
    upper: [],
    fold: 8049,
    foldFull: [8049]
  }, {
    code: 8124,
    lower: [8115],
    title: [8124],
    upper: [913, 921],
    fold: 8115,
    foldFull: [945, 953]
  }, {
    code: 8124,
    lower: [8115],
    title: [8124],
    upper: [913, 921],
    fold: 8115,
    foldFull: [945, 953]
  }, {
    code: 8126,
    lower: [],
    title: [],
    upper: [],
    fold: 953,
    foldFull: [953]
  }, {
    code: 8130,
    lower: [8130],
    title: [8138, 837],
    upper: [8138, 921],
    fold: 0,
    foldFull: [8052, 953]
  }, {
    code: 8130,
    lower: [8130],
    title: [8138, 837],
    upper: [8138, 921],
    fold: 0,
    foldFull: [8052, 953]
  }, {
    code: 8131,
    lower: [8131],
    title: [8140],
    upper: [919, 921],
    fold: 0,
    foldFull: [951, 953]
  }, {
    code: 8131,
    lower: [8131],
    title: [8140],
    upper: [919, 921],
    fold: 0,
    foldFull: [951, 953]
  }, {
    code: 8132,
    lower: [8132],
    title: [905, 837],
    upper: [905, 921],
    fold: 0,
    foldFull: [942, 953]
  }, {
    code: 8132,
    lower: [8132],
    title: [905, 837],
    upper: [905, 921],
    fold: 0,
    foldFull: [942, 953]
  }, {
    code: 8134,
    lower: [8134],
    title: [919, 834],
    upper: [919, 834],
    fold: 0,
    foldFull: [951, 834]
  }, {
    code: 8134,
    lower: [8134],
    title: [919, 834],
    upper: [919, 834],
    fold: 0,
    foldFull: [951, 834]
  }, {
    code: 8135,
    lower: [8135],
    title: [919, 834, 837],
    upper: [919, 834, 921],
    fold: 0,
    foldFull: [951, 834, 953]
  }, {
    code: 8135,
    lower: [8135],
    title: [919, 834, 837],
    upper: [919, 834, 921],
    fold: 0,
    foldFull: [951, 834, 953]
  }, {
    code: 8136,
    lower: [],
    title: [],
    upper: [],
    fold: 8050,
    foldFull: [8050]
  }, {
    code: 8137,
    lower: [],
    title: [],
    upper: [],
    fold: 8051,
    foldFull: [8051]
  }, {
    code: 8138,
    lower: [],
    title: [],
    upper: [],
    fold: 8052,
    foldFull: [8052]
  }, {
    code: 8139,
    lower: [],
    title: [],
    upper: [],
    fold: 8053,
    foldFull: [8053]
  }, {
    code: 8140,
    lower: [8131],
    title: [8140],
    upper: [919, 921],
    fold: 8131,
    foldFull: [951, 953]
  }, {
    code: 8140,
    lower: [8131],
    title: [8140],
    upper: [919, 921],
    fold: 8131,
    foldFull: [951, 953]
  }, {
    code: 8146,
    lower: [8146],
    title: [921, 776, 768],
    upper: [921, 776, 768],
    fold: 0,
    foldFull: [953, 776, 768]
  }, {
    code: 8146,
    lower: [8146],
    title: [921, 776, 768],
    upper: [921, 776, 768],
    fold: 0,
    foldFull: [953, 776, 768]
  }, {
    code: 8147,
    lower: [8147],
    title: [921, 776, 769],
    upper: [921, 776, 769],
    fold: 0,
    foldFull: [953, 776, 769]
  }, {
    code: 8147,
    lower: [8147],
    title: [921, 776, 769],
    upper: [921, 776, 769],
    fold: 0,
    foldFull: [953, 776, 769]
  }, {
    code: 8150,
    lower: [8150],
    title: [921, 834],
    upper: [921, 834],
    fold: 0,
    foldFull: [953, 834]
  }, {
    code: 8150,
    lower: [8150],
    title: [921, 834],
    upper: [921, 834],
    fold: 0,
    foldFull: [953, 834]
  }, {
    code: 8151,
    lower: [8151],
    title: [921, 776, 834],
    upper: [921, 776, 834],
    fold: 0,
    foldFull: [953, 776, 834]
  }, {
    code: 8151,
    lower: [8151],
    title: [921, 776, 834],
    upper: [921, 776, 834],
    fold: 0,
    foldFull: [953, 776, 834]
  }, {
    code: 8152,
    lower: [],
    title: [],
    upper: [],
    fold: 8144,
    foldFull: [8144]
  }, {
    code: 8153,
    lower: [],
    title: [],
    upper: [],
    fold: 8145,
    foldFull: [8145]
  }, {
    code: 8154,
    lower: [],
    title: [],
    upper: [],
    fold: 8054,
    foldFull: [8054]
  }, {
    code: 8155,
    lower: [],
    title: [],
    upper: [],
    fold: 8055,
    foldFull: [8055]
  }, {
    code: 8162,
    lower: [8162],
    title: [933, 776, 768],
    upper: [933, 776, 768],
    fold: 0,
    foldFull: [965, 776, 768]
  }, {
    code: 8162,
    lower: [8162],
    title: [933, 776, 768],
    upper: [933, 776, 768],
    fold: 0,
    foldFull: [965, 776, 768]
  }, {
    code: 8163,
    lower: [8163],
    title: [933, 776, 769],
    upper: [933, 776, 769],
    fold: 0,
    foldFull: [965, 776, 769]
  }, {
    code: 8163,
    lower: [8163],
    title: [933, 776, 769],
    upper: [933, 776, 769],
    fold: 0,
    foldFull: [965, 776, 769]
  }, {
    code: 8164,
    lower: [8164],
    title: [929, 787],
    upper: [929, 787],
    fold: 0,
    foldFull: [961, 787]
  }, {
    code: 8164,
    lower: [8164],
    title: [929, 787],
    upper: [929, 787],
    fold: 0,
    foldFull: [961, 787]
  }, {
    code: 8166,
    lower: [8166],
    title: [933, 834],
    upper: [933, 834],
    fold: 0,
    foldFull: [965, 834]
  }, {
    code: 8166,
    lower: [8166],
    title: [933, 834],
    upper: [933, 834],
    fold: 0,
    foldFull: [965, 834]
  }, {
    code: 8167,
    lower: [8167],
    title: [933, 776, 834],
    upper: [933, 776, 834],
    fold: 0,
    foldFull: [965, 776, 834]
  }, {
    code: 8167,
    lower: [8167],
    title: [933, 776, 834],
    upper: [933, 776, 834],
    fold: 0,
    foldFull: [965, 776, 834]
  }, {
    code: 8168,
    lower: [],
    title: [],
    upper: [],
    fold: 8160,
    foldFull: [8160]
  }, {
    code: 8169,
    lower: [],
    title: [],
    upper: [],
    fold: 8161,
    foldFull: [8161]
  }, {
    code: 8170,
    lower: [],
    title: [],
    upper: [],
    fold: 8058,
    foldFull: [8058]
  }, {
    code: 8171,
    lower: [],
    title: [],
    upper: [],
    fold: 8059,
    foldFull: [8059]
  }, {
    code: 8172,
    lower: [],
    title: [],
    upper: [],
    fold: 8165,
    foldFull: [8165]
  }, {
    code: 8178,
    lower: [8178],
    title: [8186, 837],
    upper: [8186, 921],
    fold: 0,
    foldFull: [8060, 953]
  }, {
    code: 8178,
    lower: [8178],
    title: [8186, 837],
    upper: [8186, 921],
    fold: 0,
    foldFull: [8060, 953]
  }, {
    code: 8179,
    lower: [8179],
    title: [8188],
    upper: [937, 921],
    fold: 0,
    foldFull: [969, 953]
  }, {
    code: 8179,
    lower: [8179],
    title: [8188],
    upper: [937, 921],
    fold: 0,
    foldFull: [969, 953]
  }, {
    code: 8180,
    lower: [8180],
    title: [911, 837],
    upper: [911, 921],
    fold: 0,
    foldFull: [974, 953]
  }, {
    code: 8180,
    lower: [8180],
    title: [911, 837],
    upper: [911, 921],
    fold: 0,
    foldFull: [974, 953]
  }, {
    code: 8182,
    lower: [8182],
    title: [937, 834],
    upper: [937, 834],
    fold: 0,
    foldFull: [969, 834]
  }, {
    code: 8182,
    lower: [8182],
    title: [937, 834],
    upper: [937, 834],
    fold: 0,
    foldFull: [969, 834]
  }, {
    code: 8183,
    lower: [8183],
    title: [937, 834, 837],
    upper: [937, 834, 921],
    fold: 0,
    foldFull: [969, 834, 953]
  }, {
    code: 8183,
    lower: [8183],
    title: [937, 834, 837],
    upper: [937, 834, 921],
    fold: 0,
    foldFull: [969, 834, 953]
  }, {
    code: 8184,
    lower: [],
    title: [],
    upper: [],
    fold: 8056,
    foldFull: [8056]
  }, {
    code: 8185,
    lower: [],
    title: [],
    upper: [],
    fold: 8057,
    foldFull: [8057]
  }, {
    code: 8186,
    lower: [],
    title: [],
    upper: [],
    fold: 8060,
    foldFull: [8060]
  }, {
    code: 8187,
    lower: [],
    title: [],
    upper: [],
    fold: 8061,
    foldFull: [8061]
  }, {
    code: 8188,
    lower: [8179],
    title: [8188],
    upper: [937, 921],
    fold: 8179,
    foldFull: [969, 953]
  }, {
    code: 8188,
    lower: [8179],
    title: [8188],
    upper: [937, 921],
    fold: 8179,
    foldFull: [969, 953]
  }, {
    code: 8486,
    lower: [],
    title: [],
    upper: [],
    fold: 969,
    foldFull: [969]
  }, {
    code: 8490,
    lower: [],
    title: [],
    upper: [],
    fold: 107,
    foldFull: [107]
  }, {
    code: 8491,
    lower: [],
    title: [],
    upper: [],
    fold: 229,
    foldFull: [229]
  }, {
    code: 8498,
    lower: [],
    title: [],
    upper: [],
    fold: 8526,
    foldFull: [8526]
  }, {
    code: 8544,
    lower: [],
    title: [],
    upper: [],
    fold: 8560,
    foldFull: [8560]
  }, {
    code: 8545,
    lower: [],
    title: [],
    upper: [],
    fold: 8561,
    foldFull: [8561]
  }, {
    code: 8546,
    lower: [],
    title: [],
    upper: [],
    fold: 8562,
    foldFull: [8562]
  }, {
    code: 8547,
    lower: [],
    title: [],
    upper: [],
    fold: 8563,
    foldFull: [8563]
  }, {
    code: 8548,
    lower: [],
    title: [],
    upper: [],
    fold: 8564,
    foldFull: [8564]
  }, {
    code: 8549,
    lower: [],
    title: [],
    upper: [],
    fold: 8565,
    foldFull: [8565]
  }, {
    code: 8550,
    lower: [],
    title: [],
    upper: [],
    fold: 8566,
    foldFull: [8566]
  }, {
    code: 8551,
    lower: [],
    title: [],
    upper: [],
    fold: 8567,
    foldFull: [8567]
  }, {
    code: 8552,
    lower: [],
    title: [],
    upper: [],
    fold: 8568,
    foldFull: [8568]
  }, {
    code: 8553,
    lower: [],
    title: [],
    upper: [],
    fold: 8569,
    foldFull: [8569]
  }, {
    code: 8554,
    lower: [],
    title: [],
    upper: [],
    fold: 8570,
    foldFull: [8570]
  }, {
    code: 8555,
    lower: [],
    title: [],
    upper: [],
    fold: 8571,
    foldFull: [8571]
  }, {
    code: 8556,
    lower: [],
    title: [],
    upper: [],
    fold: 8572,
    foldFull: [8572]
  }, {
    code: 8557,
    lower: [],
    title: [],
    upper: [],
    fold: 8573,
    foldFull: [8573]
  }, {
    code: 8558,
    lower: [],
    title: [],
    upper: [],
    fold: 8574,
    foldFull: [8574]
  }, {
    code: 8559,
    lower: [],
    title: [],
    upper: [],
    fold: 8575,
    foldFull: [8575]
  }, {
    code: 8579,
    lower: [],
    title: [],
    upper: [],
    fold: 8580,
    foldFull: [8580]
  }, {
    code: 9398,
    lower: [],
    title: [],
    upper: [],
    fold: 9424,
    foldFull: [9424]
  }, {
    code: 9399,
    lower: [],
    title: [],
    upper: [],
    fold: 9425,
    foldFull: [9425]
  }, {
    code: 9400,
    lower: [],
    title: [],
    upper: [],
    fold: 9426,
    foldFull: [9426]
  }, {
    code: 9401,
    lower: [],
    title: [],
    upper: [],
    fold: 9427,
    foldFull: [9427]
  }, {
    code: 9402,
    lower: [],
    title: [],
    upper: [],
    fold: 9428,
    foldFull: [9428]
  }, {
    code: 9403,
    lower: [],
    title: [],
    upper: [],
    fold: 9429,
    foldFull: [9429]
  }, {
    code: 9404,
    lower: [],
    title: [],
    upper: [],
    fold: 9430,
    foldFull: [9430]
  }, {
    code: 9405,
    lower: [],
    title: [],
    upper: [],
    fold: 9431,
    foldFull: [9431]
  }, {
    code: 9406,
    lower: [],
    title: [],
    upper: [],
    fold: 9432,
    foldFull: [9432]
  }, {
    code: 9407,
    lower: [],
    title: [],
    upper: [],
    fold: 9433,
    foldFull: [9433]
  }, {
    code: 9408,
    lower: [],
    title: [],
    upper: [],
    fold: 9434,
    foldFull: [9434]
  }, {
    code: 9409,
    lower: [],
    title: [],
    upper: [],
    fold: 9435,
    foldFull: [9435]
  }, {
    code: 9410,
    lower: [],
    title: [],
    upper: [],
    fold: 9436,
    foldFull: [9436]
  }, {
    code: 9411,
    lower: [],
    title: [],
    upper: [],
    fold: 9437,
    foldFull: [9437]
  }, {
    code: 9412,
    lower: [],
    title: [],
    upper: [],
    fold: 9438,
    foldFull: [9438]
  }, {
    code: 9413,
    lower: [],
    title: [],
    upper: [],
    fold: 9439,
    foldFull: [9439]
  }, {
    code: 9414,
    lower: [],
    title: [],
    upper: [],
    fold: 9440,
    foldFull: [9440]
  }, {
    code: 9415,
    lower: [],
    title: [],
    upper: [],
    fold: 9441,
    foldFull: [9441]
  }, {
    code: 9416,
    lower: [],
    title: [],
    upper: [],
    fold: 9442,
    foldFull: [9442]
  }, {
    code: 9417,
    lower: [],
    title: [],
    upper: [],
    fold: 9443,
    foldFull: [9443]
  }, {
    code: 9418,
    lower: [],
    title: [],
    upper: [],
    fold: 9444,
    foldFull: [9444]
  }, {
    code: 9419,
    lower: [],
    title: [],
    upper: [],
    fold: 9445,
    foldFull: [9445]
  }, {
    code: 9420,
    lower: [],
    title: [],
    upper: [],
    fold: 9446,
    foldFull: [9446]
  }, {
    code: 9421,
    lower: [],
    title: [],
    upper: [],
    fold: 9447,
    foldFull: [9447]
  }, {
    code: 9422,
    lower: [],
    title: [],
    upper: [],
    fold: 9448,
    foldFull: [9448]
  }, {
    code: 9423,
    lower: [],
    title: [],
    upper: [],
    fold: 9449,
    foldFull: [9449]
  }, {
    code: 11264,
    lower: [],
    title: [],
    upper: [],
    fold: 11312,
    foldFull: [11312]
  }, {
    code: 11265,
    lower: [],
    title: [],
    upper: [],
    fold: 11313,
    foldFull: [11313]
  }, {
    code: 11266,
    lower: [],
    title: [],
    upper: [],
    fold: 11314,
    foldFull: [11314]
  }, {
    code: 11267,
    lower: [],
    title: [],
    upper: [],
    fold: 11315,
    foldFull: [11315]
  }, {
    code: 11268,
    lower: [],
    title: [],
    upper: [],
    fold: 11316,
    foldFull: [11316]
  }, {
    code: 11269,
    lower: [],
    title: [],
    upper: [],
    fold: 11317,
    foldFull: [11317]
  }, {
    code: 11270,
    lower: [],
    title: [],
    upper: [],
    fold: 11318,
    foldFull: [11318]
  }, {
    code: 11271,
    lower: [],
    title: [],
    upper: [],
    fold: 11319,
    foldFull: [11319]
  }, {
    code: 11272,
    lower: [],
    title: [],
    upper: [],
    fold: 11320,
    foldFull: [11320]
  }, {
    code: 11273,
    lower: [],
    title: [],
    upper: [],
    fold: 11321,
    foldFull: [11321]
  }, {
    code: 11274,
    lower: [],
    title: [],
    upper: [],
    fold: 11322,
    foldFull: [11322]
  }, {
    code: 11275,
    lower: [],
    title: [],
    upper: [],
    fold: 11323,
    foldFull: [11323]
  }, {
    code: 11276,
    lower: [],
    title: [],
    upper: [],
    fold: 11324,
    foldFull: [11324]
  }, {
    code: 11277,
    lower: [],
    title: [],
    upper: [],
    fold: 11325,
    foldFull: [11325]
  }, {
    code: 11278,
    lower: [],
    title: [],
    upper: [],
    fold: 11326,
    foldFull: [11326]
  }, {
    code: 11279,
    lower: [],
    title: [],
    upper: [],
    fold: 11327,
    foldFull: [11327]
  }, {
    code: 11280,
    lower: [],
    title: [],
    upper: [],
    fold: 11328,
    foldFull: [11328]
  }, {
    code: 11281,
    lower: [],
    title: [],
    upper: [],
    fold: 11329,
    foldFull: [11329]
  }, {
    code: 11282,
    lower: [],
    title: [],
    upper: [],
    fold: 11330,
    foldFull: [11330]
  }, {
    code: 11283,
    lower: [],
    title: [],
    upper: [],
    fold: 11331,
    foldFull: [11331]
  }, {
    code: 11284,
    lower: [],
    title: [],
    upper: [],
    fold: 11332,
    foldFull: [11332]
  }, {
    code: 11285,
    lower: [],
    title: [],
    upper: [],
    fold: 11333,
    foldFull: [11333]
  }, {
    code: 11286,
    lower: [],
    title: [],
    upper: [],
    fold: 11334,
    foldFull: [11334]
  }, {
    code: 11287,
    lower: [],
    title: [],
    upper: [],
    fold: 11335,
    foldFull: [11335]
  }, {
    code: 11288,
    lower: [],
    title: [],
    upper: [],
    fold: 11336,
    foldFull: [11336]
  }, {
    code: 11289,
    lower: [],
    title: [],
    upper: [],
    fold: 11337,
    foldFull: [11337]
  }, {
    code: 11290,
    lower: [],
    title: [],
    upper: [],
    fold: 11338,
    foldFull: [11338]
  }, {
    code: 11291,
    lower: [],
    title: [],
    upper: [],
    fold: 11339,
    foldFull: [11339]
  }, {
    code: 11292,
    lower: [],
    title: [],
    upper: [],
    fold: 11340,
    foldFull: [11340]
  }, {
    code: 11293,
    lower: [],
    title: [],
    upper: [],
    fold: 11341,
    foldFull: [11341]
  }, {
    code: 11294,
    lower: [],
    title: [],
    upper: [],
    fold: 11342,
    foldFull: [11342]
  }, {
    code: 11295,
    lower: [],
    title: [],
    upper: [],
    fold: 11343,
    foldFull: [11343]
  }, {
    code: 11296,
    lower: [],
    title: [],
    upper: [],
    fold: 11344,
    foldFull: [11344]
  }, {
    code: 11297,
    lower: [],
    title: [],
    upper: [],
    fold: 11345,
    foldFull: [11345]
  }, {
    code: 11298,
    lower: [],
    title: [],
    upper: [],
    fold: 11346,
    foldFull: [11346]
  }, {
    code: 11299,
    lower: [],
    title: [],
    upper: [],
    fold: 11347,
    foldFull: [11347]
  }, {
    code: 11300,
    lower: [],
    title: [],
    upper: [],
    fold: 11348,
    foldFull: [11348]
  }, {
    code: 11301,
    lower: [],
    title: [],
    upper: [],
    fold: 11349,
    foldFull: [11349]
  }, {
    code: 11302,
    lower: [],
    title: [],
    upper: [],
    fold: 11350,
    foldFull: [11350]
  }, {
    code: 11303,
    lower: [],
    title: [],
    upper: [],
    fold: 11351,
    foldFull: [11351]
  }, {
    code: 11304,
    lower: [],
    title: [],
    upper: [],
    fold: 11352,
    foldFull: [11352]
  }, {
    code: 11305,
    lower: [],
    title: [],
    upper: [],
    fold: 11353,
    foldFull: [11353]
  }, {
    code: 11306,
    lower: [],
    title: [],
    upper: [],
    fold: 11354,
    foldFull: [11354]
  }, {
    code: 11307,
    lower: [],
    title: [],
    upper: [],
    fold: 11355,
    foldFull: [11355]
  }, {
    code: 11308,
    lower: [],
    title: [],
    upper: [],
    fold: 11356,
    foldFull: [11356]
  }, {
    code: 11309,
    lower: [],
    title: [],
    upper: [],
    fold: 11357,
    foldFull: [11357]
  }, {
    code: 11310,
    lower: [],
    title: [],
    upper: [],
    fold: 11358,
    foldFull: [11358]
  }, {
    code: 11360,
    lower: [],
    title: [],
    upper: [],
    fold: 11361,
    foldFull: [11361]
  }, {
    code: 11362,
    lower: [],
    title: [],
    upper: [],
    fold: 619,
    foldFull: [619]
  }, {
    code: 11363,
    lower: [],
    title: [],
    upper: [],
    fold: 7549,
    foldFull: [7549]
  }, {
    code: 11364,
    lower: [],
    title: [],
    upper: [],
    fold: 637,
    foldFull: [637]
  }, {
    code: 11367,
    lower: [],
    title: [],
    upper: [],
    fold: 11368,
    foldFull: [11368]
  }, {
    code: 11369,
    lower: [],
    title: [],
    upper: [],
    fold: 11370,
    foldFull: [11370]
  }, {
    code: 11371,
    lower: [],
    title: [],
    upper: [],
    fold: 11372,
    foldFull: [11372]
  }, {
    code: 11373,
    lower: [],
    title: [],
    upper: [],
    fold: 593,
    foldFull: [593]
  }, {
    code: 11374,
    lower: [],
    title: [],
    upper: [],
    fold: 625,
    foldFull: [625]
  }, {
    code: 11375,
    lower: [],
    title: [],
    upper: [],
    fold: 592,
    foldFull: [592]
  }, {
    code: 11376,
    lower: [],
    title: [],
    upper: [],
    fold: 594,
    foldFull: [594]
  }, {
    code: 11378,
    lower: [],
    title: [],
    upper: [],
    fold: 11379,
    foldFull: [11379]
  }, {
    code: 11381,
    lower: [],
    title: [],
    upper: [],
    fold: 11382,
    foldFull: [11382]
  }, {
    code: 11390,
    lower: [],
    title: [],
    upper: [],
    fold: 575,
    foldFull: [575]
  }, {
    code: 11391,
    lower: [],
    title: [],
    upper: [],
    fold: 576,
    foldFull: [576]
  }, {
    code: 11392,
    lower: [],
    title: [],
    upper: [],
    fold: 11393,
    foldFull: [11393]
  }, {
    code: 11394,
    lower: [],
    title: [],
    upper: [],
    fold: 11395,
    foldFull: [11395]
  }, {
    code: 11396,
    lower: [],
    title: [],
    upper: [],
    fold: 11397,
    foldFull: [11397]
  }, {
    code: 11398,
    lower: [],
    title: [],
    upper: [],
    fold: 11399,
    foldFull: [11399]
  }, {
    code: 11400,
    lower: [],
    title: [],
    upper: [],
    fold: 11401,
    foldFull: [11401]
  }, {
    code: 11402,
    lower: [],
    title: [],
    upper: [],
    fold: 11403,
    foldFull: [11403]
  }, {
    code: 11404,
    lower: [],
    title: [],
    upper: [],
    fold: 11405,
    foldFull: [11405]
  }, {
    code: 11406,
    lower: [],
    title: [],
    upper: [],
    fold: 11407,
    foldFull: [11407]
  }, {
    code: 11408,
    lower: [],
    title: [],
    upper: [],
    fold: 11409,
    foldFull: [11409]
  }, {
    code: 11410,
    lower: [],
    title: [],
    upper: [],
    fold: 11411,
    foldFull: [11411]
  }, {
    code: 11412,
    lower: [],
    title: [],
    upper: [],
    fold: 11413,
    foldFull: [11413]
  }, {
    code: 11414,
    lower: [],
    title: [],
    upper: [],
    fold: 11415,
    foldFull: [11415]
  }, {
    code: 11416,
    lower: [],
    title: [],
    upper: [],
    fold: 11417,
    foldFull: [11417]
  }, {
    code: 11418,
    lower: [],
    title: [],
    upper: [],
    fold: 11419,
    foldFull: [11419]
  }, {
    code: 11420,
    lower: [],
    title: [],
    upper: [],
    fold: 11421,
    foldFull: [11421]
  }, {
    code: 11422,
    lower: [],
    title: [],
    upper: [],
    fold: 11423,
    foldFull: [11423]
  }, {
    code: 11424,
    lower: [],
    title: [],
    upper: [],
    fold: 11425,
    foldFull: [11425]
  }, {
    code: 11426,
    lower: [],
    title: [],
    upper: [],
    fold: 11427,
    foldFull: [11427]
  }, {
    code: 11428,
    lower: [],
    title: [],
    upper: [],
    fold: 11429,
    foldFull: [11429]
  }, {
    code: 11430,
    lower: [],
    title: [],
    upper: [],
    fold: 11431,
    foldFull: [11431]
  }, {
    code: 11432,
    lower: [],
    title: [],
    upper: [],
    fold: 11433,
    foldFull: [11433]
  }, {
    code: 11434,
    lower: [],
    title: [],
    upper: [],
    fold: 11435,
    foldFull: [11435]
  }, {
    code: 11436,
    lower: [],
    title: [],
    upper: [],
    fold: 11437,
    foldFull: [11437]
  }, {
    code: 11438,
    lower: [],
    title: [],
    upper: [],
    fold: 11439,
    foldFull: [11439]
  }, {
    code: 11440,
    lower: [],
    title: [],
    upper: [],
    fold: 11441,
    foldFull: [11441]
  }, {
    code: 11442,
    lower: [],
    title: [],
    upper: [],
    fold: 11443,
    foldFull: [11443]
  }, {
    code: 11444,
    lower: [],
    title: [],
    upper: [],
    fold: 11445,
    foldFull: [11445]
  }, {
    code: 11446,
    lower: [],
    title: [],
    upper: [],
    fold: 11447,
    foldFull: [11447]
  }, {
    code: 11448,
    lower: [],
    title: [],
    upper: [],
    fold: 11449,
    foldFull: [11449]
  }, {
    code: 11450,
    lower: [],
    title: [],
    upper: [],
    fold: 11451,
    foldFull: [11451]
  }, {
    code: 11452,
    lower: [],
    title: [],
    upper: [],
    fold: 11453,
    foldFull: [11453]
  }, {
    code: 11454,
    lower: [],
    title: [],
    upper: [],
    fold: 11455,
    foldFull: [11455]
  }, {
    code: 11456,
    lower: [],
    title: [],
    upper: [],
    fold: 11457,
    foldFull: [11457]
  }, {
    code: 11458,
    lower: [],
    title: [],
    upper: [],
    fold: 11459,
    foldFull: [11459]
  }, {
    code: 11460,
    lower: [],
    title: [],
    upper: [],
    fold: 11461,
    foldFull: [11461]
  }, {
    code: 11462,
    lower: [],
    title: [],
    upper: [],
    fold: 11463,
    foldFull: [11463]
  }, {
    code: 11464,
    lower: [],
    title: [],
    upper: [],
    fold: 11465,
    foldFull: [11465]
  }, {
    code: 11466,
    lower: [],
    title: [],
    upper: [],
    fold: 11467,
    foldFull: [11467]
  }, {
    code: 11468,
    lower: [],
    title: [],
    upper: [],
    fold: 11469,
    foldFull: [11469]
  }, {
    code: 11470,
    lower: [],
    title: [],
    upper: [],
    fold: 11471,
    foldFull: [11471]
  }, {
    code: 11472,
    lower: [],
    title: [],
    upper: [],
    fold: 11473,
    foldFull: [11473]
  }, {
    code: 11474,
    lower: [],
    title: [],
    upper: [],
    fold: 11475,
    foldFull: [11475]
  }, {
    code: 11476,
    lower: [],
    title: [],
    upper: [],
    fold: 11477,
    foldFull: [11477]
  }, {
    code: 11478,
    lower: [],
    title: [],
    upper: [],
    fold: 11479,
    foldFull: [11479]
  }, {
    code: 11480,
    lower: [],
    title: [],
    upper: [],
    fold: 11481,
    foldFull: [11481]
  }, {
    code: 11482,
    lower: [],
    title: [],
    upper: [],
    fold: 11483,
    foldFull: [11483]
  }, {
    code: 11484,
    lower: [],
    title: [],
    upper: [],
    fold: 11485,
    foldFull: [11485]
  }, {
    code: 11486,
    lower: [],
    title: [],
    upper: [],
    fold: 11487,
    foldFull: [11487]
  }, {
    code: 11488,
    lower: [],
    title: [],
    upper: [],
    fold: 11489,
    foldFull: [11489]
  }, {
    code: 11490,
    lower: [],
    title: [],
    upper: [],
    fold: 11491,
    foldFull: [11491]
  }, {
    code: 11499,
    lower: [],
    title: [],
    upper: [],
    fold: 11500,
    foldFull: [11500]
  }, {
    code: 11501,
    lower: [],
    title: [],
    upper: [],
    fold: 11502,
    foldFull: [11502]
  }, {
    code: 11506,
    lower: [],
    title: [],
    upper: [],
    fold: 11507,
    foldFull: [11507]
  }, {
    code: 42560,
    lower: [],
    title: [],
    upper: [],
    fold: 42561,
    foldFull: [42561]
  }, {
    code: 42562,
    lower: [],
    title: [],
    upper: [],
    fold: 42563,
    foldFull: [42563]
  }, {
    code: 42564,
    lower: [],
    title: [],
    upper: [],
    fold: 42565,
    foldFull: [42565]
  }, {
    code: 42566,
    lower: [],
    title: [],
    upper: [],
    fold: 42567,
    foldFull: [42567]
  }, {
    code: 42568,
    lower: [],
    title: [],
    upper: [],
    fold: 42569,
    foldFull: [42569]
  }, {
    code: 42570,
    lower: [],
    title: [],
    upper: [],
    fold: 42571,
    foldFull: [42571]
  }, {
    code: 42572,
    lower: [],
    title: [],
    upper: [],
    fold: 42573,
    foldFull: [42573]
  }, {
    code: 42574,
    lower: [],
    title: [],
    upper: [],
    fold: 42575,
    foldFull: [42575]
  }, {
    code: 42576,
    lower: [],
    title: [],
    upper: [],
    fold: 42577,
    foldFull: [42577]
  }, {
    code: 42578,
    lower: [],
    title: [],
    upper: [],
    fold: 42579,
    foldFull: [42579]
  }, {
    code: 42580,
    lower: [],
    title: [],
    upper: [],
    fold: 42581,
    foldFull: [42581]
  }, {
    code: 42582,
    lower: [],
    title: [],
    upper: [],
    fold: 42583,
    foldFull: [42583]
  }, {
    code: 42584,
    lower: [],
    title: [],
    upper: [],
    fold: 42585,
    foldFull: [42585]
  }, {
    code: 42586,
    lower: [],
    title: [],
    upper: [],
    fold: 42587,
    foldFull: [42587]
  }, {
    code: 42588,
    lower: [],
    title: [],
    upper: [],
    fold: 42589,
    foldFull: [42589]
  }, {
    code: 42590,
    lower: [],
    title: [],
    upper: [],
    fold: 42591,
    foldFull: [42591]
  }, {
    code: 42592,
    lower: [],
    title: [],
    upper: [],
    fold: 42593,
    foldFull: [42593]
  }, {
    code: 42594,
    lower: [],
    title: [],
    upper: [],
    fold: 42595,
    foldFull: [42595]
  }, {
    code: 42596,
    lower: [],
    title: [],
    upper: [],
    fold: 42597,
    foldFull: [42597]
  }, {
    code: 42598,
    lower: [],
    title: [],
    upper: [],
    fold: 42599,
    foldFull: [42599]
  }, {
    code: 42600,
    lower: [],
    title: [],
    upper: [],
    fold: 42601,
    foldFull: [42601]
  }, {
    code: 42602,
    lower: [],
    title: [],
    upper: [],
    fold: 42603,
    foldFull: [42603]
  }, {
    code: 42604,
    lower: [],
    title: [],
    upper: [],
    fold: 42605,
    foldFull: [42605]
  }, {
    code: 42624,
    lower: [],
    title: [],
    upper: [],
    fold: 42625,
    foldFull: [42625]
  }, {
    code: 42626,
    lower: [],
    title: [],
    upper: [],
    fold: 42627,
    foldFull: [42627]
  }, {
    code: 42628,
    lower: [],
    title: [],
    upper: [],
    fold: 42629,
    foldFull: [42629]
  }, {
    code: 42630,
    lower: [],
    title: [],
    upper: [],
    fold: 42631,
    foldFull: [42631]
  }, {
    code: 42632,
    lower: [],
    title: [],
    upper: [],
    fold: 42633,
    foldFull: [42633]
  }, {
    code: 42634,
    lower: [],
    title: [],
    upper: [],
    fold: 42635,
    foldFull: [42635]
  }, {
    code: 42636,
    lower: [],
    title: [],
    upper: [],
    fold: 42637,
    foldFull: [42637]
  }, {
    code: 42638,
    lower: [],
    title: [],
    upper: [],
    fold: 42639,
    foldFull: [42639]
  }, {
    code: 42640,
    lower: [],
    title: [],
    upper: [],
    fold: 42641,
    foldFull: [42641]
  }, {
    code: 42642,
    lower: [],
    title: [],
    upper: [],
    fold: 42643,
    foldFull: [42643]
  }, {
    code: 42644,
    lower: [],
    title: [],
    upper: [],
    fold: 42645,
    foldFull: [42645]
  }, {
    code: 42646,
    lower: [],
    title: [],
    upper: [],
    fold: 42647,
    foldFull: [42647]
  }, {
    code: 42648,
    lower: [],
    title: [],
    upper: [],
    fold: 42649,
    foldFull: [42649]
  }, {
    code: 42650,
    lower: [],
    title: [],
    upper: [],
    fold: 42651,
    foldFull: [42651]
  }, {
    code: 42786,
    lower: [],
    title: [],
    upper: [],
    fold: 42787,
    foldFull: [42787]
  }, {
    code: 42788,
    lower: [],
    title: [],
    upper: [],
    fold: 42789,
    foldFull: [42789]
  }, {
    code: 42790,
    lower: [],
    title: [],
    upper: [],
    fold: 42791,
    foldFull: [42791]
  }, {
    code: 42792,
    lower: [],
    title: [],
    upper: [],
    fold: 42793,
    foldFull: [42793]
  }, {
    code: 42794,
    lower: [],
    title: [],
    upper: [],
    fold: 42795,
    foldFull: [42795]
  }, {
    code: 42796,
    lower: [],
    title: [],
    upper: [],
    fold: 42797,
    foldFull: [42797]
  }, {
    code: 42798,
    lower: [],
    title: [],
    upper: [],
    fold: 42799,
    foldFull: [42799]
  }, {
    code: 42802,
    lower: [],
    title: [],
    upper: [],
    fold: 42803,
    foldFull: [42803]
  }, {
    code: 42804,
    lower: [],
    title: [],
    upper: [],
    fold: 42805,
    foldFull: [42805]
  }, {
    code: 42806,
    lower: [],
    title: [],
    upper: [],
    fold: 42807,
    foldFull: [42807]
  }, {
    code: 42808,
    lower: [],
    title: [],
    upper: [],
    fold: 42809,
    foldFull: [42809]
  }, {
    code: 42810,
    lower: [],
    title: [],
    upper: [],
    fold: 42811,
    foldFull: [42811]
  }, {
    code: 42812,
    lower: [],
    title: [],
    upper: [],
    fold: 42813,
    foldFull: [42813]
  }, {
    code: 42814,
    lower: [],
    title: [],
    upper: [],
    fold: 42815,
    foldFull: [42815]
  }, {
    code: 42816,
    lower: [],
    title: [],
    upper: [],
    fold: 42817,
    foldFull: [42817]
  }, {
    code: 42818,
    lower: [],
    title: [],
    upper: [],
    fold: 42819,
    foldFull: [42819]
  }, {
    code: 42820,
    lower: [],
    title: [],
    upper: [],
    fold: 42821,
    foldFull: [42821]
  }, {
    code: 42822,
    lower: [],
    title: [],
    upper: [],
    fold: 42823,
    foldFull: [42823]
  }, {
    code: 42824,
    lower: [],
    title: [],
    upper: [],
    fold: 42825,
    foldFull: [42825]
  }, {
    code: 42826,
    lower: [],
    title: [],
    upper: [],
    fold: 42827,
    foldFull: [42827]
  }, {
    code: 42828,
    lower: [],
    title: [],
    upper: [],
    fold: 42829,
    foldFull: [42829]
  }, {
    code: 42830,
    lower: [],
    title: [],
    upper: [],
    fold: 42831,
    foldFull: [42831]
  }, {
    code: 42832,
    lower: [],
    title: [],
    upper: [],
    fold: 42833,
    foldFull: [42833]
  }, {
    code: 42834,
    lower: [],
    title: [],
    upper: [],
    fold: 42835,
    foldFull: [42835]
  }, {
    code: 42836,
    lower: [],
    title: [],
    upper: [],
    fold: 42837,
    foldFull: [42837]
  }, {
    code: 42838,
    lower: [],
    title: [],
    upper: [],
    fold: 42839,
    foldFull: [42839]
  }, {
    code: 42840,
    lower: [],
    title: [],
    upper: [],
    fold: 42841,
    foldFull: [42841]
  }, {
    code: 42842,
    lower: [],
    title: [],
    upper: [],
    fold: 42843,
    foldFull: [42843]
  }, {
    code: 42844,
    lower: [],
    title: [],
    upper: [],
    fold: 42845,
    foldFull: [42845]
  }, {
    code: 42846,
    lower: [],
    title: [],
    upper: [],
    fold: 42847,
    foldFull: [42847]
  }, {
    code: 42848,
    lower: [],
    title: [],
    upper: [],
    fold: 42849,
    foldFull: [42849]
  }, {
    code: 42850,
    lower: [],
    title: [],
    upper: [],
    fold: 42851,
    foldFull: [42851]
  }, {
    code: 42852,
    lower: [],
    title: [],
    upper: [],
    fold: 42853,
    foldFull: [42853]
  }, {
    code: 42854,
    lower: [],
    title: [],
    upper: [],
    fold: 42855,
    foldFull: [42855]
  }, {
    code: 42856,
    lower: [],
    title: [],
    upper: [],
    fold: 42857,
    foldFull: [42857]
  }, {
    code: 42858,
    lower: [],
    title: [],
    upper: [],
    fold: 42859,
    foldFull: [42859]
  }, {
    code: 42860,
    lower: [],
    title: [],
    upper: [],
    fold: 42861,
    foldFull: [42861]
  }, {
    code: 42862,
    lower: [],
    title: [],
    upper: [],
    fold: 42863,
    foldFull: [42863]
  }, {
    code: 42873,
    lower: [],
    title: [],
    upper: [],
    fold: 42874,
    foldFull: [42874]
  }, {
    code: 42875,
    lower: [],
    title: [],
    upper: [],
    fold: 42876,
    foldFull: [42876]
  }, {
    code: 42877,
    lower: [],
    title: [],
    upper: [],
    fold: 7545,
    foldFull: [7545]
  }, {
    code: 42878,
    lower: [],
    title: [],
    upper: [],
    fold: 42879,
    foldFull: [42879]
  }, {
    code: 42880,
    lower: [],
    title: [],
    upper: [],
    fold: 42881,
    foldFull: [42881]
  }, {
    code: 42882,
    lower: [],
    title: [],
    upper: [],
    fold: 42883,
    foldFull: [42883]
  }, {
    code: 42884,
    lower: [],
    title: [],
    upper: [],
    fold: 42885,
    foldFull: [42885]
  }, {
    code: 42886,
    lower: [],
    title: [],
    upper: [],
    fold: 42887,
    foldFull: [42887]
  }, {
    code: 42891,
    lower: [],
    title: [],
    upper: [],
    fold: 42892,
    foldFull: [42892]
  }, {
    code: 42893,
    lower: [],
    title: [],
    upper: [],
    fold: 613,
    foldFull: [613]
  }, {
    code: 42896,
    lower: [],
    title: [],
    upper: [],
    fold: 42897,
    foldFull: [42897]
  }, {
    code: 42898,
    lower: [],
    title: [],
    upper: [],
    fold: 42899,
    foldFull: [42899]
  }, {
    code: 42902,
    lower: [],
    title: [],
    upper: [],
    fold: 42903,
    foldFull: [42903]
  }, {
    code: 42904,
    lower: [],
    title: [],
    upper: [],
    fold: 42905,
    foldFull: [42905]
  }, {
    code: 42906,
    lower: [],
    title: [],
    upper: [],
    fold: 42907,
    foldFull: [42907]
  }, {
    code: 42908,
    lower: [],
    title: [],
    upper: [],
    fold: 42909,
    foldFull: [42909]
  }, {
    code: 42910,
    lower: [],
    title: [],
    upper: [],
    fold: 42911,
    foldFull: [42911]
  }, {
    code: 42912,
    lower: [],
    title: [],
    upper: [],
    fold: 42913,
    foldFull: [42913]
  }, {
    code: 42914,
    lower: [],
    title: [],
    upper: [],
    fold: 42915,
    foldFull: [42915]
  }, {
    code: 42916,
    lower: [],
    title: [],
    upper: [],
    fold: 42917,
    foldFull: [42917]
  }, {
    code: 42918,
    lower: [],
    title: [],
    upper: [],
    fold: 42919,
    foldFull: [42919]
  }, {
    code: 42920,
    lower: [],
    title: [],
    upper: [],
    fold: 42921,
    foldFull: [42921]
  }, {
    code: 42922,
    lower: [],
    title: [],
    upper: [],
    fold: 614,
    foldFull: [614]
  }, {
    code: 42923,
    lower: [],
    title: [],
    upper: [],
    fold: 604,
    foldFull: [604]
  }, {
    code: 42924,
    lower: [],
    title: [],
    upper: [],
    fold: 609,
    foldFull: [609]
  }, {
    code: 42925,
    lower: [],
    title: [],
    upper: [],
    fold: 620,
    foldFull: [620]
  }, {
    code: 42926,
    lower: [],
    title: [],
    upper: [],
    fold: 618,
    foldFull: [618]
  }, {
    code: 42928,
    lower: [],
    title: [],
    upper: [],
    fold: 670,
    foldFull: [670]
  }, {
    code: 42929,
    lower: [],
    title: [],
    upper: [],
    fold: 647,
    foldFull: [647]
  }, {
    code: 42930,
    lower: [],
    title: [],
    upper: [],
    fold: 669,
    foldFull: [669]
  }, {
    code: 42931,
    lower: [],
    title: [],
    upper: [],
    fold: 43859,
    foldFull: [43859]
  }, {
    code: 42932,
    lower: [],
    title: [],
    upper: [],
    fold: 42933,
    foldFull: [42933]
  }, {
    code: 42934,
    lower: [],
    title: [],
    upper: [],
    fold: 42935,
    foldFull: [42935]
  }, {
    code: 42936,
    lower: [],
    title: [],
    upper: [],
    fold: 42937,
    foldFull: [42937]
  }, {
    code: 42938,
    lower: [],
    title: [],
    upper: [],
    fold: 42939,
    foldFull: [42939]
  }, {
    code: 42940,
    lower: [],
    title: [],
    upper: [],
    fold: 42941,
    foldFull: [42941]
  }, {
    code: 42942,
    lower: [],
    title: [],
    upper: [],
    fold: 42943,
    foldFull: [42943]
  }, {
    code: 42946,
    lower: [],
    title: [],
    upper: [],
    fold: 42947,
    foldFull: [42947]
  }, {
    code: 42948,
    lower: [],
    title: [],
    upper: [],
    fold: 42900,
    foldFull: [42900]
  }, {
    code: 42949,
    lower: [],
    title: [],
    upper: [],
    fold: 642,
    foldFull: [642]
  }, {
    code: 42950,
    lower: [],
    title: [],
    upper: [],
    fold: 7566,
    foldFull: [7566]
  }, {
    code: 42951,
    lower: [],
    title: [],
    upper: [],
    fold: 42952,
    foldFull: [42952]
  }, {
    code: 42953,
    lower: [],
    title: [],
    upper: [],
    fold: 42954,
    foldFull: [42954]
  }, {
    code: 42997,
    lower: [],
    title: [],
    upper: [],
    fold: 42998,
    foldFull: [42998]
  }, {
    code: 43888,
    lower: [],
    title: [],
    upper: [],
    fold: 5024,
    foldFull: [5024]
  }, {
    code: 43889,
    lower: [],
    title: [],
    upper: [],
    fold: 5025,
    foldFull: [5025]
  }, {
    code: 43890,
    lower: [],
    title: [],
    upper: [],
    fold: 5026,
    foldFull: [5026]
  }, {
    code: 43891,
    lower: [],
    title: [],
    upper: [],
    fold: 5027,
    foldFull: [5027]
  }, {
    code: 43892,
    lower: [],
    title: [],
    upper: [],
    fold: 5028,
    foldFull: [5028]
  }, {
    code: 43893,
    lower: [],
    title: [],
    upper: [],
    fold: 5029,
    foldFull: [5029]
  }, {
    code: 43894,
    lower: [],
    title: [],
    upper: [],
    fold: 5030,
    foldFull: [5030]
  }, {
    code: 43895,
    lower: [],
    title: [],
    upper: [],
    fold: 5031,
    foldFull: [5031]
  }, {
    code: 43896,
    lower: [],
    title: [],
    upper: [],
    fold: 5032,
    foldFull: [5032]
  }, {
    code: 43897,
    lower: [],
    title: [],
    upper: [],
    fold: 5033,
    foldFull: [5033]
  }, {
    code: 43898,
    lower: [],
    title: [],
    upper: [],
    fold: 5034,
    foldFull: [5034]
  }, {
    code: 43899,
    lower: [],
    title: [],
    upper: [],
    fold: 5035,
    foldFull: [5035]
  }, {
    code: 43900,
    lower: [],
    title: [],
    upper: [],
    fold: 5036,
    foldFull: [5036]
  }, {
    code: 43901,
    lower: [],
    title: [],
    upper: [],
    fold: 5037,
    foldFull: [5037]
  }, {
    code: 43902,
    lower: [],
    title: [],
    upper: [],
    fold: 5038,
    foldFull: [5038]
  }, {
    code: 43903,
    lower: [],
    title: [],
    upper: [],
    fold: 5039,
    foldFull: [5039]
  }, {
    code: 43904,
    lower: [],
    title: [],
    upper: [],
    fold: 5040,
    foldFull: [5040]
  }, {
    code: 43905,
    lower: [],
    title: [],
    upper: [],
    fold: 5041,
    foldFull: [5041]
  }, {
    code: 43906,
    lower: [],
    title: [],
    upper: [],
    fold: 5042,
    foldFull: [5042]
  }, {
    code: 43907,
    lower: [],
    title: [],
    upper: [],
    fold: 5043,
    foldFull: [5043]
  }, {
    code: 43908,
    lower: [],
    title: [],
    upper: [],
    fold: 5044,
    foldFull: [5044]
  }, {
    code: 43909,
    lower: [],
    title: [],
    upper: [],
    fold: 5045,
    foldFull: [5045]
  }, {
    code: 43910,
    lower: [],
    title: [],
    upper: [],
    fold: 5046,
    foldFull: [5046]
  }, {
    code: 43911,
    lower: [],
    title: [],
    upper: [],
    fold: 5047,
    foldFull: [5047]
  }, {
    code: 43912,
    lower: [],
    title: [],
    upper: [],
    fold: 5048,
    foldFull: [5048]
  }, {
    code: 43913,
    lower: [],
    title: [],
    upper: [],
    fold: 5049,
    foldFull: [5049]
  }, {
    code: 43914,
    lower: [],
    title: [],
    upper: [],
    fold: 5050,
    foldFull: [5050]
  }, {
    code: 43915,
    lower: [],
    title: [],
    upper: [],
    fold: 5051,
    foldFull: [5051]
  }, {
    code: 43916,
    lower: [],
    title: [],
    upper: [],
    fold: 5052,
    foldFull: [5052]
  }, {
    code: 43917,
    lower: [],
    title: [],
    upper: [],
    fold: 5053,
    foldFull: [5053]
  }, {
    code: 43918,
    lower: [],
    title: [],
    upper: [],
    fold: 5054,
    foldFull: [5054]
  }, {
    code: 43919,
    lower: [],
    title: [],
    upper: [],
    fold: 5055,
    foldFull: [5055]
  }, {
    code: 43920,
    lower: [],
    title: [],
    upper: [],
    fold: 5056,
    foldFull: [5056]
  }, {
    code: 43921,
    lower: [],
    title: [],
    upper: [],
    fold: 5057,
    foldFull: [5057]
  }, {
    code: 43922,
    lower: [],
    title: [],
    upper: [],
    fold: 5058,
    foldFull: [5058]
  }, {
    code: 43923,
    lower: [],
    title: [],
    upper: [],
    fold: 5059,
    foldFull: [5059]
  }, {
    code: 43924,
    lower: [],
    title: [],
    upper: [],
    fold: 5060,
    foldFull: [5060]
  }, {
    code: 43925,
    lower: [],
    title: [],
    upper: [],
    fold: 5061,
    foldFull: [5061]
  }, {
    code: 43926,
    lower: [],
    title: [],
    upper: [],
    fold: 5062,
    foldFull: [5062]
  }, {
    code: 43927,
    lower: [],
    title: [],
    upper: [],
    fold: 5063,
    foldFull: [5063]
  }, {
    code: 43928,
    lower: [],
    title: [],
    upper: [],
    fold: 5064,
    foldFull: [5064]
  }, {
    code: 43929,
    lower: [],
    title: [],
    upper: [],
    fold: 5065,
    foldFull: [5065]
  }, {
    code: 43930,
    lower: [],
    title: [],
    upper: [],
    fold: 5066,
    foldFull: [5066]
  }, {
    code: 43931,
    lower: [],
    title: [],
    upper: [],
    fold: 5067,
    foldFull: [5067]
  }, {
    code: 43932,
    lower: [],
    title: [],
    upper: [],
    fold: 5068,
    foldFull: [5068]
  }, {
    code: 43933,
    lower: [],
    title: [],
    upper: [],
    fold: 5069,
    foldFull: [5069]
  }, {
    code: 43934,
    lower: [],
    title: [],
    upper: [],
    fold: 5070,
    foldFull: [5070]
  }, {
    code: 43935,
    lower: [],
    title: [],
    upper: [],
    fold: 5071,
    foldFull: [5071]
  }, {
    code: 43936,
    lower: [],
    title: [],
    upper: [],
    fold: 5072,
    foldFull: [5072]
  }, {
    code: 43937,
    lower: [],
    title: [],
    upper: [],
    fold: 5073,
    foldFull: [5073]
  }, {
    code: 43938,
    lower: [],
    title: [],
    upper: [],
    fold: 5074,
    foldFull: [5074]
  }, {
    code: 43939,
    lower: [],
    title: [],
    upper: [],
    fold: 5075,
    foldFull: [5075]
  }, {
    code: 43940,
    lower: [],
    title: [],
    upper: [],
    fold: 5076,
    foldFull: [5076]
  }, {
    code: 43941,
    lower: [],
    title: [],
    upper: [],
    fold: 5077,
    foldFull: [5077]
  }, {
    code: 43942,
    lower: [],
    title: [],
    upper: [],
    fold: 5078,
    foldFull: [5078]
  }, {
    code: 43943,
    lower: [],
    title: [],
    upper: [],
    fold: 5079,
    foldFull: [5079]
  }, {
    code: 43944,
    lower: [],
    title: [],
    upper: [],
    fold: 5080,
    foldFull: [5080]
  }, {
    code: 43945,
    lower: [],
    title: [],
    upper: [],
    fold: 5081,
    foldFull: [5081]
  }, {
    code: 43946,
    lower: [],
    title: [],
    upper: [],
    fold: 5082,
    foldFull: [5082]
  }, {
    code: 43947,
    lower: [],
    title: [],
    upper: [],
    fold: 5083,
    foldFull: [5083]
  }, {
    code: 43948,
    lower: [],
    title: [],
    upper: [],
    fold: 5084,
    foldFull: [5084]
  }, {
    code: 43949,
    lower: [],
    title: [],
    upper: [],
    fold: 5085,
    foldFull: [5085]
  }, {
    code: 43950,
    lower: [],
    title: [],
    upper: [],
    fold: 5086,
    foldFull: [5086]
  }, {
    code: 43951,
    lower: [],
    title: [],
    upper: [],
    fold: 5087,
    foldFull: [5087]
  }, {
    code: 43952,
    lower: [],
    title: [],
    upper: [],
    fold: 5088,
    foldFull: [5088]
  }, {
    code: 43953,
    lower: [],
    title: [],
    upper: [],
    fold: 5089,
    foldFull: [5089]
  }, {
    code: 43954,
    lower: [],
    title: [],
    upper: [],
    fold: 5090,
    foldFull: [5090]
  }, {
    code: 43955,
    lower: [],
    title: [],
    upper: [],
    fold: 5091,
    foldFull: [5091]
  }, {
    code: 43956,
    lower: [],
    title: [],
    upper: [],
    fold: 5092,
    foldFull: [5092]
  }, {
    code: 43957,
    lower: [],
    title: [],
    upper: [],
    fold: 5093,
    foldFull: [5093]
  }, {
    code: 43958,
    lower: [],
    title: [],
    upper: [],
    fold: 5094,
    foldFull: [5094]
  }, {
    code: 43959,
    lower: [],
    title: [],
    upper: [],
    fold: 5095,
    foldFull: [5095]
  }, {
    code: 43960,
    lower: [],
    title: [],
    upper: [],
    fold: 5096,
    foldFull: [5096]
  }, {
    code: 43961,
    lower: [],
    title: [],
    upper: [],
    fold: 5097,
    foldFull: [5097]
  }, {
    code: 43962,
    lower: [],
    title: [],
    upper: [],
    fold: 5098,
    foldFull: [5098]
  }, {
    code: 43963,
    lower: [],
    title: [],
    upper: [],
    fold: 5099,
    foldFull: [5099]
  }, {
    code: 43964,
    lower: [],
    title: [],
    upper: [],
    fold: 5100,
    foldFull: [5100]
  }, {
    code: 43965,
    lower: [],
    title: [],
    upper: [],
    fold: 5101,
    foldFull: [5101]
  }, {
    code: 43966,
    lower: [],
    title: [],
    upper: [],
    fold: 5102,
    foldFull: [5102]
  }, {
    code: 43967,
    lower: [],
    title: [],
    upper: [],
    fold: 5103,
    foldFull: [5103]
  }, {
    code: 64256,
    lower: [64256],
    title: [70, 102],
    upper: [70, 70],
    fold: 0,
    foldFull: [102, 102]
  }, {
    code: 64256,
    lower: [64256],
    title: [70, 102],
    upper: [70, 70],
    fold: 0,
    foldFull: [102, 102]
  }, {
    code: 64257,
    lower: [64257],
    title: [70, 105],
    upper: [70, 73],
    fold: 0,
    foldFull: [102, 105]
  }, {
    code: 64257,
    lower: [64257],
    title: [70, 105],
    upper: [70, 73],
    fold: 0,
    foldFull: [102, 105]
  }, {
    code: 64258,
    lower: [64258],
    title: [70, 108],
    upper: [70, 76],
    fold: 0,
    foldFull: [102, 108]
  }, {
    code: 64258,
    lower: [64258],
    title: [70, 108],
    upper: [70, 76],
    fold: 0,
    foldFull: [102, 108]
  }, {
    code: 64259,
    lower: [64259],
    title: [70, 102, 105],
    upper: [70, 70, 73],
    fold: 0,
    foldFull: [102, 102, 105]
  }, {
    code: 64259,
    lower: [64259],
    title: [70, 102, 105],
    upper: [70, 70, 73],
    fold: 0,
    foldFull: [102, 102, 105]
  }, {
    code: 64260,
    lower: [64260],
    title: [70, 102, 108],
    upper: [70, 70, 76],
    fold: 0,
    foldFull: [102, 102, 108]
  }, {
    code: 64260,
    lower: [64260],
    title: [70, 102, 108],
    upper: [70, 70, 76],
    fold: 0,
    foldFull: [102, 102, 108]
  }, {
    code: 64261,
    lower: [64261],
    title: [83, 116],
    upper: [83, 84],
    fold: 0,
    foldFull: [115, 116]
  }, {
    code: 64261,
    lower: [64261],
    title: [83, 116],
    upper: [83, 84],
    fold: 0,
    foldFull: [115, 116]
  }, {
    code: 64262,
    lower: [64262],
    title: [83, 116],
    upper: [83, 84],
    fold: 0,
    foldFull: [115, 116]
  }, {
    code: 64262,
    lower: [64262],
    title: [83, 116],
    upper: [83, 84],
    fold: 0,
    foldFull: [115, 116]
  }, {
    code: 64275,
    lower: [64275],
    title: [1348, 1398],
    upper: [1348, 1350],
    fold: 0,
    foldFull: [1396, 1398]
  }, {
    code: 64275,
    lower: [64275],
    title: [1348, 1398],
    upper: [1348, 1350],
    fold: 0,
    foldFull: [1396, 1398]
  }, {
    code: 64276,
    lower: [64276],
    title: [1348, 1381],
    upper: [1348, 1333],
    fold: 0,
    foldFull: [1396, 1381]
  }, {
    code: 64276,
    lower: [64276],
    title: [1348, 1381],
    upper: [1348, 1333],
    fold: 0,
    foldFull: [1396, 1381]
  }, {
    code: 64277,
    lower: [64277],
    title: [1348, 1387],
    upper: [1348, 1339],
    fold: 0,
    foldFull: [1396, 1387]
  }, {
    code: 64277,
    lower: [64277],
    title: [1348, 1387],
    upper: [1348, 1339],
    fold: 0,
    foldFull: [1396, 1387]
  }, {
    code: 64278,
    lower: [64278],
    title: [1358, 1398],
    upper: [1358, 1350],
    fold: 0,
    foldFull: [1406, 1398]
  }, {
    code: 64278,
    lower: [64278],
    title: [1358, 1398],
    upper: [1358, 1350],
    fold: 0,
    foldFull: [1406, 1398]
  }, {
    code: 64279,
    lower: [64279],
    title: [1348, 1389],
    upper: [1348, 1341],
    fold: 0,
    foldFull: [1396, 1389]
  }, {
    code: 64279,
    lower: [64279],
    title: [1348, 1389],
    upper: [1348, 1341],
    fold: 0,
    foldFull: [1396, 1389]
  }, {
    code: 65313,
    lower: [],
    title: [],
    upper: [],
    fold: 65345,
    foldFull: [65345]
  }, {
    code: 65314,
    lower: [],
    title: [],
    upper: [],
    fold: 65346,
    foldFull: [65346]
  }, {
    code: 65315,
    lower: [],
    title: [],
    upper: [],
    fold: 65347,
    foldFull: [65347]
  }, {
    code: 65316,
    lower: [],
    title: [],
    upper: [],
    fold: 65348,
    foldFull: [65348]
  }, {
    code: 65317,
    lower: [],
    title: [],
    upper: [],
    fold: 65349,
    foldFull: [65349]
  }, {
    code: 65318,
    lower: [],
    title: [],
    upper: [],
    fold: 65350,
    foldFull: [65350]
  }, {
    code: 65319,
    lower: [],
    title: [],
    upper: [],
    fold: 65351,
    foldFull: [65351]
  }, {
    code: 65320,
    lower: [],
    title: [],
    upper: [],
    fold: 65352,
    foldFull: [65352]
  }, {
    code: 65321,
    lower: [],
    title: [],
    upper: [],
    fold: 65353,
    foldFull: [65353]
  }, {
    code: 65322,
    lower: [],
    title: [],
    upper: [],
    fold: 65354,
    foldFull: [65354]
  }, {
    code: 65323,
    lower: [],
    title: [],
    upper: [],
    fold: 65355,
    foldFull: [65355]
  }, {
    code: 65324,
    lower: [],
    title: [],
    upper: [],
    fold: 65356,
    foldFull: [65356]
  }, {
    code: 65325,
    lower: [],
    title: [],
    upper: [],
    fold: 65357,
    foldFull: [65357]
  }, {
    code: 65326,
    lower: [],
    title: [],
    upper: [],
    fold: 65358,
    foldFull: [65358]
  }, {
    code: 65327,
    lower: [],
    title: [],
    upper: [],
    fold: 65359,
    foldFull: [65359]
  }, {
    code: 65328,
    lower: [],
    title: [],
    upper: [],
    fold: 65360,
    foldFull: [65360]
  }, {
    code: 65329,
    lower: [],
    title: [],
    upper: [],
    fold: 65361,
    foldFull: [65361]
  }, {
    code: 65330,
    lower: [],
    title: [],
    upper: [],
    fold: 65362,
    foldFull: [65362]
  }, {
    code: 65331,
    lower: [],
    title: [],
    upper: [],
    fold: 65363,
    foldFull: [65363]
  }, {
    code: 65332,
    lower: [],
    title: [],
    upper: [],
    fold: 65364,
    foldFull: [65364]
  }, {
    code: 65333,
    lower: [],
    title: [],
    upper: [],
    fold: 65365,
    foldFull: [65365]
  }, {
    code: 65334,
    lower: [],
    title: [],
    upper: [],
    fold: 65366,
    foldFull: [65366]
  }, {
    code: 65335,
    lower: [],
    title: [],
    upper: [],
    fold: 65367,
    foldFull: [65367]
  }, {
    code: 65336,
    lower: [],
    title: [],
    upper: [],
    fold: 65368,
    foldFull: [65368]
  }, {
    code: 65337,
    lower: [],
    title: [],
    upper: [],
    fold: 65369,
    foldFull: [65369]
  }, {
    code: 65338,
    lower: [],
    title: [],
    upper: [],
    fold: 65370,
    foldFull: [65370]
  }, {
    code: 66560,
    lower: [],
    title: [],
    upper: [],
    fold: 66600,
    foldFull: [66600]
  }, {
    code: 66561,
    lower: [],
    title: [],
    upper: [],
    fold: 66601,
    foldFull: [66601]
  }, {
    code: 66562,
    lower: [],
    title: [],
    upper: [],
    fold: 66602,
    foldFull: [66602]
  }, {
    code: 66563,
    lower: [],
    title: [],
    upper: [],
    fold: 66603,
    foldFull: [66603]
  }, {
    code: 66564,
    lower: [],
    title: [],
    upper: [],
    fold: 66604,
    foldFull: [66604]
  }, {
    code: 66565,
    lower: [],
    title: [],
    upper: [],
    fold: 66605,
    foldFull: [66605]
  }, {
    code: 66566,
    lower: [],
    title: [],
    upper: [],
    fold: 66606,
    foldFull: [66606]
  }, {
    code: 66567,
    lower: [],
    title: [],
    upper: [],
    fold: 66607,
    foldFull: [66607]
  }, {
    code: 66568,
    lower: [],
    title: [],
    upper: [],
    fold: 66608,
    foldFull: [66608]
  }, {
    code: 66569,
    lower: [],
    title: [],
    upper: [],
    fold: 66609,
    foldFull: [66609]
  }, {
    code: 66570,
    lower: [],
    title: [],
    upper: [],
    fold: 66610,
    foldFull: [66610]
  }, {
    code: 66571,
    lower: [],
    title: [],
    upper: [],
    fold: 66611,
    foldFull: [66611]
  }, {
    code: 66572,
    lower: [],
    title: [],
    upper: [],
    fold: 66612,
    foldFull: [66612]
  }, {
    code: 66573,
    lower: [],
    title: [],
    upper: [],
    fold: 66613,
    foldFull: [66613]
  }, {
    code: 66574,
    lower: [],
    title: [],
    upper: [],
    fold: 66614,
    foldFull: [66614]
  }, {
    code: 66575,
    lower: [],
    title: [],
    upper: [],
    fold: 66615,
    foldFull: [66615]
  }, {
    code: 66576,
    lower: [],
    title: [],
    upper: [],
    fold: 66616,
    foldFull: [66616]
  }, {
    code: 66577,
    lower: [],
    title: [],
    upper: [],
    fold: 66617,
    foldFull: [66617]
  }, {
    code: 66578,
    lower: [],
    title: [],
    upper: [],
    fold: 66618,
    foldFull: [66618]
  }, {
    code: 66579,
    lower: [],
    title: [],
    upper: [],
    fold: 66619,
    foldFull: [66619]
  }, {
    code: 66580,
    lower: [],
    title: [],
    upper: [],
    fold: 66620,
    foldFull: [66620]
  }, {
    code: 66581,
    lower: [],
    title: [],
    upper: [],
    fold: 66621,
    foldFull: [66621]
  }, {
    code: 66582,
    lower: [],
    title: [],
    upper: [],
    fold: 66622,
    foldFull: [66622]
  }, {
    code: 66583,
    lower: [],
    title: [],
    upper: [],
    fold: 66623,
    foldFull: [66623]
  }, {
    code: 66584,
    lower: [],
    title: [],
    upper: [],
    fold: 66624,
    foldFull: [66624]
  }, {
    code: 66585,
    lower: [],
    title: [],
    upper: [],
    fold: 66625,
    foldFull: [66625]
  }, {
    code: 66586,
    lower: [],
    title: [],
    upper: [],
    fold: 66626,
    foldFull: [66626]
  }, {
    code: 66587,
    lower: [],
    title: [],
    upper: [],
    fold: 66627,
    foldFull: [66627]
  }, {
    code: 66588,
    lower: [],
    title: [],
    upper: [],
    fold: 66628,
    foldFull: [66628]
  }, {
    code: 66589,
    lower: [],
    title: [],
    upper: [],
    fold: 66629,
    foldFull: [66629]
  }, {
    code: 66590,
    lower: [],
    title: [],
    upper: [],
    fold: 66630,
    foldFull: [66630]
  }, {
    code: 66591,
    lower: [],
    title: [],
    upper: [],
    fold: 66631,
    foldFull: [66631]
  }, {
    code: 66592,
    lower: [],
    title: [],
    upper: [],
    fold: 66632,
    foldFull: [66632]
  }, {
    code: 66593,
    lower: [],
    title: [],
    upper: [],
    fold: 66633,
    foldFull: [66633]
  }, {
    code: 66594,
    lower: [],
    title: [],
    upper: [],
    fold: 66634,
    foldFull: [66634]
  }, {
    code: 66595,
    lower: [],
    title: [],
    upper: [],
    fold: 66635,
    foldFull: [66635]
  }, {
    code: 66596,
    lower: [],
    title: [],
    upper: [],
    fold: 66636,
    foldFull: [66636]
  }, {
    code: 66597,
    lower: [],
    title: [],
    upper: [],
    fold: 66637,
    foldFull: [66637]
  }, {
    code: 66598,
    lower: [],
    title: [],
    upper: [],
    fold: 66638,
    foldFull: [66638]
  }, {
    code: 66599,
    lower: [],
    title: [],
    upper: [],
    fold: 66639,
    foldFull: [66639]
  }, {
    code: 66736,
    lower: [],
    title: [],
    upper: [],
    fold: 66776,
    foldFull: [66776]
  }, {
    code: 66737,
    lower: [],
    title: [],
    upper: [],
    fold: 66777,
    foldFull: [66777]
  }, {
    code: 66738,
    lower: [],
    title: [],
    upper: [],
    fold: 66778,
    foldFull: [66778]
  }, {
    code: 66739,
    lower: [],
    title: [],
    upper: [],
    fold: 66779,
    foldFull: [66779]
  }, {
    code: 66740,
    lower: [],
    title: [],
    upper: [],
    fold: 66780,
    foldFull: [66780]
  }, {
    code: 66741,
    lower: [],
    title: [],
    upper: [],
    fold: 66781,
    foldFull: [66781]
  }, {
    code: 66742,
    lower: [],
    title: [],
    upper: [],
    fold: 66782,
    foldFull: [66782]
  }, {
    code: 66743,
    lower: [],
    title: [],
    upper: [],
    fold: 66783,
    foldFull: [66783]
  }, {
    code: 66744,
    lower: [],
    title: [],
    upper: [],
    fold: 66784,
    foldFull: [66784]
  }, {
    code: 66745,
    lower: [],
    title: [],
    upper: [],
    fold: 66785,
    foldFull: [66785]
  }, {
    code: 66746,
    lower: [],
    title: [],
    upper: [],
    fold: 66786,
    foldFull: [66786]
  }, {
    code: 66747,
    lower: [],
    title: [],
    upper: [],
    fold: 66787,
    foldFull: [66787]
  }, {
    code: 66748,
    lower: [],
    title: [],
    upper: [],
    fold: 66788,
    foldFull: [66788]
  }, {
    code: 66749,
    lower: [],
    title: [],
    upper: [],
    fold: 66789,
    foldFull: [66789]
  }, {
    code: 66750,
    lower: [],
    title: [],
    upper: [],
    fold: 66790,
    foldFull: [66790]
  }, {
    code: 66751,
    lower: [],
    title: [],
    upper: [],
    fold: 66791,
    foldFull: [66791]
  }, {
    code: 66752,
    lower: [],
    title: [],
    upper: [],
    fold: 66792,
    foldFull: [66792]
  }, {
    code: 66753,
    lower: [],
    title: [],
    upper: [],
    fold: 66793,
    foldFull: [66793]
  }, {
    code: 66754,
    lower: [],
    title: [],
    upper: [],
    fold: 66794,
    foldFull: [66794]
  }, {
    code: 66755,
    lower: [],
    title: [],
    upper: [],
    fold: 66795,
    foldFull: [66795]
  }, {
    code: 66756,
    lower: [],
    title: [],
    upper: [],
    fold: 66796,
    foldFull: [66796]
  }, {
    code: 66757,
    lower: [],
    title: [],
    upper: [],
    fold: 66797,
    foldFull: [66797]
  }, {
    code: 66758,
    lower: [],
    title: [],
    upper: [],
    fold: 66798,
    foldFull: [66798]
  }, {
    code: 66759,
    lower: [],
    title: [],
    upper: [],
    fold: 66799,
    foldFull: [66799]
  }, {
    code: 66760,
    lower: [],
    title: [],
    upper: [],
    fold: 66800,
    foldFull: [66800]
  }, {
    code: 66761,
    lower: [],
    title: [],
    upper: [],
    fold: 66801,
    foldFull: [66801]
  }, {
    code: 66762,
    lower: [],
    title: [],
    upper: [],
    fold: 66802,
    foldFull: [66802]
  }, {
    code: 66763,
    lower: [],
    title: [],
    upper: [],
    fold: 66803,
    foldFull: [66803]
  }, {
    code: 66764,
    lower: [],
    title: [],
    upper: [],
    fold: 66804,
    foldFull: [66804]
  }, {
    code: 66765,
    lower: [],
    title: [],
    upper: [],
    fold: 66805,
    foldFull: [66805]
  }, {
    code: 66766,
    lower: [],
    title: [],
    upper: [],
    fold: 66806,
    foldFull: [66806]
  }, {
    code: 66767,
    lower: [],
    title: [],
    upper: [],
    fold: 66807,
    foldFull: [66807]
  }, {
    code: 66768,
    lower: [],
    title: [],
    upper: [],
    fold: 66808,
    foldFull: [66808]
  }, {
    code: 66769,
    lower: [],
    title: [],
    upper: [],
    fold: 66809,
    foldFull: [66809]
  }, {
    code: 66770,
    lower: [],
    title: [],
    upper: [],
    fold: 66810,
    foldFull: [66810]
  }, {
    code: 66771,
    lower: [],
    title: [],
    upper: [],
    fold: 66811,
    foldFull: [66811]
  }, {
    code: 68736,
    lower: [],
    title: [],
    upper: [],
    fold: 68800,
    foldFull: [68800]
  }, {
    code: 68737,
    lower: [],
    title: [],
    upper: [],
    fold: 68801,
    foldFull: [68801]
  }, {
    code: 68738,
    lower: [],
    title: [],
    upper: [],
    fold: 68802,
    foldFull: [68802]
  }, {
    code: 68739,
    lower: [],
    title: [],
    upper: [],
    fold: 68803,
    foldFull: [68803]
  }, {
    code: 68740,
    lower: [],
    title: [],
    upper: [],
    fold: 68804,
    foldFull: [68804]
  }, {
    code: 68741,
    lower: [],
    title: [],
    upper: [],
    fold: 68805,
    foldFull: [68805]
  }, {
    code: 68742,
    lower: [],
    title: [],
    upper: [],
    fold: 68806,
    foldFull: [68806]
  }, {
    code: 68743,
    lower: [],
    title: [],
    upper: [],
    fold: 68807,
    foldFull: [68807]
  }, {
    code: 68744,
    lower: [],
    title: [],
    upper: [],
    fold: 68808,
    foldFull: [68808]
  }, {
    code: 68745,
    lower: [],
    title: [],
    upper: [],
    fold: 68809,
    foldFull: [68809]
  }, {
    code: 68746,
    lower: [],
    title: [],
    upper: [],
    fold: 68810,
    foldFull: [68810]
  }, {
    code: 68747,
    lower: [],
    title: [],
    upper: [],
    fold: 68811,
    foldFull: [68811]
  }, {
    code: 68748,
    lower: [],
    title: [],
    upper: [],
    fold: 68812,
    foldFull: [68812]
  }, {
    code: 68749,
    lower: [],
    title: [],
    upper: [],
    fold: 68813,
    foldFull: [68813]
  }, {
    code: 68750,
    lower: [],
    title: [],
    upper: [],
    fold: 68814,
    foldFull: [68814]
  }, {
    code: 68751,
    lower: [],
    title: [],
    upper: [],
    fold: 68815,
    foldFull: [68815]
  }, {
    code: 68752,
    lower: [],
    title: [],
    upper: [],
    fold: 68816,
    foldFull: [68816]
  }, {
    code: 68753,
    lower: [],
    title: [],
    upper: [],
    fold: 68817,
    foldFull: [68817]
  }, {
    code: 68754,
    lower: [],
    title: [],
    upper: [],
    fold: 68818,
    foldFull: [68818]
  }, {
    code: 68755,
    lower: [],
    title: [],
    upper: [],
    fold: 68819,
    foldFull: [68819]
  }, {
    code: 68756,
    lower: [],
    title: [],
    upper: [],
    fold: 68820,
    foldFull: [68820]
  }, {
    code: 68757,
    lower: [],
    title: [],
    upper: [],
    fold: 68821,
    foldFull: [68821]
  }, {
    code: 68758,
    lower: [],
    title: [],
    upper: [],
    fold: 68822,
    foldFull: [68822]
  }, {
    code: 68759,
    lower: [],
    title: [],
    upper: [],
    fold: 68823,
    foldFull: [68823]
  }, {
    code: 68760,
    lower: [],
    title: [],
    upper: [],
    fold: 68824,
    foldFull: [68824]
  }, {
    code: 68761,
    lower: [],
    title: [],
    upper: [],
    fold: 68825,
    foldFull: [68825]
  }, {
    code: 68762,
    lower: [],
    title: [],
    upper: [],
    fold: 68826,
    foldFull: [68826]
  }, {
    code: 68763,
    lower: [],
    title: [],
    upper: [],
    fold: 68827,
    foldFull: [68827]
  }, {
    code: 68764,
    lower: [],
    title: [],
    upper: [],
    fold: 68828,
    foldFull: [68828]
  }, {
    code: 68765,
    lower: [],
    title: [],
    upper: [],
    fold: 68829,
    foldFull: [68829]
  }, {
    code: 68766,
    lower: [],
    title: [],
    upper: [],
    fold: 68830,
    foldFull: [68830]
  }, {
    code: 68767,
    lower: [],
    title: [],
    upper: [],
    fold: 68831,
    foldFull: [68831]
  }, {
    code: 68768,
    lower: [],
    title: [],
    upper: [],
    fold: 68832,
    foldFull: [68832]
  }, {
    code: 68769,
    lower: [],
    title: [],
    upper: [],
    fold: 68833,
    foldFull: [68833]
  }, {
    code: 68770,
    lower: [],
    title: [],
    upper: [],
    fold: 68834,
    foldFull: [68834]
  }, {
    code: 68771,
    lower: [],
    title: [],
    upper: [],
    fold: 68835,
    foldFull: [68835]
  }, {
    code: 68772,
    lower: [],
    title: [],
    upper: [],
    fold: 68836,
    foldFull: [68836]
  }, {
    code: 68773,
    lower: [],
    title: [],
    upper: [],
    fold: 68837,
    foldFull: [68837]
  }, {
    code: 68774,
    lower: [],
    title: [],
    upper: [],
    fold: 68838,
    foldFull: [68838]
  }, {
    code: 68775,
    lower: [],
    title: [],
    upper: [],
    fold: 68839,
    foldFull: [68839]
  }, {
    code: 68776,
    lower: [],
    title: [],
    upper: [],
    fold: 68840,
    foldFull: [68840]
  }, {
    code: 68777,
    lower: [],
    title: [],
    upper: [],
    fold: 68841,
    foldFull: [68841]
  }, {
    code: 68778,
    lower: [],
    title: [],
    upper: [],
    fold: 68842,
    foldFull: [68842]
  }, {
    code: 68779,
    lower: [],
    title: [],
    upper: [],
    fold: 68843,
    foldFull: [68843]
  }, {
    code: 68780,
    lower: [],
    title: [],
    upper: [],
    fold: 68844,
    foldFull: [68844]
  }, {
    code: 68781,
    lower: [],
    title: [],
    upper: [],
    fold: 68845,
    foldFull: [68845]
  }, {
    code: 68782,
    lower: [],
    title: [],
    upper: [],
    fold: 68846,
    foldFull: [68846]
  }, {
    code: 68783,
    lower: [],
    title: [],
    upper: [],
    fold: 68847,
    foldFull: [68847]
  }, {
    code: 68784,
    lower: [],
    title: [],
    upper: [],
    fold: 68848,
    foldFull: [68848]
  }, {
    code: 68785,
    lower: [],
    title: [],
    upper: [],
    fold: 68849,
    foldFull: [68849]
  }, {
    code: 68786,
    lower: [],
    title: [],
    upper: [],
    fold: 68850,
    foldFull: [68850]
  }, {
    code: 71840,
    lower: [],
    title: [],
    upper: [],
    fold: 71872,
    foldFull: [71872]
  }, {
    code: 71841,
    lower: [],
    title: [],
    upper: [],
    fold: 71873,
    foldFull: [71873]
  }, {
    code: 71842,
    lower: [],
    title: [],
    upper: [],
    fold: 71874,
    foldFull: [71874]
  }, {
    code: 71843,
    lower: [],
    title: [],
    upper: [],
    fold: 71875,
    foldFull: [71875]
  }, {
    code: 71844,
    lower: [],
    title: [],
    upper: [],
    fold: 71876,
    foldFull: [71876]
  }, {
    code: 71845,
    lower: [],
    title: [],
    upper: [],
    fold: 71877,
    foldFull: [71877]
  }, {
    code: 71846,
    lower: [],
    title: [],
    upper: [],
    fold: 71878,
    foldFull: [71878]
  }, {
    code: 71847,
    lower: [],
    title: [],
    upper: [],
    fold: 71879,
    foldFull: [71879]
  }, {
    code: 71848,
    lower: [],
    title: [],
    upper: [],
    fold: 71880,
    foldFull: [71880]
  }, {
    code: 71849,
    lower: [],
    title: [],
    upper: [],
    fold: 71881,
    foldFull: [71881]
  }, {
    code: 71850,
    lower: [],
    title: [],
    upper: [],
    fold: 71882,
    foldFull: [71882]
  }, {
    code: 71851,
    lower: [],
    title: [],
    upper: [],
    fold: 71883,
    foldFull: [71883]
  }, {
    code: 71852,
    lower: [],
    title: [],
    upper: [],
    fold: 71884,
    foldFull: [71884]
  }, {
    code: 71853,
    lower: [],
    title: [],
    upper: [],
    fold: 71885,
    foldFull: [71885]
  }, {
    code: 71854,
    lower: [],
    title: [],
    upper: [],
    fold: 71886,
    foldFull: [71886]
  }, {
    code: 71855,
    lower: [],
    title: [],
    upper: [],
    fold: 71887,
    foldFull: [71887]
  }, {
    code: 71856,
    lower: [],
    title: [],
    upper: [],
    fold: 71888,
    foldFull: [71888]
  }, {
    code: 71857,
    lower: [],
    title: [],
    upper: [],
    fold: 71889,
    foldFull: [71889]
  }, {
    code: 71858,
    lower: [],
    title: [],
    upper: [],
    fold: 71890,
    foldFull: [71890]
  }, {
    code: 71859,
    lower: [],
    title: [],
    upper: [],
    fold: 71891,
    foldFull: [71891]
  }, {
    code: 71860,
    lower: [],
    title: [],
    upper: [],
    fold: 71892,
    foldFull: [71892]
  }, {
    code: 71861,
    lower: [],
    title: [],
    upper: [],
    fold: 71893,
    foldFull: [71893]
  }, {
    code: 71862,
    lower: [],
    title: [],
    upper: [],
    fold: 71894,
    foldFull: [71894]
  }, {
    code: 71863,
    lower: [],
    title: [],
    upper: [],
    fold: 71895,
    foldFull: [71895]
  }, {
    code: 71864,
    lower: [],
    title: [],
    upper: [],
    fold: 71896,
    foldFull: [71896]
  }, {
    code: 71865,
    lower: [],
    title: [],
    upper: [],
    fold: 71897,
    foldFull: [71897]
  }, {
    code: 71866,
    lower: [],
    title: [],
    upper: [],
    fold: 71898,
    foldFull: [71898]
  }, {
    code: 71867,
    lower: [],
    title: [],
    upper: [],
    fold: 71899,
    foldFull: [71899]
  }, {
    code: 71868,
    lower: [],
    title: [],
    upper: [],
    fold: 71900,
    foldFull: [71900]
  }, {
    code: 71869,
    lower: [],
    title: [],
    upper: [],
    fold: 71901,
    foldFull: [71901]
  }, {
    code: 71870,
    lower: [],
    title: [],
    upper: [],
    fold: 71902,
    foldFull: [71902]
  }, {
    code: 71871,
    lower: [],
    title: [],
    upper: [],
    fold: 71903,
    foldFull: [71903]
  }, {
    code: 93760,
    lower: [],
    title: [],
    upper: [],
    fold: 93792,
    foldFull: [93792]
  }, {
    code: 93761,
    lower: [],
    title: [],
    upper: [],
    fold: 93793,
    foldFull: [93793]
  }, {
    code: 93762,
    lower: [],
    title: [],
    upper: [],
    fold: 93794,
    foldFull: [93794]
  }, {
    code: 93763,
    lower: [],
    title: [],
    upper: [],
    fold: 93795,
    foldFull: [93795]
  }, {
    code: 93764,
    lower: [],
    title: [],
    upper: [],
    fold: 93796,
    foldFull: [93796]
  }, {
    code: 93765,
    lower: [],
    title: [],
    upper: [],
    fold: 93797,
    foldFull: [93797]
  }, {
    code: 93766,
    lower: [],
    title: [],
    upper: [],
    fold: 93798,
    foldFull: [93798]
  }, {
    code: 93767,
    lower: [],
    title: [],
    upper: [],
    fold: 93799,
    foldFull: [93799]
  }, {
    code: 93768,
    lower: [],
    title: [],
    upper: [],
    fold: 93800,
    foldFull: [93800]
  }, {
    code: 93769,
    lower: [],
    title: [],
    upper: [],
    fold: 93801,
    foldFull: [93801]
  }, {
    code: 93770,
    lower: [],
    title: [],
    upper: [],
    fold: 93802,
    foldFull: [93802]
  }, {
    code: 93771,
    lower: [],
    title: [],
    upper: [],
    fold: 93803,
    foldFull: [93803]
  }, {
    code: 93772,
    lower: [],
    title: [],
    upper: [],
    fold: 93804,
    foldFull: [93804]
  }, {
    code: 93773,
    lower: [],
    title: [],
    upper: [],
    fold: 93805,
    foldFull: [93805]
  }, {
    code: 93774,
    lower: [],
    title: [],
    upper: [],
    fold: 93806,
    foldFull: [93806]
  }, {
    code: 93775,
    lower: [],
    title: [],
    upper: [],
    fold: 93807,
    foldFull: [93807]
  }, {
    code: 93776,
    lower: [],
    title: [],
    upper: [],
    fold: 93808,
    foldFull: [93808]
  }, {
    code: 93777,
    lower: [],
    title: [],
    upper: [],
    fold: 93809,
    foldFull: [93809]
  }, {
    code: 93778,
    lower: [],
    title: [],
    upper: [],
    fold: 93810,
    foldFull: [93810]
  }, {
    code: 93779,
    lower: [],
    title: [],
    upper: [],
    fold: 93811,
    foldFull: [93811]
  }, {
    code: 93780,
    lower: [],
    title: [],
    upper: [],
    fold: 93812,
    foldFull: [93812]
  }, {
    code: 93781,
    lower: [],
    title: [],
    upper: [],
    fold: 93813,
    foldFull: [93813]
  }, {
    code: 93782,
    lower: [],
    title: [],
    upper: [],
    fold: 93814,
    foldFull: [93814]
  }, {
    code: 93783,
    lower: [],
    title: [],
    upper: [],
    fold: 93815,
    foldFull: [93815]
  }, {
    code: 93784,
    lower: [],
    title: [],
    upper: [],
    fold: 93816,
    foldFull: [93816]
  }, {
    code: 93785,
    lower: [],
    title: [],
    upper: [],
    fold: 93817,
    foldFull: [93817]
  }, {
    code: 93786,
    lower: [],
    title: [],
    upper: [],
    fold: 93818,
    foldFull: [93818]
  }, {
    code: 93787,
    lower: [],
    title: [],
    upper: [],
    fold: 93819,
    foldFull: [93819]
  }, {
    code: 93788,
    lower: [],
    title: [],
    upper: [],
    fold: 93820,
    foldFull: [93820]
  }, {
    code: 93789,
    lower: [],
    title: [],
    upper: [],
    fold: 93821,
    foldFull: [93821]
  }, {
    code: 93790,
    lower: [],
    title: [],
    upper: [],
    fold: 93822,
    foldFull: [93822]
  }, {
    code: 93791,
    lower: [],
    title: [],
    upper: [],
    fold: 93823,
    foldFull: [93823]
  }, {
    code: 125184,
    lower: [],
    title: [],
    upper: [],
    fold: 125218,
    foldFull: [125218]
  }, {
    code: 125185,
    lower: [],
    title: [],
    upper: [],
    fold: 125219,
    foldFull: [125219]
  }, {
    code: 125186,
    lower: [],
    title: [],
    upper: [],
    fold: 125220,
    foldFull: [125220]
  }, {
    code: 125187,
    lower: [],
    title: [],
    upper: [],
    fold: 125221,
    foldFull: [125221]
  }, {
    code: 125188,
    lower: [],
    title: [],
    upper: [],
    fold: 125222,
    foldFull: [125222]
  }, {
    code: 125189,
    lower: [],
    title: [],
    upper: [],
    fold: 125223,
    foldFull: [125223]
  }, {
    code: 125190,
    lower: [],
    title: [],
    upper: [],
    fold: 125224,
    foldFull: [125224]
  }, {
    code: 125191,
    lower: [],
    title: [],
    upper: [],
    fold: 125225,
    foldFull: [125225]
  }, {
    code: 125192,
    lower: [],
    title: [],
    upper: [],
    fold: 125226,
    foldFull: [125226]
  }, {
    code: 125193,
    lower: [],
    title: [],
    upper: [],
    fold: 125227,
    foldFull: [125227]
  }, {
    code: 125194,
    lower: [],
    title: [],
    upper: [],
    fold: 125228,
    foldFull: [125228]
  }, {
    code: 125195,
    lower: [],
    title: [],
    upper: [],
    fold: 125229,
    foldFull: [125229]
  }, {
    code: 125196,
    lower: [],
    title: [],
    upper: [],
    fold: 125230,
    foldFull: [125230]
  }, {
    code: 125197,
    lower: [],
    title: [],
    upper: [],
    fold: 125231,
    foldFull: [125231]
  }, {
    code: 125198,
    lower: [],
    title: [],
    upper: [],
    fold: 125232,
    foldFull: [125232]
  }, {
    code: 125199,
    lower: [],
    title: [],
    upper: [],
    fold: 125233,
    foldFull: [125233]
  }, {
    code: 125200,
    lower: [],
    title: [],
    upper: [],
    fold: 125234,
    foldFull: [125234]
  }, {
    code: 125201,
    lower: [],
    title: [],
    upper: [],
    fold: 125235,
    foldFull: [125235]
  }, {
    code: 125202,
    lower: [],
    title: [],
    upper: [],
    fold: 125236,
    foldFull: [125236]
  }, {
    code: 125203,
    lower: [],
    title: [],
    upper: [],
    fold: 125237,
    foldFull: [125237]
  }, {
    code: 125204,
    lower: [],
    title: [],
    upper: [],
    fold: 125238,
    foldFull: [125238]
  }, {
    code: 125205,
    lower: [],
    title: [],
    upper: [],
    fold: 125239,
    foldFull: [125239]
  }, {
    code: 125206,
    lower: [],
    title: [],
    upper: [],
    fold: 125240,
    foldFull: [125240]
  }, {
    code: 125207,
    lower: [],
    title: [],
    upper: [],
    fold: 125241,
    foldFull: [125241]
  }, {
    code: 125208,
    lower: [],
    title: [],
    upper: [],
    fold: 125242,
    foldFull: [125242]
  }, {
    code: 125209,
    lower: [],
    title: [],
    upper: [],
    fold: 125243,
    foldFull: [125243]
  }, {
    code: 125210,
    lower: [],
    title: [],
    upper: [],
    fold: 125244,
    foldFull: [125244]
  }, {
    code: 125211,
    lower: [],
    title: [],
    upper: [],
    fold: 125245,
    foldFull: [125245]
  }, {
    code: 125212,
    lower: [],
    title: [],
    upper: [],
    fold: 125246,
    foldFull: [125246]
  }, {
    code: 125213,
    lower: [],
    title: [],
    upper: [],
    fold: 125247,
    foldFull: [125247]
  }, {
    code: 125214,
    lower: [],
    title: [],
    upper: [],
    fold: 125248,
    foldFull: [125248]
  }, {
    code: 125215,
    lower: [],
    title: [],
    upper: [],
    fold: 125249,
    foldFull: [125249]
  }, {
    code: 125216,
    lower: [],
    title: [],
    upper: [],
    fold: 125250,
    foldFull: [125250]
  }, {
    code: 125217,
    lower: [],
    title: [],
    upper: [],
    fold: 125251,
    foldFull: [125251]
  }];
  var recCmp = function(v2) {
    return function(v1) {
      return compare2(v2.code)(v1.code);
    };
  };
  var findRule = function(code) {
    var v2 = bsearch(zeroRec(code))(rules)(length2(rules))(recCmp);
    if (v2 instanceof Nothing) {
      return zeroRec(code);
    }
    ;
    if (v2 instanceof Just) {
      return v2.value0;
    }
    ;
    throw new Error("Failed pattern match at Data.CodePoint.Unicode.Internal.Casing (line 1627, column 17 - line 1629, column 14): " + [v2.constructor.name]);
  };
  var lower = function(code) {
    var lowered = findRule(code).lower;
    var $13 = $$null2(lowered);
    if ($13) {
      return [uTowlower(code)];
    }
    ;
    return lowered;
  };

  // output/Data.CodePoint.Unicode/index.js
  var modifyFull = unsafeCoerce;
  var toLower2 = /* @__PURE__ */ modifyFull(lower);

  // output/Data.String.Unicode/index.js
  var bindFlipped4 = /* @__PURE__ */ bindFlipped(bindArray);
  var convertFull = function(f2) {
    var $4 = bindFlipped4(f2);
    return function($5) {
      return fromCodePointArray($4(toCodePointArray($5)));
    };
  };
  var toLower3 = /* @__PURE__ */ convertFull(toLower2);

  // output/Data.String.Extra/index.js
  var foldMap2 = /* @__PURE__ */ foldMap(foldableMaybe);
  var foldMap22 = /* @__PURE__ */ foldMap2(monoidArray);
  var map14 = /* @__PURE__ */ map(functorArray);
  var regexGlobal = function(regexStr) {
    return unsafeRegex(regexStr)(global);
  };
  var regexHasASCIIWords = /* @__PURE__ */ regexGlobal("[^\0-/:-@[-`{-\x7F]+");
  var regexHasUnicodeWords = /* @__PURE__ */ regexGlobal("[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9]");
  var regexUnicodeWords = /* @__PURE__ */ function() {
    var rsUpper = "[A-Z\\xc0-\\xd6\\xd8-\\xde]";
    var rsOptVar = "[\\ufe0e\\ufe0f]?";
    var rsLower = "[a-z\\xdf-\\xf6\\xf8-\\xff]";
    var rsDingbat = "[\\u2700-\\u27bf]";
    var rsBreakRange = "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    var rsBreak = "[" + (rsBreakRange + "]");
    var rsMisc = "[^" + ("\\ud800-\\udfff" + (rsBreakRange + "\\d\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde]"));
    var rsMiscLower = "(?:" + (rsLower + ("|" + (rsMisc + ")")));
    var rsMiscUpper = "(?:" + (rsUpper + ("|" + (rsMisc + ")")));
    var rsNonAstral = "[^\\ud800-\\udfff]";
    var rsOptContrLower = "(?:['\\u2019](?:d|ll|m|re|s|t|ve))?";
    var rsOptContrUpper = "(?:['\\u2019](?:D|LL|M|RE|S|T|VE))?";
    var rsComboRange = "\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\u1ab0-\\u1aff\\u1dc0-\\u1dff";
    var rsCombo = "[" + (rsComboRange + "]");
    var rsModifier = "(?:" + (rsCombo + "|\\ud83c[\\udffb-\\udfff])");
    var reOptMod = rsModifier + "?";
    var rsOptJoin = "(?:" + ("\\u200d" + ("(?:" + (rsNonAstral + ("|" + ("(?:\\ud83c[\\udde6-\\uddff]){2}" + ("|" + ("[\\ud800-\\udbff][\\udc00-\\udfff]" + (")" + (rsOptVar + (reOptMod + ")*"))))))))));
    var rsSeq = rsOptVar + (reOptMod + rsOptJoin);
    var rsEmoji = "(?:" + (rsDingbat + ("|" + ("(?:\\ud83c[\\udde6-\\uddff]){2}" + ("|" + ("[\\ud800-\\udbff][\\udc00-\\udfff]" + (")" + rsSeq))))));
    return regexGlobal(joinWith("|")([rsUpper + ("?" + (rsLower + ("+" + (rsOptContrLower + ("(?=" + (rsBreak + ("|" + (rsUpper + "|$)")))))))), rsMiscUpper + ("+" + (rsOptContrUpper + ("(?=" + (rsBreak + ("|" + (rsUpper + (rsMiscLower + "|$)"))))))), rsUpper + ("?" + (rsMiscLower + ("+" + rsOptContrLower))), rsUpper + ("+" + rsOptContrUpper), "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", "\\d+", rsEmoji]));
  }();
  var unicodeWords = /* @__PURE__ */ function() {
    var $19 = foldMap22(catMaybes2);
    var $20 = match(regexUnicodeWords);
    return function($21) {
      return $19($20($21));
    };
  }();
  var hasUnicodeWords = /* @__PURE__ */ test(regexHasUnicodeWords);
  var asciiWords = /* @__PURE__ */ function() {
    var $22 = foldMap22(catMaybes2);
    var $23 = match(regexHasASCIIWords);
    return function($24) {
      return $22($23($24));
    };
  }();
  var words = function(string2) {
    var $13 = hasUnicodeWords(string2);
    if ($13) {
      return unicodeWords(string2);
    }
    ;
    return asciiWords(string2);
  };
  var snakeCase = /* @__PURE__ */ function() {
    var $32 = joinWith("_");
    var $33 = map14(toLower3);
    return function($34) {
      return $32($33(words($34)));
    };
  }();

  // output/Yoga.JSON.Generics.TaggedSumRep/index.js
  var bind3 = /* @__PURE__ */ bind(/* @__PURE__ */ bindExceptT(monadIdentity));
  var read$prime3 = /* @__PURE__ */ read$prime(/* @__PURE__ */ readForeignObject(readForeignForeign));
  var fail4 = /* @__PURE__ */ fail(monadIdentity);
  var pure9 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeExceptT(monadIdentity));
  var read$prime1 = /* @__PURE__ */ read$prime(readForeignString);
  var map15 = /* @__PURE__ */ map(functorNonEmptyList);
  var map16 = /* @__PURE__ */ map(/* @__PURE__ */ functorExceptT(functorIdentity));
  var alt2 = /* @__PURE__ */ alt(/* @__PURE__ */ altExceptT(semigroupNonEmptyList)(monadIdentity));
  var readGenericTaggedSumRepAr = function(dictReadForeign) {
    var readImpl2 = readImpl(dictReadForeign);
    return {
      genericReadForeignTaggedSumRep: function(v2) {
        return function(f2) {
          return map16(Argument)(readImpl2(f2));
        };
      }
    };
  };
  var genericReadForeignTaggedSumRep = function(dict) {
    return dict.genericReadForeignTaggedSumRep;
  };
  var readGenericTaggedSumRepCo1 = function(dictReadGenericTaggedSumRep) {
    var genericReadForeignTaggedSumRep1 = genericReadForeignTaggedSumRep(dictReadGenericTaggedSumRep);
    return function(dictIsSymbol) {
      var reflectSymbol2 = reflectSymbol(dictIsSymbol);
      return {
        genericReadForeignTaggedSumRep: function(v2) {
          return function(f2) {
            var name16 = v2.toConstructorName(reflectSymbol2($$Proxy.value));
            return bind3(read$prime3(f2))(function(v1) {
              return bind3(maybe(fail4(new ErrorAtProperty(v2.typeTag, new ForeignError("Missing type tag: " + v2.typeTag))))(pure9)(lookup(v2.typeTag)(v1)))(function(typeFgn) {
                return bind3(read$prime1(typeFgn))(function(typeStr) {
                  return bind3(maybe(fail4(new ErrorAtProperty(v2.valueTag, new ForeignError("Missing value tag: " + v2.valueTag))))(pure9)(lookup(v2.valueTag)(v1)))(function(value12) {
                    var $94 = typeStr === name16;
                    if ($94) {
                      return withExcept(map15(ErrorAtProperty.create(name16)))(map16(Constructor)(genericReadForeignTaggedSumRep1(v2)(value12)));
                    }
                    ;
                    return fail4(new ForeignError("Wrong constructor name tag " + (typeStr + (" where " + (name16 + " was expected.")))));
                  });
                });
              });
            });
          };
        }
      };
    };
  };
  var readGenericTaggedSumRepSu = function(dictReadGenericTaggedSumRep) {
    var genericReadForeignTaggedSumRep1 = genericReadForeignTaggedSumRep(dictReadGenericTaggedSumRep);
    return function(dictReadGenericTaggedSumRep1) {
      var genericReadForeignTaggedSumRep2 = genericReadForeignTaggedSumRep(dictReadGenericTaggedSumRep1);
      return {
        genericReadForeignTaggedSumRep: function(options2) {
          return function(f2) {
            return alt2(map16(Inl.create)(genericReadForeignTaggedSumRep1(options2)(f2)))(map16(Inr.create)(genericReadForeignTaggedSumRep2(options2)(f2)));
          };
        }
      };
    };
  };
  var genericReadForeignTaggedSum = function(dictGeneric) {
    var to3 = to(dictGeneric);
    return function(dictReadGenericTaggedSumRep) {
      var genericReadForeignTaggedSumRep1 = genericReadForeignTaggedSumRep(dictReadGenericTaggedSumRep);
      return function(options2) {
        return function(f2) {
          return map16(to3)(genericReadForeignTaggedSumRep1(options2)(f2));
        };
      };
    };
  };

  // output/Scriptzzz.JSON/index.js
  var readForeignTaggedSum = function(dictGeneric) {
    var genericReadForeignTaggedSum2 = genericReadForeignTaggedSum(dictGeneric);
    return function(dictReadGenericTaggedSumRep) {
      return genericReadForeignTaggedSum2(dictReadGenericTaggedSumRep)({
        typeTag: "kind",
        valueTag: "data",
        toConstructorName: snakeCase
      });
    };
  };

  // output/Scriptzzz.App.Model.AnimationState/index.js
  var UninitializedIsSymbol = {
    reflectSymbol: function() {
      return "Uninitialized";
    }
  };
  var gameStepIsSymbol = {
    reflectSymbol: function() {
      return "gameStep";
    }
  };
  var UpdatedIsSymbol = {
    reflectSymbol: function() {
      return "Updated";
    }
  };
  var UpdatingIsSymbol = {
    reflectSymbol: function() {
      return "Updating";
    }
  };
  var add3 = /* @__PURE__ */ add(semiringNatural);
  var one2 = /* @__PURE__ */ one(semiringNatural);
  var Uninitialized = /* @__PURE__ */ function() {
    function Uninitialized2() {
    }
    ;
    Uninitialized2.value = new Uninitialized2();
    return Uninitialized2;
  }();
  var Updated = /* @__PURE__ */ function() {
    function Updated2(value0) {
      this.value0 = value0;
    }
    ;
    Updated2.create = function(value0) {
      return new Updated2(value0);
    };
    return Updated2;
  }();
  var Updating = /* @__PURE__ */ function() {
    function Updating2(value0) {
      this.value0 = value0;
    }
    ;
    Updating2.create = function(value0) {
      return new Updating2(value0);
    };
    return Updating2;
  }();
  var showGameStep = showNatural;
  var genericShowConstructor2 = /* @__PURE__ */ genericShowConstructor(/* @__PURE__ */ genericShowArgsArgument(/* @__PURE__ */ showRecord()()(/* @__PURE__ */ showRecordFieldsConsNil(gameStepIsSymbol)(showGameStep))));
  var genericAnimationState_ = {
    to: function(x2) {
      if (x2 instanceof Inl) {
        return Uninitialized.value;
      }
      ;
      if (x2 instanceof Inr && x2.value0 instanceof Inl) {
        return new Updated(x2.value0.value0);
      }
      ;
      if (x2 instanceof Inr && x2.value0 instanceof Inr) {
        return new Updating(x2.value0.value0);
      }
      ;
      throw new Error("Failed pattern match at Scriptzzz.App.Model.AnimationState (line 25, column 1 - line 25, column 41): " + [x2.constructor.name]);
    },
    from: function(x2) {
      if (x2 instanceof Uninitialized) {
        return new Inl(NoArguments.value);
      }
      ;
      if (x2 instanceof Updated) {
        return new Inr(new Inl(x2.value0));
      }
      ;
      if (x2 instanceof Updating) {
        return new Inr(new Inr(x2.value0));
      }
      ;
      throw new Error("Failed pattern match at Scriptzzz.App.Model.AnimationState (line 25, column 1 - line 25, column 41): " + [x2.constructor.name]);
    }
  };
  var showAnimationState = {
    show: /* @__PURE__ */ genericShow(genericAnimationState_)(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor(genericShowArgsNoArguments)(UninitializedIsSymbol))(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor2(UpdatedIsSymbol))(/* @__PURE__ */ genericShowConstructor2(UpdatingIsSymbol))))
  };
  var eqGameStep = eqNatural;
  var genericEqConstructor2 = /* @__PURE__ */ genericEqConstructor(/* @__PURE__ */ genericEqArgument(/* @__PURE__ */ eqRec()(/* @__PURE__ */ eqRowCons(eqRowNil)()(gameStepIsSymbol)(eqGameStep))));
  var eqAnimationState = {
    eq: /* @__PURE__ */ genericEq(genericAnimationState_)(/* @__PURE__ */ genericEqSum(/* @__PURE__ */ genericEqConstructor(genericEqNoArguments))(/* @__PURE__ */ genericEqSum(genericEqConstructor2)(genericEqConstructor2)))
  };
  var nextGameStep = function(v2) {
    return add3(v2)(one2);
  };
  var initialGameStep = /* @__PURE__ */ zero(semiringNatural);

  // output/Control.Monad.RWS.Trans/index.js
  var RWSResult = /* @__PURE__ */ function() {
    function RWSResult2(value0, value1, value22) {
      this.value0 = value0;
      this.value1 = value1;
      this.value2 = value22;
    }
    ;
    RWSResult2.create = function(value0) {
      return function(value1) {
        return function(value22) {
          return new RWSResult2(value0, value1, value22);
        };
      };
    };
    return RWSResult2;
  }();
  var functorRWST = function(dictFunctor) {
    var map27 = map(dictFunctor);
    return {
      map: function(f2) {
        return function(v2) {
          return function(r2) {
            return function(s2) {
              return map27(function(v1) {
                return new RWSResult(v1.value0, f2(v1.value1), v1.value2);
              })(v2(r2)(s2));
            };
          };
        };
      }
    };
  };
  var execRWST = function(dictMonad) {
    var bind8 = bind(dictMonad.Bind1());
    var pure19 = pure(dictMonad.Applicative0());
    return function(v2) {
      return function(r2) {
        return function(s2) {
          return bind8(v2(r2)(s2))(function(v1) {
            return pure19(new Tuple(v1.value0, v1.value2));
          });
        };
      };
    };
  };
  var applyRWST = function(dictBind) {
    var bind8 = bind(dictBind);
    var Functor0 = dictBind.Apply0().Functor0();
    var mapFlipped2 = mapFlipped(Functor0);
    var functorRWST1 = functorRWST(Functor0);
    return function(dictMonoid) {
      var append6 = append(dictMonoid.Semigroup0());
      return {
        apply: function(v2) {
          return function(v1) {
            return function(r2) {
              return function(s2) {
                return bind8(v2(r2)(s2))(function(v22) {
                  return mapFlipped2(v1(r2)(v22.value0))(function(v3) {
                    return new RWSResult(v3.value0, v22.value1(v3.value1), append6(v22.value2)(v3.value2));
                  });
                });
              };
            };
          };
        },
        Functor0: function() {
          return functorRWST1;
        }
      };
    };
  };
  var bindRWST = function(dictBind) {
    var bind8 = bind(dictBind);
    var mapFlipped2 = mapFlipped(dictBind.Apply0().Functor0());
    var applyRWST1 = applyRWST(dictBind);
    return function(dictMonoid) {
      var append6 = append(dictMonoid.Semigroup0());
      var applyRWST2 = applyRWST1(dictMonoid);
      return {
        bind: function(v2) {
          return function(f2) {
            return function(r2) {
              return function(s2) {
                return bind8(v2(r2)(s2))(function(v1) {
                  var v22 = f2(v1.value1);
                  return mapFlipped2(v22(r2)(v1.value0))(function(v3) {
                    return new RWSResult(v3.value0, v3.value1, append6(v1.value2)(v3.value2));
                  });
                });
              };
            };
          };
        },
        Apply0: function() {
          return applyRWST2;
        }
      };
    };
  };
  var applicativeRWST = function(dictMonad) {
    var pure19 = pure(dictMonad.Applicative0());
    var applyRWST1 = applyRWST(dictMonad.Bind1());
    return function(dictMonoid) {
      var mempty4 = mempty(dictMonoid);
      var applyRWST2 = applyRWST1(dictMonoid);
      return {
        pure: function(a2) {
          return function(v2) {
            return function(s2) {
              return pure19(new RWSResult(s2, a2, mempty4));
            };
          };
        },
        Apply0: function() {
          return applyRWST2;
        }
      };
    };
  };
  var monadRWST = function(dictMonad) {
    var applicativeRWST1 = applicativeRWST(dictMonad);
    var bindRWST1 = bindRWST(dictMonad.Bind1());
    return function(dictMonoid) {
      var applicativeRWST2 = applicativeRWST1(dictMonoid);
      var bindRWST2 = bindRWST1(dictMonoid);
      return {
        Applicative0: function() {
          return applicativeRWST2;
        },
        Bind1: function() {
          return bindRWST2;
        }
      };
    };
  };
  var monadAskRWST = function(dictMonad) {
    var pure19 = pure(dictMonad.Applicative0());
    var monadRWST1 = monadRWST(dictMonad);
    return function(dictMonoid) {
      var mempty4 = mempty(dictMonoid);
      var monadRWST2 = monadRWST1(dictMonoid);
      return {
        ask: function(r2) {
          return function(s2) {
            return pure19(new RWSResult(s2, r2, mempty4));
          };
        },
        Monad0: function() {
          return monadRWST2;
        }
      };
    };
  };
  var monadStateRWST = function(dictMonad) {
    var pure19 = pure(dictMonad.Applicative0());
    var monadRWST1 = monadRWST(dictMonad);
    return function(dictMonoid) {
      var mempty4 = mempty(dictMonoid);
      var monadRWST2 = monadRWST1(dictMonoid);
      return {
        state: function(f2) {
          return function(v2) {
            return function(s2) {
              var v1 = f2(s2);
              return pure19(new RWSResult(v1.value1, v1.value0, mempty4));
            };
          };
        },
        Monad0: function() {
          return monadRWST2;
        }
      };
    };
  };
  var monadTellRWST = function(dictMonad) {
    var pure19 = pure(dictMonad.Applicative0());
    var monadRWST1 = monadRWST(dictMonad);
    return function(dictMonoid) {
      var Semigroup0 = dictMonoid.Semigroup0();
      var monadRWST2 = monadRWST1(dictMonoid);
      return {
        tell: function(w2) {
          return function(v2) {
            return function(s2) {
              return pure19(new RWSResult(s2, unit, w2));
            };
          };
        },
        Semigroup0: function() {
          return Semigroup0;
        },
        Monad1: function() {
          return monadRWST2;
        }
      };
    };
  };

  // output/Control.Monad.RWS/index.js
  var unwrap4 = /* @__PURE__ */ unwrap();
  var execRWST2 = /* @__PURE__ */ execRWST(monadIdentity);
  var execRWS = function(m2) {
    return function(r2) {
      return function(s2) {
        return unwrap4(execRWST2(m2)(r2)(s2));
      };
    };
  };

  // output/Foreign.Keys/foreign.js
  var unsafeKeys = Object.keys || function(value12) {
    var keys6 = [];
    for (var prop in value12) {
      if (Object.prototype.hasOwnProperty.call(value12, prop)) {
        keys6.push(prop);
      }
    }
    return keys6;
  };

  // output/Foreign.Keys/index.js
  var keys3 = function(dictMonad) {
    var fail6 = fail(dictMonad);
    var pure19 = pure(applicativeExceptT(dictMonad));
    return function(value12) {
      if (isNull2(value12)) {
        return fail6(new TypeMismatch2("object", "null"));
      }
      ;
      if (isUndefined(value12)) {
        return fail6(new TypeMismatch2("object", "undefined"));
      }
      ;
      if (typeOf(value12) === "object") {
        return pure19(unsafeKeys(value12));
      }
      ;
      if (otherwise) {
        return fail6(new TypeMismatch2("object", typeOf(value12)));
      }
      ;
      throw new Error("Failed pattern match at Foreign.Keys (line 17, column 1 - line 17, column 93): " + [value12.constructor.name]);
    };
  };

  // output/Scriptzzz.Game.Command/index.js
  var showMap2 = /* @__PURE__ */ showMap(showId2);
  var fail5 = /* @__PURE__ */ fail(monadIdentity);
  var bind4 = /* @__PURE__ */ bind(/* @__PURE__ */ bindExceptT(monadIdentity));
  var ix2 = /* @__PURE__ */ ix(/* @__PURE__ */ indexableForeign(monadIdentity))(/* @__PURE__ */ indexString(monadIdentity));
  var pure10 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeExceptT(monadIdentity));
  var insert7 = /* @__PURE__ */ insert3(ordId);
  var keys4 = /* @__PURE__ */ keys3(monadIdentity);
  var foldM4 = /* @__PURE__ */ foldM(foldableArray)(/* @__PURE__ */ monadExceptT(monadIdentity));
  var eqMap2 = /* @__PURE__ */ eqMap(eqId);
  var showUnitCommands = function(dictShow) {
    return showMap2(dictShow);
  };
  var readForeignUnitCommands = function(dictReadForeign) {
    var readImpl2 = readImpl(dictReadForeign);
    return {
      readImpl: function(json) {
        var accummulate = function(v2) {
          return function(key) {
            var v1 = parseId(key);
            if (v1 instanceof Left) {
              return fail5(new ForeignError("invalid unit command ID: " + v1.value0));
            }
            ;
            if (v1 instanceof Right) {
              return bind4(ix2(json)(key))(function(commandValue) {
                return bind4(readImpl2(commandValue))(function(command2) {
                  return pure10(insert7(v1.value0)(command2)(v2));
                });
              });
            }
            ;
            throw new Error("Failed pattern match at Scriptzzz.Game.Command (line 48, column 42 - line 55, column 54): " + [v1.constructor.name]);
          };
        };
        return bind4(keys4(json))(function(ks) {
          return foldM4(accummulate)(empty3)(ks);
        });
      }
    };
  };
  var foldableWithIndexIdUnitCo = foldableWithIndexMap;
  var eqUnitCommands = function(dictEq) {
    return eqMap2(dictEq);
  };

  // output/Scriptzzz.PathFinding/foreign.js
  var import_pathfinding = __toESM(require_pathfinding(), 1);
  var finder = new import_pathfinding.default.AStarFinder({ allowDiagonal: true, dontCrossCorners: true });
  function findPathImpl(obstacleMatrix) {
    return (sourcePosition) => {
      return (targetPosition) => {
        const grid = new import_pathfinding.default.Grid(obstacleMatrix);
        return finder.findPath(sourcePosition.x, sourcePosition.y, targetPosition.x, targetPosition.y, grid);
      };
    };
  }

  // output/Data.Vec/index.js
  var map17 = /* @__PURE__ */ map(functorArray);
  var toArray3 = function(v2) {
    return v2;
  };
  var fill = function(dictNat) {
    var toInt$prime2 = toInt$prime(dictNat);
    return function(f2) {
      var s2 = toInt$prime2($$Proxy.value);
      var range_ = function() {
        if (s2 === 0) {
          return [];
        }
        ;
        return range2(0)(s2 - 1 | 0);
      }();
      return map17(f2)(range_);
    };
  };
  var eqVec = function(dictEq) {
    return eqArray(dictEq);
  };

  // output/Scriptzzz.PathFinding.Map/index.js
  var eqVec2 = /* @__PURE__ */ eqVec(/* @__PURE__ */ eqVec(eqBoolean));
  var map18 = /* @__PURE__ */ map(functorArray);
  var eqObstacleMatrix = function(dictPos) {
    return function(dictPos1) {
      return eqVec2;
    };
  };
  var obstacleMatrixToArray = function(dictPos) {
    return function(dictPos1) {
      return function(v2) {
        return map18(toArray3)(toArray3(v2));
      };
    };
  };
  var showObstacleMatrix = function(dictPos) {
    return function(dictPos1) {
      return {
        show: function() {
          var renderRow = function() {
            var $47 = joinWith("");
            var $48 = map18(function(v2) {
              if (v2) {
                return "[#]";
              }
              ;
              return "[ ]";
            });
            return function($49) {
              return $47($48($49));
            };
          }();
          var showFull = function() {
            var $50 = joinWith("\n");
            var $51 = map18(renderRow);
            var $52 = obstacleMatrixToArray(dictPos1)(dictPos);
            return function($53) {
              return $50($51($52($53)));
            };
          }();
          var capLength = function(s2) {
            var $46 = length3(s2) < 21;
            if ($46) {
              return s2;
            }
            ;
            return take2(18)(s2) + "...";
          };
          return function($54) {
            return capLength(showFull($54));
          };
        }()
      };
    };
  };
  var emptyObstacleMatrix = function(dictPos) {
    var fill2 = fill(dictPos.Nat0());
    return function(dictPos1) {
      var fill1 = fill(dictPos1.Nat0());
      return fill2(function(v2) {
        return fill1(function(v1) {
          return false;
        });
      });
    };
  };

  // output/Scriptzzz.PathFinding/index.js
  var bind5 = /* @__PURE__ */ bind(/* @__PURE__ */ bindExceptT(monadIdentity));
  var pure11 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeExceptT(monadIdentity));
  var fromFoldable1 = /* @__PURE__ */ fromFoldable4(foldableArray);
  var map19 = /* @__PURE__ */ map(functorArray);
  var showPath = /* @__PURE__ */ showList(showPosition);
  var readForeignPath = function(dictPos) {
    var readForeignPosition2 = readForeignPosition(dictPos);
    return function(dictPos1) {
      var read$prime4 = read$prime(readForeignArray(readForeignPosition2(dictPos1)));
      return {
        readImpl: function(f2) {
          return bind5(read$prime4(f2))(function(v2) {
            return pure11(fromFoldable1(v2));
          });
        }
      };
    };
  };
  var eqPath = /* @__PURE__ */ eqList(eqPosition);
  var followPath = function(v2) {
    if (v2 instanceof Nil) {
      return Nothing.value;
    }
    ;
    if (v2 instanceof Cons) {
      return new Just(new Tuple(v2.value0, v2.value1));
    }
    ;
    throw new Error("Failed pattern match at Scriptzzz.PathFinding (line 66, column 31 - line 71, column 47): " + [v2.constructor.name]);
  };
  var findPath = function(dictPos) {
    return function(dictPos1) {
      var obstacleMatrixToArray2 = obstacleMatrixToArray(dictPos1)(dictPos);
      var read$prime4 = read$prime(readForeignPath(dictPos1)(dictPos));
      return function(obstacleMatrix) {
        return function(sourcePosition) {
          return function(targetPosition) {
            var convertObstacleMatrix = function() {
              var $61 = map19(map19(function(v2) {
                if (v2) {
                  return 1;
                }
                ;
                return 0;
              }));
              return function($62) {
                return $61(obstacleMatrixToArray2($62));
              };
            }();
            return runExcept(read$prime4(findPathImpl(convertObstacleMatrix(obstacleMatrix))(sourcePosition)(targetPosition)));
          };
        };
      };
    };
  };

  // output/Scriptzzz.Game/index.js
  var showRecord2 = /* @__PURE__ */ showRecord()();
  var positionIsSymbol = {
    reflectSymbol: function() {
      return "position";
    }
  };
  var showRecordFieldsCons2 = /* @__PURE__ */ showRecordFieldsCons(positionIsSymbol);
  var quantityIsSymbol = {
    reflectSymbol: function() {
      return "quantity";
    }
  };
  var EnergySourceIsSymbol = {
    reflectSymbol: function() {
      return "EnergySource";
    }
  };
  var TrailIsSymbol = {
    reflectSymbol: function() {
      return "Trail";
    }
  };
  var taskIsSymbol = {
    reflectSymbol: function() {
      return "task";
    }
  };
  var pathIsSymbol = {
    reflectSymbol: function() {
      return "path";
    }
  };
  var targetPositionIsSymbol = {
    reflectSymbol: function() {
      return "targetPosition";
    }
  };
  var WorkerIsSymbol = {
    reflectSymbol: function() {
      return "Worker";
    }
  };
  var show6 = /* @__PURE__ */ show(showId2);
  var eqRec2 = /* @__PURE__ */ eqRec();
  var eqRowCons2 = /* @__PURE__ */ eqRowCons(eqRowNil)();
  var bind13 = /* @__PURE__ */ bind(/* @__PURE__ */ bindRWST(bindIdentity)(monoidArray));
  var monadStateRWST2 = /* @__PURE__ */ monadStateRWST(monadIdentity)(monoidArray);
  var get3 = /* @__PURE__ */ get(monadStateRWST2);
  var lookup4 = /* @__PURE__ */ lookup2(ordId);
  var tell2 = /* @__PURE__ */ tell(/* @__PURE__ */ monadTellRWST(monadIdentity)(monoidArray));
  var ask2 = /* @__PURE__ */ ask(/* @__PURE__ */ monadAskRWST(monadIdentity)(monoidArray));
  var show12 = /* @__PURE__ */ show(/* @__PURE__ */ showNonEmptyList(showForeignError));
  var bind22 = /* @__PURE__ */ bind(bindMaybe);
  var put2 = /* @__PURE__ */ put(monadStateRWST2);
  var insert8 = /* @__PURE__ */ insert3(ordId);
  var pure13 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeRWST(monadIdentity)(monoidArray));
  var foldWithIndexM2 = /* @__PURE__ */ foldWithIndexM(foldableWithIndexIdUnitCo)(/* @__PURE__ */ monadRWST(monadIdentity)(monoidArray));
  var EnergySource = /* @__PURE__ */ function() {
    function EnergySource2(value0) {
      this.value0 = value0;
    }
    ;
    EnergySource2.create = function(value0) {
      return new EnergySource2(value0);
    };
    return EnergySource2;
  }();
  var Trail = /* @__PURE__ */ function() {
    function Trail2(value0) {
      this.value0 = value0;
    }
    ;
    Trail2.create = function(value0) {
      return new Trail2(value0);
    };
    return Trail2;
  }();
  var Worker2 = /* @__PURE__ */ function() {
    function Worker3(value0) {
      this.value0 = value0;
    }
    ;
    Worker3.create = function(value0) {
      return new Worker3(value0);
    };
    return Worker3;
  }();
  var showUpdateError = showString;
  var genericEntity_ = {
    to: function(x2) {
      if (x2 instanceof Inl) {
        return new EnergySource(x2.value0);
      }
      ;
      if (x2 instanceof Inr && x2.value0 instanceof Inl) {
        return new Trail(x2.value0.value0);
      }
      ;
      if (x2 instanceof Inr && x2.value0 instanceof Inr) {
        return new Worker2(x2.value0.value0);
      }
      ;
      throw new Error("Failed pattern match at Scriptzzz.Game (line 42, column 1 - line 42, column 39): " + [x2.constructor.name]);
    },
    from: function(x2) {
      if (x2 instanceof EnergySource) {
        return new Inl(x2.value0);
      }
      ;
      if (x2 instanceof Trail) {
        return new Inr(new Inl(x2.value0));
      }
      ;
      if (x2 instanceof Worker2) {
        return new Inr(new Inr(x2.value0));
      }
      ;
      throw new Error("Failed pattern match at Scriptzzz.Game (line 42, column 1 - line 42, column 39): " + [x2.constructor.name]);
    }
  };
  var showEntity = {
    show: /* @__PURE__ */ genericShow(genericEntity_)(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor(/* @__PURE__ */ genericShowArgsArgument(/* @__PURE__ */ showRecord2(/* @__PURE__ */ showRecordFieldsCons2(/* @__PURE__ */ showRecordFieldsConsNil(quantityIsSymbol)(showInt))(showPosition))))(EnergySourceIsSymbol))(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor(/* @__PURE__ */ genericShowArgsArgument(/* @__PURE__ */ showRecord2(/* @__PURE__ */ showRecordFieldsConsNil(positionIsSymbol)(showPosition))))(TrailIsSymbol))(/* @__PURE__ */ genericShowConstructor(/* @__PURE__ */ genericShowArgsArgument(/* @__PURE__ */ showRecord2(/* @__PURE__ */ showRecordFieldsCons2(/* @__PURE__ */ showRecordFieldsConsNil(taskIsSymbol)(/* @__PURE__ */ showMaybe(/* @__PURE__ */ showRecord2(/* @__PURE__ */ showRecordFieldsCons(pathIsSymbol)(/* @__PURE__ */ showRecordFieldsConsNil(targetPositionIsSymbol)(showPosition))(showPath)))))(showPosition))))(WorkerIsSymbol))))
  };
  var showState = /* @__PURE__ */ showMap(showId2)(showEntity);
  var eqUpdateError = eqString;
  var eqEntity = {
    eq: /* @__PURE__ */ genericEq(genericEntity_)(/* @__PURE__ */ genericEqSum(/* @__PURE__ */ genericEqConstructor(/* @__PURE__ */ genericEqArgument(/* @__PURE__ */ eqRec2(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons2(quantityIsSymbol)(eqInt))()(positionIsSymbol)(eqPosition)))))(/* @__PURE__ */ genericEqSum(/* @__PURE__ */ genericEqConstructor(/* @__PURE__ */ genericEqArgument(/* @__PURE__ */ eqRec2(/* @__PURE__ */ eqRowCons2(positionIsSymbol)(eqPosition)))))(/* @__PURE__ */ genericEqConstructor(/* @__PURE__ */ genericEqArgument(/* @__PURE__ */ eqRec2(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons2(taskIsSymbol)(/* @__PURE__ */ eqMaybe(/* @__PURE__ */ eqRec2(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons2(targetPositionIsSymbol)(eqPosition))()(pathIsSymbol)(eqPath)))))()(positionIsSymbol)(eqPosition)))))))
  };
  var eqState = /* @__PURE__ */ eqMap(eqId)(eqEntity);
  var moveTo = function(dictPos) {
    return function(dictPos1) {
      var findPath2 = findPath(dictPos1)(dictPos);
      return function(commands) {
        return bind13(get3)(function(v2) {
          var f2 = function(id5) {
            return function(v1) {
              return function(v22) {
                var v3 = lookup4(id5)(v2);
                if (v3 instanceof Just) {
                  if (v3.value0 instanceof EnergySource) {
                    return tell2(["cannot move a structure entity: " + show6(id5)]);
                  }
                  ;
                  if (v3.value0 instanceof Trail) {
                    return tell2(["cannot move a hint entity: " + show6(id5)]);
                  }
                  ;
                  if (v3.value0 instanceof Worker2) {
                    return bind13(ask2)(function(v4) {
                      var v5 = findPath2(v4.obstacleMatrix)(v3.value0.value0.position)(v22.position);
                      if (v5 instanceof Left) {
                        return tell2(["cannot calculate path: " + show12(v5.value0)]);
                      }
                      ;
                      if (v5 instanceof Right) {
                        var v6 = bind22(followPath(v5.value0))(function($320) {
                          return followPath(snd($320));
                        });
                        if (v6 instanceof Just) {
                          return put2(insert8(id5)(new Worker2({
                            position: v6.value0.value0,
                            task: new Just({
                              path: v6.value0.value1,
                              targetPosition: v22.position
                            })
                          }))(v2));
                        }
                        ;
                        if (v6 instanceof Nothing) {
                          return pure13(unit);
                        }
                        ;
                        throw new Error("Failed pattern match at Scriptzzz.Game (line 151, column 17 - line 165, column 30): " + [v6.constructor.name]);
                      }
                      ;
                      throw new Error("Failed pattern match at Scriptzzz.Game (line 137, column 13 - line 165, column 30): " + [v5.constructor.name]);
                    });
                  }
                  ;
                  throw new Error("Failed pattern match at Scriptzzz.Game (line 120, column 9 - line 165, column 30): " + [v3.value0.constructor.name]);
                }
                ;
                if (v3 instanceof Nothing) {
                  return tell2(["cannot move non-existion entity: " + show6(id5)]);
                }
                ;
                throw new Error("Failed pattern match at Scriptzzz.Game (line 118, column 27 - line 173, column 12): " + [v3.constructor.name]);
              };
            };
          };
          return foldWithIndexM2(f2)(unit)(commands);
        });
      };
    };
  };
  var update = function(dictPos) {
    var moveTo1 = moveTo(dictPos);
    return function(dictPos1) {
      var moveTo22 = moveTo1(dictPos1);
      return function(environment) {
        return function(commands) {
          return function(state4) {
            return execRWS(moveTo22(commands.workers.moveTo))(environment)(state4);
          };
        };
      };
    };
  };
  var blankState = function(dictPos) {
    return function(dictPos1) {
      return empty3;
    };
  };

  // output/Scriptzzz.Canvas.Animation/index.js
  var lookup5 = /* @__PURE__ */ lookup2(ordId);
  var notEq2 = /* @__PURE__ */ notEq(eqPosition);
  var append4 = /* @__PURE__ */ append(semigroupArray);
  var foldlWithIndex2 = /* @__PURE__ */ foldlWithIndex(foldableWithIndexMap);
  var difference3 = /* @__PURE__ */ difference2(ordId);
  var showFPS = showNatural;
  var eqFPS = eqNatural;
  var tenFramesPerSecond = /* @__PURE__ */ intToNat(10);
  var animate = function(dictPos) {
    return function(dictPos1) {
      return function(v2) {
        return function(v1) {
          var update3 = function(id5) {
            return function(acc) {
              return function(previousEntity) {
                var v22 = lookup5(id5)(v1);
                if (v22 instanceof Just) {
                  if (previousEntity instanceof EnergySource) {
                    return acc;
                  }
                  ;
                  if (previousEntity instanceof Trail) {
                    return acc;
                  }
                  ;
                  if (previousEntity instanceof Worker2) {
                    if (v22.value0 instanceof Worker2) {
                      var $33 = notEq2(v22.value0.value0.position)(previousEntity.value0.position);
                      if ($33) {
                        return append4(acc)([{
                          id: id5,
                          sourcePosition: previousEntity.value0.position,
                          targetPosition: v22.value0.value0.position
                        }]);
                      }
                      ;
                      return acc;
                    }
                    ;
                    return acc;
                  }
                  ;
                  throw new Error("Failed pattern match at Scriptzzz.Canvas.Animation (line 86, column 7 - line 106, column 18): " + [previousEntity.constructor.name]);
                }
                ;
                if (v22 instanceof Nothing) {
                  return acc;
                }
                ;
                throw new Error("Failed pattern match at Scriptzzz.Canvas.Animation (line 84, column 34 - line 108, column 10): " + [v22.constructor.name]);
              };
            };
          };
          var destroy = function(id5) {
            return function(acc) {
              return function(v22) {
                return append4(acc)([{
                  id: id5
                }]);
              };
            };
          };
          var create3 = function(id5) {
            return function(acc) {
              return function(v22) {
                if (v22 instanceof EnergySource) {
                  return append4(acc)([{
                    id: id5,
                    position: v22.value0.position,
                    entityType: "energy-source"
                  }]);
                }
                ;
                if (v22 instanceof Trail) {
                  return append4(acc)([{
                    id: id5,
                    position: v22.value0.position,
                    entityType: "trail"
                  }]);
                }
                ;
                if (v22 instanceof Worker2) {
                  return append4(acc)([{
                    id: id5,
                    position: v22.value0.position,
                    entityType: "worker"
                  }]);
                }
                ;
                throw new Error("Failed pattern match at Scriptzzz.Canvas.Animation (line 64, column 19 - line 70, column 56): " + [v22.constructor.name]);
              };
            };
          };
          return {
            createEntity: foldlWithIndex2(create3)([])(difference3(v1)(v2)),
            destroyEntity: foldlWithIndex2(destroy)([])(difference3(v2)(v1)),
            updateEntity: foldlWithIndex2(update3)([])(v2)
          };
        };
      };
    };
  };

  // output/Scriptzzz.Sandbox/foreign.js
  function showForeignImpl(value12) {
    return JSON.stringify(value12);
  }

  // output/Web.Worker.MessageEvent/foreign.js
  function data_(ev) {
    return ev.data;
  }

  // output/Web.Worker.Worker/foreign.js
  function _new2(src9) {
    return function(opts) {
      return function() {
        return new Worker(src9, opts);
      };
    };
  }
  function postMessageImpl(data) {
    return function(transfer) {
      return function(worker) {
        return function() {
          worker.postMessage(data, transfer.length > 0 ? transfer : void 0);
        };
      };
    };
  }
  function onMessage(f2) {
    return function(worker) {
      return function() {
        worker.onmessage = function(ev) {
          f2(ev)();
        };
      };
    };
  }
  function onError(f2) {
    return function(worker) {
      return function() {
        worker.onerror = function(ev) {
          f2(ev)();
        };
      };
    };
  }

  // output/Web.Worker.Worker/index.js
  var Classic = /* @__PURE__ */ function() {
    function Classic2() {
    }
    ;
    Classic2.value = new Classic2();
    return Classic2;
  }();
  var Module = /* @__PURE__ */ function() {
    function Module2() {
    }
    ;
    Module2.value = new Module2();
    return Module2;
  }();
  var Omit = /* @__PURE__ */ function() {
    function Omit2() {
    }
    ;
    Omit2.value = new Omit2();
    return Omit2;
  }();
  var SameOrigin = /* @__PURE__ */ function() {
    function SameOrigin2() {
    }
    ;
    SameOrigin2.value = new SameOrigin2();
    return SameOrigin2;
  }();
  var Include = /* @__PURE__ */ function() {
    function Include2() {
    }
    ;
    Include2.value = new Include2();
    return Include2;
  }();
  var showWorkerType = {
    show: function(v2) {
      if (v2 instanceof Classic) {
        return "classic";
      }
      ;
      if (v2 instanceof Module) {
        return "module";
      }
      ;
      throw new Error("Failed pattern match at Web.Worker.Worker (line 85, column 10 - line 87, column 24): " + [v2.constructor.name]);
    }
  };
  var show7 = /* @__PURE__ */ show(showWorkerType);
  var showCredentials = {
    show: function(v2) {
      if (v2 instanceof Omit) {
        return "omit";
      }
      ;
      if (v2 instanceof SameOrigin) {
        return "same-origin";
      }
      ;
      if (v2 instanceof Include) {
        return "include";
      }
      ;
      throw new Error("Failed pattern match at Web.Worker.Worker (line 90, column 10 - line 93, column 28): " + [v2.constructor.name]);
    }
  };
  var show13 = /* @__PURE__ */ show(showCredentials);
  var postMessage = function(msg) {
    return postMessageImpl(msg)([]);
  };
  var $$new2 = function(url2) {
    return function(v2) {
      return _new2(url2)({
        name: v2.name,
        credentials: show13(v2.credentials),
        type: show7(v2.type)
      });
    };
  };
  var defaultWorkerOptions = /* @__PURE__ */ function() {
    return {
      name: "",
      credentials: Omit.value,
      type: Classic.value
    };
  }();

  // output/Yoga.JSON.Error/index.js
  var show8 = /* @__PURE__ */ show(showInt);
  var toJSONPath = function(fe) {
    var go2 = function(v2) {
      if (v2 instanceof ForeignError) {
        return "";
      }
      ;
      if (v2 instanceof TypeMismatch2) {
        return "";
      }
      ;
      if (v2 instanceof ErrorAtIndex) {
        return "[" + (show8(v2.value0) + ("]" + go2(v2.value1)));
      }
      ;
      if (v2 instanceof ErrorAtProperty && (v2.value1 instanceof TypeMismatch2 && v2.value1.value1 === "undefined")) {
        return "";
      }
      ;
      if (v2 instanceof ErrorAtProperty) {
        return "." + (v2.value0 + go2(v2.value1));
      }
      ;
      throw new Error("Failed pattern match at Yoga.JSON.Error (line 11, column 8 - line 16, column 49): " + [v2.constructor.name]);
    };
    var path2 = go2(fe);
    return "$" + path2;
  };
  var errorToJSON = function(err) {
    var path2 = toJSONPath(err);
    var go2 = function($copy_v) {
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v2) {
        if (v2 instanceof ForeignError) {
          $tco_done = true;
          return {
            path: path2,
            message: v2.value0
          };
        }
        ;
        if (v2 instanceof TypeMismatch2 && v2.value1 === "Undefined") {
          $tco_done = true;
          return {
            path: path2,
            message: "Must provide a value of type '" + (v2.value0 + "'")
          };
        }
        ;
        if (v2 instanceof TypeMismatch2 && v2.value1 === "undefined") {
          $tco_done = true;
          return {
            path: path2,
            message: "Must provide a value of type '" + (v2.value0 + "'")
          };
        }
        ;
        if (v2 instanceof TypeMismatch2) {
          $tco_done = true;
          return {
            path: path2,
            message: "Must provide a value of type '" + (v2.value0 + ("' instead of '" + (v2.value1 + "'")))
          };
        }
        ;
        if (v2 instanceof ErrorAtIndex) {
          $copy_v = v2.value1;
          return;
        }
        ;
        if (v2 instanceof ErrorAtProperty) {
          $copy_v = v2.value1;
          return;
        }
        ;
        throw new Error("Failed pattern match at Yoga.JSON.Error (line 31, column 8 - line 49, column 31): " + [v2.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($copy_v);
      }
      ;
      return $tco_result;
    };
    return go2(err);
  };
  var renderHumanError = /* @__PURE__ */ function() {
    var toHuman = function(v2) {
      return v2.message + (" at " + v2.path);
    };
    return function($33) {
      return toHuman(errorToJSON($33));
    };
  }();

  // output/Scriptzzz.Sandbox/index.js
  var fromFoldable7 = /* @__PURE__ */ fromFoldable(foldableNonEmptyList);
  var map20 = /* @__PURE__ */ map(functorNonEmptyList);
  var ExecutionTimeoutIsSymbol = {
    reflectSymbol: function() {
      return "ExecutionTimeout";
    }
  };
  var genericShowConstructor3 = /* @__PURE__ */ genericShowConstructor(/* @__PURE__ */ genericShowArgsArgument(showString));
  var WebWorkerErrorIsSymbol = {
    reflectSymbol: function() {
      return "WebWorkerError";
    }
  };
  var readGenericTaggedSumRepCo12 = /* @__PURE__ */ readGenericTaggedSumRepCo1(/* @__PURE__ */ readGenericTaggedSumRepAr(readForeignString));
  var ExceptionIsSymbol = {
    reflectSymbol: function() {
      return "Exception";
    }
  };
  var ValueIsSymbol = {
    reflectSymbol: function() {
      return "Value";
    }
  };
  var showRecord3 = /* @__PURE__ */ showRecord()();
  var errorsIsSymbol = {
    reflectSymbol: function() {
      return "errors";
    }
  };
  var showRecordFieldsCons3 = /* @__PURE__ */ showRecordFieldsCons(errorsIsSymbol);
  var valueIsSymbol = {
    reflectSymbol: function() {
      return "value";
    }
  };
  var InternalParsingErrorIsSymbol = {
    reflectSymbol: function() {
      return "InternalParsingError";
    }
  };
  var ScriptExecutionErrorIsSymbol = {
    reflectSymbol: function() {
      return "ScriptExecutionError";
    }
  };
  var genericShowSum2 = /* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor3(ScriptExecutionErrorIsSymbol));
  var ScriptReturnValueNotReceivedIsSymbol = {
    reflectSymbol: function() {
      return "ScriptReturnValueNotReceived";
    }
  };
  var valueJsonIsSymbol = {
    reflectSymbol: function() {
      return "valueJson";
    }
  };
  var ScriptReturnValueParsingFailureIsSymbol = {
    reflectSymbol: function() {
      return "ScriptReturnValueParsingFailure";
    }
  };
  var SuccessIsSymbol = {
    reflectSymbol: function() {
      return "Success";
    }
  };
  var genericEqConstructor3 = /* @__PURE__ */ genericEqConstructor(/* @__PURE__ */ genericEqArgument(eqString));
  var genericEqSum2 = /* @__PURE__ */ genericEqSum(genericEqConstructor3);
  var eqRec3 = /* @__PURE__ */ eqRec();
  var eqRowCons3 = /* @__PURE__ */ eqRowCons(eqRowNil)();
  var liftEffect3 = /* @__PURE__ */ liftEffect(monadEffectAff);
  var discard3 = /* @__PURE__ */ discard(discardUnit);
  var bind14 = /* @__PURE__ */ bind(bindAff);
  var discard1 = /* @__PURE__ */ discard3(bindAff);
  var pure14 = /* @__PURE__ */ pure(applicativeAff);
  var ExecutionTimeout = /* @__PURE__ */ function() {
    function ExecutionTimeout2(value0) {
      this.value0 = value0;
    }
    ;
    ExecutionTimeout2.create = function(value0) {
      return new ExecutionTimeout2(value0);
    };
    return ExecutionTimeout2;
  }();
  var WebWorkerError = /* @__PURE__ */ function() {
    function WebWorkerError2(value0) {
      this.value0 = value0;
    }
    ;
    WebWorkerError2.create = function(value0) {
      return new WebWorkerError2(value0);
    };
    return WebWorkerError2;
  }();
  var Exception = /* @__PURE__ */ function() {
    function Exception2(value0) {
      this.value0 = value0;
    }
    ;
    Exception2.create = function(value0) {
      return new Exception2(value0);
    };
    return Exception2;
  }();
  var Value = /* @__PURE__ */ function() {
    function Value2(value0) {
      this.value0 = value0;
    }
    ;
    Value2.create = function(value0) {
      return new Value2(value0);
    };
    return Value2;
  }();
  var InternalParsingError = /* @__PURE__ */ function() {
    function InternalParsingError2(value0) {
      this.value0 = value0;
    }
    ;
    InternalParsingError2.create = function(value0) {
      return new InternalParsingError2(value0);
    };
    return InternalParsingError2;
  }();
  var ScriptExecutionError = /* @__PURE__ */ function() {
    function ScriptExecutionError2(value0) {
      this.value0 = value0;
    }
    ;
    ScriptExecutionError2.create = function(value0) {
      return new ScriptExecutionError2(value0);
    };
    return ScriptExecutionError2;
  }();
  var ScriptReturnValueNotReceived = /* @__PURE__ */ function() {
    function ScriptReturnValueNotReceived2(value0) {
      this.value0 = value0;
    }
    ;
    ScriptReturnValueNotReceived2.create = function(value0) {
      return new ScriptReturnValueNotReceived2(value0);
    };
    return ScriptReturnValueNotReceived2;
  }();
  var ScriptReturnValueParsingFailure = /* @__PURE__ */ function() {
    function ScriptReturnValueParsingFailure2(value0) {
      this.value0 = value0;
    }
    ;
    ScriptReturnValueParsingFailure2.create = function(value0) {
      return new ScriptReturnValueParsingFailure2(value0);
    };
    return ScriptReturnValueParsingFailure2;
  }();
  var Success = /* @__PURE__ */ function() {
    function Success2(value0) {
      this.value0 = value0;
    }
    ;
    Success2.create = function(value0) {
      return new Success2(value0);
    };
    return Success2;
  }();
  var showParsingErrors = {
    show: function(v2) {
      return joinWith(", ")(fromFoldable7(map20(renderHumanError)(v2)));
    }
  };
  var genericShowSum1 = /* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor(/* @__PURE__ */ genericShowArgsArgument(/* @__PURE__ */ showRecord3(/* @__PURE__ */ showRecordFieldsCons3(/* @__PURE__ */ showRecordFieldsConsNil(valueJsonIsSymbol)(showString))(showParsingErrors))))(ScriptReturnValueParsingFailureIsSymbol));
  var showForeignValue = {
    show: function(v2) {
      return showForeignImpl(v2);
    }
  };
  var genericShowSum22 = /* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor(/* @__PURE__ */ genericShowArgsArgument(/* @__PURE__ */ showRecord3(/* @__PURE__ */ showRecordFieldsCons3(/* @__PURE__ */ showRecordFieldsConsNil(valueIsSymbol)(showForeignValue))(showParsingErrors))))(InternalParsingErrorIsSymbol));
  var show14 = /* @__PURE__ */ show(showForeignValue);
  var monadSandboxM = /* @__PURE__ */ monadReaderT(monadEffect);
  var monadEffectSandboxM = /* @__PURE__ */ monadEffectReader(monadEffectEffect);
  var liftEffect22 = /* @__PURE__ */ liftEffect(monadEffectSandboxM);
  var monadAskWorkerSandboxM = /* @__PURE__ */ monadAskReaderT(monadEffect);
  var ask3 = /* @__PURE__ */ ask(monadAskWorkerSandboxM);
  var genericValueNotReceivedRe = {
    to: function(x2) {
      if (x2 instanceof Inl) {
        return new ExecutionTimeout(x2.value0);
      }
      ;
      if (x2 instanceof Inr) {
        return new WebWorkerError(x2.value0);
      }
      ;
      throw new Error("Failed pattern match at Scriptzzz.Sandbox (line 189, column 1 - line 189, column 49): " + [x2.constructor.name]);
    },
    from: function(x2) {
      if (x2 instanceof ExecutionTimeout) {
        return new Inl(x2.value0);
      }
      ;
      if (x2 instanceof WebWorkerError) {
        return new Inr(x2.value0);
      }
      ;
      throw new Error("Failed pattern match at Scriptzzz.Sandbox (line 189, column 1 - line 189, column 49): " + [x2.constructor.name]);
    }
  };
  var showValueNotReceivedReaso = {
    show: /* @__PURE__ */ genericShow(genericValueNotReceivedRe)(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor(/* @__PURE__ */ genericShowArgsArgument(showMilliseconds))(ExecutionTimeoutIsSymbol))(/* @__PURE__ */ genericShowConstructor3(WebWorkerErrorIsSymbol)))
  };
  var genericShowSum3 = /* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor(/* @__PURE__ */ genericShowArgsArgument(showValueNotReceivedReaso))(ScriptReturnValueNotReceivedIsSymbol));
  var genericSandboxWorkerMessa = {
    to: function(x2) {
      if (x2 instanceof Inl) {
        return new Exception(x2.value0);
      }
      ;
      if (x2 instanceof Inr) {
        return new Value(x2.value0);
      }
      ;
      throw new Error("Failed pattern match at Scriptzzz.Sandbox (line 141, column 1 - line 141, column 51): " + [x2.constructor.name]);
    },
    from: function(x2) {
      if (x2 instanceof Exception) {
        return new Inl(x2.value0);
      }
      ;
      if (x2 instanceof Value) {
        return new Inr(x2.value0);
      }
      ;
      throw new Error("Failed pattern match at Scriptzzz.Sandbox (line 141, column 1 - line 141, column 51): " + [x2.constructor.name]);
    }
  };
  var readForeignSandboxWorkerM = {
    readImpl: /* @__PURE__ */ readForeignTaggedSum(genericSandboxWorkerMessa)(/* @__PURE__ */ readGenericTaggedSumRepSu(/* @__PURE__ */ readGenericTaggedSumRepCo12(ExceptionIsSymbol))(/* @__PURE__ */ readGenericTaggedSumRepCo12(ValueIsSymbol)))
  };
  var genericExecutionResult_ = {
    to: function(x2) {
      if (x2 instanceof Inl) {
        return new InternalParsingError(x2.value0);
      }
      ;
      if (x2 instanceof Inr && x2.value0 instanceof Inl) {
        return new ScriptExecutionError(x2.value0.value0);
      }
      ;
      if (x2 instanceof Inr && (x2.value0 instanceof Inr && x2.value0.value0 instanceof Inl)) {
        return new ScriptReturnValueNotReceived(x2.value0.value0.value0);
      }
      ;
      if (x2 instanceof Inr && (x2.value0 instanceof Inr && (x2.value0.value0 instanceof Inr && x2.value0.value0.value0 instanceof Inl))) {
        return new ScriptReturnValueParsingFailure(x2.value0.value0.value0.value0);
      }
      ;
      if (x2 instanceof Inr && (x2.value0 instanceof Inr && (x2.value0.value0 instanceof Inr && x2.value0.value0.value0 instanceof Inr))) {
        return new Success(x2.value0.value0.value0.value0);
      }
      ;
      throw new Error("Failed pattern match at Scriptzzz.Sandbox (line 211, column 1 - line 211, column 46): " + [x2.constructor.name]);
    },
    from: function(x2) {
      if (x2 instanceof InternalParsingError) {
        return new Inl(x2.value0);
      }
      ;
      if (x2 instanceof ScriptExecutionError) {
        return new Inr(new Inl(x2.value0));
      }
      ;
      if (x2 instanceof ScriptReturnValueNotReceived) {
        return new Inr(new Inr(new Inl(x2.value0)));
      }
      ;
      if (x2 instanceof ScriptReturnValueParsingFailure) {
        return new Inr(new Inr(new Inr(new Inl(x2.value0))));
      }
      ;
      if (x2 instanceof Success) {
        return new Inr(new Inr(new Inr(new Inr(x2.value0))));
      }
      ;
      throw new Error("Failed pattern match at Scriptzzz.Sandbox (line 211, column 1 - line 211, column 46): " + [x2.constructor.name]);
    }
  };
  var genericShow2 = /* @__PURE__ */ genericShow(genericExecutionResult_);
  var genericEq2 = /* @__PURE__ */ genericEq(genericExecutionResult_);
  var showExecutionResult = function(dictShow) {
    return {
      show: genericShow2(genericShowSum22(genericShowSum2(genericShowSum3(genericShowSum1(genericShowConstructor(genericShowArgsArgument(dictShow))(SuccessIsSymbol))))))
    };
  };
  var eqValueNotReceivedReason = {
    eq: /* @__PURE__ */ genericEq(genericValueNotReceivedRe)(/* @__PURE__ */ genericEqSum(/* @__PURE__ */ genericEqConstructor(/* @__PURE__ */ genericEqArgument(eqMilliseconds)))(genericEqConstructor3))
  };
  var genericEqSum1 = /* @__PURE__ */ genericEqSum(/* @__PURE__ */ genericEqConstructor(/* @__PURE__ */ genericEqArgument(eqValueNotReceivedReason)));
  var eqParsingErrors = /* @__PURE__ */ eqNonEmptyList(eqForeignError);
  var genericEqSum22 = /* @__PURE__ */ genericEqSum(/* @__PURE__ */ genericEqConstructor(/* @__PURE__ */ genericEqArgument(/* @__PURE__ */ eqRec3(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons3(valueJsonIsSymbol)(eqString))()(errorsIsSymbol)(eqParsingErrors)))));
  var eqForeignValue = {
    eq: function(f1) {
      return function(f2) {
        return show14(f1) === show14(f2);
      };
    }
  };
  var genericEqSum3 = /* @__PURE__ */ genericEqSum(/* @__PURE__ */ genericEqConstructor(/* @__PURE__ */ genericEqArgument(/* @__PURE__ */ eqRec3(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons3(valueIsSymbol)(eqForeignValue))()(errorsIsSymbol)(eqParsingErrors)))));
  var eqExecutionResult = function(dictEq) {
    return {
      eq: genericEq2(genericEqSum3(genericEqSum2(genericEqSum1(genericEqSum22(genericEqConstructor(genericEqArgument(dictEq)))))))
    };
  };
  var bindSandboxM = /* @__PURE__ */ bindReaderT(bindEffect);
  var bind32 = /* @__PURE__ */ bind(bindSandboxM);
  var manageWebWorkerSandboxM = {
    onWebWorkerError: function(callback) {
      return bind32(ask3)(function(worker) {
        return liftEffect22(onError(callback)(worker));
      });
    },
    onWebWorkerMessage: function(callback) {
      return bind32(ask3)(function(worker) {
        return liftEffect22(onMessage(callback)(worker));
      });
    },
    postWebWorkerMessage: function(message2) {
      return bind32(ask3)(function(worker) {
        return liftEffect22(postMessage(message2)(worker));
      });
    },
    Monad0: function() {
      return monadSandboxM;
    }
  };
  var runSandboxM = function(workerScriptPath) {
    return function(v2) {
      return liftEffect3(function __do() {
        var worker = $$new2(workerScriptPath)(defaultWorkerOptions)();
        return runReaderT(v2)(worker)();
      });
    };
  };
  var readSandboxWorkerMessageData = /* @__PURE__ */ function() {
    var $429 = read$prime(readForeignSandboxWorkerM);
    return function($430) {
      return runExcept($429($430));
    };
  }();
  var postWebWorkerMessage = function(dict) {
    return dict.postWebWorkerMessage;
  };
  var onWebWorkerMessage = function(dict) {
    return dict.onWebWorkerMessage;
  };
  var onWebWorkerError = function(dict) {
    return dict.onWebWorkerError;
  };
  var output = function(dictMonadEffect) {
    return function(dictManageWebWorker) {
      var discard32 = discard3(dictManageWebWorker.Monad0().Bind1());
      var onWebWorkerError1 = onWebWorkerError(dictManageWebWorker);
      var onWebWorkerMessage1 = onWebWorkerMessage(dictManageWebWorker);
      var postWebWorkerMessage1 = postWebWorkerMessage(dictManageWebWorker);
      return function(ref) {
        return function(script) {
          return discard32(onWebWorkerError1(function(v2) {
            return write(new Left(new WebWorkerError("after initialization")))(ref);
          }))(function() {
            return discard32(onWebWorkerMessage1(function(messageEvent) {
              return write(new Right(data_(messageEvent)))(ref);
            }))(function() {
              return postWebWorkerMessage1(scriptToString(script));
            });
          });
        };
      };
    };
  };
  var runProgram = function(dictDuration) {
    var fromDuration2 = fromDuration(dictDuration);
    return function(dictManageWebWorker) {
      return function(dictMonadEffect) {
        var output1 = output(dictMonadEffect)(dictManageWebWorker);
        return function(dictReadForeign) {
          var readJSON$prime2 = readJSON$prime(dictReadForeign);
          return function(executeOutputProgram) {
            return function(maxDuration) {
              return function(script) {
                return bind14(liftEffect3($$new(new Left(new ExecutionTimeout(fromDuration2(maxDuration))))))(function(foreignValueResultRef) {
                  return bind14(forkAff(executeOutputProgram(output1(foreignValueResultRef)(script))))(function(outputProgramExecutionFiber) {
                    return discard1(delay(fromDuration2(maxDuration)))(function() {
                      return discard1(killFiber(error("timed out"))(outputProgramExecutionFiber))(function() {
                        return bind14(liftEffect3(read(foreignValueResultRef)))(function(foreignValueResult) {
                          return pure14(function() {
                            if (foreignValueResult instanceof Left) {
                              return new ScriptReturnValueNotReceived(foreignValueResult.value0);
                            }
                            ;
                            if (foreignValueResult instanceof Right) {
                              var v2 = readSandboxWorkerMessageData(foreignValueResult.value0);
                              if (v2 instanceof Left) {
                                return new InternalParsingError({
                                  errors: v2.value0,
                                  value: foreignValueResult.value0
                                });
                              }
                              ;
                              if (v2 instanceof Right) {
                                if (v2.value0 instanceof Exception) {
                                  return new ScriptExecutionError(v2.value0.value0);
                                }
                                ;
                                if (v2.value0 instanceof Value) {
                                  var v1 = runExcept(readJSON$prime2(v2.value0.value0));
                                  if (v1 instanceof Left) {
                                    return new ScriptReturnValueParsingFailure({
                                      errors: v1.value0,
                                      valueJson: v2.value0.value0
                                    });
                                  }
                                  ;
                                  if (v1 instanceof Right) {
                                    return new Success(v1.value0);
                                  }
                                  ;
                                  throw new Error("Failed pattern match at Scriptzzz.Sandbox (line 294, column 15 - line 302, column 32): " + [v1.constructor.name]);
                                }
                                ;
                                throw new Error("Failed pattern match at Scriptzzz.Sandbox (line 289, column 11 - line 302, column 32): " + [v2.value0.constructor.name]);
                              }
                              ;
                              throw new Error("Failed pattern match at Scriptzzz.Sandbox (line 281, column 7 - line 302, column 32): " + [v2.constructor.name]);
                            }
                            ;
                            throw new Error("Failed pattern match at Scriptzzz.Sandbox (line 276, column 8 - line 302, column 32): " + [foreignValueResult.constructor.name]);
                          }());
                        });
                      });
                    });
                  });
                });
              };
            };
          };
        };
      };
    };
  };

  // output/Scriptzzz.App.Model/index.js
  var showRecord4 = /* @__PURE__ */ showRecord()();
  var obstacleMatrixIsSymbol = {
    reflectSymbol: function() {
      return "obstacleMatrix";
    }
  };
  var showRecordFieldsConsNil2 = /* @__PURE__ */ showRecordFieldsConsNil(obstacleMatrixIsSymbol);
  var CanvasInitializingIsSymbol = {
    reflectSymbol: function() {
      return "CanvasInitializing";
    }
  };
  var gameSettingsIsSymbol = {
    reflectSymbol: function() {
      return "gameSettings";
    }
  };
  var lastScriptExecutionIsSymbol = {
    reflectSymbol: function() {
      return "lastScriptExecution";
    }
  };
  var scriptIsSymbol = {
    reflectSymbol: function() {
      return "script";
    }
  };
  var finishTimeIsSymbol = {
    reflectSymbol: function() {
      return "finishTime";
    }
  };
  var resultIsSymbol = {
    reflectSymbol: function() {
      return "result";
    }
  };
  var startTimeIsSymbol = {
    reflectSymbol: function() {
      return "startTime";
    }
  };
  var workersIsSymbol = {
    reflectSymbol: function() {
      return "workers";
    }
  };
  var moveToIsSymbol = {
    reflectSymbol: function() {
      return "moveTo";
    }
  };
  var positionIsSymbol2 = {
    reflectSymbol: function() {
      return "position";
    }
  };
  var showRecordFieldsCons4 = /* @__PURE__ */ showRecordFieldsCons(gameSettingsIsSymbol)(/* @__PURE__ */ showRecordFieldsCons(lastScriptExecutionIsSymbol)(/* @__PURE__ */ showRecordFieldsConsNil(scriptIsSymbol)(showScript))(/* @__PURE__ */ showMaybe(/* @__PURE__ */ showRecord4(/* @__PURE__ */ showRecordFieldsCons(finishTimeIsSymbol)(/* @__PURE__ */ showRecordFieldsCons(resultIsSymbol)(/* @__PURE__ */ showRecordFieldsConsNil(startTimeIsSymbol)(showTimestamp))(/* @__PURE__ */ showExecutionResult(/* @__PURE__ */ showRecord4(/* @__PURE__ */ showRecordFieldsConsNil(workersIsSymbol)(/* @__PURE__ */ showRecord4(/* @__PURE__ */ showRecordFieldsConsNil(moveToIsSymbol)(/* @__PURE__ */ showUnitCommands(/* @__PURE__ */ showRecord4(/* @__PURE__ */ showRecordFieldsConsNil(positionIsSymbol2)(showPosition))))))))))(showTimestamp)))));
  var environmentIsSymbol = {
    reflectSymbol: function() {
      return "environment";
    }
  };
  var initialStateIsSymbol = {
    reflectSymbol: function() {
      return "initialState";
    }
  };
  var restartOnScriptChangeIsSymbol = {
    reflectSymbol: function() {
      return "restartOnScriptChange";
    }
  };
  var stopOnErrorIsSymbol = {
    reflectSymbol: function() {
      return "stopOnError";
    }
  };
  var targetFpsIsSymbol = {
    reflectSymbol: function() {
      return "targetFps";
    }
  };
  var showRecordFieldsCons1 = /* @__PURE__ */ showRecordFieldsCons(environmentIsSymbol)(/* @__PURE__ */ showRecordFieldsCons(initialStateIsSymbol)(/* @__PURE__ */ showRecordFieldsCons(restartOnScriptChangeIsSymbol)(/* @__PURE__ */ showRecordFieldsCons(stopOnErrorIsSymbol)(/* @__PURE__ */ showRecordFieldsConsNil(targetFpsIsSymbol)(showFPS))(showBoolean))(showBoolean))(showState));
  var EditingIsSymbol = {
    reflectSymbol: function() {
      return "Editing";
    }
  };
  var animationStateIsSymbol = {
    reflectSymbol: function() {
      return "animationState";
    }
  };
  var showRecordFieldsCons22 = /* @__PURE__ */ showRecordFieldsCons(animationStateIsSymbol);
  var editorIsSymbol = {
    reflectSymbol: function() {
      return "editor";
    }
  };
  var gameLogsIsSymbol = {
    reflectSymbol: function() {
      return "gameLogs";
    }
  };
  var gameStateIsSymbol = {
    reflectSymbol: function() {
      return "gameState";
    }
  };
  var showRecordFieldsCons32 = /* @__PURE__ */ showRecordFieldsCons(editorIsSymbol)(/* @__PURE__ */ showRecordFieldsCons(gameLogsIsSymbol)(/* @__PURE__ */ showRecordFieldsConsNil(gameStateIsSymbol)(showState))(/* @__PURE__ */ showArray(showUpdateError)));
  var SimulatingIsSymbol = {
    reflectSymbol: function() {
      return "Simulating";
    }
  };
  var eqRec4 = /* @__PURE__ */ eqRec();
  var eqRowCons4 = /* @__PURE__ */ eqRowCons(eqRowNil)();
  var eqRowCons1 = /* @__PURE__ */ eqRowCons4(obstacleMatrixIsSymbol);
  var eqRowCons22 = /* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons4(scriptIsSymbol)(eqScript))()(lastScriptExecutionIsSymbol)(/* @__PURE__ */ eqMaybe(/* @__PURE__ */ eqRec4(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons4(startTimeIsSymbol)(eqTimestamp))()(resultIsSymbol)(/* @__PURE__ */ eqExecutionResult(/* @__PURE__ */ eqRec4(/* @__PURE__ */ eqRowCons4(workersIsSymbol)(/* @__PURE__ */ eqRec4(/* @__PURE__ */ eqRowCons4(moveToIsSymbol)(/* @__PURE__ */ eqUnitCommands(/* @__PURE__ */ eqRec4(/* @__PURE__ */ eqRowCons4(positionIsSymbol2)(eqPosition))))))))))()(finishTimeIsSymbol)(eqTimestamp)))))()(gameSettingsIsSymbol);
  var eqRowCons32 = /* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons4(targetFpsIsSymbol)(eqFPS))()(stopOnErrorIsSymbol)(eqBoolean))()(restartOnScriptChangeIsSymbol)(eqBoolean))()(initialStateIsSymbol)(eqState))()(environmentIsSymbol);
  var eqRowCons42 = /* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons4(gameStateIsSymbol)(eqState))()(gameLogsIsSymbol)(/* @__PURE__ */ eqArray(eqUpdateError)))()(editorIsSymbol);
  var CanvasInitializing = /* @__PURE__ */ function() {
    function CanvasInitializing2(value0) {
      this.value0 = value0;
    }
    ;
    CanvasInitializing2.create = function(value0) {
      return new CanvasInitializing2(value0);
    };
    return CanvasInitializing2;
  }();
  var Editing = /* @__PURE__ */ function() {
    function Editing2(value0) {
      this.value0 = value0;
    }
    ;
    Editing2.create = function(value0) {
      return new Editing2(value0);
    };
    return Editing2;
  }();
  var Simulating = /* @__PURE__ */ function() {
    function Simulating2(value0) {
      this.value0 = value0;
    }
    ;
    Simulating2.create = function(value0) {
      return new Simulating2(value0);
    };
    return Simulating2;
  }();
  var genericModel_ = {
    to: function(x2) {
      if (x2 instanceof Inl) {
        return new CanvasInitializing(x2.value0);
      }
      ;
      if (x2 instanceof Inr && x2.value0 instanceof Inl) {
        return new Editing(x2.value0.value0);
      }
      ;
      if (x2 instanceof Inr && x2.value0 instanceof Inr) {
        return new Simulating(x2.value0.value0);
      }
      ;
      throw new Error("Failed pattern match at Scriptzzz.App.Model (line 21, column 1 - line 21, column 38): " + [x2.constructor.name]);
    },
    from: function(x2) {
      if (x2 instanceof CanvasInitializing) {
        return new Inl(x2.value0);
      }
      ;
      if (x2 instanceof Editing) {
        return new Inr(new Inl(x2.value0));
      }
      ;
      if (x2 instanceof Simulating) {
        return new Inr(new Inr(x2.value0));
      }
      ;
      throw new Error("Failed pattern match at Scriptzzz.App.Model (line 21, column 1 - line 21, column 38): " + [x2.constructor.name]);
    }
  };
  var genericShow3 = /* @__PURE__ */ genericShow(genericModel_);
  var genericEq3 = /* @__PURE__ */ genericEq(genericModel_);
  var showModel = function(dictPos) {
    return function(dictPos1) {
      var showRecord1 = showRecord4(showRecordFieldsConsNil2(showObstacleMatrix(dictPos1)(dictPos)));
      var showRecord22 = showRecord4(showRecordFieldsCons4(showRecord4(showRecordFieldsCons1(showRecord1))));
      return {
        show: genericShow3(genericShowSum(genericShowConstructor(genericShowArgsArgument(showRecord1))(CanvasInitializingIsSymbol))(genericShowSum(genericShowConstructor(genericShowArgsArgument(showRecord22))(EditingIsSymbol))(genericShowConstructor(genericShowArgsArgument(showRecord4(showRecordFieldsCons22(showRecordFieldsCons32(showRecord22))(showAnimationState))))(SimulatingIsSymbol))))
      };
    };
  };
  var eqModel = function(dictPos) {
    var eqObstacleMatrix2 = eqObstacleMatrix(dictPos);
    return function(dictPos1) {
      var eqRec1 = eqRec4(eqRowCons1(eqObstacleMatrix2(dictPos1)));
      var eqRec22 = eqRec4(eqRowCons22(eqRec4(eqRowCons32(eqRec1))));
      return {
        eq: genericEq3(genericEqSum(genericEqConstructor(genericEqArgument(eqRec1)))(genericEqSum(genericEqConstructor(genericEqArgument(eqRec22)))(genericEqConstructor(genericEqArgument(eqRec4(eqRowCons(eqRowCons42(eqRec22))()(animationStateIsSymbol)(eqAnimationState)))))))
      };
    };
  };

  // output/Scriptzzz.App.Controller.Handler.AnimationUpdated/index.js
  var handle = function(dictPos) {
    var withExecuteScript2 = withExecuteScript(dictPos);
    var none5 = none(dictPos);
    return function(dictPos1) {
      var withExecuteScript1 = withExecuteScript2(dictPos1);
      var none1 = none5(dictPos1);
      return function(model) {
        return function(message2) {
          if (model instanceof Simulating) {
            var newModel = new Simulating({
              editor: model.value0.editor,
              gameLogs: model.value0.gameLogs,
              gameState: model.value0.gameState,
              animationState: new Updated({
                gameStep: message2.gameStep
              })
            });
            var commands = withExecuteScript1(none1)(model.value0.editor.script);
            return success({
              commands,
              newModel
            });
          }
          ;
          return failure("Not in simulating mode.");
        };
      };
    };
  };

  // output/Scriptzzz.App.Controller.Handler.CanvasInitialized/index.js
  var makeId2 = /* @__PURE__ */ makeId(/* @__PURE__ */ makeId1({
    reflectSymbol: function() {
      return "foo";
    }
  }));
  var mempty2 = /* @__PURE__ */ mempty(monoidScript);
  var initialGameState = function(dictPos) {
    var arbitraryPosition2 = arbitraryPosition(dictPos);
    return function(dictPos1) {
      var position2 = evalGen(arbitrary(arbitraryPosition2(dictPos1)))({
        newSeed: mkSeed(0),
        size: 1
      });
      var worker = new Worker2({
        position: position2,
        task: Nothing.value
      });
      return singleton8(makeId2($$Proxy.value))(worker);
    };
  };
  var handle2 = function(dictPos) {
    var initialGameState1 = initialGameState(dictPos);
    var none5 = none(dictPos);
    return function(dictPos1) {
      var initialGameState2 = initialGameState1(dictPos1);
      var none1 = none5(dictPos1);
      return function(model) {
        return function(v2) {
          if (model instanceof CanvasInitializing) {
            var newModel = new Editing({
              gameSettings: {
                environment: model.value0,
                initialState: initialGameState2,
                restartOnScriptChange: false,
                stopOnError: false,
                targetFps: tenFramesPerSecond
              },
              lastScriptExecution: Nothing.value,
              script: mempty2
            });
            return success({
              commands: none1,
              newModel
            });
          }
          ;
          return failure("Canvas has already been initialized.");
        };
      };
    };
  };

  // output/Scriptzzz.App.Controller.Handler.EditorUpdated/index.js
  var handle3 = function(dictPos) {
    var none5 = none(dictPos);
    return function(dictPos1) {
      var none1 = none5(dictPos1);
      return function(model) {
        return function(script) {
          if (model instanceof Editing) {
            return new Right(new Tuple(new Editing({
              gameSettings: model.value0.gameSettings,
              lastScriptExecution: model.value0.lastScriptExecution,
              script
            }), none1));
          }
          ;
          return new Left("Not in editing mode.");
        };
      };
    };
  };

  // output/Scriptzzz.App.Controller.Handler.ScriptExecuted/index.js
  var append5 = /* @__PURE__ */ append(semigroupArray);
  var handle4 = function(dictPos) {
    var update3 = update(dictPos);
    var animate2 = animate(dictPos);
    var withUpdateAnimation2 = withUpdateAnimation(dictPos);
    var none5 = none(dictPos);
    return function(dictPos1) {
      var update1 = update3(dictPos1);
      var animate1 = animate2(dictPos1);
      var withUpdateAnimation1 = withUpdateAnimation2(dictPos1);
      var none1 = none5(dictPos1);
      return function(model) {
        return function(message2) {
          if (model instanceof Simulating) {
            if (model.value0.animationState instanceof Uninitialized) {
              return new Left("Animation has not been initialized yet.");
            }
            ;
            if (model.value0.animationState instanceof Updating) {
              return new Left("Previous animation has not finished.");
            }
            ;
            if (model.value0.animationState instanceof Updated) {
              var gameStep = nextGameStep(model.value0.animationState.value0.gameStep);
              if (message2.executionResult instanceof Success) {
                var v2 = update1(model.value0.editor.gameSettings.environment)(message2.executionResult.value0)(model.value0.gameState);
                var newModel = new Simulating({
                  animationState: new Updating({
                    gameStep
                  }),
                  editor: {
                    gameSettings: model.value0.editor.gameSettings,
                    script: model.value0.editor.script,
                    lastScriptExecution: new Just({
                      finishTime: message2.executionFinishTime,
                      result: new Success(message2.executionResult.value0),
                      startTime: message2.executionStartTime
                    })
                  },
                  gameLogs: append5(model.value0.gameLogs)(v2.value1),
                  gameState: v2.value0
                });
                var animation = animate1(model.value0.gameState)(v2.value0);
                var commands = withUpdateAnimation1(none1)({
                  animation,
                  gameStep
                });
                return new Right(new Tuple(newModel, commands));
              }
              ;
              return new Right(function() {
                if (model.value0.editor.gameSettings.stopOnError) {
                  return new Tuple(new Editing({
                    gameSettings: model.value0.editor.gameSettings,
                    script: model.value0.editor.script,
                    lastScriptExecution: new Just({
                      finishTime: message2.executionFinishTime,
                      result: message2.executionResult,
                      startTime: message2.executionStartTime
                    })
                  }), none1);
                }
                ;
                return new Tuple(new Simulating({
                  gameLogs: model.value0.gameLogs,
                  gameState: model.value0.gameState,
                  animationState: new Updated({
                    gameStep
                  }),
                  editor: {
                    gameSettings: model.value0.editor.gameSettings,
                    script: model.value0.editor.script,
                    lastScriptExecution: new Just({
                      finishTime: message2.executionFinishTime,
                      result: message2.executionResult,
                      startTime: message2.executionStartTime
                    })
                  }
                }), none1);
              }());
            }
            ;
            throw new Error("Failed pattern match at Scriptzzz.App.Controller.Handler.ScriptExecuted (line 29, column 5 - line 97, column 29): " + [model.value0.animationState.constructor.name]);
          }
          ;
          return new Left("Not in simulating mode.");
        };
      };
    };
  };

  // output/Scriptzzz.App.Controller.Handler.SimulationStartRequested/index.js
  var mempty3 = /* @__PURE__ */ mempty(monoidArray);
  var handle5 = function(dictPos) {
    var withUpdateAnimation2 = withUpdateAnimation(dictPos);
    var none5 = none(dictPos);
    var animate2 = animate(dictPos);
    var blankState2 = blankState(dictPos);
    return function(dictPos1) {
      var withUpdateAnimation1 = withUpdateAnimation2(dictPos1);
      var none1 = none5(dictPos1);
      var animate1 = animate2(dictPos1);
      var blankState1 = blankState2(dictPos1);
      return function(model) {
        return function(v2) {
          if (model instanceof Editing) {
            var newModel = new Simulating({
              animationState: Uninitialized.value,
              editor: model.value0,
              gameLogs: mempty3,
              gameState: model.value0.gameSettings.initialState
            });
            var commands = withUpdateAnimation1(none1)({
              animation: animate1(blankState1)(model.value0.gameSettings.initialState),
              gameStep: initialGameStep
            });
            return success({
              commands,
              newModel
            });
          }
          ;
          return failure("Not in editing mode.");
        };
      };
    };
  };

  // output/Scriptzzz.App.Controller.Handler.SimulationStopRequested/index.js
  var handle6 = function(dictPos) {
    var none5 = none(dictPos);
    return function(dictPos1) {
      var none1 = none5(dictPos1);
      return function(model) {
        return function(v2) {
          if (model instanceof Simulating) {
            var newModel = new Editing(model.value0.editor);
            return success({
              commands: none1,
              newModel
            });
          }
          ;
          return failure("Not in simulating mode.");
        };
      };
    };
  };

  // output/Scriptzzz.App.Controller.Handler.TimeUpdated/index.js
  var handle7 = function(dictPos) {
    var none5 = none(dictPos);
    return function(dictPos1) {
      var none1 = none5(dictPos1);
      return function(model) {
        return function(v2) {
          return new Right(new Tuple(model, none1));
        };
      };
    };
  };

  // output/Scriptzzz.App.Message/index.js
  var showRecord5 = /* @__PURE__ */ showRecord()();
  var showRecordFieldsCons5 = /* @__PURE__ */ showRecordFieldsCons({
    reflectSymbol: function() {
      return "executionFinishTime";
    }
  });
  var executionStartTimeIsSymbol = {
    reflectSymbol: function() {
      return "executionStartTime";
    }
  };
  var genericShowConstructor4 = /* @__PURE__ */ genericShowConstructor(/* @__PURE__ */ genericShowArgsArgument(showUnit));
  var map21 = /* @__PURE__ */ map(functorEffect);
  var AnimationUpdated = /* @__PURE__ */ function() {
    function AnimationUpdated2(value0) {
      this.value0 = value0;
    }
    ;
    AnimationUpdated2.create = function(value0) {
      return new AnimationUpdated2(value0);
    };
    return AnimationUpdated2;
  }();
  var CanvasInitialized = /* @__PURE__ */ function() {
    function CanvasInitialized2(value0) {
      this.value0 = value0;
    }
    ;
    CanvasInitialized2.create = function(value0) {
      return new CanvasInitialized2(value0);
    };
    return CanvasInitialized2;
  }();
  var EditorUpdated = /* @__PURE__ */ function() {
    function EditorUpdated2(value0) {
      this.value0 = value0;
    }
    ;
    EditorUpdated2.create = function(value0) {
      return new EditorUpdated2(value0);
    };
    return EditorUpdated2;
  }();
  var ScriptExecuted = /* @__PURE__ */ function() {
    function ScriptExecuted2(value0) {
      this.value0 = value0;
    }
    ;
    ScriptExecuted2.create = function(value0) {
      return new ScriptExecuted2(value0);
    };
    return ScriptExecuted2;
  }();
  var SimulationStartRequested = /* @__PURE__ */ function() {
    function SimulationStartRequested2(value0) {
      this.value0 = value0;
    }
    ;
    SimulationStartRequested2.create = function(value0) {
      return new SimulationStartRequested2(value0);
    };
    return SimulationStartRequested2;
  }();
  var SimulationStopRequested = /* @__PURE__ */ function() {
    function SimulationStopRequested2(value0) {
      this.value0 = value0;
    }
    ;
    SimulationStopRequested2.create = function(value0) {
      return new SimulationStopRequested2(value0);
    };
    return SimulationStopRequested2;
  }();
  var TimeUpdated = /* @__PURE__ */ function() {
    function TimeUpdated2(value0) {
      this.value0 = value0;
    }
    ;
    TimeUpdated2.create = function(value0) {
      return new TimeUpdated2(value0);
    };
    return TimeUpdated2;
  }();
  var genericBody_ = {
    to: function(x2) {
      if (x2 instanceof Inl) {
        return new AnimationUpdated(x2.value0);
      }
      ;
      if (x2 instanceof Inr && x2.value0 instanceof Inl) {
        return new CanvasInitialized(x2.value0.value0);
      }
      ;
      if (x2 instanceof Inr && (x2.value0 instanceof Inr && x2.value0.value0 instanceof Inl)) {
        return new EditorUpdated(x2.value0.value0.value0);
      }
      ;
      if (x2 instanceof Inr && (x2.value0 instanceof Inr && (x2.value0.value0 instanceof Inr && x2.value0.value0.value0 instanceof Inl))) {
        return new ScriptExecuted(x2.value0.value0.value0.value0);
      }
      ;
      if (x2 instanceof Inr && (x2.value0 instanceof Inr && (x2.value0.value0 instanceof Inr && (x2.value0.value0.value0 instanceof Inr && x2.value0.value0.value0.value0 instanceof Inl)))) {
        return new SimulationStartRequested(x2.value0.value0.value0.value0.value0);
      }
      ;
      if (x2 instanceof Inr && (x2.value0 instanceof Inr && (x2.value0.value0 instanceof Inr && (x2.value0.value0.value0 instanceof Inr && (x2.value0.value0.value0.value0 instanceof Inr && x2.value0.value0.value0.value0.value0 instanceof Inl))))) {
        return new SimulationStopRequested(x2.value0.value0.value0.value0.value0.value0);
      }
      ;
      if (x2 instanceof Inr && (x2.value0 instanceof Inr && (x2.value0.value0 instanceof Inr && (x2.value0.value0.value0 instanceof Inr && (x2.value0.value0.value0.value0 instanceof Inr && x2.value0.value0.value0.value0.value0 instanceof Inr))))) {
        return new TimeUpdated(x2.value0.value0.value0.value0.value0.value0);
      }
      ;
      throw new Error("Failed pattern match at Scriptzzz.App.Message (line 41, column 1 - line 41, column 37): " + [x2.constructor.name]);
    },
    from: function(x2) {
      if (x2 instanceof AnimationUpdated) {
        return new Inl(x2.value0);
      }
      ;
      if (x2 instanceof CanvasInitialized) {
        return new Inr(new Inl(x2.value0));
      }
      ;
      if (x2 instanceof EditorUpdated) {
        return new Inr(new Inr(new Inl(x2.value0)));
      }
      ;
      if (x2 instanceof ScriptExecuted) {
        return new Inr(new Inr(new Inr(new Inl(x2.value0))));
      }
      ;
      if (x2 instanceof SimulationStartRequested) {
        return new Inr(new Inr(new Inr(new Inr(new Inl(x2.value0)))));
      }
      ;
      if (x2 instanceof SimulationStopRequested) {
        return new Inr(new Inr(new Inr(new Inr(new Inr(new Inl(x2.value0))))));
      }
      ;
      if (x2 instanceof TimeUpdated) {
        return new Inr(new Inr(new Inr(new Inr(new Inr(new Inr(x2.value0))))));
      }
      ;
      throw new Error("Failed pattern match at Scriptzzz.App.Message (line 41, column 1 - line 41, column 37): " + [x2.constructor.name]);
    }
  };
  var showBody = {
    show: /* @__PURE__ */ genericShow(genericBody_)(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor(/* @__PURE__ */ genericShowArgsArgument(/* @__PURE__ */ showRecord5(/* @__PURE__ */ showRecordFieldsCons5(/* @__PURE__ */ showRecordFieldsCons(executionStartTimeIsSymbol)(/* @__PURE__ */ showRecordFieldsConsNil({
      reflectSymbol: function() {
        return "gameStep";
      }
    })(showGameStep))(showTimestamp))(showTimestamp))))({
      reflectSymbol: function() {
        return "AnimationUpdated";
      }
    }))(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor4({
      reflectSymbol: function() {
        return "CanvasInitialized";
      }
    }))(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor(/* @__PURE__ */ genericShowArgsArgument(showScript))({
      reflectSymbol: function() {
        return "EditorUpdated";
      }
    }))(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor(/* @__PURE__ */ genericShowArgsArgument(/* @__PURE__ */ showRecord5(/* @__PURE__ */ showRecordFieldsCons5(/* @__PURE__ */ showRecordFieldsCons({
      reflectSymbol: function() {
        return "executionResult";
      }
    })(/* @__PURE__ */ showRecordFieldsConsNil(executionStartTimeIsSymbol)(showTimestamp))(/* @__PURE__ */ showExecutionResult(/* @__PURE__ */ showRecord5(/* @__PURE__ */ showRecordFieldsConsNil({
      reflectSymbol: function() {
        return "workers";
      }
    })(/* @__PURE__ */ showRecord5(/* @__PURE__ */ showRecordFieldsConsNil({
      reflectSymbol: function() {
        return "moveTo";
      }
    })(/* @__PURE__ */ showUnitCommands(/* @__PURE__ */ showRecord5(/* @__PURE__ */ showRecordFieldsConsNil({
      reflectSymbol: function() {
        return "position";
      }
    })(showPosition))))))))))(showTimestamp))))({
      reflectSymbol: function() {
        return "ScriptExecuted";
      }
    }))(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor4({
      reflectSymbol: function() {
        return "SimulationStartRequested";
      }
    }))(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor4({
      reflectSymbol: function() {
        return "SimulationStopRequested";
      }
    }))(/* @__PURE__ */ genericShowConstructor(/* @__PURE__ */ genericShowArgsArgument(showTimestamp))({
      reflectSymbol: function() {
        return "TimeUpdated";
      }
    }))))))))
  };
  var createWithoutTimestamp = function(dictPos) {
    return function(dictPos1) {
      return function(body) {
        return {
          body,
          header: {
            creationTime: Nothing.value
          }
        };
      };
    };
  };
  var createWithTimestamp = function(dictPos) {
    return function(dictPos1) {
      return function(body) {
        return function __do() {
          var creationTime = map21(timestamp)(now)();
          return {
            body,
            header: {
              creationTime: new Just(creationTime)
            }
          };
        };
      };
    };
  };

  // output/Scriptzzz.App.Controller/index.js
  var bind6 = /* @__PURE__ */ bind(bindMaybe);
  var pure15 = /* @__PURE__ */ pure(applicativeMaybe);
  var show9 = /* @__PURE__ */ show(showString);
  var showRecord6 = /* @__PURE__ */ showRecord()();
  var showMaybe2 = /* @__PURE__ */ showMaybe(showTimestamp);
  var show15 = /* @__PURE__ */ show(/* @__PURE__ */ showRecord6(/* @__PURE__ */ showRecordFieldsCons({
    reflectSymbol: function() {
      return "body";
    }
  })(/* @__PURE__ */ showRecordFieldsConsNil({
    reflectSymbol: function() {
      return "header";
    }
  })(/* @__PURE__ */ showRecord6(/* @__PURE__ */ showRecordFieldsConsNil({
    reflectSymbol: function() {
      return "creationTime";
    }
  })(showMaybe2))))(showBody)));
  var show23 = /* @__PURE__ */ show(showMaybe2);
  var show32 = /* @__PURE__ */ show(showBody);
  var map24 = /* @__PURE__ */ map(functorEither);
  var runCommands2 = /* @__PURE__ */ runCommands(monadEffectAff)(monadErrorAff);
  var Full = /* @__PURE__ */ function() {
    function Full2(value0) {
      this.value0 = value0;
    }
    ;
    Full2.create = function(value0) {
      return new Full2(value0);
    };
    return Full2;
  }();
  var MessageNamesOnly = /* @__PURE__ */ function() {
    function MessageNamesOnly2() {
    }
    ;
    MessageNamesOnly2.value = new MessageNamesOnly2();
    return MessageNamesOnly2;
  }();
  var MessagesOnly = /* @__PURE__ */ function() {
    function MessagesOnly2() {
    }
    ;
    MessagesOnly2.value = new MessagesOnly2();
    return MessagesOnly2;
  }();
  var None = /* @__PURE__ */ function() {
    function None3() {
    }
    ;
    None3.value = new None3();
    return None3;
  }();
  var init4 = function(dictPos) {
    return function(dictPos1) {
      return function(obstacleMatrix) {
        return new Tuple(new CanvasInitializing({
          obstacleMatrix
        }), []);
      };
    };
  };
  var commandResultHandlers = function(dictPos) {
    return function(dictPos1) {
      var withCreationTime = function(toBody) {
        return function(args) {
          return bind6(toBody(args))(function(body) {
            return pure15({
              body,
              header: {
                creationTime: new Just(args.finishTime)
              }
            });
          });
        };
      };
      return {
        executeScript: withCreationTime(function(v2) {
          if (v2.commandExecutionResult instanceof Left) {
            return Nothing.value;
          }
          ;
          if (v2.commandExecutionResult instanceof Right) {
            return new Just(new ScriptExecuted({
              executionFinishTime: v2.finishTime,
              executionResult: v2.commandExecutionResult.value0,
              executionStartTime: v2.startTime
            }));
          }
          ;
          throw new Error("Failed pattern match at Scriptzzz.App.Controller (line 178, column 9 - line 187, column 16): " + [v2.commandExecutionResult.constructor.name]);
        }),
        logDebug: $$const(Nothing.value),
        logError: $$const(Nothing.value),
        updateAnimation: withCreationTime(function(v2) {
          if (v2.commandExecutionResult instanceof Left) {
            return Nothing.value;
          }
          ;
          if (v2.commandExecutionResult instanceof Right) {
            return new Just(new AnimationUpdated({
              executionFinishTime: v2.finishTime,
              executionStartTime: v2.startTime,
              gameStep: v2.commandParameters.gameStep
            }));
          }
          ;
          throw new Error("Failed pattern match at Scriptzzz.App.Controller (line 196, column 9 - line 205, column 16): " + [v2.commandExecutionResult.constructor.name]);
        })
      };
    };
  };
  var update2 = function(dictPos) {
    var showModel2 = showModel(dictPos);
    var withLogError2 = withLogError(dictPos);
    var none5 = none(dictPos);
    var eqModel2 = eqModel(dictPos);
    var withLogDebug2 = withLogDebug(dictPos);
    var handle8 = handle(dictPos);
    var handle1 = handle2(dictPos);
    var handle22 = handle3(dictPos);
    var handle32 = handle4(dictPos);
    var handle42 = handle5(dictPos);
    var handle52 = handle6(dictPos);
    var handle62 = handle7(dictPos);
    var runCommands1 = runCommands2(dictPos);
    var commandResultHandlers1 = commandResultHandlers(dictPos);
    return function(dictPos1) {
      var show42 = show(showModel2(dictPos1));
      var withLogError1 = withLogError2(dictPos1);
      var none1 = none5(dictPos1);
      var eq3 = eq(eqModel2(dictPos1));
      var withLogDebug1 = withLogDebug2(dictPos1);
      var handle72 = handle8(dictPos1);
      var handle82 = handle1(dictPos1);
      var handle9 = handle22(dictPos1);
      var handle10 = handle32(dictPos1);
      var handle11 = handle42(dictPos1);
      var handle12 = handle52(dictPos1);
      var handle13 = handle62(dictPos1);
      var runCommands22 = runCommands1(dictPos1);
      var commandResultHandlers2 = commandResultHandlers1(dictPos1);
      return function(commandExecutors2) {
        return function(debugLevel) {
          return function(previousModel) {
            return function(message2) {
              var handleErrors = function(v3) {
                if (v3 instanceof Left) {
                  var errorInfo = joinWith("\n")(["!!!", "Previous state:", show42(previousModel), "---", "Error Message:", show9(v3.value0), "---", "Next state:", "<NO_CHANGE>", "!!!"]);
                  return new Tuple(previousModel, withLogError1(none1)(errorInfo));
                }
                ;
                if (v3 instanceof Right) {
                  return v3.value0;
                }
                ;
                throw new Error("Failed pattern match at Scriptzzz.App.Controller (line 147, column 18 - line 168, column 27): " + [v3.constructor.name]);
              };
              var addDebugCommands = function(v3) {
                if (debugLevel instanceof Full) {
                  var debugInfo = joinWith("\n")(["===", "Previous state:", debugLevel.value0(previousModel), "---", "Message:", show15(message2), "---", "Next state:", function() {
                    var $86 = eq3(v3.value0)(previousModel);
                    if ($86) {
                      return "<NO_CHANGE>";
                    }
                    ;
                    return debugLevel.value0(v3.value0);
                  }(), "==="]);
                  return new Tuple(v3.value0, withLogDebug1(v3.value1)(debugInfo));
                }
                ;
                if (debugLevel instanceof MessageNamesOnly) {
                  var messageName = function() {
                    if (message2.body instanceof AnimationUpdated) {
                      return "Animation Updted";
                    }
                    ;
                    if (message2.body instanceof CanvasInitialized) {
                      return "Canvas Initialized";
                    }
                    ;
                    if (message2.body instanceof EditorUpdated) {
                      return "Editor Updted";
                    }
                    ;
                    if (message2.body instanceof ScriptExecuted) {
                      return "Script Executed";
                    }
                    ;
                    if (message2.body instanceof SimulationStartRequested) {
                      return "Simulation Start Requested";
                    }
                    ;
                    if (message2.body instanceof SimulationStopRequested) {
                      return "Simulation Stop Requested";
                    }
                    ;
                    if (message2.body instanceof TimeUpdated) {
                      return "Time Updated";
                    }
                    ;
                    throw new Error("Failed pattern match at Scriptzzz.App.Controller (line 101, column 25 - line 121, column 29): " + [message2.body.constructor.name]);
                  }();
                  var debugInfo = "Message: " + messageName;
                  return new Tuple(v3.value0, withLogDebug1(v3.value1)(debugInfo));
                }
                ;
                if (debugLevel instanceof MessagesOnly) {
                  var headerText = show23(message2.header.creationTime);
                  var bodyText = show32(message2.body);
                  var debugInfo = "Message: " + (headerText + (" | " + bodyText));
                  return new Tuple(v3.value0, withLogDebug1(v3.value1)(debugInfo));
                }
                ;
                if (debugLevel instanceof None) {
                  return new Tuple(v3.value0, v3.value1);
                }
                ;
                throw new Error("Failed pattern match at Scriptzzz.App.Controller (line 76, column 5 - line 142, column 30): " + [debugLevel.constructor.name]);
              };
              var modelAndCommandsResult = function() {
                if (message2.body instanceof AnimationUpdated) {
                  return handle72(previousModel)(message2.body.value0);
                }
                ;
                if (message2.body instanceof CanvasInitialized) {
                  return handle82(previousModel)(message2.body.value0);
                }
                ;
                if (message2.body instanceof EditorUpdated) {
                  return handle9(previousModel)(message2.body.value0);
                }
                ;
                if (message2.body instanceof ScriptExecuted) {
                  return handle10(previousModel)(message2.body.value0);
                }
                ;
                if (message2.body instanceof SimulationStartRequested) {
                  return handle11(previousModel)(message2.body.value0);
                }
                ;
                if (message2.body instanceof SimulationStopRequested) {
                  return handle12(previousModel)(message2.body.value0);
                }
                ;
                if (message2.body instanceof TimeUpdated) {
                  return handle13(previousModel)(message2.body.value0);
                }
                ;
                throw new Error("Failed pattern match at Scriptzzz.App.Controller (line 46, column 30 - line 60, column 49): " + [message2.body.constructor.name]);
              }();
              var v2 = handleErrors(map24(addDebugCommands)(modelAndCommandsResult));
              return new Tuple(v2.value0, runCommands22(commandExecutors2)(commandResultHandlers2)(v2.value1));
            };
          };
        };
      };
    };
  };

  // output/Flame.Html.Event/foreign.js
  var messageEventData = 5;
  function createEvent_(name16) {
    return function(message2) {
      return [messageEventData, name16, message2];
    };
  }

  // output/Flame.Html.Event/index.js
  var createEvent = function(name16) {
    return function(message2) {
      return createEvent_(name16)(message2);
    };
  };
  var onClick = /* @__PURE__ */ createEvent("click");

  // node_modules/pixi.js/lib/environment-browser/browserExt.mjs
  init_Extensions();
  var browserExt = {
    extension: {
      type: ExtensionType.Environment,
      name: "browser",
      priority: -1
    },
    test: () => true,
    load: async () => {
      await Promise.resolve().then(() => (init_browserAll(), browserAll_exports));
    }
  };

  // node_modules/pixi.js/lib/environment-webworker/webworkerExt.mjs
  init_Extensions();
  var webworkerExt = {
    extension: {
      type: ExtensionType.Environment,
      name: "webworker",
      priority: 0
    },
    test: () => typeof self !== "undefined" && self.WorkerGlobalScope !== void 0,
    load: async () => {
      await Promise.resolve().then(() => (init_webworkerAll(), webworkerAll_exports));
    }
  };

  // node_modules/pixi.js/lib/index.mjs
  init_Extensions();
  init_init5();
  init_init4();

  // node_modules/pixi.js/lib/app/Application.mjs
  init_Extensions();

  // node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs
  init_adapter();
  init_AbstractRenderer();
  var _isWebGLSupported;
  function isWebGLSupported(failIfMajorPerformanceCaveat) {
    if (_isWebGLSupported !== void 0)
      return _isWebGLSupported;
    _isWebGLSupported = (() => {
      const contextOptions = {
        stencil: true,
        failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
      };
      try {
        if (!DOMAdapter.get().getWebGLRenderingContext()) {
          return false;
        }
        const canvas2 = DOMAdapter.get().createCanvas();
        let gl = canvas2.getContext("webgl", contextOptions);
        const success2 = !!gl?.getContextAttributes()?.stencil;
        if (gl) {
          const loseContext = gl.getExtension("WEBGL_lose_context");
          if (loseContext) {
            loseContext.loseContext();
          }
        }
        gl = null;
        return success2;
      } catch (e2) {
        return false;
      }
    })();
    return _isWebGLSupported;
  }

  // node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs
  init_adapter();
  var _isWebGPUSupported;
  async function isWebGPUSupported(options2 = {}) {
    if (_isWebGPUSupported !== void 0)
      return _isWebGPUSupported;
    _isWebGPUSupported = await (async () => {
      const gpu = DOMAdapter.get().getNavigator().gpu;
      if (!gpu) {
        return false;
      }
      try {
        const adapter = await gpu.requestAdapter(options2);
        await adapter.requestDevice();
        return true;
      } catch (e2) {
        return false;
      }
    })();
    return _isWebGPUSupported;
  }

  // node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs
  init_AbstractRenderer();
  var renderPriority = ["webgl", "webgpu", "canvas"];
  async function autoDetectRenderer(options2) {
    let preferredOrder = [];
    if (options2.preference) {
      preferredOrder.push(options2.preference);
      renderPriority.forEach((item) => {
        if (item !== options2.preference) {
          preferredOrder.push(item);
        }
      });
    } else {
      preferredOrder = renderPriority.slice();
    }
    let RendererClass;
    let finalOptions = {};
    for (let i2 = 0; i2 < preferredOrder.length; i2++) {
      const rendererType = preferredOrder[i2];
      if (rendererType === "webgpu" && await isWebGPUSupported()) {
        const { WebGPURenderer: WebGPURenderer2 } = await Promise.resolve().then(() => (init_WebGPURenderer(), WebGPURenderer_exports));
        RendererClass = WebGPURenderer2;
        finalOptions = { ...options2, ...options2.webgpu };
        break;
      } else if (rendererType === "webgl" && isWebGLSupported(
        options2.failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
      )) {
        const { WebGLRenderer: WebGLRenderer2 } = await Promise.resolve().then(() => (init_WebGLRenderer(), WebGLRenderer_exports));
        RendererClass = WebGLRenderer2;
        finalOptions = { ...options2, ...options2.webgl };
        break;
      } else if (rendererType === "canvas") {
        finalOptions = { ...options2 };
        throw new Error("CanvasRenderer is not yet implemented");
      }
    }
    delete finalOptions.webgpu;
    delete finalOptions.webgl;
    if (!RendererClass) {
      throw new Error("No available renderer for the current environment");
    }
    const renderer = new RendererClass();
    await renderer.init(finalOptions);
    return renderer;
  }

  // node_modules/pixi.js/lib/app/Application.mjs
  init_Container();
  init_globalHooks();
  init_deprecation();
  var _Application = class _Application2 {
    /** @ignore */
    constructor(...args) {
      this.stage = new Container();
      if (args[0] !== void 0) {
        deprecation(v8_0_0, "Application constructor options are deprecated, please use Application.init() instead.");
      }
    }
    /**
     * @param options - The optional application and renderer parameters.
     */
    async init(options2) {
      options2 = { ...options2 };
      this.renderer = await autoDetectRenderer(options2);
      _Application2._plugins.forEach((plugin) => {
        plugin.init.call(this, options2);
      });
    }
    /** Render the current stage. */
    render() {
      this.renderer.render({ container: this.stage });
    }
    /**
     * Reference to the renderer's canvas element.
     * @readonly
     * @member {HTMLCanvasElement}
     */
    get canvas() {
      return this.renderer.canvas;
    }
    /**
     * Reference to the renderer's canvas element.
     * @member {HTMLCanvasElement}
     * @deprecated since 8.0.0
     */
    get view() {
      deprecation(v8_0_0, "Application.view is deprecated, please use Application.canvas instead.");
      return this.renderer.canvas;
    }
    /**
     * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.
     * @readonly
     */
    get screen() {
      return this.renderer.screen;
    }
    /**
     * Destroys the application and all of its resources.
     * @param {object|boolean}[rendererDestroyOptions=false] - The options for destroying the renderer.
     * @param {boolean}[rendererDestroyOptions.removeView=false] - Removes the Canvas element from the DOM.
     * @param {object|boolean} [options=false] - The options for destroying the stage.
     * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method
     * called as well. `options` will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.
     * If options.children is set to true,
     * it should destroy the texture of the child sprite.
     * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.
     *  If options.children is set to true,
     * it should destroy the texture source of the child sprite.
     * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.
     * If options.children is set to true,
     * it should destroy the context of the child graphics.
     */
    destroy(rendererDestroyOptions = false, options2 = false) {
      const plugins = _Application2._plugins.slice(0);
      plugins.reverse();
      plugins.forEach((plugin) => {
        plugin.destroy.call(this);
      });
      this.stage.destroy(options2);
      this.stage = null;
      this.renderer.destroy(rendererDestroyOptions);
      this.renderer = null;
    }
  };
  _Application._plugins = [];
  var Application = _Application;
  extensions.handleByList(ExtensionType.Application, Application._plugins);
  extensions.add(ApplicationInitHook);

  // node_modules/pixi.js/lib/assets/Assets.mjs
  init_Extensions();

  // node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.mjs
  init_LoaderParser();
  init_copySearchParams();
  init_adapter();
  init_Extensions();
  init_path();

  // node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.mjs
  init_Rectangle();
  init_Texture();
  init_AbstractBitmapFont();
  init_BitmapFontManager();
  var BitmapFont = class extends AbstractBitmapFont {
    constructor(options2, url2) {
      super();
      const { textures, data } = options2;
      Object.keys(data.pages).forEach((key) => {
        const pageData = data.pages[parseInt(key, 10)];
        const texture = textures[pageData.id];
        this.pages.push({ texture });
      });
      Object.keys(data.chars).forEach((key) => {
        const charData = data.chars[key];
        const {
          frame: textureFrame,
          source: textureSource
        } = textures[charData.page];
        const frameReal = new Rectangle(
          charData.x + textureFrame.x,
          charData.y + textureFrame.y,
          charData.width,
          charData.height
        );
        const texture = new Texture({
          source: textureSource,
          frame: frameReal
        });
        this.chars[key] = {
          id: key.codePointAt(0),
          xOffset: charData.xOffset,
          yOffset: charData.yOffset,
          xAdvance: charData.xAdvance,
          kerning: charData.kerning ?? {},
          texture
        };
      });
      this.baseRenderedFontSize = data.fontSize;
      this.baseMeasurementFontSize = data.fontSize;
      this.fontMetrics = {
        ascent: 0,
        descent: 0,
        fontSize: data.fontSize
      };
      this.baseLineOffset = data.baseLineOffset;
      this.lineHeight = data.lineHeight;
      this.fontFamily = data.fontFamily;
      this.distanceField = data.distanceField ?? {
        type: "none",
        range: 0
      };
      this.url = url2;
    }
    /** Destroys the BitmapFont object. */
    destroy() {
      super.destroy();
      for (let i2 = 0; i2 < this.pages.length; i2++) {
        const { texture } = this.pages[i2];
        texture.destroy(true);
      }
      this.pages = null;
    }
    /**
     * Generates a bitmap-font for the given style and character set
     * @param options - Setup options for font generation.
     * @returns Font generated by style options.
     * @example
     * import { BitmapFont, BitmapText } from 'pixi.js';
     *
     * BitmapFont.install('TitleFont', {
     *     fontFamily: 'Arial',
     *     fontSize: 12,
     *     strokeThickness: 2,
     *     fill: 'purple',
     * });
     *
     * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });
     */
    static install(options2) {
      BitmapFontManager.install(options2);
    }
    /**
     * Uninstalls a bitmap font from the cache.
     * @param {string} name - The name of the bitmap font to uninstall.
     */
    static uninstall(name16) {
      BitmapFontManager.uninstall(name16);
    }
  };

  // node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.mjs
  var bitmapFontTextParser = {
    test(data) {
      return typeof data === "string" && data.startsWith("info face=");
    },
    parse(txt) {
      const items = txt.match(/^[a-z]+\s+.+$/gm);
      const rawData = {
        info: [],
        common: [],
        page: [],
        char: [],
        chars: [],
        kerning: [],
        kernings: [],
        distanceField: []
      };
      for (const i2 in items) {
        const name16 = items[i2].match(/^[a-z]+/gm)[0];
        const attributeList = items[i2].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
        const itemData = {};
        for (const i22 in attributeList) {
          const split3 = attributeList[i22].split("=");
          const key = split3[0];
          const strValue = split3[1].replace(/"/gm, "");
          const floatValue = parseFloat(strValue);
          const value12 = isNaN(floatValue) ? strValue : floatValue;
          itemData[key] = value12;
        }
        rawData[name16].push(itemData);
      }
      const font = {
        chars: {},
        pages: [],
        lineHeight: 0,
        fontSize: 0,
        fontFamily: "",
        distanceField: null,
        baseLineOffset: 0
      };
      const [info2] = rawData.info;
      const [common] = rawData.common;
      const [distanceField] = rawData.distanceField ?? [];
      if (distanceField) {
        font.distanceField = {
          range: parseInt(distanceField.distanceRange, 10),
          type: distanceField.fieldType
        };
      }
      font.fontSize = parseInt(info2.size, 10);
      font.fontFamily = info2.face;
      font.lineHeight = parseInt(common.lineHeight, 10);
      const page = rawData.page;
      for (let i2 = 0; i2 < page.length; i2++) {
        font.pages.push({
          id: parseInt(page[i2].id, 10) || 0,
          file: page[i2].file
        });
      }
      const map27 = {};
      font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);
      const char2 = rawData.char;
      for (let i2 = 0; i2 < char2.length; i2++) {
        const charNode = char2[i2];
        const id5 = parseInt(charNode.id, 10);
        let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id5);
        if (letter === "space")
          letter = " ";
        map27[id5] = letter;
        font.chars[letter] = {
          id: id5,
          // texture deets..
          page: parseInt(charNode.page, 10) || 0,
          x: parseInt(charNode.x, 10),
          y: parseInt(charNode.y, 10),
          width: parseInt(charNode.width, 10),
          height: parseInt(charNode.height, 10),
          xOffset: parseInt(charNode.xoffset, 10),
          yOffset: parseInt(charNode.yoffset, 10),
          xAdvance: parseInt(charNode.xadvance, 10),
          kerning: {}
        };
      }
      const kerning = rawData.kerning || [];
      for (let i2 = 0; i2 < kerning.length; i2++) {
        const first = parseInt(kerning[i2].first, 10);
        const second2 = parseInt(kerning[i2].second, 10);
        const amount = parseInt(kerning[i2].amount, 10);
        font.chars[map27[second2]].kerning[map27[first]] = amount;
      }
      return font;
    }
  };

  // node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs
  init_adapter();

  // node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.mjs
  var bitmapFontXMLParser = {
    test(data) {
      const xml = data;
      return typeof xml !== "string" && "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
    },
    parse(xml) {
      const data = {
        chars: {},
        pages: [],
        lineHeight: 0,
        fontSize: 0,
        fontFamily: "",
        distanceField: null,
        baseLineOffset: 0
      };
      const info2 = xml.getElementsByTagName("info")[0];
      const common = xml.getElementsByTagName("common")[0];
      const distanceField = xml.getElementsByTagName("distanceField")[0];
      if (distanceField) {
        data.distanceField = {
          type: distanceField.getAttribute("fieldType"),
          range: parseInt(distanceField.getAttribute("distanceRange"), 10)
        };
      }
      const page = xml.getElementsByTagName("page");
      const char2 = xml.getElementsByTagName("char");
      const kerning = xml.getElementsByTagName("kerning");
      data.fontSize = parseInt(info2.getAttribute("size"), 10);
      data.fontFamily = info2.getAttribute("face");
      data.lineHeight = parseInt(common.getAttribute("lineHeight"), 10);
      for (let i2 = 0; i2 < page.length; i2++) {
        data.pages.push({
          id: parseInt(page[i2].getAttribute("id"), 10) || 0,
          file: page[i2].getAttribute("file")
        });
      }
      const map27 = {};
      data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute("base"), 10);
      for (let i2 = 0; i2 < char2.length; i2++) {
        const charNode = char2[i2];
        const id5 = parseInt(charNode.getAttribute("id"), 10);
        let letter = charNode.getAttribute("letter") ?? charNode.getAttribute("char") ?? String.fromCharCode(id5);
        if (letter === "space")
          letter = " ";
        map27[id5] = letter;
        data.chars[letter] = {
          id: id5,
          // texture deets..
          page: parseInt(charNode.getAttribute("page"), 10) || 0,
          x: parseInt(charNode.getAttribute("x"), 10),
          y: parseInt(charNode.getAttribute("y"), 10),
          width: parseInt(charNode.getAttribute("width"), 10),
          height: parseInt(charNode.getAttribute("height"), 10),
          // render deets..
          xOffset: parseInt(charNode.getAttribute("xoffset"), 10),
          yOffset: parseInt(charNode.getAttribute("yoffset"), 10),
          // + baseLineOffset,
          xAdvance: parseInt(charNode.getAttribute("xadvance"), 10),
          kerning: {}
        };
      }
      for (let i2 = 0; i2 < kerning.length; i2++) {
        const first = parseInt(kerning[i2].getAttribute("first"), 10);
        const second2 = parseInt(kerning[i2].getAttribute("second"), 10);
        const amount = parseInt(kerning[i2].getAttribute("amount"), 10);
        data.chars[map27[second2]].kerning[map27[first]] = amount;
      }
      return data;
    }
  };

  // node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs
  var bitmapFontXMLStringParser = {
    test(data) {
      if (typeof data === "string" && data.includes("<font>")) {
        return bitmapFontXMLParser.test(DOMAdapter.get().parseXML(data));
      }
      return false;
    },
    parse(data) {
      return bitmapFontXMLParser.parse(DOMAdapter.get().parseXML(data));
    }
  };

  // node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.mjs
  var validExtensions = [".xml", ".fnt"];
  var bitmapFontCachePlugin = {
    extension: {
      type: ExtensionType.CacheParser,
      name: "cacheBitmapFont"
    },
    test: (asset) => asset instanceof BitmapFont,
    getCacheableAssets(keys6, asset) {
      const out2 = {};
      keys6.forEach((key) => {
        out2[key] = asset;
        out2[`${key}-bitmap`] = asset;
      });
      out2[`${asset.fontFamily}-bitmap`] = asset;
      return out2;
    }
  };
  var loadBitmapFont = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Normal
    },
    name: "loadBitmapFont",
    test(url2) {
      return validExtensions.includes(path.extname(url2).toLowerCase());
    },
    async testParse(data) {
      return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);
    },
    async parse(asset, data, loader) {
      const bitmapFontData = bitmapFontTextParser.test(asset) ? bitmapFontTextParser.parse(asset) : bitmapFontXMLStringParser.parse(asset);
      const { src: src9 } = data;
      const { pages } = bitmapFontData;
      const textureUrls = [];
      const textureOptions = bitmapFontData.distanceField ? {
        scaleMode: "linear",
        alphaMode: "premultiply-alpha-on-upload",
        autoGenerateMipmaps: false,
        resolution: 1
      } : {};
      for (let i2 = 0; i2 < pages.length; ++i2) {
        const pageFile = pages[i2].file;
        let imagePath = path.join(path.dirname(src9), pageFile);
        imagePath = copySearchParams(imagePath, src9);
        textureUrls.push({
          src: imagePath,
          data: textureOptions
        });
      }
      const loadedTextures = await loader.load(textureUrls);
      const textures = textureUrls.map((url2) => loadedTextures[url2.src]);
      const bitmapFont = new BitmapFont({
        data: bitmapFontData,
        textures
      }, src9);
      return bitmapFont;
    },
    async load(url2, _options) {
      const response = await DOMAdapter.get().fetch(url2);
      return await response.text();
    },
    async unload(bitmapFont, _resolvedAsset, loader) {
      await Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));
      bitmapFont.destroy();
    }
  };

  // node_modules/pixi.js/lib/assets/Assets.mjs
  init_warn();

  // node_modules/pixi.js/lib/assets/BackgroundLoader.mjs
  var BackgroundLoader = class {
    /**
     * @param loader
     * @param verbose - should the loader log to the console
     */
    constructor(loader, verbose2 = false) {
      this._loader = loader;
      this._assetList = [];
      this._isLoading = false;
      this._maxConcurrent = 1;
      this.verbose = verbose2;
    }
    /**
     * Adds an array of assets to load.
     * @param assetUrls - assets to load
     */
    add(assetUrls) {
      assetUrls.forEach((a2) => {
        this._assetList.push(a2);
      });
      if (this.verbose) {
        console.log("[BackgroundLoader] assets: ", this._assetList);
      }
      if (this._isActive && !this._isLoading) {
        void this._next();
      }
    }
    /**
     * Loads the next set of assets. Will try to load as many assets as it can at the same time.
     *
     * The max assets it will try to load at one time will be 4.
     */
    async _next() {
      if (this._assetList.length && this._isActive) {
        this._isLoading = true;
        const toLoad = [];
        const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);
        for (let i2 = 0; i2 < toLoadAmount; i2++) {
          toLoad.push(this._assetList.pop());
        }
        await this._loader.load(toLoad);
        this._isLoading = false;
        void this._next();
      }
    }
    /**
     * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.
     * @returns whether the class is active
     */
    get active() {
      return this._isActive;
    }
    set active(value12) {
      if (this._isActive === value12)
        return;
      this._isActive = value12;
      if (value12 && !this._isLoading) {
        void this._next();
      }
    }
  };

  // node_modules/pixi.js/lib/assets/Assets.mjs
  init_Cache();

  // node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.mjs
  init_Extensions();
  init_Texture();
  var cacheTextureArray = {
    extension: {
      type: ExtensionType.CacheParser,
      name: "cacheTextureArray"
    },
    test: (asset) => Array.isArray(asset) && asset.every((t3) => t3 instanceof Texture),
    getCacheableAssets: (keys6, asset) => {
      const out2 = {};
      keys6.forEach((key) => {
        asset.forEach((item, i2) => {
          out2[key + (i2 === 0 ? "" : i2 + 1)] = item;
        });
      });
      return out2;
    }
  };

  // node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs
  init_Extensions();

  // node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.mjs
  async function testImageFormat(imageData) {
    if ("Image" in globalThis) {
      return new Promise((resolve) => {
        const image = new Image();
        image.onload = () => {
          resolve(true);
        };
        image.onerror = () => {
          resolve(false);
        };
        image.src = imageData;
      });
    }
    if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
      try {
        const blob = await (await fetch(imageData)).blob();
        await createImageBitmap(blob);
      } catch (e2) {
        return false;
      }
      return true;
    }
    return false;
  }

  // node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs
  var detectAvif = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: 1
    },
    test: async () => testImageFormat(
      // eslint-disable-next-line max-len
      "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="
    ),
    add: async (formats) => [...formats, "avif"],
    remove: async (formats) => formats.filter((f2) => f2 !== "avif")
  };

  // node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.mjs
  init_Extensions();
  var imageFormats = ["png", "jpg", "jpeg"];
  var detectDefaults = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: -1
    },
    test: () => Promise.resolve(true),
    add: async (formats) => [...formats, ...imageFormats],
    remove: async (formats) => formats.filter((f2) => !imageFormats.includes(f2))
  };

  // node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs
  init_Extensions();

  // node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs
  var inWorker = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
  function testVideoFormat(mimeType) {
    if (inWorker) {
      return false;
    }
    const video = document.createElement("video");
    return video.canPlayType(mimeType) !== "";
  }

  // node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs
  var detectMp4 = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: 0
    },
    test: async () => testVideoFormat("video/mp4"),
    add: async (formats) => [...formats, "mp4", "m4v"],
    remove: async (formats) => formats.filter((f2) => f2 !== "mp4" && f2 !== "m4v")
  };

  // node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.mjs
  init_Extensions();
  var detectOgv = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: 0
    },
    test: async () => testVideoFormat("video/ogg"),
    add: async (formats) => [...formats, "ogv"],
    remove: async (formats) => formats.filter((f2) => f2 !== "ogv")
  };

  // node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.mjs
  init_Extensions();
  var detectWebm = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: 0
    },
    test: async () => testVideoFormat("video/webm"),
    add: async (formats) => [...formats, "webm"],
    remove: async (formats) => formats.filter((f2) => f2 !== "webm")
  };

  // node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.mjs
  init_Extensions();
  var detectWebp = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: 0
    },
    test: async () => testImageFormat(
      "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="
    ),
    add: async (formats) => [...formats, "webp"],
    remove: async (formats) => formats.filter((f2) => f2 !== "webp")
  };

  // node_modules/pixi.js/lib/assets/loader/Loader.mjs
  init_warn();
  init_path();
  init_convertToList();
  init_isSingleItem();
  var Loader = class {
    constructor() {
      this._parsers = [];
      this._parsersValidated = false;
      this.parsers = new Proxy(this._parsers, {
        set: (target5, key, value12) => {
          this._parsersValidated = false;
          target5[key] = value12;
          return true;
        }
      });
      this.promiseCache = {};
    }
    /** function used for testing */
    reset() {
      this._parsersValidated = false;
      this.promiseCache = {};
    }
    /**
     * Used internally to generate a promise for the asset to be loaded.
     * @param url - The URL to be loaded
     * @param data - any custom additional information relevant to the asset being loaded
     * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object
     */
    _getLoadPromiseAndParser(url2, data) {
      const result = {
        promise: null,
        parser: null
      };
      result.promise = (async () => {
        let asset = null;
        let parser2 = null;
        if (data.loadParser) {
          parser2 = this._parserHash[data.loadParser];
          if (!parser2) {
            warn2(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url2}`);
          }
        }
        if (!parser2) {
          for (let i2 = 0; i2 < this.parsers.length; i2++) {
            const parserX = this.parsers[i2];
            if (parserX.load && parserX.test?.(url2, data, this)) {
              parser2 = parserX;
              break;
            }
          }
          if (!parser2) {
            warn2(`[Assets] ${url2} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);
            return null;
          }
        }
        asset = await parser2.load(url2, data, this);
        result.parser = parser2;
        for (let i2 = 0; i2 < this.parsers.length; i2++) {
          const parser22 = this.parsers[i2];
          if (parser22.parse) {
            if (parser22.parse && await parser22.testParse?.(asset, data, this)) {
              asset = await parser22.parse(asset, data, this) || asset;
              result.parser = parser22;
            }
          }
        }
        return asset;
      })();
      return result;
    }
    async load(assetsToLoadIn, onProgress) {
      if (!this._parsersValidated) {
        this._validateParsers();
      }
      let count2 = 0;
      const assets = {};
      const singleAsset = isSingleItem(assetsToLoadIn);
      const assetsToLoad = convertToList(assetsToLoadIn, (item) => ({
        alias: [item],
        src: item,
        data: {}
      }));
      const total = assetsToLoad.length;
      const promises = assetsToLoad.map(async (asset) => {
        const url2 = path.toAbsolute(asset.src);
        if (!assets[asset.src]) {
          try {
            if (!this.promiseCache[url2]) {
              this.promiseCache[url2] = this._getLoadPromiseAndParser(url2, asset);
            }
            assets[asset.src] = await this.promiseCache[url2].promise;
            if (onProgress)
              onProgress(++count2 / total);
          } catch (e2) {
            delete this.promiseCache[url2];
            delete assets[asset.src];
            throw new Error(`[Loader.load] Failed to load ${url2}.
${e2}`);
          }
        }
      });
      await Promise.all(promises);
      return singleAsset ? assets[assetsToLoad[0].src] : assets;
    }
    /**
     * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.
     * The parser that created the asset, will be the one that unloads it.
     * @example
     * // Single asset:
     * const asset = await Loader.load('cool.png');
     *
     * await Loader.unload('cool.png');
     *
     * console.log(asset.destroyed); // true
     * @param assetsToUnloadIn - urls that you want to unload, or a single one!
     */
    async unload(assetsToUnloadIn) {
      const assetsToUnload = convertToList(assetsToUnloadIn, (item) => ({
        alias: [item],
        src: item
      }));
      const promises = assetsToUnload.map(async (asset) => {
        const url2 = path.toAbsolute(asset.src);
        const loadPromise = this.promiseCache[url2];
        if (loadPromise) {
          const loadedAsset = await loadPromise.promise;
          delete this.promiseCache[url2];
          await loadPromise.parser?.unload?.(loadedAsset, asset, this);
        }
      });
      await Promise.all(promises);
    }
    /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */
    _validateParsers() {
      this._parsersValidated = true;
      this._parserHash = this._parsers.filter((parser2) => parser2.name).reduce((hash2, parser2) => {
        if (!parser2.name) {
          warn2(`[Assets] loadParser should have a name`);
        } else if (hash2[parser2.name]) {
          warn2(`[Assets] loadParser name conflict "${parser2.name}"`);
        }
        return { ...hash2, [parser2.name]: parser2 };
      }, {});
    }
  };

  // node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs
  init_adapter();
  init_Extensions();

  // node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs
  function checkDataUrl(url2, mimes) {
    if (Array.isArray(mimes)) {
      for (const mime of mimes) {
        if (url2.startsWith(`data:${mime}`))
          return true;
      }
      return false;
    }
    return url2.startsWith(`data:${mimes}`);
  }

  // node_modules/pixi.js/lib/assets/utils/checkExtension.mjs
  init_path();
  function checkExtension(url2, extension) {
    const tempURL = url2.split("?")[0];
    const ext = path.extname(tempURL).toLowerCase();
    if (Array.isArray(extension)) {
      return extension.includes(ext);
    }
    return ext === extension;
  }

  // node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs
  init_LoaderParser();
  var validJSONExtension = ".json";
  var validJSONMIME = "application/json";
  var loadJson = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Low
    },
    name: "loadJson",
    test(url2) {
      return checkDataUrl(url2, validJSONMIME) || checkExtension(url2, validJSONExtension);
    },
    async load(url2) {
      const response = await DOMAdapter.get().fetch(url2);
      const json = await response.json();
      return json;
    }
  };

  // node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.mjs
  init_adapter();
  init_Extensions();
  init_LoaderParser();
  var validTXTExtension = ".txt";
  var validTXTMIME = "text/plain";
  var loadTxt = {
    name: "loadTxt",
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Low,
      name: "loadTxt"
    },
    test(url2) {
      return checkDataUrl(url2, validTXTMIME) || checkExtension(url2, validTXTExtension);
    },
    async load(url2) {
      const response = await DOMAdapter.get().fetch(url2);
      const txt = await response.text();
      return txt;
    }
  };

  // node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.mjs
  init_adapter();
  init_Extensions();
  init_warn();
  init_path();
  init_Cache();
  init_LoaderParser();
  var validWeights = [
    "normal",
    "bold",
    "100",
    "200",
    "300",
    "400",
    "500",
    "600",
    "700",
    "800",
    "900"
  ];
  var validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"];
  var validFontMIMEs = [
    "font/ttf",
    "font/otf",
    "font/woff",
    "font/woff2"
  ];
  var CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
  function getFontFamilyName(url2) {
    const ext = path.extname(url2);
    const name16 = path.basename(url2, ext);
    const nameWithSpaces = name16.replace(/(-|_)/g, " ");
    const nameTokens = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));
    let valid = nameTokens.length > 0;
    for (const token of nameTokens) {
      if (!token.match(CSS_IDENT_TOKEN_REGEX)) {
        valid = false;
        break;
      }
    }
    let fontFamilyName = nameTokens.join(" ");
    if (!valid) {
      fontFamilyName = `"${fontFamilyName.replace(/[\\"]/g, "\\$&")}"`;
    }
    return fontFamilyName;
  }
  var validURICharactersRegex = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
  function encodeURIWhenNeeded(uri) {
    if (validURICharactersRegex.test(uri)) {
      return uri;
    }
    return encodeURI(uri);
  }
  var loadWebFont = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Low
    },
    name: "loadWebFont",
    test(url2) {
      return checkDataUrl(url2, validFontMIMEs) || checkExtension(url2, validFontExtensions);
    },
    async load(url2, options2) {
      const fonts = DOMAdapter.get().getFontFaceSet();
      if (fonts) {
        const fontFaces = [];
        const name16 = options2.data?.family ?? getFontFamilyName(url2);
        const weights = options2.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ["normal"];
        const data = options2.data ?? {};
        for (let i2 = 0; i2 < weights.length; i2++) {
          const weight = weights[i2];
          const font = new FontFace(name16, `url(${encodeURIWhenNeeded(url2)})`, {
            ...data,
            weight
          });
          await font.load();
          fonts.add(font);
          fontFaces.push(font);
        }
        Cache.set(`${name16}-and-url`, {
          url: url2,
          fontFaces
        });
        return fontFaces.length === 1 ? fontFaces[0] : fontFaces;
      }
      warn2("[loadWebFont] FontFace API is not supported. Skipping loading font");
      return null;
    },
    unload(font) {
      (Array.isArray(font) ? font : [font]).forEach((t3) => {
        Cache.remove(t3.family);
        DOMAdapter.get().getFontFaceSet().delete(t3);
      });
    }
  };

  // node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs
  init_adapter();
  init_Extensions();
  init_ImageSource();
  init_GraphicsContext();

  // node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs
  init_Resolver();
  function getResolutionOfUrl(url2, defaultValue5 = 1) {
    const resolution = Resolver.RETINA_PREFIX?.exec(url2);
    if (resolution) {
      return parseFloat(resolution[1]);
    }
    return defaultValue5;
  }

  // node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs
  init_LoaderParser();

  // node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs
  init_Texture();
  init_warn();
  init_Cache();
  function createTexture(source3, loader, url2) {
    source3.label = url2;
    source3._sourceOrigin = url2;
    const texture = new Texture({
      source: source3,
      label: url2
    });
    const unload = () => {
      delete loader.promiseCache[url2];
      if (Cache.has(url2)) {
        Cache.remove(url2);
      }
    };
    texture.source.once("destroy", () => {
      if (loader.promiseCache[url2]) {
        warn2("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource.");
        unload();
      }
    });
    texture.once("destroy", () => {
      if (!source3.destroyed) {
        warn2("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture.");
        unload();
      }
    });
    return texture;
  }

  // node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs
  var validSVGExtension = ".svg";
  var validSVGMIME = "image/svg+xml";
  var loadSvg = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Low,
      name: "loadSVG"
    },
    name: "loadSVG",
    config: {
      crossOrigin: "anonymous",
      parseAsGraphicsContext: false
    },
    test(url2) {
      return checkDataUrl(url2, validSVGMIME) || checkExtension(url2, validSVGExtension);
    },
    async load(url2, asset, loader) {
      if (asset.data.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext) {
        return loadAsGraphics(url2);
      }
      return loadAsTexture(url2, asset, loader, this.config.crossOrigin);
    },
    unload(asset) {
      asset.destroy(true);
    }
  };
  async function loadAsTexture(url2, asset, loader, crossOrigin5) {
    const response = await DOMAdapter.get().fetch(url2);
    const blob = await response.blob();
    const blobUrl = URL.createObjectURL(blob);
    const image = new Image();
    image.src = blobUrl;
    image.crossOrigin = crossOrigin5;
    await image.decode();
    URL.revokeObjectURL(blobUrl);
    const canvas2 = document.createElement("canvas");
    const context3 = canvas2.getContext("2d");
    const resolution = asset.data?.resolution || getResolutionOfUrl(url2);
    const width8 = asset.data?.width ?? image.width;
    const height8 = asset.data?.height ?? image.height;
    canvas2.width = width8 * resolution;
    canvas2.height = height8 * resolution;
    context3.drawImage(image, 0, 0, width8 * resolution, height8 * resolution);
    const { parseAsGraphicsContext: _p, ...rest } = asset.data;
    const base2 = new ImageSource({
      resource: canvas2,
      alphaMode: "premultiply-alpha-on-upload",
      resolution,
      ...rest
    });
    return createTexture(base2, loader, url2);
  }
  async function loadAsGraphics(url2) {
    const response = await DOMAdapter.get().fetch(url2);
    const svgSource = await response.text();
    const context3 = new GraphicsContext();
    context3.svg(svgSource);
    return context3;
  }

  // node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs
  init_adapter();
  init_Extensions();
  init_ImageSource();

  // node_modules/pixi.js/lib/_virtual/checkImageBitmap.worker.mjs
  var WORKER_CODE = `(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`;
  var WORKER_URL = null;
  var WorkerInstance = class {
    constructor() {
      if (!WORKER_URL) {
        WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: "application/javascript" }));
      }
      this.worker = new Worker(WORKER_URL);
    }
  };
  WorkerInstance.revokeObjectURL = function revokeObjectURL() {
    if (WORKER_URL) {
      URL.revokeObjectURL(WORKER_URL);
      WORKER_URL = null;
    }
  };

  // node_modules/pixi.js/lib/_virtual/loadImageBitmap.worker.mjs
  var WORKER_CODE2 = '(function () {\n    \'use strict\';\n\n    async function loadImageBitmap(url, alphaMode) {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\n      }\n      const imageBlob = await response.blob();\n      return alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);\n    }\n    self.onmessage = async (event) => {\n      try {\n        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);\n        self.postMessage({\n          data: imageBitmap,\n          uuid: event.data.uuid,\n          id: event.data.id\n        }, [imageBitmap]);\n      } catch (e) {\n        self.postMessage({\n          error: e,\n          uuid: event.data.uuid,\n          id: event.data.id\n        });\n      }\n    };\n\n})();\n';
  var WORKER_URL2 = null;
  var WorkerInstance2 = class {
    constructor() {
      if (!WORKER_URL2) {
        WORKER_URL2 = URL.createObjectURL(new Blob([WORKER_CODE2], { type: "application/javascript" }));
      }
      this.worker = new Worker(WORKER_URL2);
    }
  };
  WorkerInstance2.revokeObjectURL = function revokeObjectURL2() {
    if (WORKER_URL2) {
      URL.revokeObjectURL(WORKER_URL2);
      WORKER_URL2 = null;
    }
  };

  // node_modules/pixi.js/lib/assets/loader/workers/WorkerManager.mjs
  var UUID = 0;
  var MAX_WORKERS;
  var WorkerManagerClass = class {
    constructor() {
      this._initialized = false;
      this._createdWorkers = 0;
      this._workerPool = [];
      this._queue = [];
      this._resolveHash = {};
    }
    isImageBitmapSupported() {
      if (this._isImageBitmapSupported !== void 0)
        return this._isImageBitmapSupported;
      this._isImageBitmapSupported = new Promise((resolve) => {
        const { worker } = new WorkerInstance();
        worker.addEventListener("message", (event) => {
          worker.terminate();
          WorkerInstance.revokeObjectURL();
          resolve(event.data);
        });
      });
      return this._isImageBitmapSupported;
    }
    loadImageBitmap(src9, asset) {
      return this._run("loadImageBitmap", [src9, asset?.data?.alphaMode]);
    }
    async _initWorkers() {
      if (this._initialized)
        return;
      this._initialized = true;
    }
    _getWorker() {
      if (MAX_WORKERS === void 0) {
        MAX_WORKERS = navigator.hardwareConcurrency || 4;
      }
      let worker = this._workerPool.pop();
      if (!worker && this._createdWorkers < MAX_WORKERS) {
        this._createdWorkers++;
        worker = new WorkerInstance2().worker;
        worker.addEventListener("message", (event) => {
          this._complete(event.data);
          this._returnWorker(event.target);
          this._next();
        });
      }
      return worker;
    }
    _returnWorker(worker) {
      this._workerPool.push(worker);
    }
    _complete(data) {
      if (data.error !== void 0) {
        this._resolveHash[data.uuid].reject(data.error);
      } else {
        this._resolveHash[data.uuid].resolve(data.data);
      }
      this._resolveHash[data.uuid] = null;
    }
    async _run(id5, args) {
      await this._initWorkers();
      const promise2 = new Promise((resolve, reject) => {
        this._queue.push({ id: id5, arguments: args, resolve, reject });
      });
      this._next();
      return promise2;
    }
    _next() {
      if (!this._queue.length)
        return;
      const worker = this._getWorker();
      if (!worker) {
        return;
      }
      const toDo = this._queue.pop();
      const id5 = toDo.id;
      this._resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };
      worker.postMessage({
        data: toDo.arguments,
        uuid: UUID++,
        id: id5
      });
    }
  };
  var WorkerManager = new WorkerManagerClass();

  // node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs
  init_LoaderParser();
  var validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"];
  var validImageMIMEs = [
    "image/jpeg",
    "image/png",
    "image/webp",
    "image/avif"
  ];
  async function loadImageBitmap(url2, asset) {
    const response = await DOMAdapter.get().fetch(url2);
    if (!response.ok) {
      throw new Error(`[loadImageBitmap] Failed to fetch ${url2}: ${response.status} ${response.statusText}`);
    }
    const imageBlob = await response.blob();
    return asset?.data?.alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);
  }
  var loadTextures = {
    name: "loadTextures",
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.High,
      name: "loadTextures"
    },
    config: {
      preferWorkers: true,
      preferCreateImageBitmap: true,
      crossOrigin: "anonymous"
    },
    test(url2) {
      return checkDataUrl(url2, validImageMIMEs) || checkExtension(url2, validImageExtensions);
    },
    async load(url2, asset, loader) {
      let src9 = null;
      if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {
        if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported()) {
          src9 = await WorkerManager.loadImageBitmap(url2, asset);
        } else {
          src9 = await loadImageBitmap(url2, asset);
        }
      } else {
        src9 = await new Promise((resolve) => {
          src9 = new Image();
          src9.crossOrigin = this.config.crossOrigin;
          src9.src = url2;
          if (src9.complete) {
            resolve(src9);
          } else {
            src9.onload = () => {
              resolve(src9);
            };
          }
        });
      }
      const base2 = new ImageSource({
        resource: src9,
        alphaMode: "premultiply-alpha-on-upload",
        resolution: asset.data?.resolution || getResolutionOfUrl(url2),
        ...asset.data
      });
      return createTexture(base2, loader, url2);
    },
    unload(texture) {
      texture.destroy(true);
    }
  };

  // node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.mjs
  init_Extensions();
  init_VideoSource();
  init_detectVideoAlphaMode();
  var validVideoExtensions = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"];
  var validVideoMIMEs = validVideoExtensions.map((ext) => `video/${ext.substring(1)}`);
  function crossOrigin(element, url2, crossorigin) {
    if (crossorigin === void 0 && !url2.startsWith("data:")) {
      element.crossOrigin = determineCrossOrigin(url2);
    } else if (crossorigin !== false) {
      element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
    }
  }
  function preloadVideo(element) {
    return new Promise((resolve, reject) => {
      element.addEventListener("canplaythrough", loaded);
      element.addEventListener("error", error5);
      element.load();
      function loaded() {
        cleanup();
        resolve();
      }
      function error5(err) {
        cleanup();
        reject(err);
      }
      function cleanup() {
        element.removeEventListener("canplaythrough", loaded);
        element.removeEventListener("error", error5);
      }
    });
  }
  function determineCrossOrigin(url2, loc = globalThis.location) {
    if (url2.startsWith("data:")) {
      return "";
    }
    loc = loc || globalThis.location;
    const parsedUrl = new URL(url2, document.baseURI);
    if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol) {
      return "anonymous";
    }
    return "";
  }
  var loadVideoTextures = {
    name: "loadVideo",
    extension: {
      type: ExtensionType.LoadParser,
      name: "loadVideo"
    },
    test(url2) {
      const isValidDataUrl = checkDataUrl(url2, validVideoMIMEs);
      const isValidExtension = checkExtension(url2, validVideoExtensions);
      return isValidDataUrl || isValidExtension;
    },
    async load(url2, asset, loader) {
      const options2 = {
        ...VideoSource.defaultOptions,
        resolution: asset.data?.resolution || getResolutionOfUrl(url2),
        alphaMode: asset.data?.alphaMode || await detectVideoAlphaMode(),
        ...asset.data
      };
      const videoElement = document.createElement("video");
      const attributeMap = {
        preload: options2.autoLoad !== false ? "auto" : void 0,
        "webkit-playsinline": options2.playsinline !== false ? "" : void 0,
        playsinline: options2.playsinline !== false ? "" : void 0,
        muted: options2.muted === true ? "" : void 0,
        loop: options2.loop === true ? "" : void 0,
        autoplay: options2.autoPlay !== false ? "" : void 0
      };
      Object.keys(attributeMap).forEach((key) => {
        const value12 = attributeMap[key];
        if (value12 !== void 0)
          videoElement.setAttribute(key, value12);
      });
      if (options2.muted === true) {
        videoElement.muted = true;
      }
      crossOrigin(videoElement, url2, options2.crossorigin);
      const sourceElement = document.createElement("source");
      let mime;
      if (url2.startsWith("data:")) {
        mime = url2.slice(5, url2.indexOf(";"));
      } else if (!url2.startsWith("blob:")) {
        const ext = url2.split("?")[0].slice(url2.lastIndexOf(".") + 1).toLowerCase();
        mime = VideoSource.MIME_TYPES[ext] || `video/${ext}`;
      }
      sourceElement.src = url2;
      if (mime) {
        sourceElement.type = mime;
      }
      return new Promise((resolve) => {
        const onCanPlay = async () => {
          const base2 = new VideoSource({ ...options2, resource: videoElement });
          videoElement.removeEventListener("canplay", onCanPlay);
          if (asset.data.preload) {
            await preloadVideo(videoElement);
          }
          resolve(createTexture(base2, loader, url2));
        };
        videoElement.addEventListener("canplay", onCanPlay);
        videoElement.appendChild(sourceElement);
      });
    },
    unload(texture) {
      texture.destroy(true);
    }
  };

  // node_modules/pixi.js/lib/assets/resolver/parsers/resolveJsonUrl.mjs
  init_Extensions();
  init_Resolver();

  // node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.mjs
  init_Extensions();
  init_Resolver();
  var resolveTextureUrl = {
    extension: {
      type: ExtensionType.ResolveParser,
      name: "resolveTexture"
    },
    test: loadTextures.test,
    parse: (value12) => ({
      resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value12)?.[1] ?? "1"),
      format: value12.split(".").pop(),
      src: value12
    })
  };

  // node_modules/pixi.js/lib/assets/resolver/parsers/resolveJsonUrl.mjs
  var resolveJsonUrl = {
    extension: {
      type: ExtensionType.ResolveParser,
      priority: -2,
      name: "resolveJson"
    },
    test: (value12) => Resolver.RETINA_PREFIX.test(value12) && value12.endsWith(".json"),
    parse: resolveTextureUrl.parse
  };

  // node_modules/pixi.js/lib/assets/Assets.mjs
  init_Resolver();
  init_convertToList();
  init_isSingleItem();
  var AssetsClass = class {
    constructor() {
      this._detections = [];
      this._initialized = false;
      this.resolver = new Resolver();
      this.loader = new Loader();
      this.cache = Cache;
      this._backgroundLoader = new BackgroundLoader(this.loader);
      this._backgroundLoader.active = true;
      this.reset();
    }
    /**
     * Best practice is to call this function before any loading commences
     * Initiating is the best time to add any customization to the way things are loaded.
     *
     * you do not need to call this for the Assets class to work, only if you want to set any initial properties
     * @param options - options to initialize the Assets manager with
     */
    async init(options2 = {}) {
      if (this._initialized) {
        warn2("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");
        return;
      }
      this._initialized = true;
      if (options2.defaultSearchParams) {
        this.resolver.setDefaultSearchParams(options2.defaultSearchParams);
      }
      if (options2.basePath) {
        this.resolver.basePath = options2.basePath;
      }
      if (options2.bundleIdentifier) {
        this.resolver.setBundleIdentifier(options2.bundleIdentifier);
      }
      if (options2.manifest) {
        let manifest = options2.manifest;
        if (typeof manifest === "string") {
          manifest = await this.load(manifest);
        }
        this.resolver.addManifest(manifest);
      }
      const resolutionPref = options2.texturePreference?.resolution ?? 1;
      const resolution = typeof resolutionPref === "number" ? [resolutionPref] : resolutionPref;
      const formats = await this._detectFormats({
        preferredFormats: options2.texturePreference?.format,
        skipDetections: options2.skipDetections,
        detections: this._detections
      });
      this.resolver.prefer({
        params: {
          format: formats,
          resolution
        }
      });
      if (options2.preferences) {
        this.setPreferences(options2.preferences);
      }
    }
    /**
     * Allows you to specify how to resolve any assets load requests.
     * There are a few ways to add things here as shown below:
     * @example
     * import { Assets } from 'pixi.js';
     *
     * // Simple
     * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.png'});
     * const bunny = await Assets.load('bunnyBooBoo');
     *
     * // Multiple keys:
     * Assets.add({alias: ['burger', 'chicken'], src: 'bunny.png'});
     *
     * const bunny = await Assets.load('burger');
     * const bunny2 = await Assets.load('chicken');
     *
     * // passing options to to the object
     * Assets.add({
     *     alias: 'bunnyBooBooSmooth',
     *     src: 'bunny{png,webp}',
     *     data: { scaleMode: SCALE_MODES.NEAREST }, // Base texture options
     * });
     *
     * // Multiple assets
     *
     * // The following all do the same thing:
     *
     * Assets.add({alias: 'bunnyBooBoo', src: 'bunny{png,webp}'});
     *
     * Assets.add({
     *     alias: 'bunnyBooBoo',
     *     src: [
     *         'bunny.png',
     *         'bunny.webp',
     *    ],
     * });
     *
     * const bunny = await Assets.load('bunnyBooBoo'); // Will try to load WebP if available
     * @param assets - the unresolved assets to add to the resolver
     */
    add(assets) {
      this.resolver.add(assets);
    }
    async load(urls, onProgress) {
      if (!this._initialized) {
        await this.init();
      }
      const singleAsset = isSingleItem(urls);
      const urlArray = convertToList(urls).map((url2) => {
        if (typeof url2 !== "string") {
          const aliases = this.resolver.getAlias(url2);
          if (aliases.some((alias) => !this.resolver.hasKey(alias))) {
            this.add(url2);
          }
          return Array.isArray(aliases) ? aliases[0] : aliases;
        }
        if (!this.resolver.hasKey(url2))
          this.add({ alias: url2, src: url2 });
        return url2;
      });
      const resolveResults = this.resolver.resolve(urlArray);
      const out2 = await this._mapLoadToResolve(resolveResults, onProgress);
      return singleAsset ? out2[urlArray[0]] : out2;
    }
    /**
     * This adds a bundle of assets in one go so that you can load them as a group.
     * For example you could add a bundle for each screen in you pixi app
     * @example
     * import { Assets } from 'pixi.js';
     *
     * Assets.addBundle('animals', [
     *  { alias: 'bunny', src: 'bunny.png' },
     *  { alias: 'chicken', src: 'chicken.png' },
     *  { alias: 'thumper', src: 'thumper.png' },
     * ]);
     * // or
     * Assets.addBundle('animals', {
     *     bunny: 'bunny.png',
     *     chicken: 'chicken.png',
     *     thumper: 'thumper.png',
     * });
     *
     * const assets = await Assets.loadBundle('animals');
     * @param bundleId - the id of the bundle to add
     * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key
     */
    addBundle(bundleId, assets) {
      this.resolver.addBundle(bundleId, assets);
    }
    /**
     * Bundles are a way to load multiple assets at once.
     * If a manifest has been provided to the init function then you can load a bundle, or bundles.
     * you can also add bundles via `addBundle`
     * @example
     * import { Assets } from 'pixi.js';
     *
     * // Manifest Example
     * const manifest = {
     *     bundles: [
     *         {
     *             name: 'load-screen',
     *             assets: [
     *                 {
     *                     alias: 'background',
     *                     src: 'sunset.png',
     *                 },
     *                 {
     *                     alias: 'bar',
     *                     src: 'load-bar.{png,webp}',
     *                 },
     *             ],
     *         },
     *         {
     *             name: 'game-screen',
     *             assets: [
     *                 {
     *                     alias: 'character',
     *                     src: 'robot.png',
     *                 },
     *                 {
     *                     alias: 'enemy',
     *                     src: 'bad-guy.png',
     *                 },
     *             ],
     *         },
     *     ]
     * };
     *
     * await Assets.init({ manifest });
     *
     * // Load a bundle...
     * loadScreenAssets = await Assets.loadBundle('load-screen');
     * // Load another bundle...
     * gameScreenAssets = await Assets.loadBundle('game-screen');
     * @param bundleIds - the bundle id or ids to load
     * @param onProgress - Optional function that is called when progress on asset loading is made.
     * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)
     * of the assets loaded. Do not use this function to detect when assets are complete and available,
     * instead use the Promise returned by this function.
     * @returns all the bundles assets or a hash of assets for each bundle specified
     */
    async loadBundle(bundleIds, onProgress) {
      if (!this._initialized) {
        await this.init();
      }
      let singleAsset = false;
      if (typeof bundleIds === "string") {
        singleAsset = true;
        bundleIds = [bundleIds];
      }
      const resolveResults = this.resolver.resolveBundle(bundleIds);
      const out2 = {};
      const keys6 = Object.keys(resolveResults);
      let count2 = 0;
      let total = 0;
      const _onProgress = () => {
        onProgress?.(++count2 / total);
      };
      const promises = keys6.map((bundleId) => {
        const resolveResult = resolveResults[bundleId];
        total += Object.keys(resolveResult).length;
        return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {
          out2[bundleId] = resolveResult2;
        });
      });
      await Promise.all(promises);
      return singleAsset ? out2[bundleIds[0]] : out2;
    }
    /**
     * Initiate a background load of some assets. It will passively begin to load these assets in the background.
     * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately
     *
     * An example of this might be that you would background load game assets after your initial load.
     * then when you got to actually load your game screen assets when a player goes to the game - the loading
     * would already have stared or may even be complete, saving you having to show an interim load bar.
     * @example
     * import { Assets } from 'pixi.js';
     *
     * Assets.backgroundLoad('bunny.png');
     *
     * // later on in your app...
     * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!
     * @param urls - the url / urls you want to background load
     */
    async backgroundLoad(urls) {
      if (!this._initialized) {
        await this.init();
      }
      if (typeof urls === "string") {
        urls = [urls];
      }
      const resolveResults = this.resolver.resolve(urls);
      this._backgroundLoader.add(Object.values(resolveResults));
    }
    /**
     * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.
     * this can only be used if the loader has been initiated with a manifest
     * @example
     * import { Assets } from 'pixi.js';
     *
     * await Assets.init({
     *     manifest: {
     *         bundles: [
     *             {
     *                 name: 'load-screen',
     *                 assets: [...],
     *             },
     *             ...
     *         ],
     *     },
     * });
     *
     * Assets.backgroundLoadBundle('load-screen');
     *
     * // Later on in your app...
     * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!
     * @param bundleIds - the bundleId / bundleIds you want to background load
     */
    async backgroundLoadBundle(bundleIds) {
      if (!this._initialized) {
        await this.init();
      }
      if (typeof bundleIds === "string") {
        bundleIds = [bundleIds];
      }
      const resolveResults = this.resolver.resolveBundle(bundleIds);
      Object.values(resolveResults).forEach((resolveResult) => {
        this._backgroundLoader.add(Object.values(resolveResult));
      });
    }
    /**
     * Only intended for development purposes.
     * This will wipe the resolver and caches.
     * You will need to reinitialize the Asset
     */
    reset() {
      this.resolver.reset();
      this.loader.reset();
      this.cache.reset();
      this._initialized = false;
    }
    get(keys6) {
      if (typeof keys6 === "string") {
        return Cache.get(keys6);
      }
      const assets = {};
      for (let i2 = 0; i2 < keys6.length; i2++) {
        assets[i2] = Cache.get(keys6[i2]);
      }
      return assets;
    }
    /**
     * helper function to map resolved assets back to loaded assets
     * @param resolveResults - the resolve results from the resolver
     * @param onProgress - the progress callback
     */
    async _mapLoadToResolve(resolveResults, onProgress) {
      const resolveArray = [...new Set(Object.values(resolveResults))];
      this._backgroundLoader.active = false;
      const loadedAssets = await this.loader.load(resolveArray, onProgress);
      this._backgroundLoader.active = true;
      const out2 = {};
      resolveArray.forEach((resolveResult) => {
        const asset = loadedAssets[resolveResult.src];
        const keys6 = [resolveResult.src];
        if (resolveResult.alias) {
          keys6.push(...resolveResult.alias);
        }
        keys6.forEach((key) => {
          out2[key] = asset;
        });
        Cache.set(keys6, asset);
      });
      return out2;
    }
    /**
     * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function
     * this will make sure to destroy any assets and release them from memory.
     * Once unloaded, you will need to load the asset again.
     *
     * Use this to help manage assets if you find that you have a large app and you want to free up memory.
     *
     * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,
     * Pixi won't break but you will end up with missing assets. Not a good look for the user!
     * @example
     * import { Assets } from 'pixi.js';
     *
     * // Load a URL:
     * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture
     *
     * await Assets.unload('http://some.url.com/image.png')
     *
     * // myImageTexture will be destroyed now.
     *
     * // Unload multiple assets:
     * const textures = await Assets.unload(['thumper', 'chicko']);
     * @param urls - the urls to unload
     */
    async unload(urls) {
      if (!this._initialized) {
        await this.init();
      }
      const urlArray = convertToList(urls).map((url2) => typeof url2 !== "string" ? url2.src : url2);
      const resolveResults = this.resolver.resolve(urlArray);
      await this._unloadFromResolved(resolveResults);
    }
    /**
     * Bundles are a way to manage multiple assets at once.
     * this will unload all files in a bundle.
     *
     * once a bundle has been unloaded, you need to load it again to have access to the assets.
     * @example
     * import { Assets } from 'pixi.js';
     *
     * Assets.addBundle({
     *     'thumper': 'http://some.url.com/thumper.png',
     * })
     *
     * const assets = await Assets.loadBundle('thumper');
     *
     * // Now to unload...
     *
     * await Assets.unloadBundle('thumper');
     *
     * // All assets in the assets object will now have been destroyed and purged from the cache
     * @param bundleIds - the bundle id or ids to unload
     */
    async unloadBundle(bundleIds) {
      if (!this._initialized) {
        await this.init();
      }
      bundleIds = convertToList(bundleIds);
      const resolveResults = this.resolver.resolveBundle(bundleIds);
      const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));
      await Promise.all(promises);
    }
    async _unloadFromResolved(resolveResult) {
      const resolveArray = Object.values(resolveResult);
      resolveArray.forEach((resolveResult2) => {
        Cache.remove(resolveResult2.src);
      });
      await this.loader.unload(resolveArray);
    }
    /**
     * Detects the supported formats for the browser, and returns an array of supported formats, respecting
     * the users preferred formats order.
     * @param options - the options to use when detecting formats
     * @param options.preferredFormats - the preferred formats to use
     * @param options.skipDetections - if we should skip the detections altogether
     * @param options.detections - the detections to use
     * @returns - the detected formats
     */
    async _detectFormats(options2) {
      let formats = [];
      if (options2.preferredFormats) {
        formats = Array.isArray(options2.preferredFormats) ? options2.preferredFormats : [options2.preferredFormats];
      }
      for (const detection of options2.detections) {
        if (options2.skipDetections || await detection.test()) {
          formats = await detection.add(formats);
        } else if (!options2.skipDetections) {
          formats = await detection.remove(formats);
        }
      }
      formats = formats.filter((format, index6) => formats.indexOf(format) === index6);
      return formats;
    }
    /** All the detection parsers currently added to the Assets class. */
    get detections() {
      return this._detections;
    }
    /**
     * General setter for preferences. This is a helper function to set preferences on all parsers.
     * @param preferences - the preferences to set
     */
    setPreferences(preferences) {
      this.loader.parsers.forEach((parser2) => {
        if (!parser2.config)
          return;
        Object.keys(parser2.config).filter((key) => key in preferences).forEach((key) => {
          parser2.config[key] = preferences[key];
        });
      });
    }
  };
  var Assets = new AssetsClass();
  extensions.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);
  extensions.add(
    cacheTextureArray,
    detectDefaults,
    detectAvif,
    detectWebp,
    detectMp4,
    detectOgv,
    detectWebm,
    loadJson,
    loadTxt,
    loadWebFont,
    loadSvg,
    loadTextures,
    loadVideoTextures,
    loadBitmapFont,
    bitmapFontCachePlugin,
    resolveTextureUrl,
    resolveJsonUrl
  );
  var assetKeyMap = {
    loader: ExtensionType.LoadParser,
    resolver: ExtensionType.ResolveParser,
    cache: ExtensionType.CacheParser,
    detection: ExtensionType.DetectionParser
  };
  extensions.handle(ExtensionType.Asset, (extension) => {
    const ref = extension.ref;
    Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => extensions.add(Object.assign(
      ref[key],
      // Allow the function to optionally define it's own
      // ExtensionMetadata, the use cases here is priority for LoaderParsers
      { extension: ref[key].extension ?? type }
    )));
  }, (extension) => {
    const ref = extension.ref;
    Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => extensions.remove(ref[key]));
  });

  // node_modules/pixi.js/lib/scene/text/AbstractText.mjs
  init_ObservablePoint();
  init_deprecation();
  init_ViewContainer();
  var AbstractText = class extends ViewContainer {
    constructor(options2, styleClass) {
      const { text: text6, resolution, style: style3, anchor, width: width8, height: height8, roundPixels, ...rest } = options2;
      super({
        ...rest
      });
      this.batched = true;
      this._resolution = null;
      this._autoResolution = true;
      this._didTextUpdate = true;
      this._styleClass = styleClass;
      this.text = text6 ?? "";
      this.style = style3;
      this.resolution = resolution ?? null;
      this.allowChildren = false;
      this._anchor = new ObservablePoint(
        {
          _onUpdate: () => {
            this.onViewUpdate();
          }
        }
      );
      if (anchor)
        this.anchor = anchor;
      this.roundPixels = roundPixels ?? false;
      if (width8 !== void 0)
        this.width = width8;
      if (height8 !== void 0)
        this.height = height8;
    }
    /**
     * The anchor sets the origin point of the text.
     * The default is `(0,0)`, this means the text's origin is the top left.
     *
     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.
     *
     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.
     *
     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
     * @example
     * import { Text } from 'pixi.js';
     *
     * const text = new Text('hello world');
     * text.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
     */
    get anchor() {
      return this._anchor;
    }
    set anchor(value12) {
      typeof value12 === "number" ? this._anchor.set(value12) : this._anchor.copyFrom(value12);
    }
    /** Set the copy for the text object. To split a line you can use '\n'. */
    set text(value12) {
      value12 = value12.toString();
      if (this._text === value12)
        return;
      this._text = value12;
      this.onViewUpdate();
    }
    get text() {
      return this._text;
    }
    /**
     * The resolution / device pixel ratio of the canvas.
     * @default 1
     */
    set resolution(value12) {
      this._autoResolution = value12 === null;
      this._resolution = value12;
      this.onViewUpdate();
    }
    get resolution() {
      return this._resolution;
    }
    get style() {
      return this._style;
    }
    /**
     * Set the style of the text.
     *
     * Set up an event listener to listen for changes on the style object and mark the text as dirty.
     *
     * If setting the `style` can also be partial {@link AnyTextStyleOptions}.
     * @type {
     * text.TextStyle |
     * Partial<text.TextStyle> |
     * text.TextStyleOptions |
     * text.HTMLTextStyle |
     * Partial<text.HTMLTextStyle> |
     * text.HTMLTextStyleOptions
     * }
     */
    set style(style3) {
      style3 = style3 || {};
      this._style?.off("update", this.onViewUpdate, this);
      if (style3 instanceof this._styleClass) {
        this._style = style3;
      } else {
        this._style = new this._styleClass(style3);
      }
      this._style.on("update", this.onViewUpdate, this);
      this.onViewUpdate();
    }
    /**
     * The local bounds of the Text.
     * @type {rendering.Bounds}
     */
    get bounds() {
      if (this._boundsDirty) {
        this._updateBounds();
        this._boundsDirty = false;
      }
      return this._bounds;
    }
    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
    get width() {
      return Math.abs(this.scale.x) * this.bounds.width;
    }
    set width(value12) {
      this._setWidth(value12, this.bounds.width);
    }
    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
    get height() {
      return Math.abs(this.scale.y) * this.bounds.height;
    }
    set height(value12) {
      this._setHeight(value12, this.bounds.height);
    }
    /**
     * Retrieves the size of the Text as a [Size]{@link Size} object.
     * This is faster than get the width and height separately.
     * @param out - Optional object to store the size in.
     * @returns - The size of the Text.
     */
    getSize(out2) {
      out2 || (out2 = {});
      out2.width = Math.abs(this.scale.x) * this.bounds.width;
      out2.height = Math.abs(this.scale.y) * this.bounds.height;
      return out2;
    }
    /**
     * Sets the size of the Text to the specified width and height.
     * This is faster than setting the width and height separately.
     * @param value - This can be either a number or a [Size]{@link Size} object.
     * @param height - The height to set. Defaults to the value of `width` if not provided.
     */
    setSize(value12, height8) {
      if (typeof value12 === "object") {
        height8 = value12.height ?? value12.width;
        value12 = value12.width;
      } else {
        height8 ?? (height8 = value12);
      }
      value12 !== void 0 && this._setWidth(value12, this.bounds.width);
      height8 !== void 0 && this._setHeight(height8, this.bounds.height);
    }
    /**
     * Adds the bounds of this text to the bounds object.
     * @param bounds - The output bounds object.
     */
    addBounds(bounds) {
      const _bounds = this.bounds;
      bounds.addFrame(
        _bounds.minX,
        _bounds.minY,
        _bounds.maxX,
        _bounds.maxY
      );
    }
    /**
     * Checks if the text contains the given point.
     * @param point - The point to check
     */
    containsPoint(point) {
      const width8 = this.bounds.width;
      const height8 = this.bounds.height;
      const x1 = -width8 * this.anchor.x;
      let y1 = 0;
      if (point.x >= x1 && point.x <= x1 + width8) {
        y1 = -height8 * this.anchor.y;
        if (point.y >= y1 && point.y <= y1 + height8)
          return true;
      }
      return false;
    }
    onViewUpdate() {
      this._boundsDirty = true;
      if (!this.didViewUpdate)
        this._didTextUpdate = true;
      super.onViewUpdate();
    }
    _getKey() {
      return `${this.text}:${this._style.styleKey}:${this._resolution}`;
    }
    /**
     * Destroys this text renderable and optionally its style texture.
     * @param options - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style
     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style
     * @param {boolean} [options.style=false] - Should it destroy the style of the text
     */
    destroy(options2 = false) {
      super.destroy(options2);
      this.owner = null;
      this._bounds = null;
      this._anchor = null;
      if (typeof options2 === "boolean" ? options2 : options2?.style) {
        this._style.destroy(options2);
      }
      this._style = null;
      this._text = null;
    }
  };
  function ensureOptions(args, name16) {
    let options2 = args[0] ?? {};
    if (typeof options2 === "string" || args[1]) {
      deprecation(v8_0_0, `use new ${name16}({ text: "hi!", style }) instead`);
      options2 = {
        text: options2,
        style: args[1]
      };
    }
    return options2;
  }

  // node_modules/pixi.js/lib/scene/text/Text.mjs
  init_CanvasTextMetrics();
  init_TextStyle();
  var Text = class extends AbstractText {
    constructor(...args) {
      const options2 = ensureOptions(args, "Text");
      super(options2, TextStyle);
      this.renderPipeId = "text";
    }
    _updateBounds() {
      const bounds = this._bounds;
      const anchor = this._anchor;
      const canvasMeasurement = CanvasTextMetrics.measureText(
        this._text,
        this._style
      );
      const { width: width8, height: height8 } = canvasMeasurement;
      bounds.minX = -anchor._x * width8;
      bounds.maxX = bounds.minX + width8;
      bounds.minY = -anchor._y * height8;
      bounds.maxY = bounds.minY + height8;
    }
  };

  // node_modules/pixi.js/lib/index.mjs
  init_textureFrom();
  init_Container();
  init_Graphics();
  init_Sprite();
  init_TextStyle();
  init_eventemitter3();
  var import_earcut2 = __toESM(require_earcut(), 1);
  extensions.add(browserExt, webworkerExt);

  // output/Scriptzzz.Canvas/foreign.js
  var minCellDimension = 3;
  var context2 = {
    application: null,
    entities: {},
    grid: {
      cellSize: {
        height: null,
        width: null
      },
      height: null,
      pixelHeight: null,
      pixelWidth: null,
      width: null
    },
    textures: {
      entity: null
    }
  };
  function gridToCellX(x2) {
    return x2 * context2.grid.cellSize.width;
  }
  function gridToCellY(y2) {
    return y2 * context2.grid.cellSize.height;
  }
  function checkApplicationInitialized() {
    if (!context2.application) {
      throw Error("Application uninitialized");
    }
    if (!context2.grid.width || !context2.grid.height) {
      throw Error("Grid uninitialized");
    }
    const cellWidth = context2.grid.cellSize.width;
    const cellHeight = context2.grid.cellSize.height;
    if (cellWidth < minCellDimension || cellHeight < minCellDimension) {
      throw Error(`Grid cell to small: (${cellWidth},${cellHeight})`);
    }
  }
  function createGrid() {
    checkApplicationInitialized();
    const graphics = new Graphics();
    for (let j2 = 0; j2 < context2.grid.height; j2++) {
      for (let i2 = 0; i2 < context2.grid.width; i2++) {
        const x2 = 1 + i2 * context2.grid.cellSize.width;
        const y2 = 1 + j2 * context2.grid.cellSize.height;
        graphics.rect(x2, y2, context2.grid.cellSize.width - 2, context2.grid.cellSize.height - 2);
        graphics.stroke({ alpha: 0.2, color: 16777215 });
        graphics.fill({ alpha: 0.1, color: 16777215 });
      }
    }
    return graphics;
  }
  async function initializeApplication({ gridHeight, gridWidth, pixelHeight, pixelWidth }) {
    context2.grid.width = gridWidth;
    context2.grid.height = gridHeight;
    context2.grid.pixelWidth = pixelWidth;
    context2.grid.pixelHeight = pixelHeight;
    context2.grid.cellSize.width = pixelWidth / gridWidth;
    context2.grid.cellSize.height = pixelHeight / gridHeight;
    const app = new Application();
    context2.application = app;
    await app.init({ width: pixelWidth, height: pixelHeight });
    const entityTexture = await Assets.load("entity.png");
    context2.textures.entity = entityTexture;
    app.stage.addChild(createGrid({ gridHeight, gridWidth, pixelHeight, pixelWidth }));
    return app;
  }
  function createCanvasImpl(gridWidth) {
    return (gridHeight) => {
      return (pixelWidth) => {
        return (pixelHeight) => {
          return (canvasInitializedCallback) => {
            return () => {
              const parent2 = document.createElement("div");
              parent2.id = "canvas";
              initializeApplication({ gridHeight, gridWidth, pixelHeight, pixelWidth }).then((app) => {
                parent2.appendChild(app.canvas);
                canvasInitializedCallback();
              });
              return parent2;
            };
          };
        };
      };
    };
  }
  function destroyEntityImpl(id5) {
    return () => {
      checkApplicationInitialized();
      const entity = context2.entities[id5];
      if (!entity) {
        throw Error(`Entity '${id5}' not found.`);
      }
      context2.application.stage.removeChild(entity);
    };
  }
  function createEntityImpl(id5) {
    return (entityType) => {
      return (position2) => {
        return () => {
          checkApplicationInitialized();
          if (context2.entities[id5]) {
            throw Error(`Entity '${id5}' already exists.`);
          }
          const sprite = new Sprite(context2.textures.entity);
          sprite.x = 0;
          sprite.y = 0;
          const label4 = new Text({ style: new TextStyle({ align: "center", fill: "white", fontSize: 10 }), text: id5 });
          label4.x = sprite.x;
          label4.y = sprite.y + 20;
          const entity = new Container();
          entity.addChild(sprite);
          entity.addChild(label4);
          entity.x = gridToCellX(position2.x);
          entity.y = gridToCellY(position2.y);
          context2.application.stage.addChild(entity);
          context2.entities[id5] = entity;
        };
      };
    };
  }
  function updateEntityPositionImpl(id5) {
    return (position2) => {
      return () => {
        checkApplicationInitialized();
        const entity = context2.entities[id5];
        if (!entity) {
          throw Error(`Entity '${id5}' not found.`);
        }
        entity.x = gridToCellX(position2.x);
        entity.y = gridToCellY(position2.y);
      };
    };
  }

  // output/Scriptzzz.Canvas/index.js
  var liftEffect4 = /* @__PURE__ */ liftEffect(monadEffectAff);
  var updateEntityPosition = function(id5) {
    return function(position2) {
      return liftEffect4(updateEntityPositionImpl(idToString(id5))(position2));
    };
  };
  var destroyEntity = function(id5) {
    return liftEffect4(destroyEntityImpl(idToString(id5)));
  };
  var createEntity = function(dictPos) {
    return function(dictPos1) {
      return function(id5) {
        return function(entityType) {
          return function(position2) {
            return liftEffect4(createEntityImpl(idToString(id5))(entityType)(position2));
          };
        };
      };
    };
  };
  var createCanvas = function(dictPos) {
    var toInt2 = toInt(dictPos.Nat0());
    return function(dictPos1) {
      var toInt1 = toInt(dictPos1.Nat0());
      return function(v2) {
        var gridWidth = toInt2($$undefined);
        var gridHeight = toInt1($$undefined);
        var pixelHeight = gridHeight * 32 | 0;
        var pixelWidth = gridWidth * 32 | 0;
        return createCanvasImpl(gridWidth)(gridHeight)(pixelWidth)(pixelHeight);
      };
    };
  };

  // node_modules/@codemirror/state/dist/index.js
  var Text2 = class _Text {
    /**
    Get the line description around the given position.
    */
    lineAt(pos) {
      if (pos < 0 || pos > this.length)
        throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
      return this.lineInner(pos, false, 1, 0);
    }
    /**
    Get the description for the given (1-based) line number.
    */
    line(n2) {
      if (n2 < 1 || n2 > this.lines)
        throw new RangeError(`Invalid line number ${n2} in ${this.lines}-line document`);
      return this.lineInner(n2, true, 1, 0);
    }
    /**
    Replace a range of the text with the given content.
    */
    replace(from3, to3, text6) {
      [from3, to3] = clip(this, from3, to3);
      let parts = [];
      this.decompose(
        0,
        from3,
        parts,
        2
        /* Open.To */
      );
      if (text6.length)
        text6.decompose(
          0,
          text6.length,
          parts,
          1 | 2
          /* Open.To */
        );
      this.decompose(
        to3,
        this.length,
        parts,
        1
        /* Open.From */
      );
      return TextNode.from(parts, this.length - (to3 - from3) + text6.length);
    }
    /**
    Append another document to this one.
    */
    append(other) {
      return this.replace(this.length, this.length, other);
    }
    /**
    Retrieve the text between the given points.
    */
    slice(from3, to3 = this.length) {
      [from3, to3] = clip(this, from3, to3);
      let parts = [];
      this.decompose(from3, to3, parts, 0);
      return TextNode.from(parts, to3 - from3);
    }
    /**
    Test whether this text is equal to another instance.
    */
    eq(other) {
      if (other == this)
        return true;
      if (other.length != this.length || other.lines != this.lines)
        return false;
      let start3 = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
      let a2 = new RawTextCursor(this), b2 = new RawTextCursor(other);
      for (let skip = start3, pos = start3; ; ) {
        a2.next(skip);
        b2.next(skip);
        skip = 0;
        if (a2.lineBreak != b2.lineBreak || a2.done != b2.done || a2.value != b2.value)
          return false;
        pos += a2.value.length;
        if (a2.done || pos >= end)
          return true;
      }
    }
    /**
    Iterate over the text. When `dir` is `-1`, iteration happens
    from end to start. This will return lines and the breaks between
    them as separate strings.
    */
    iter(dir2 = 1) {
      return new RawTextCursor(this, dir2);
    }
    /**
    Iterate over a range of the text. When `from` > `to`, the
    iterator will run in reverse.
    */
    iterRange(from3, to3 = this.length) {
      return new PartialTextCursor(this, from3, to3);
    }
    /**
    Return a cursor that iterates over the given range of lines,
    _without_ returning the line breaks between, and yielding empty
    strings for empty lines.
    
    When `from` and `to` are given, they should be 1-based line numbers.
    */
    iterLines(from3, to3) {
      let inner;
      if (from3 == null) {
        inner = this.iter();
      } else {
        if (to3 == null)
          to3 = this.lines + 1;
        let start3 = this.line(from3).from;
        inner = this.iterRange(start3, Math.max(start3, to3 == this.lines + 1 ? this.length : to3 <= 1 ? 0 : this.line(to3 - 1).to));
      }
      return new LineCursor(inner);
    }
    /**
    Return the document as a string, using newline characters to
    separate lines.
    */
    toString() {
      return this.sliceString(0);
    }
    /**
    Convert the document to an array of lines (which can be
    deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
    */
    toJSON() {
      let lines = [];
      this.flatten(lines);
      return lines;
    }
    /**
    @internal
    */
    constructor() {
    }
    /**
    Create a `Text` instance for the given array of lines.
    */
    static of(text6) {
      if (text6.length == 0)
        throw new RangeError("A document must have at least one line");
      if (text6.length == 1 && !text6[0])
        return _Text.empty;
      return text6.length <= 32 ? new TextLeaf(text6) : TextNode.from(TextLeaf.split(text6, []));
    }
  };
  var TextLeaf = class _TextLeaf extends Text2 {
    constructor(text6, length9 = textLength(text6)) {
      super();
      this.text = text6;
      this.length = length9;
    }
    get lines() {
      return this.text.length;
    }
    get children() {
      return null;
    }
    lineInner(target5, isLine, line, offset) {
      for (let i2 = 0; ; i2++) {
        let string2 = this.text[i2], end = offset + string2.length;
        if ((isLine ? line : end) >= target5)
          return new Line(offset, end, line, string2);
        offset = end + 1;
        line++;
      }
    }
    decompose(from3, to3, target5, open) {
      let text6 = from3 <= 0 && to3 >= this.length ? this : new _TextLeaf(sliceText(this.text, from3, to3), Math.min(to3, this.length) - Math.max(0, from3));
      if (open & 1) {
        let prev = target5.pop();
        let joined = appendText(text6.text, prev.text.slice(), 0, text6.length);
        if (joined.length <= 32) {
          target5.push(new _TextLeaf(joined, prev.length + text6.length));
        } else {
          let mid = joined.length >> 1;
          target5.push(new _TextLeaf(joined.slice(0, mid)), new _TextLeaf(joined.slice(mid)));
        }
      } else {
        target5.push(text6);
      }
    }
    replace(from3, to3, text6) {
      if (!(text6 instanceof _TextLeaf))
        return super.replace(from3, to3, text6);
      [from3, to3] = clip(this, from3, to3);
      let lines = appendText(this.text, appendText(text6.text, sliceText(this.text, 0, from3)), to3);
      let newLen = this.length + text6.length - (to3 - from3);
      if (lines.length <= 32)
        return new _TextLeaf(lines, newLen);
      return TextNode.from(_TextLeaf.split(lines, []), newLen);
    }
    sliceString(from3, to3 = this.length, lineSep = "\n") {
      [from3, to3] = clip(this, from3, to3);
      let result = "";
      for (let pos = 0, i2 = 0; pos <= to3 && i2 < this.text.length; i2++) {
        let line = this.text[i2], end = pos + line.length;
        if (pos > from3 && i2)
          result += lineSep;
        if (from3 < end && to3 > pos)
          result += line.slice(Math.max(0, from3 - pos), to3 - pos);
        pos = end + 1;
      }
      return result;
    }
    flatten(target5) {
      for (let line of this.text)
        target5.push(line);
    }
    scanIdentical() {
      return 0;
    }
    static split(text6, target5) {
      let part = [], len = -1;
      for (let line of text6) {
        part.push(line);
        len += line.length + 1;
        if (part.length == 32) {
          target5.push(new _TextLeaf(part, len));
          part = [];
          len = -1;
        }
      }
      if (len > -1)
        target5.push(new _TextLeaf(part, len));
      return target5;
    }
  };
  var TextNode = class _TextNode extends Text2 {
    constructor(children2, length9) {
      super();
      this.children = children2;
      this.length = length9;
      this.lines = 0;
      for (let child of children2)
        this.lines += child.lines;
    }
    lineInner(target5, isLine, line, offset) {
      for (let i2 = 0; ; i2++) {
        let child = this.children[i2], end = offset + child.length, endLine = line + child.lines - 1;
        if ((isLine ? endLine : end) >= target5)
          return child.lineInner(target5, isLine, line, offset);
        offset = end + 1;
        line = endLine + 1;
      }
    }
    decompose(from3, to3, target5, open) {
      for (let i2 = 0, pos = 0; pos <= to3 && i2 < this.children.length; i2++) {
        let child = this.children[i2], end = pos + child.length;
        if (from3 <= end && to3 >= pos) {
          let childOpen = open & ((pos <= from3 ? 1 : 0) | (end >= to3 ? 2 : 0));
          if (pos >= from3 && end <= to3 && !childOpen)
            target5.push(child);
          else
            child.decompose(from3 - pos, to3 - pos, target5, childOpen);
        }
        pos = end + 1;
      }
    }
    replace(from3, to3, text6) {
      [from3, to3] = clip(this, from3, to3);
      if (text6.lines < this.lines)
        for (let i2 = 0, pos = 0; i2 < this.children.length; i2++) {
          let child = this.children[i2], end = pos + child.length;
          if (from3 >= pos && to3 <= end) {
            let updated = child.replace(from3 - pos, to3 - pos, text6);
            let totalLines = this.lines - child.lines + updated.lines;
            if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
              let copy = this.children.slice();
              copy[i2] = updated;
              return new _TextNode(copy, this.length - (to3 - from3) + text6.length);
            }
            return super.replace(pos, end, updated);
          }
          pos = end + 1;
        }
      return super.replace(from3, to3, text6);
    }
    sliceString(from3, to3 = this.length, lineSep = "\n") {
      [from3, to3] = clip(this, from3, to3);
      let result = "";
      for (let i2 = 0, pos = 0; i2 < this.children.length && pos <= to3; i2++) {
        let child = this.children[i2], end = pos + child.length;
        if (pos > from3 && i2)
          result += lineSep;
        if (from3 < end && to3 > pos)
          result += child.sliceString(from3 - pos, to3 - pos, lineSep);
        pos = end + 1;
      }
      return result;
    }
    flatten(target5) {
      for (let child of this.children)
        child.flatten(target5);
    }
    scanIdentical(other, dir2) {
      if (!(other instanceof _TextNode))
        return 0;
      let length9 = 0;
      let [iA, iB, eA, eB] = dir2 > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
      for (; ; iA += dir2, iB += dir2) {
        if (iA == eA || iB == eB)
          return length9;
        let chA = this.children[iA], chB = other.children[iB];
        if (chA != chB)
          return length9 + chA.scanIdentical(chB, dir2);
        length9 += chA.length + 1;
      }
    }
    static from(children2, length9 = children2.reduce((l2, ch) => l2 + ch.length + 1, -1)) {
      let lines = 0;
      for (let ch of children2)
        lines += ch.lines;
      if (lines < 32) {
        let flat = [];
        for (let ch of children2)
          ch.flatten(flat);
        return new TextLeaf(flat, length9);
      }
      let chunk = Math.max(
        32,
        lines >> 5
        /* Tree.BranchShift */
      ), maxChunk = chunk << 1, minChunk = chunk >> 1;
      let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
      function add5(child) {
        let last4;
        if (child.lines > maxChunk && child instanceof _TextNode) {
          for (let node of child.children)
            add5(node);
        } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
          flush();
          chunked.push(child);
        } else if (child instanceof TextLeaf && currentLines && (last4 = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last4.lines <= 32) {
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk[currentChunk.length - 1] = new TextLeaf(last4.text.concat(child.text), last4.length + 1 + child.length);
        } else {
          if (currentLines + child.lines > chunk)
            flush();
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk.push(child);
        }
      }
      function flush() {
        if (currentLines == 0)
          return;
        chunked.push(currentChunk.length == 1 ? currentChunk[0] : _TextNode.from(currentChunk, currentLen));
        currentLen = -1;
        currentLines = currentChunk.length = 0;
      }
      for (let child of children2)
        add5(child);
      flush();
      return chunked.length == 1 ? chunked[0] : new _TextNode(chunked, length9);
    }
  };
  Text2.empty = /* @__PURE__ */ new TextLeaf([""], 0);
  function textLength(text6) {
    let length9 = -1;
    for (let line of text6)
      length9 += line.length + 1;
    return length9;
  }
  function appendText(text6, target5, from3 = 0, to3 = 1e9) {
    for (let pos = 0, i2 = 0, first = true; i2 < text6.length && pos <= to3; i2++) {
      let line = text6[i2], end = pos + line.length;
      if (end >= from3) {
        if (end > to3)
          line = line.slice(0, to3 - pos);
        if (pos < from3)
          line = line.slice(from3 - pos);
        if (first) {
          target5[target5.length - 1] += line;
          first = false;
        } else
          target5.push(line);
      }
      pos = end + 1;
    }
    return target5;
  }
  function sliceText(text6, from3, to3) {
    return appendText(text6, [""], from3, to3);
  }
  var RawTextCursor = class {
    constructor(text6, dir2 = 1) {
      this.dir = dir2;
      this.done = false;
      this.lineBreak = false;
      this.value = "";
      this.nodes = [text6];
      this.offsets = [dir2 > 0 ? 1 : (text6 instanceof TextLeaf ? text6.text.length : text6.children.length) << 1];
    }
    nextInner(skip, dir2) {
      this.done = this.lineBreak = false;
      for (; ; ) {
        let last4 = this.nodes.length - 1;
        let top4 = this.nodes[last4], offsetValue = this.offsets[last4], offset = offsetValue >> 1;
        let size5 = top4 instanceof TextLeaf ? top4.text.length : top4.children.length;
        if (offset == (dir2 > 0 ? size5 : 0)) {
          if (last4 == 0) {
            this.done = true;
            this.value = "";
            return this;
          }
          if (dir2 > 0)
            this.offsets[last4 - 1]++;
          this.nodes.pop();
          this.offsets.pop();
        } else if ((offsetValue & 1) == (dir2 > 0 ? 0 : 1)) {
          this.offsets[last4] += dir2;
          if (skip == 0) {
            this.lineBreak = true;
            this.value = "\n";
            return this;
          }
          skip--;
        } else if (top4 instanceof TextLeaf) {
          let next = top4.text[offset + (dir2 < 0 ? -1 : 0)];
          this.offsets[last4] += dir2;
          if (next.length > Math.max(0, skip)) {
            this.value = skip == 0 ? next : dir2 > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
            return this;
          }
          skip -= next.length;
        } else {
          let next = top4.children[offset + (dir2 < 0 ? -1 : 0)];
          if (skip > next.length) {
            skip -= next.length;
            this.offsets[last4] += dir2;
          } else {
            if (dir2 < 0)
              this.offsets[last4]--;
            this.nodes.push(next);
            this.offsets.push(dir2 > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
          }
        }
      }
    }
    next(skip = 0) {
      if (skip < 0) {
        this.nextInner(-skip, -this.dir);
        skip = this.value.length;
      }
      return this.nextInner(skip, this.dir);
    }
  };
  var PartialTextCursor = class {
    constructor(text6, start3, end) {
      this.value = "";
      this.done = false;
      this.cursor = new RawTextCursor(text6, start3 > end ? -1 : 1);
      this.pos = start3 > end ? text6.length : 0;
      this.from = Math.min(start3, end);
      this.to = Math.max(start3, end);
    }
    nextInner(skip, dir2) {
      if (dir2 < 0 ? this.pos <= this.from : this.pos >= this.to) {
        this.value = "";
        this.done = true;
        return this;
      }
      skip += Math.max(0, dir2 < 0 ? this.pos - this.to : this.from - this.pos);
      let limit = dir2 < 0 ? this.pos - this.from : this.to - this.pos;
      if (skip > limit)
        skip = limit;
      limit -= skip;
      let { value: value12 } = this.cursor.next(skip);
      this.pos += (value12.length + skip) * dir2;
      this.value = value12.length <= limit ? value12 : dir2 < 0 ? value12.slice(value12.length - limit) : value12.slice(0, limit);
      this.done = !this.value;
      return this;
    }
    next(skip = 0) {
      if (skip < 0)
        skip = Math.max(skip, this.from - this.pos);
      else if (skip > 0)
        skip = Math.min(skip, this.to - this.pos);
      return this.nextInner(skip, this.cursor.dir);
    }
    get lineBreak() {
      return this.cursor.lineBreak && this.value != "";
    }
  };
  var LineCursor = class {
    constructor(inner) {
      this.inner = inner;
      this.afterBreak = true;
      this.value = "";
      this.done = false;
    }
    next(skip = 0) {
      let { done, lineBreak, value: value12 } = this.inner.next(skip);
      if (done && this.afterBreak) {
        this.value = "";
        this.afterBreak = false;
      } else if (done) {
        this.done = true;
        this.value = "";
      } else if (lineBreak) {
        if (this.afterBreak) {
          this.value = "";
        } else {
          this.afterBreak = true;
          this.next();
        }
      } else {
        this.value = value12;
        this.afterBreak = false;
      }
      return this;
    }
    get lineBreak() {
      return false;
    }
  };
  if (typeof Symbol != "undefined") {
    Text2.prototype[Symbol.iterator] = function() {
      return this.iter();
    };
    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  }
  var Line = class {
    /**
    @internal
    */
    constructor(from3, to3, number2, text6) {
      this.from = from3;
      this.to = to3;
      this.number = number2;
      this.text = text6;
    }
    /**
    The length of the line (not including any line break after it).
    */
    get length() {
      return this.to - this.from;
    }
  };
  function clip(text6, from3, to3) {
    from3 = Math.max(0, Math.min(text6.length, from3));
    return [from3, Math.max(from3, Math.min(text6.length, to3))];
  }
  var extend2 = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s2) => s2 ? parseInt(s2, 36) : 1);
  for (let i2 = 1; i2 < extend2.length; i2++)
    extend2[i2] += extend2[i2 - 1];
  function isExtendingChar(code) {
    for (let i2 = 1; i2 < extend2.length; i2 += 2)
      if (extend2[i2] > code)
        return extend2[i2 - 1] <= code;
    return false;
  }
  function isRegionalIndicator(code) {
    return code >= 127462 && code <= 127487;
  }
  var ZWJ = 8205;
  function findClusterBreak(str, pos, forward2 = true, includeExtending = true) {
    return (forward2 ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
  }
  function nextClusterBreak(str, pos, includeExtending) {
    if (pos == str.length)
      return pos;
    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
      pos--;
    let prev = codePointAt2(str, pos);
    pos += codePointSize(prev);
    while (pos < str.length) {
      let next = codePointAt2(str, pos);
      if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
        pos += codePointSize(next);
        prev = next;
      } else if (isRegionalIndicator(next)) {
        let countBefore = 0, i2 = pos - 2;
        while (i2 >= 0 && isRegionalIndicator(codePointAt2(str, i2))) {
          countBefore++;
          i2 -= 2;
        }
        if (countBefore % 2 == 0)
          break;
        else
          pos += 2;
      } else {
        break;
      }
    }
    return pos;
  }
  function prevClusterBreak(str, pos, includeExtending) {
    while (pos > 0) {
      let found = nextClusterBreak(str, pos - 2, includeExtending);
      if (found < pos)
        return found;
      pos--;
    }
    return 0;
  }
  function surrogateLow(ch) {
    return ch >= 56320 && ch < 57344;
  }
  function surrogateHigh(ch) {
    return ch >= 55296 && ch < 56320;
  }
  function codePointAt2(str, pos) {
    let code0 = str.charCodeAt(pos);
    if (!surrogateHigh(code0) || pos + 1 == str.length)
      return code0;
    let code1 = str.charCodeAt(pos + 1);
    if (!surrogateLow(code1))
      return code0;
    return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
  }
  function fromCodePoint(code) {
    if (code <= 65535)
      return String.fromCharCode(code);
    code -= 65536;
    return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
  }
  function codePointSize(code) {
    return code < 65536 ? 1 : 2;
  }
  var DefaultSplit = /\r\n?|\n/;
  var MapMode = /* @__PURE__ */ function(MapMode2) {
    MapMode2[MapMode2["Simple"] = 0] = "Simple";
    MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
    MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
    MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
    return MapMode2;
  }(MapMode || (MapMode = {}));
  var ChangeDesc = class _ChangeDesc {
    // Sections are encoded as pairs of integers. The first is the
    // length in the current document, and the second is -1 for
    // unaffected sections, and the length of the replacement content
    // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
    // 0), and a replacement two positive numbers.
    /**
    @internal
    */
    constructor(sections) {
      this.sections = sections;
    }
    /**
    The length of the document before the change.
    */
    get length() {
      let result = 0;
      for (let i2 = 0; i2 < this.sections.length; i2 += 2)
        result += this.sections[i2];
      return result;
    }
    /**
    The length of the document after the change.
    */
    get newLength() {
      let result = 0;
      for (let i2 = 0; i2 < this.sections.length; i2 += 2) {
        let ins = this.sections[i2 + 1];
        result += ins < 0 ? this.sections[i2] : ins;
      }
      return result;
    }
    /**
    False when there are actual changes in this set.
    */
    get empty() {
      return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
    }
    /**
    Iterate over the unchanged parts left by these changes. `posA`
    provides the position of the range in the old document, `posB`
    the new position in the changed document.
    */
    iterGaps(f2) {
      for (let i2 = 0, posA = 0, posB = 0; i2 < this.sections.length; ) {
        let len = this.sections[i2++], ins = this.sections[i2++];
        if (ins < 0) {
          f2(posA, posB, len);
          posB += len;
        } else {
          posB += ins;
        }
        posA += len;
      }
    }
    /**
    Iterate over the ranges changed by these changes. (See
    [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
    variant that also provides you with the inserted text.)
    `fromA`/`toA` provides the extent of the change in the starting
    document, `fromB`/`toB` the extent of the replacement in the
    changed document.
    
    When `individual` is true, adjacent changes (which are kept
    separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
    reported separately.
    */
    iterChangedRanges(f2, individual = false) {
      iterChanges(this, f2, individual);
    }
    /**
    Get a description of the inverted form of these changes.
    */
    get invertedDesc() {
      let sections = [];
      for (let i2 = 0; i2 < this.sections.length; ) {
        let len = this.sections[i2++], ins = this.sections[i2++];
        if (ins < 0)
          sections.push(len, ins);
        else
          sections.push(ins, len);
      }
      return new _ChangeDesc(sections);
    }
    /**
    Compute the combined effect of applying another set of changes
    after this one. The length of the document after this set should
    match the length before `other`.
    */
    composeDesc(other) {
      return this.empty ? other : other.empty ? this : composeSets(this, other);
    }
    /**
    Map this description, which should start with the same document
    as `other`, over another set of changes, so that it can be
    applied after it. When `before` is true, map as if the changes
    in `other` happened before the ones in `this`.
    */
    mapDesc(other, before = false) {
      return other.empty ? this : mapSet(this, other, before);
    }
    mapPos(pos, assoc = -1, mode = MapMode.Simple) {
      let posA = 0, posB = 0;
      for (let i2 = 0; i2 < this.sections.length; ) {
        let len = this.sections[i2++], ins = this.sections[i2++], endA = posA + len;
        if (ins < 0) {
          if (endA > pos)
            return posB + (pos - posA);
          posB += len;
        } else {
          if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
            return null;
          if (endA > pos || endA == pos && assoc < 0 && !len)
            return pos == posA || assoc < 0 ? posB : posB + ins;
          posB += ins;
        }
        posA = endA;
      }
      if (pos > posA)
        throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
      return posB;
    }
    /**
    Check whether these changes touch a given range. When one of the
    changes entirely covers the range, the string `"cover"` is
    returned.
    */
    touchesRange(from3, to3 = from3) {
      for (let i2 = 0, pos = 0; i2 < this.sections.length && pos <= to3; ) {
        let len = this.sections[i2++], ins = this.sections[i2++], end = pos + len;
        if (ins >= 0 && pos <= to3 && end >= from3)
          return pos < from3 && end > to3 ? "cover" : true;
        pos = end;
      }
      return false;
    }
    /**
    @internal
    */
    toString() {
      let result = "";
      for (let i2 = 0; i2 < this.sections.length; ) {
        let len = this.sections[i2++], ins = this.sections[i2++];
        result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
      }
      return result;
    }
    /**
    Serialize this change desc to a JSON-representable value.
    */
    toJSON() {
      return this.sections;
    }
    /**
    Create a change desc from its JSON representation (as produced
    by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
    */
    static fromJSON(json) {
      if (!Array.isArray(json) || json.length % 2 || json.some((a2) => typeof a2 != "number"))
        throw new RangeError("Invalid JSON representation of ChangeDesc");
      return new _ChangeDesc(json);
    }
    /**
    @internal
    */
    static create(sections) {
      return new _ChangeDesc(sections);
    }
  };
  var ChangeSet = class _ChangeSet extends ChangeDesc {
    constructor(sections, inserted) {
      super(sections);
      this.inserted = inserted;
    }
    /**
    Apply the changes to a document, returning the modified
    document.
    */
    apply(doc2) {
      if (this.length != doc2.length)
        throw new RangeError("Applying change set to a document with the wrong length");
      iterChanges(this, (fromA, toA, fromB, _toB, text6) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text6), false);
      return doc2;
    }
    mapDesc(other, before = false) {
      return mapSet(this, other, before, true);
    }
    /**
    Given the document as it existed _before_ the changes, return a
    change set that represents the inverse of this set, which could
    be used to go from the document created by the changes back to
    the document as it existed before the changes.
    */
    invert(doc2) {
      let sections = this.sections.slice(), inserted = [];
      for (let i2 = 0, pos = 0; i2 < sections.length; i2 += 2) {
        let len = sections[i2], ins = sections[i2 + 1];
        if (ins >= 0) {
          sections[i2] = ins;
          sections[i2 + 1] = len;
          let index6 = i2 >> 1;
          while (inserted.length < index6)
            inserted.push(Text2.empty);
          inserted.push(len ? doc2.slice(pos, pos + len) : Text2.empty);
        }
        pos += len;
      }
      return new _ChangeSet(sections, inserted);
    }
    /**
    Combine two subsequent change sets into a single set. `other`
    must start in the document produced by `this`. If `this` goes
    `docA` → `docB` and `other` represents `docB` → `docC`, the
    returned value will represent the change `docA` → `docC`.
    */
    compose(other) {
      return this.empty ? other : other.empty ? this : composeSets(this, other, true);
    }
    /**
    Given another change set starting in the same document, maps this
    change set over the other, producing a new change set that can be
    applied to the document produced by applying `other`. When
    `before` is `true`, order changes as if `this` comes before
    `other`, otherwise (the default) treat `other` as coming first.
    
    Given two changes `A` and `B`, `A.compose(B.map(A))` and
    `B.compose(A.map(B, true))` will produce the same document. This
    provides a basic form of [operational
    transformation](https://en.wikipedia.org/wiki/Operational_transformation),
    and can be used for collaborative editing.
    */
    map(other, before = false) {
      return other.empty ? this : mapSet(this, other, before, true);
    }
    /**
    Iterate over the changed ranges in the document, calling `f` for
    each, with the range in the original document (`fromA`-`toA`)
    and the range that replaces it in the new document
    (`fromB`-`toB`).
    
    When `individual` is true, adjacent changes are reported
    separately.
    */
    iterChanges(f2, individual = false) {
      iterChanges(this, f2, individual);
    }
    /**
    Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
    set.
    */
    get desc() {
      return ChangeDesc.create(this.sections);
    }
    /**
    @internal
    */
    filter(ranges) {
      let resultSections = [], resultInserted = [], filteredSections = [];
      let iter = new SectionIter(this);
      done: for (let i2 = 0, pos = 0; ; ) {
        let next = i2 == ranges.length ? 1e9 : ranges[i2++];
        while (pos < next || pos == next && iter.len == 0) {
          if (iter.done)
            break done;
          let len = Math.min(iter.len, next - pos);
          addSection(filteredSections, len, -1);
          let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
          addSection(resultSections, len, ins);
          if (ins > 0)
            addInsert(resultInserted, resultSections, iter.text);
          iter.forward(len);
          pos += len;
        }
        let end = ranges[i2++];
        while (pos < end) {
          if (iter.done)
            break done;
          let len = Math.min(iter.len, end - pos);
          addSection(resultSections, len, -1);
          addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
          iter.forward(len);
          pos += len;
        }
      }
      return {
        changes: new _ChangeSet(resultSections, resultInserted),
        filtered: ChangeDesc.create(filteredSections)
      };
    }
    /**
    Serialize this change set to a JSON-representable value.
    */
    toJSON() {
      let parts = [];
      for (let i2 = 0; i2 < this.sections.length; i2 += 2) {
        let len = this.sections[i2], ins = this.sections[i2 + 1];
        if (ins < 0)
          parts.push(len);
        else if (ins == 0)
          parts.push([len]);
        else
          parts.push([len].concat(this.inserted[i2 >> 1].toJSON()));
      }
      return parts;
    }
    /**
    Create a change set for the given changes, for a document of the
    given length, using `lineSep` as line separator.
    */
    static of(changes, length9, lineSep) {
      let sections = [], inserted = [], pos = 0;
      let total = null;
      function flush(force2 = false) {
        if (!force2 && !sections.length)
          return;
        if (pos < length9)
          addSection(sections, length9 - pos, -1);
        let set = new _ChangeSet(sections, inserted);
        total = total ? total.compose(set.map(total)) : set;
        sections = [];
        inserted = [];
        pos = 0;
      }
      function process2(spec) {
        if (Array.isArray(spec)) {
          for (let sub2 of spec)
            process2(sub2);
        } else if (spec instanceof _ChangeSet) {
          if (spec.length != length9)
            throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length9})`);
          flush();
          total = total ? total.compose(spec.map(total)) : spec;
        } else {
          let { from: from3, to: to3 = from3, insert: insert10 } = spec;
          if (from3 > to3 || from3 < 0 || to3 > length9)
            throw new RangeError(`Invalid change range ${from3} to ${to3} (in doc of length ${length9})`);
          let insText = !insert10 ? Text2.empty : typeof insert10 == "string" ? Text2.of(insert10.split(lineSep || DefaultSplit)) : insert10;
          let insLen = insText.length;
          if (from3 == to3 && insLen == 0)
            return;
          if (from3 < pos)
            flush();
          if (from3 > pos)
            addSection(sections, from3 - pos, -1);
          addSection(sections, to3 - from3, insLen);
          addInsert(inserted, sections, insText);
          pos = to3;
        }
      }
      process2(changes);
      flush(!total);
      return total;
    }
    /**
    Create an empty changeset of the given length.
    */
    static empty(length9) {
      return new _ChangeSet(length9 ? [length9, -1] : [], []);
    }
    /**
    Create a changeset from its JSON representation (as produced by
    [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
    */
    static fromJSON(json) {
      if (!Array.isArray(json))
        throw new RangeError("Invalid JSON representation of ChangeSet");
      let sections = [], inserted = [];
      for (let i2 = 0; i2 < json.length; i2++) {
        let part = json[i2];
        if (typeof part == "number") {
          sections.push(part, -1);
        } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e2, i3) => i3 && typeof e2 != "string")) {
          throw new RangeError("Invalid JSON representation of ChangeSet");
        } else if (part.length == 1) {
          sections.push(part[0], 0);
        } else {
          while (inserted.length < i2)
            inserted.push(Text2.empty);
          inserted[i2] = Text2.of(part.slice(1));
          sections.push(part[0], inserted[i2].length);
        }
      }
      return new _ChangeSet(sections, inserted);
    }
    /**
    @internal
    */
    static createSet(sections, inserted) {
      return new _ChangeSet(sections, inserted);
    }
  };
  function addSection(sections, len, ins, forceJoin = false) {
    if (len == 0 && ins <= 0)
      return;
    let last4 = sections.length - 2;
    if (last4 >= 0 && ins <= 0 && ins == sections[last4 + 1])
      sections[last4] += len;
    else if (len == 0 && sections[last4] == 0)
      sections[last4 + 1] += ins;
    else if (forceJoin) {
      sections[last4] += len;
      sections[last4 + 1] += ins;
    } else
      sections.push(len, ins);
  }
  function addInsert(values, sections, value12) {
    if (value12.length == 0)
      return;
    let index6 = sections.length - 2 >> 1;
    if (index6 < values.length) {
      values[values.length - 1] = values[values.length - 1].append(value12);
    } else {
      while (values.length < index6)
        values.push(Text2.empty);
      values.push(value12);
    }
  }
  function iterChanges(desc, f2, individual) {
    let inserted = desc.inserted;
    for (let posA = 0, posB = 0, i2 = 0; i2 < desc.sections.length; ) {
      let len = desc.sections[i2++], ins = desc.sections[i2++];
      if (ins < 0) {
        posA += len;
        posB += len;
      } else {
        let endA = posA, endB = posB, text6 = Text2.empty;
        for (; ; ) {
          endA += len;
          endB += ins;
          if (ins && inserted)
            text6 = text6.append(inserted[i2 - 2 >> 1]);
          if (individual || i2 == desc.sections.length || desc.sections[i2 + 1] < 0)
            break;
          len = desc.sections[i2++];
          ins = desc.sections[i2++];
        }
        f2(posA, endA, posB, endB, text6);
        posA = endA;
        posB = endB;
      }
    }
  }
  function mapSet(setA, setB, before, mkSet = false) {
    let sections = [], insert10 = mkSet ? [] : null;
    let a2 = new SectionIter(setA), b2 = new SectionIter(setB);
    for (let inserted = -1; ; ) {
      if (a2.ins == -1 && b2.ins == -1) {
        let len = Math.min(a2.len, b2.len);
        addSection(sections, len, -1);
        a2.forward(len);
        b2.forward(len);
      } else if (b2.ins >= 0 && (a2.ins < 0 || inserted == a2.i || a2.off == 0 && (b2.len < a2.len || b2.len == a2.len && !before))) {
        let len = b2.len;
        addSection(sections, b2.ins, -1);
        while (len) {
          let piece = Math.min(a2.len, len);
          if (a2.ins >= 0 && inserted < a2.i && a2.len <= piece) {
            addSection(sections, 0, a2.ins);
            if (insert10)
              addInsert(insert10, sections, a2.text);
            inserted = a2.i;
          }
          a2.forward(piece);
          len -= piece;
        }
        b2.next();
      } else if (a2.ins >= 0) {
        let len = 0, left = a2.len;
        while (left) {
          if (b2.ins == -1) {
            let piece = Math.min(left, b2.len);
            len += piece;
            left -= piece;
            b2.forward(piece);
          } else if (b2.ins == 0 && b2.len < left) {
            left -= b2.len;
            b2.next();
          } else {
            break;
          }
        }
        addSection(sections, len, inserted < a2.i ? a2.ins : 0);
        if (insert10 && inserted < a2.i)
          addInsert(insert10, sections, a2.text);
        inserted = a2.i;
        a2.forward(a2.len - left);
      } else if (a2.done && b2.done) {
        return insert10 ? ChangeSet.createSet(sections, insert10) : ChangeDesc.create(sections);
      } else {
        throw new Error("Mismatched change set lengths");
      }
    }
  }
  function composeSets(setA, setB, mkSet = false) {
    let sections = [];
    let insert10 = mkSet ? [] : null;
    let a2 = new SectionIter(setA), b2 = new SectionIter(setB);
    for (let open = false; ; ) {
      if (a2.done && b2.done) {
        return insert10 ? ChangeSet.createSet(sections, insert10) : ChangeDesc.create(sections);
      } else if (a2.ins == 0) {
        addSection(sections, a2.len, 0, open);
        a2.next();
      } else if (b2.len == 0 && !b2.done) {
        addSection(sections, 0, b2.ins, open);
        if (insert10)
          addInsert(insert10, sections, b2.text);
        b2.next();
      } else if (a2.done || b2.done) {
        throw new Error("Mismatched change set lengths");
      } else {
        let len = Math.min(a2.len2, b2.len), sectionLen = sections.length;
        if (a2.ins == -1) {
          let insB = b2.ins == -1 ? -1 : b2.off ? 0 : b2.ins;
          addSection(sections, len, insB, open);
          if (insert10 && insB)
            addInsert(insert10, sections, b2.text);
        } else if (b2.ins == -1) {
          addSection(sections, a2.off ? 0 : a2.len, len, open);
          if (insert10)
            addInsert(insert10, sections, a2.textBit(len));
        } else {
          addSection(sections, a2.off ? 0 : a2.len, b2.off ? 0 : b2.ins, open);
          if (insert10 && !b2.off)
            addInsert(insert10, sections, b2.text);
        }
        open = (a2.ins > len || b2.ins >= 0 && b2.len > len) && (open || sections.length > sectionLen);
        a2.forward2(len);
        b2.forward(len);
      }
    }
  }
  var SectionIter = class {
    constructor(set) {
      this.set = set;
      this.i = 0;
      this.next();
    }
    next() {
      let { sections } = this.set;
      if (this.i < sections.length) {
        this.len = sections[this.i++];
        this.ins = sections[this.i++];
      } else {
        this.len = 0;
        this.ins = -2;
      }
      this.off = 0;
    }
    get done() {
      return this.ins == -2;
    }
    get len2() {
      return this.ins < 0 ? this.len : this.ins;
    }
    get text() {
      let { inserted } = this.set, index6 = this.i - 2 >> 1;
      return index6 >= inserted.length ? Text2.empty : inserted[index6];
    }
    textBit(len) {
      let { inserted } = this.set, index6 = this.i - 2 >> 1;
      return index6 >= inserted.length && !len ? Text2.empty : inserted[index6].slice(this.off, len == null ? void 0 : this.off + len);
    }
    forward(len) {
      if (len == this.len)
        this.next();
      else {
        this.len -= len;
        this.off += len;
      }
    }
    forward2(len) {
      if (this.ins == -1)
        this.forward(len);
      else if (len == this.ins)
        this.next();
      else {
        this.ins -= len;
        this.off += len;
      }
    }
  };
  var SelectionRange = class _SelectionRange {
    constructor(from3, to3, flags) {
      this.from = from3;
      this.to = to3;
      this.flags = flags;
    }
    /**
    The anchor of the range—the side that doesn't move when you
    extend it.
    */
    get anchor() {
      return this.flags & 32 ? this.to : this.from;
    }
    /**
    The head of the range, which is moved when the range is
    [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
    */
    get head() {
      return this.flags & 32 ? this.from : this.to;
    }
    /**
    True when `anchor` and `head` are at the same position.
    */
    get empty() {
      return this.from == this.to;
    }
    /**
    If this is a cursor that is explicitly associated with the
    character on one of its sides, this returns the side. -1 means
    the character before its position, 1 the character after, and 0
    means no association.
    */
    get assoc() {
      return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
    }
    /**
    The bidirectional text level associated with this cursor, if
    any.
    */
    get bidiLevel() {
      let level = this.flags & 7;
      return level == 7 ? null : level;
    }
    /**
    The goal column (stored vertical offset) associated with a
    cursor. This is used to preserve the vertical position when
    [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
    lines of different length.
    */
    get goalColumn() {
      let value12 = this.flags >> 6;
      return value12 == 16777215 ? void 0 : value12;
    }
    /**
    Map this range through a change, producing a valid range in the
    updated document.
    */
    map(change, assoc = -1) {
      let from3, to3;
      if (this.empty) {
        from3 = to3 = change.mapPos(this.from, assoc);
      } else {
        from3 = change.mapPos(this.from, 1);
        to3 = change.mapPos(this.to, -1);
      }
      return from3 == this.from && to3 == this.to ? this : new _SelectionRange(from3, to3, this.flags);
    }
    /**
    Extend this range to cover at least `from` to `to`.
    */
    extend(from3, to3 = from3) {
      if (from3 <= this.anchor && to3 >= this.anchor)
        return EditorSelection.range(from3, to3);
      let head5 = Math.abs(from3 - this.anchor) > Math.abs(to3 - this.anchor) ? from3 : to3;
      return EditorSelection.range(this.anchor, head5);
    }
    /**
    Compare this range to another range.
    */
    eq(other, includeAssoc = false) {
      return this.anchor == other.anchor && this.head == other.head && (!includeAssoc || !this.empty || this.assoc == other.assoc);
    }
    /**
    Return a JSON-serializable object representing the range.
    */
    toJSON() {
      return { anchor: this.anchor, head: this.head };
    }
    /**
    Convert a JSON representation of a range to a `SelectionRange`
    instance.
    */
    static fromJSON(json) {
      if (!json || typeof json.anchor != "number" || typeof json.head != "number")
        throw new RangeError("Invalid JSON representation for SelectionRange");
      return EditorSelection.range(json.anchor, json.head);
    }
    /**
    @internal
    */
    static create(from3, to3, flags) {
      return new _SelectionRange(from3, to3, flags);
    }
  };
  var EditorSelection = class _EditorSelection {
    constructor(ranges, mainIndex) {
      this.ranges = ranges;
      this.mainIndex = mainIndex;
    }
    /**
    Map a selection through a change. Used to adjust the selection
    position for changes.
    */
    map(change, assoc = -1) {
      if (change.empty)
        return this;
      return _EditorSelection.create(this.ranges.map((r2) => r2.map(change, assoc)), this.mainIndex);
    }
    /**
    Compare this selection to another selection. By default, ranges
    are compared only by position. When `includeAssoc` is true,
    cursor ranges must also have the same
    [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
    */
    eq(other, includeAssoc = false) {
      if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
        return false;
      for (let i2 = 0; i2 < this.ranges.length; i2++)
        if (!this.ranges[i2].eq(other.ranges[i2], includeAssoc))
          return false;
      return true;
    }
    /**
    Get the primary selection range. Usually, you should make sure
    your code applies to _all_ ranges, by using methods like
    [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
    */
    get main() {
      return this.ranges[this.mainIndex];
    }
    /**
    Make sure the selection only has one range. Returns a selection
    holding only the main range from this selection.
    */
    asSingle() {
      return this.ranges.length == 1 ? this : new _EditorSelection([this.main], 0);
    }
    /**
    Extend this selection with an extra range.
    */
    addRange(range3, main4 = true) {
      return _EditorSelection.create([range3].concat(this.ranges), main4 ? 0 : this.mainIndex + 1);
    }
    /**
    Replace a given range with another range, and then normalize the
    selection to merge and sort ranges if necessary.
    */
    replaceRange(range3, which = this.mainIndex) {
      let ranges = this.ranges.slice();
      ranges[which] = range3;
      return _EditorSelection.create(ranges, this.mainIndex);
    }
    /**
    Convert this selection to an object that can be serialized to
    JSON.
    */
    toJSON() {
      return { ranges: this.ranges.map((r2) => r2.toJSON()), main: this.mainIndex };
    }
    /**
    Create a selection from a JSON representation.
    */
    static fromJSON(json) {
      if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
        throw new RangeError("Invalid JSON representation for EditorSelection");
      return new _EditorSelection(json.ranges.map((r2) => SelectionRange.fromJSON(r2)), json.main);
    }
    /**
    Create a selection holding a single range.
    */
    static single(anchor, head5 = anchor) {
      return new _EditorSelection([_EditorSelection.range(anchor, head5)], 0);
    }
    /**
    Sort and merge the given set of ranges, creating a valid
    selection.
    */
    static create(ranges, mainIndex = 0) {
      if (ranges.length == 0)
        throw new RangeError("A selection needs at least one range");
      for (let pos = 0, i2 = 0; i2 < ranges.length; i2++) {
        let range3 = ranges[i2];
        if (range3.empty ? range3.from <= pos : range3.from < pos)
          return _EditorSelection.normalized(ranges.slice(), mainIndex);
        pos = range3.to;
      }
      return new _EditorSelection(ranges, mainIndex);
    }
    /**
    Create a cursor selection range at the given position. You can
    safely ignore the optional arguments in most situations.
    */
    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
      return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 : 16) | (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6);
    }
    /**
    Create a selection range.
    */
    static range(anchor, head5, goalColumn, bidiLevel) {
      let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6 | (bidiLevel == null ? 7 : Math.min(6, bidiLevel));
      return head5 < anchor ? SelectionRange.create(head5, anchor, 32 | 16 | flags) : SelectionRange.create(anchor, head5, (head5 > anchor ? 8 : 0) | flags);
    }
    /**
    @internal
    */
    static normalized(ranges, mainIndex = 0) {
      let main4 = ranges[mainIndex];
      ranges.sort((a2, b2) => a2.from - b2.from);
      mainIndex = ranges.indexOf(main4);
      for (let i2 = 1; i2 < ranges.length; i2++) {
        let range3 = ranges[i2], prev = ranges[i2 - 1];
        if (range3.empty ? range3.from <= prev.to : range3.from < prev.to) {
          let from3 = prev.from, to3 = Math.max(range3.to, prev.to);
          if (i2 <= mainIndex)
            mainIndex--;
          ranges.splice(--i2, 2, range3.anchor > range3.head ? _EditorSelection.range(to3, from3) : _EditorSelection.range(from3, to3));
        }
      }
      return new _EditorSelection(ranges, mainIndex);
    }
  };
  function checkSelection(selection, docLength) {
    for (let range3 of selection.ranges)
      if (range3.to > docLength)
        throw new RangeError("Selection points outside of document");
  }
  var nextID = 0;
  var Facet = class _Facet {
    constructor(combine, compareInput, compare4, isStatic, enables) {
      this.combine = combine;
      this.compareInput = compareInput;
      this.compare = compare4;
      this.isStatic = isStatic;
      this.id = nextID++;
      this.default = combine([]);
      this.extensions = typeof enables == "function" ? enables(this) : enables;
    }
    /**
    Returns a facet reader for this facet, which can be used to
    [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
    */
    get reader() {
      return this;
    }
    /**
    Define a new facet.
    */
    static define(config2 = {}) {
      return new _Facet(config2.combine || ((a2) => a2), config2.compareInput || ((a2, b2) => a2 === b2), config2.compare || (!config2.combine ? sameArray : (a2, b2) => a2 === b2), !!config2.static, config2.enables);
    }
    /**
    Returns an extension that adds the given value to this facet.
    */
    of(value12) {
      return new FacetProvider([], this, 0, value12);
    }
    /**
    Create an extension that computes a value for the facet from a
    state. You must take care to declare the parts of the state that
    this value depends on, since your function is only called again
    for a new state when one of those parts changed.
    
    In cases where your value depends only on a single field, you'll
    want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
    */
    compute(deps, get4) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new FacetProvider(deps, this, 1, get4);
    }
    /**
    Create an extension that computes zero or more values for this
    facet from a state.
    */
    computeN(deps, get4) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new FacetProvider(deps, this, 2, get4);
    }
    from(field, get4) {
      if (!get4)
        get4 = (x2) => x2;
      return this.compute([field], (state4) => get4(state4.field(field)));
    }
  };
  function sameArray(a2, b2) {
    return a2 == b2 || a2.length == b2.length && a2.every((e2, i2) => e2 === b2[i2]);
  }
  var FacetProvider = class {
    constructor(dependencies, facet, type, value12) {
      this.dependencies = dependencies;
      this.facet = facet;
      this.type = type;
      this.value = value12;
      this.id = nextID++;
    }
    dynamicSlot(addresses) {
      var _a2;
      let getter = this.value;
      let compare4 = this.facet.compareInput;
      let id5 = this.id, idx = addresses[id5] >> 1, multi = this.type == 2;
      let depDoc = false, depSel = false, depAddrs = [];
      for (let dep of this.dependencies) {
        if (dep == "doc")
          depDoc = true;
        else if (dep == "selection")
          depSel = true;
        else if ((((_a2 = addresses[dep.id]) !== null && _a2 !== void 0 ? _a2 : 1) & 1) == 0)
          depAddrs.push(addresses[dep.id]);
      }
      return {
        create(state4) {
          state4.values[idx] = getter(state4);
          return 1;
        },
        update(state4, tr) {
          if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state4, depAddrs)) {
            let newVal = getter(state4);
            if (multi ? !compareArray(newVal, state4.values[idx], compare4) : !compare4(newVal, state4.values[idx])) {
              state4.values[idx] = newVal;
              return 1;
            }
          }
          return 0;
        },
        reconfigure: (state4, oldState) => {
          let newVal, oldAddr = oldState.config.address[id5];
          if (oldAddr != null) {
            let oldVal = getAddr(oldState, oldAddr);
            if (this.dependencies.every((dep) => {
              return dep instanceof Facet ? oldState.facet(dep) === state4.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state4.field(dep, false) : true;
            }) || (multi ? compareArray(newVal = getter(state4), oldVal, compare4) : compare4(newVal = getter(state4), oldVal))) {
              state4.values[idx] = oldVal;
              return 0;
            }
          } else {
            newVal = getter(state4);
          }
          state4.values[idx] = newVal;
          return 1;
        }
      };
    }
  };
  function compareArray(a2, b2, compare4) {
    if (a2.length != b2.length)
      return false;
    for (let i2 = 0; i2 < a2.length; i2++)
      if (!compare4(a2[i2], b2[i2]))
        return false;
    return true;
  }
  function ensureAll(state4, addrs) {
    let changed = false;
    for (let addr of addrs)
      if (ensureAddr(state4, addr) & 1)
        changed = true;
    return changed;
  }
  function dynamicFacetSlot(addresses, facet, providers) {
    let providerAddrs = providers.map((p2) => addresses[p2.id]);
    let providerTypes = providers.map((p2) => p2.type);
    let dynamic = providerAddrs.filter((p2) => !(p2 & 1));
    let idx = addresses[facet.id] >> 1;
    function get4(state4) {
      let values = [];
      for (let i2 = 0; i2 < providerAddrs.length; i2++) {
        let value12 = getAddr(state4, providerAddrs[i2]);
        if (providerTypes[i2] == 2)
          for (let val of value12)
            values.push(val);
        else
          values.push(value12);
      }
      return facet.combine(values);
    }
    return {
      create(state4) {
        for (let addr of providerAddrs)
          ensureAddr(state4, addr);
        state4.values[idx] = get4(state4);
        return 1;
      },
      update(state4, tr) {
        if (!ensureAll(state4, dynamic))
          return 0;
        let value12 = get4(state4);
        if (facet.compare(value12, state4.values[idx]))
          return 0;
        state4.values[idx] = value12;
        return 1;
      },
      reconfigure(state4, oldState) {
        let depChanged = ensureAll(state4, providerAddrs);
        let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
        if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
          state4.values[idx] = oldValue;
          return 0;
        }
        let value12 = get4(state4);
        if (facet.compare(value12, oldValue)) {
          state4.values[idx] = oldValue;
          return 0;
        }
        state4.values[idx] = value12;
        return 1;
      }
    };
  }
  var initField = /* @__PURE__ */ Facet.define({ static: true });
  var StateField = class _StateField {
    constructor(id5, createF, updateF, compareF, spec) {
      this.id = id5;
      this.createF = createF;
      this.updateF = updateF;
      this.compareF = compareF;
      this.spec = spec;
      this.provides = void 0;
    }
    /**
    Define a state field.
    */
    static define(config2) {
      let field = new _StateField(nextID++, config2.create, config2.update, config2.compare || ((a2, b2) => a2 === b2), config2);
      if (config2.provide)
        field.provides = config2.provide(field);
      return field;
    }
    create(state4) {
      let init6 = state4.facet(initField).find((i2) => i2.field == this);
      return ((init6 === null || init6 === void 0 ? void 0 : init6.create) || this.createF)(state4);
    }
    /**
    @internal
    */
    slot(addresses) {
      let idx = addresses[this.id] >> 1;
      return {
        create: (state4) => {
          state4.values[idx] = this.create(state4);
          return 1;
        },
        update: (state4, tr) => {
          let oldVal = state4.values[idx];
          let value12 = this.updateF(oldVal, tr);
          if (this.compareF(oldVal, value12))
            return 0;
          state4.values[idx] = value12;
          return 1;
        },
        reconfigure: (state4, oldState) => {
          if (oldState.config.address[this.id] != null) {
            state4.values[idx] = oldState.field(this);
            return 0;
          }
          state4.values[idx] = this.create(state4);
          return 1;
        }
      };
    }
    /**
    Returns an extension that enables this field and overrides the
    way it is initialized. Can be useful when you need to provide a
    non-default starting value for the field.
    */
    init(create3) {
      return [this, initField.of({ field: this, create: create3 })];
    }
    /**
    State field instances can be used as
    [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
    given state.
    */
    get extension() {
      return this;
    }
  };
  var Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
  function prec(value12) {
    return (ext) => new PrecExtension(ext, value12);
  }
  var Prec = {
    /**
    The highest precedence level, for extensions that should end up
    near the start of the precedence ordering.
    */
    highest: /* @__PURE__ */ prec(Prec_.highest),
    /**
    A higher-than-default precedence, for extensions that should
    come before those with default precedence.
    */
    high: /* @__PURE__ */ prec(Prec_.high),
    /**
    The default precedence, which is also used for extensions
    without an explicit precedence.
    */
    default: /* @__PURE__ */ prec(Prec_.default),
    /**
    A lower-than-default precedence.
    */
    low: /* @__PURE__ */ prec(Prec_.low),
    /**
    The lowest precedence level. Meant for things that should end up
    near the end of the extension order.
    */
    lowest: /* @__PURE__ */ prec(Prec_.lowest)
  };
  var PrecExtension = class {
    constructor(inner, prec2) {
      this.inner = inner;
      this.prec = prec2;
    }
  };
  var Compartment = class _Compartment {
    /**
    Create an instance of this compartment to add to your [state
    configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
    */
    of(ext) {
      return new CompartmentInstance(this, ext);
    }
    /**
    Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
    reconfigures this compartment.
    */
    reconfigure(content4) {
      return _Compartment.reconfigure.of({ compartment: this, extension: content4 });
    }
    /**
    Get the current content of the compartment in the state, or
    `undefined` if it isn't present.
    */
    get(state4) {
      return state4.config.compartments.get(this);
    }
  };
  var CompartmentInstance = class {
    constructor(compartment, inner) {
      this.compartment = compartment;
      this.inner = inner;
    }
  };
  var Configuration = class _Configuration {
    constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
      this.base = base2;
      this.compartments = compartments;
      this.dynamicSlots = dynamicSlots;
      this.address = address;
      this.staticValues = staticValues;
      this.facets = facets;
      this.statusTemplate = [];
      while (this.statusTemplate.length < dynamicSlots.length)
        this.statusTemplate.push(
          0
          /* SlotStatus.Unresolved */
        );
    }
    staticFacet(facet) {
      let addr = this.address[facet.id];
      return addr == null ? facet.default : this.staticValues[addr >> 1];
    }
    static resolve(base2, compartments, oldState) {
      let fields = [];
      let facets = /* @__PURE__ */ Object.create(null);
      let newCompartments = /* @__PURE__ */ new Map();
      for (let ext of flatten(base2, compartments, newCompartments)) {
        if (ext instanceof StateField)
          fields.push(ext);
        else
          (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
      }
      let address = /* @__PURE__ */ Object.create(null);
      let staticValues = [];
      let dynamicSlots = [];
      for (let field of fields) {
        address[field.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a2) => field.slot(a2));
      }
      let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
      for (let id5 in facets) {
        let providers = facets[id5], facet = providers[0].facet;
        let oldProviders = oldFacets && oldFacets[id5] || [];
        if (providers.every(
          (p2) => p2.type == 0
          /* Provider.Static */
        )) {
          address[facet.id] = staticValues.length << 1 | 1;
          if (sameArray(oldProviders, providers)) {
            staticValues.push(oldState.facet(facet));
          } else {
            let value12 = facet.combine(providers.map((p2) => p2.value));
            staticValues.push(oldState && facet.compare(value12, oldState.facet(facet)) ? oldState.facet(facet) : value12);
          }
        } else {
          for (let p2 of providers) {
            if (p2.type == 0) {
              address[p2.id] = staticValues.length << 1 | 1;
              staticValues.push(p2.value);
            } else {
              address[p2.id] = dynamicSlots.length << 1;
              dynamicSlots.push((a2) => p2.dynamicSlot(a2));
            }
          }
          address[facet.id] = dynamicSlots.length << 1;
          dynamicSlots.push((a2) => dynamicFacetSlot(a2, facet, providers));
        }
      }
      let dynamic = dynamicSlots.map((f2) => f2(address));
      return new _Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
    }
  };
  function flatten(extension, compartments, newCompartments) {
    let result = [[], [], [], [], []];
    let seen = /* @__PURE__ */ new Map();
    function inner(ext, prec2) {
      let known = seen.get(ext);
      if (known != null) {
        if (known <= prec2)
          return;
        let found = result[known].indexOf(ext);
        if (found > -1)
          result[known].splice(found, 1);
        if (ext instanceof CompartmentInstance)
          newCompartments.delete(ext.compartment);
      }
      seen.set(ext, prec2);
      if (Array.isArray(ext)) {
        for (let e2 of ext)
          inner(e2, prec2);
      } else if (ext instanceof CompartmentInstance) {
        if (newCompartments.has(ext.compartment))
          throw new RangeError(`Duplicate use of compartment in extensions`);
        let content4 = compartments.get(ext.compartment) || ext.inner;
        newCompartments.set(ext.compartment, content4);
        inner(content4, prec2);
      } else if (ext instanceof PrecExtension) {
        inner(ext.inner, ext.prec);
      } else if (ext instanceof StateField) {
        result[prec2].push(ext);
        if (ext.provides)
          inner(ext.provides, prec2);
      } else if (ext instanceof FacetProvider) {
        result[prec2].push(ext);
        if (ext.facet.extensions)
          inner(ext.facet.extensions, Prec_.default);
      } else {
        let content4 = ext.extension;
        if (!content4)
          throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
        inner(content4, prec2);
      }
    }
    inner(extension, Prec_.default);
    return result.reduce((a2, b2) => a2.concat(b2));
  }
  function ensureAddr(state4, addr) {
    if (addr & 1)
      return 2;
    let idx = addr >> 1;
    let status = state4.status[idx];
    if (status == 4)
      throw new Error("Cyclic dependency between fields and/or facets");
    if (status & 2)
      return status;
    state4.status[idx] = 4;
    let changed = state4.computeSlot(state4, state4.config.dynamicSlots[idx]);
    return state4.status[idx] = 2 | changed;
  }
  function getAddr(state4, addr) {
    return addr & 1 ? state4.config.staticValues[addr >> 1] : state4.values[addr >> 1];
  }
  var languageData = /* @__PURE__ */ Facet.define();
  var allowMultipleSelections = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((v2) => v2),
    static: true
  });
  var lineSeparator = /* @__PURE__ */ Facet.define({
    combine: (values) => values.length ? values[0] : void 0,
    static: true
  });
  var changeFilter = /* @__PURE__ */ Facet.define();
  var transactionFilter = /* @__PURE__ */ Facet.define();
  var transactionExtender = /* @__PURE__ */ Facet.define();
  var readOnly = /* @__PURE__ */ Facet.define({
    combine: (values) => values.length ? values[0] : false
  });
  var Annotation = class {
    /**
    @internal
    */
    constructor(type, value12) {
      this.type = type;
      this.value = value12;
    }
    /**
    Define a new type of annotation.
    */
    static define() {
      return new AnnotationType();
    }
  };
  var AnnotationType = class {
    /**
    Create an instance of this annotation.
    */
    of(value12) {
      return new Annotation(this, value12);
    }
  };
  var StateEffectType = class {
    /**
    @internal
    */
    constructor(map27) {
      this.map = map27;
    }
    /**
    Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
    type.
    */
    of(value12) {
      return new StateEffect(this, value12);
    }
  };
  var StateEffect = class _StateEffect {
    /**
    @internal
    */
    constructor(type, value12) {
      this.type = type;
      this.value = value12;
    }
    /**
    Map this effect through a position mapping. Will return
    `undefined` when that ends up deleting the effect.
    */
    map(mapping) {
      let mapped = this.type.map(this.value, mapping);
      return mapped === void 0 ? void 0 : mapped == this.value ? this : new _StateEffect(this.type, mapped);
    }
    /**
    Tells you whether this effect object is of a given
    [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
    */
    is(type) {
      return this.type == type;
    }
    /**
    Define a new effect type. The type parameter indicates the type
    of values that his effect holds. It should be a type that
    doesn't include `undefined`, since that is used in
    [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
    removed.
    */
    static define(spec = {}) {
      return new StateEffectType(spec.map || ((v2) => v2));
    }
    /**
    Map an array of effects through a change set.
    */
    static mapEffects(effects, mapping) {
      if (!effects.length)
        return effects;
      let result = [];
      for (let effect of effects) {
        let mapped = effect.map(mapping);
        if (mapped)
          result.push(mapped);
      }
      return result;
    }
  };
  StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
  StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
  var Transaction = class _Transaction {
    constructor(startState, changes, selection, effects, annotations, scrollIntoView3) {
      this.startState = startState;
      this.changes = changes;
      this.selection = selection;
      this.effects = effects;
      this.annotations = annotations;
      this.scrollIntoView = scrollIntoView3;
      this._doc = null;
      this._state = null;
      if (selection)
        checkSelection(selection, changes.newLength);
      if (!annotations.some((a2) => a2.type == _Transaction.time))
        this.annotations = annotations.concat(_Transaction.time.of(Date.now()));
    }
    /**
    @internal
    */
    static create(startState, changes, selection, effects, annotations, scrollIntoView3) {
      return new _Transaction(startState, changes, selection, effects, annotations, scrollIntoView3);
    }
    /**
    The new document produced by the transaction. Contrary to
    [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
    force the entire new state to be computed right away, so it is
    recommended that [transaction
    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
    when they need to look at the new document.
    */
    get newDoc() {
      return this._doc || (this._doc = this.changes.apply(this.startState.doc));
    }
    /**
    The new selection produced by the transaction. If
    [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
    this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
    current selection through the changes made by the transaction.
    */
    get newSelection() {
      return this.selection || this.startState.selection.map(this.changes);
    }
    /**
    The new state created by the transaction. Computed on demand
    (but retained for subsequent access), so it is recommended not to
    access it in [transaction
    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
    */
    get state() {
      if (!this._state)
        this.startState.applyTransaction(this);
      return this._state;
    }
    /**
    Get the value of the given annotation type, if any.
    */
    annotation(type) {
      for (let ann of this.annotations)
        if (ann.type == type)
          return ann.value;
      return void 0;
    }
    /**
    Indicates whether the transaction changed the document.
    */
    get docChanged() {
      return !this.changes.empty;
    }
    /**
    Indicates whether this transaction reconfigures the state
    (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
    with a top-level configuration
    [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
    */
    get reconfigured() {
      return this.startState.config != this.state.config;
    }
    /**
    Returns true if the transaction has a [user
    event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
    or more specific than `event`. For example, if the transaction
    has `"select.pointer"` as user event, `"select"` and
    `"select.pointer"` will match it.
    */
    isUserEvent(event) {
      let e2 = this.annotation(_Transaction.userEvent);
      return !!(e2 && (e2 == event || e2.length > event.length && e2.slice(0, event.length) == event && e2[event.length] == "."));
    }
  };
  Transaction.time = /* @__PURE__ */ Annotation.define();
  Transaction.userEvent = /* @__PURE__ */ Annotation.define();
  Transaction.addToHistory = /* @__PURE__ */ Annotation.define();
  Transaction.remote = /* @__PURE__ */ Annotation.define();
  function joinRanges(a2, b2) {
    let result = [];
    for (let iA = 0, iB = 0; ; ) {
      let from3, to3;
      if (iA < a2.length && (iB == b2.length || b2[iB] >= a2[iA])) {
        from3 = a2[iA++];
        to3 = a2[iA++];
      } else if (iB < b2.length) {
        from3 = b2[iB++];
        to3 = b2[iB++];
      } else
        return result;
      if (!result.length || result[result.length - 1] < from3)
        result.push(from3, to3);
      else if (result[result.length - 1] < to3)
        result[result.length - 1] = to3;
    }
  }
  function mergeTransaction(a2, b2, sequential2) {
    var _a2;
    let mapForA, mapForB, changes;
    if (sequential2) {
      mapForA = b2.changes;
      mapForB = ChangeSet.empty(b2.changes.length);
      changes = a2.changes.compose(b2.changes);
    } else {
      mapForA = b2.changes.map(a2.changes);
      mapForB = a2.changes.mapDesc(b2.changes, true);
      changes = a2.changes.compose(mapForA);
    }
    return {
      changes,
      selection: b2.selection ? b2.selection.map(mapForB) : (_a2 = a2.selection) === null || _a2 === void 0 ? void 0 : _a2.map(mapForA),
      effects: StateEffect.mapEffects(a2.effects, mapForA).concat(StateEffect.mapEffects(b2.effects, mapForB)),
      annotations: a2.annotations.length ? a2.annotations.concat(b2.annotations) : b2.annotations,
      scrollIntoView: a2.scrollIntoView || b2.scrollIntoView
    };
  }
  function resolveTransactionInner(state4, spec, docSize) {
    let sel = spec.selection, annotations = asArray(spec.annotations);
    if (spec.userEvent)
      annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
    return {
      changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state4.facet(lineSeparator)),
      selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
      effects: asArray(spec.effects),
      annotations,
      scrollIntoView: !!spec.scrollIntoView
    };
  }
  function resolveTransaction(state4, specs, filter3) {
    let s2 = resolveTransactionInner(state4, specs.length ? specs[0] : {}, state4.doc.length);
    if (specs.length && specs[0].filter === false)
      filter3 = false;
    for (let i2 = 1; i2 < specs.length; i2++) {
      if (specs[i2].filter === false)
        filter3 = false;
      let seq = !!specs[i2].sequential;
      s2 = mergeTransaction(s2, resolveTransactionInner(state4, specs[i2], seq ? s2.changes.newLength : state4.doc.length), seq);
    }
    let tr = Transaction.create(state4, s2.changes, s2.selection, s2.effects, s2.annotations, s2.scrollIntoView);
    return extendTransaction(filter3 ? filterTransaction(tr) : tr);
  }
  function filterTransaction(tr) {
    let state4 = tr.startState;
    let result = true;
    for (let filter3 of state4.facet(changeFilter)) {
      let value12 = filter3(tr);
      if (value12 === false) {
        result = false;
        break;
      }
      if (Array.isArray(value12))
        result = result === true ? value12 : joinRanges(result, value12);
    }
    if (result !== true) {
      let changes, back2;
      if (result === false) {
        back2 = tr.changes.invertedDesc;
        changes = ChangeSet.empty(state4.doc.length);
      } else {
        let filtered = tr.changes.filter(result);
        changes = filtered.changes;
        back2 = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
      }
      tr = Transaction.create(state4, changes, tr.selection && tr.selection.map(back2), StateEffect.mapEffects(tr.effects, back2), tr.annotations, tr.scrollIntoView);
    }
    let filters = state4.facet(transactionFilter);
    for (let i2 = filters.length - 1; i2 >= 0; i2--) {
      let filtered = filters[i2](tr);
      if (filtered instanceof Transaction)
        tr = filtered;
      else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
        tr = filtered[0];
      else
        tr = resolveTransaction(state4, asArray(filtered), false);
    }
    return tr;
  }
  function extendTransaction(tr) {
    let state4 = tr.startState, extenders = state4.facet(transactionExtender), spec = tr;
    for (let i2 = extenders.length - 1; i2 >= 0; i2--) {
      let extension = extenders[i2](tr);
      if (extension && Object.keys(extension).length)
        spec = mergeTransaction(spec, resolveTransactionInner(state4, extension, tr.changes.newLength), true);
    }
    return spec == tr ? tr : Transaction.create(state4, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
  }
  var none2 = [];
  function asArray(value12) {
    return value12 == null ? none2 : Array.isArray(value12) ? value12 : [value12];
  }
  var CharCategory = /* @__PURE__ */ function(CharCategory2) {
    CharCategory2[CharCategory2["Word"] = 0] = "Word";
    CharCategory2[CharCategory2["Space"] = 1] = "Space";
    CharCategory2[CharCategory2["Other"] = 2] = "Other";
    return CharCategory2;
  }(CharCategory || (CharCategory = {}));
  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  var wordChar;
  try {
    wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
  } catch (_) {
  }
  function hasWordChar(str) {
    if (wordChar)
      return wordChar.test(str);
    for (let i2 = 0; i2 < str.length; i2++) {
      let ch = str[i2];
      if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
        return true;
    }
    return false;
  }
  function makeCategorizer(wordChars) {
    return (char2) => {
      if (!/\S/.test(char2))
        return CharCategory.Space;
      if (hasWordChar(char2))
        return CharCategory.Word;
      for (let i2 = 0; i2 < wordChars.length; i2++)
        if (char2.indexOf(wordChars[i2]) > -1)
          return CharCategory.Word;
      return CharCategory.Other;
    };
  }
  var EditorState = class _EditorState {
    constructor(config2, doc2, selection, values, computeSlot, tr) {
      this.config = config2;
      this.doc = doc2;
      this.selection = selection;
      this.values = values;
      this.status = config2.statusTemplate.slice();
      this.computeSlot = computeSlot;
      if (tr)
        tr._state = this;
      for (let i2 = 0; i2 < this.config.dynamicSlots.length; i2++)
        ensureAddr(this, i2 << 1);
      this.computeSlot = null;
    }
    field(field, require2 = true) {
      let addr = this.config.address[field.id];
      if (addr == null) {
        if (require2)
          throw new RangeError("Field is not present in this state");
        return void 0;
      }
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    /**
    Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
    state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
    can be passed. Unless
    [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
    [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
    are assumed to start in the _current_ document (not the document
    produced by previous specs), and its
    [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
    [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
    to the document created by its _own_ changes. The resulting
    transaction contains the combined effect of all the different
    specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
    specs take precedence over earlier ones.
    */
    update(...specs) {
      return resolveTransaction(this, specs, true);
    }
    /**
    @internal
    */
    applyTransaction(tr) {
      let conf = this.config, { base: base2, compartments } = conf;
      for (let effect of tr.effects) {
        if (effect.is(Compartment.reconfigure)) {
          if (conf) {
            compartments = /* @__PURE__ */ new Map();
            conf.compartments.forEach((val, key) => compartments.set(key, val));
            conf = null;
          }
          compartments.set(effect.value.compartment, effect.value.extension);
        } else if (effect.is(StateEffect.reconfigure)) {
          conf = null;
          base2 = effect.value;
        } else if (effect.is(StateEffect.appendConfig)) {
          conf = null;
          base2 = asArray(base2).concat(effect.value);
        }
      }
      let startValues;
      if (!conf) {
        conf = Configuration.resolve(base2, compartments, this);
        let intermediateState = new _EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state4, slot) => slot.reconfigure(state4, this), null);
        startValues = intermediateState.values;
      } else {
        startValues = tr.startState.values.slice();
      }
      let selection = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();
      new _EditorState(conf, tr.newDoc, selection, startValues, (state4, slot) => slot.update(state4, tr), tr);
    }
    /**
    Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
    replaces every selection range with the given content.
    */
    replaceSelection(text6) {
      if (typeof text6 == "string")
        text6 = this.toText(text6);
      return this.changeByRange((range3) => ({
        changes: { from: range3.from, to: range3.to, insert: text6 },
        range: EditorSelection.cursor(range3.from + text6.length)
      }));
    }
    /**
    Create a set of changes and a new selection by running the given
    function for each range in the active selection. The function
    can return an optional set of changes (in the coordinate space
    of the start document), plus an updated range (in the coordinate
    space of the document produced by the call's own changes). This
    method will merge all the changes and ranges into a single
    changeset and selection, and return it as a [transaction
    spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
    [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
    */
    changeByRange(f2) {
      let sel = this.selection;
      let result1 = f2(sel.ranges[0]);
      let changes = this.changes(result1.changes), ranges = [result1.range];
      let effects = asArray(result1.effects);
      for (let i2 = 1; i2 < sel.ranges.length; i2++) {
        let result = f2(sel.ranges[i2]);
        let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
        for (let j2 = 0; j2 < i2; j2++)
          ranges[j2] = ranges[j2].map(newMapped);
        let mapBy = changes.mapDesc(newChanges, true);
        ranges.push(result.range.map(mapBy));
        changes = changes.compose(newMapped);
        effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
      }
      return {
        changes,
        selection: EditorSelection.create(ranges, sel.mainIndex),
        effects
      };
    }
    /**
    Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
    description, taking the state's document length and line
    separator into account.
    */
    changes(spec = []) {
      if (spec instanceof ChangeSet)
        return spec;
      return ChangeSet.of(spec, this.doc.length, this.facet(_EditorState.lineSeparator));
    }
    /**
    Using the state's [line
    separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
    [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
    */
    toText(string2) {
      return Text2.of(string2.split(this.facet(_EditorState.lineSeparator) || DefaultSplit));
    }
    /**
    Return the given range of the document as a string.
    */
    sliceDoc(from3 = 0, to3 = this.doc.length) {
      return this.doc.sliceString(from3, to3, this.lineBreak);
    }
    /**
    Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
    */
    facet(facet) {
      let addr = this.config.address[facet.id];
      if (addr == null)
        return facet.default;
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    /**
    Convert this state to a JSON-serializable object. When custom
    fields should be serialized, you can pass them in as an object
    mapping property names (in the resulting object, which should
    not use `doc` or `selection`) to fields.
    */
    toJSON(fields) {
      let result = {
        doc: this.sliceDoc(),
        selection: this.selection.toJSON()
      };
      if (fields)
        for (let prop in fields) {
          let value12 = fields[prop];
          if (value12 instanceof StateField && this.config.address[value12.id] != null)
            result[prop] = value12.spec.toJSON(this.field(fields[prop]), this);
        }
      return result;
    }
    /**
    Deserialize a state from its JSON representation. When custom
    fields should be deserialized, pass the same object you passed
    to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
    third argument.
    */
    static fromJSON(json, config2 = {}, fields) {
      if (!json || typeof json.doc != "string")
        throw new RangeError("Invalid JSON representation for EditorState");
      let fieldInit = [];
      if (fields)
        for (let prop in fields) {
          if (Object.prototype.hasOwnProperty.call(json, prop)) {
            let field = fields[prop], value12 = json[prop];
            fieldInit.push(field.init((state4) => field.spec.fromJSON(value12, state4)));
          }
        }
      return _EditorState.create({
        doc: json.doc,
        selection: EditorSelection.fromJSON(json.selection),
        extensions: config2.extensions ? fieldInit.concat([config2.extensions]) : fieldInit
      });
    }
    /**
    Create a new state. You'll usually only need this when
    initializing an editor—updated states are created by applying
    transactions.
    */
    static create(config2 = {}) {
      let configuration = Configuration.resolve(config2.extensions || [], /* @__PURE__ */ new Map());
      let doc2 = config2.doc instanceof Text2 ? config2.doc : Text2.of((config2.doc || "").split(configuration.staticFacet(_EditorState.lineSeparator) || DefaultSplit));
      let selection = !config2.selection ? EditorSelection.single(0) : config2.selection instanceof EditorSelection ? config2.selection : EditorSelection.single(config2.selection.anchor, config2.selection.head);
      checkSelection(selection, doc2.length);
      if (!configuration.staticFacet(allowMultipleSelections))
        selection = selection.asSingle();
      return new _EditorState(configuration, doc2, selection, configuration.dynamicSlots.map(() => null), (state4, slot) => slot.create(state4), null);
    }
    /**
    The size (in columns) of a tab in the document, determined by
    the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
    */
    get tabSize() {
      return this.facet(_EditorState.tabSize);
    }
    /**
    Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
    string for this state.
    */
    get lineBreak() {
      return this.facet(_EditorState.lineSeparator) || "\n";
    }
    /**
    Returns true when the editor is
    [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
    */
    get readOnly() {
      return this.facet(readOnly);
    }
    /**
    Look up a translation for the given phrase (via the
    [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
    original string if no translation is found.
    
    If additional arguments are passed, they will be inserted in
    place of markers like `$1` (for the first value) and `$2`, etc.
    A single `$` is equivalent to `$1`, and `$$` will produce a
    literal dollar sign.
    */
    phrase(phrase2, ...insert10) {
      for (let map27 of this.facet(_EditorState.phrases))
        if (Object.prototype.hasOwnProperty.call(map27, phrase2)) {
          phrase2 = map27[phrase2];
          break;
        }
      if (insert10.length)
        phrase2 = phrase2.replace(/\$(\$|\d*)/g, (m2, i2) => {
          if (i2 == "$")
            return "$";
          let n2 = +(i2 || 1);
          return !n2 || n2 > insert10.length ? m2 : insert10[n2 - 1];
        });
      return phrase2;
    }
    /**
    Find the values for a given language data field, provided by the
    the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
    
    Examples of language data fields are...
    
    - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
      comment syntax.
    - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
      for providing language-specific completion sources.
    - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
      characters that should be considered part of words in this
      language.
    - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
      bracket closing behavior.
    */
    languageDataAt(name16, pos, side = -1) {
      let values = [];
      for (let provider of this.facet(languageData)) {
        for (let result of provider(this, pos, side)) {
          if (Object.prototype.hasOwnProperty.call(result, name16))
            values.push(result[name16]);
        }
      }
      return values;
    }
    /**
    Return a function that can categorize strings (expected to
    represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
    into one of:
    
     - Word (contains an alphanumeric character or a character
       explicitly listed in the local language's `"wordChars"`
       language data, which should be a string)
     - Space (contains only whitespace)
     - Other (anything else)
    */
    charCategorizer(at) {
      return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
    }
    /**
    Find the word at the given position, meaning the range
    containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
    around it. If no word characters are adjacent to the position,
    this returns null.
    */
    wordAt(pos) {
      let { text: text6, from: from3, length: length9 } = this.doc.lineAt(pos);
      let cat = this.charCategorizer(pos);
      let start3 = pos - from3, end = pos - from3;
      while (start3 > 0) {
        let prev = findClusterBreak(text6, start3, false);
        if (cat(text6.slice(prev, start3)) != CharCategory.Word)
          break;
        start3 = prev;
      }
      while (end < length9) {
        let next = findClusterBreak(text6, end);
        if (cat(text6.slice(end, next)) != CharCategory.Word)
          break;
        end = next;
      }
      return start3 == end ? null : EditorSelection.range(start3 + from3, end + from3);
    }
  };
  EditorState.allowMultipleSelections = allowMultipleSelections;
  EditorState.tabSize = /* @__PURE__ */ Facet.define({
    combine: (values) => values.length ? values[0] : 4
  });
  EditorState.lineSeparator = lineSeparator;
  EditorState.readOnly = readOnly;
  EditorState.phrases = /* @__PURE__ */ Facet.define({
    compare(a2, b2) {
      let kA = Object.keys(a2), kB = Object.keys(b2);
      return kA.length == kB.length && kA.every((k2) => a2[k2] == b2[k2]);
    }
  });
  EditorState.languageData = languageData;
  EditorState.changeFilter = changeFilter;
  EditorState.transactionFilter = transactionFilter;
  EditorState.transactionExtender = transactionExtender;
  Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
  function combineConfig(configs, defaults3, combine = {}) {
    let result = {};
    for (let config2 of configs)
      for (let key of Object.keys(config2)) {
        let value12 = config2[key], current = result[key];
        if (current === void 0)
          result[key] = value12;
        else if (current === value12 || value12 === void 0) ;
        else if (Object.hasOwnProperty.call(combine, key))
          result[key] = combine[key](current, value12);
        else
          throw new Error("Config merge conflict for field " + key);
      }
    for (let key in defaults3)
      if (result[key] === void 0)
        result[key] = defaults3[key];
    return result;
  }
  var RangeValue = class {
    /**
    Compare this value with another value. Used when comparing
    rangesets. The default implementation compares by identity.
    Unless you are only creating a fixed number of unique instances
    of your value type, it is a good idea to implement this
    properly.
    */
    eq(other) {
      return this == other;
    }
    /**
    Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
    */
    range(from3, to3 = from3) {
      return Range.create(from3, to3, this);
    }
  };
  RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
  RangeValue.prototype.point = false;
  RangeValue.prototype.mapMode = MapMode.TrackDel;
  var Range = class _Range {
    constructor(from3, to3, value12) {
      this.from = from3;
      this.to = to3;
      this.value = value12;
    }
    /**
    @internal
    */
    static create(from3, to3, value12) {
      return new _Range(from3, to3, value12);
    }
  };
  function cmpRange(a2, b2) {
    return a2.from - b2.from || a2.value.startSide - b2.value.startSide;
  }
  var Chunk = class _Chunk {
    constructor(from3, to3, value12, maxPoint) {
      this.from = from3;
      this.to = to3;
      this.value = value12;
      this.maxPoint = maxPoint;
    }
    get length() {
      return this.to[this.to.length - 1];
    }
    // Find the index of the given position and side. Use the ranges'
    // `from` pos when `end == false`, `to` when `end == true`.
    findIndex(pos, side, end, startAt = 0) {
      let arr = end ? this.to : this.from;
      for (let lo = startAt, hi = arr.length; ; ) {
        if (lo == hi)
          return lo;
        let mid = lo + hi >> 1;
        let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
        if (mid == lo)
          return diff >= 0 ? lo : hi;
        if (diff >= 0)
          hi = mid;
        else
          lo = mid + 1;
      }
    }
    between(offset, from3, to3, f2) {
      for (let i2 = this.findIndex(from3, -1e9, true), e2 = this.findIndex(to3, 1e9, false, i2); i2 < e2; i2++)
        if (f2(this.from[i2] + offset, this.to[i2] + offset, this.value[i2]) === false)
          return false;
    }
    map(offset, changes) {
      let value12 = [], from3 = [], to3 = [], newPos = -1, maxPoint = -1;
      for (let i2 = 0; i2 < this.value.length; i2++) {
        let val = this.value[i2], curFrom = this.from[i2] + offset, curTo = this.to[i2] + offset, newFrom, newTo;
        if (curFrom == curTo) {
          let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
          if (mapped == null)
            continue;
          newFrom = newTo = mapped;
          if (val.startSide != val.endSide) {
            newTo = changes.mapPos(curFrom, val.endSide);
            if (newTo < newFrom)
              continue;
          }
        } else {
          newFrom = changes.mapPos(curFrom, val.startSide);
          newTo = changes.mapPos(curTo, val.endSide);
          if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
            continue;
        }
        if ((newTo - newFrom || val.endSide - val.startSide) < 0)
          continue;
        if (newPos < 0)
          newPos = newFrom;
        if (val.point)
          maxPoint = Math.max(maxPoint, newTo - newFrom);
        value12.push(val);
        from3.push(newFrom - newPos);
        to3.push(newTo - newPos);
      }
      return { mapped: value12.length ? new _Chunk(from3, to3, value12, maxPoint) : null, pos: newPos };
    }
  };
  var RangeSet = class _RangeSet {
    constructor(chunkPos, chunk, nextLayer, maxPoint) {
      this.chunkPos = chunkPos;
      this.chunk = chunk;
      this.nextLayer = nextLayer;
      this.maxPoint = maxPoint;
    }
    /**
    @internal
    */
    static create(chunkPos, chunk, nextLayer, maxPoint) {
      return new _RangeSet(chunkPos, chunk, nextLayer, maxPoint);
    }
    /**
    @internal
    */
    get length() {
      let last4 = this.chunk.length - 1;
      return last4 < 0 ? 0 : Math.max(this.chunkEnd(last4), this.nextLayer.length);
    }
    /**
    The number of ranges in the set.
    */
    get size() {
      if (this.isEmpty)
        return 0;
      let size5 = this.nextLayer.size;
      for (let chunk of this.chunk)
        size5 += chunk.value.length;
      return size5;
    }
    /**
    @internal
    */
    chunkEnd(index6) {
      return this.chunkPos[index6] + this.chunk[index6].length;
    }
    /**
    Update the range set, optionally adding new ranges or filtering
    out existing ones.
    
    (Note: The type parameter is just there as a kludge to work
    around TypeScript variance issues that prevented `RangeSet<X>`
    from being a subtype of `RangeSet<Y>` when `X` is a subtype of
    `Y`.)
    */
    update(updateSpec) {
      let { add: add5 = [], sort: sort2 = false, filterFrom = 0, filterTo = this.length } = updateSpec;
      let filter3 = updateSpec.filter;
      if (add5.length == 0 && !filter3)
        return this;
      if (sort2)
        add5 = add5.slice().sort(cmpRange);
      if (this.isEmpty)
        return add5.length ? _RangeSet.of(add5) : this;
      let cur2 = new LayerCursor(this, null, -1).goto(0), i2 = 0, spill = [];
      let builder = new RangeSetBuilder();
      while (cur2.value || i2 < add5.length) {
        if (i2 < add5.length && (cur2.from - add5[i2].from || cur2.startSide - add5[i2].value.startSide) >= 0) {
          let range3 = add5[i2++];
          if (!builder.addInner(range3.from, range3.to, range3.value))
            spill.push(range3);
        } else if (cur2.rangeIndex == 1 && cur2.chunkIndex < this.chunk.length && (i2 == add5.length || this.chunkEnd(cur2.chunkIndex) < add5[i2].from) && (!filter3 || filterFrom > this.chunkEnd(cur2.chunkIndex) || filterTo < this.chunkPos[cur2.chunkIndex]) && builder.addChunk(this.chunkPos[cur2.chunkIndex], this.chunk[cur2.chunkIndex])) {
          cur2.nextChunk();
        } else {
          if (!filter3 || filterFrom > cur2.to || filterTo < cur2.from || filter3(cur2.from, cur2.to, cur2.value)) {
            if (!builder.addInner(cur2.from, cur2.to, cur2.value))
              spill.push(Range.create(cur2.from, cur2.to, cur2.value));
          }
          cur2.next();
        }
      }
      return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? _RangeSet.empty : this.nextLayer.update({ add: spill, filter: filter3, filterFrom, filterTo }));
    }
    /**
    Map this range set through a set of changes, return the new set.
    */
    map(changes) {
      if (changes.empty || this.isEmpty)
        return this;
      let chunks = [], chunkPos = [], maxPoint = -1;
      for (let i2 = 0; i2 < this.chunk.length; i2++) {
        let start3 = this.chunkPos[i2], chunk = this.chunk[i2];
        let touch = changes.touchesRange(start3, start3 + chunk.length);
        if (touch === false) {
          maxPoint = Math.max(maxPoint, chunk.maxPoint);
          chunks.push(chunk);
          chunkPos.push(changes.mapPos(start3));
        } else if (touch === true) {
          let { mapped, pos } = chunk.map(start3, changes);
          if (mapped) {
            maxPoint = Math.max(maxPoint, mapped.maxPoint);
            chunks.push(mapped);
            chunkPos.push(pos);
          }
        }
      }
      let next = this.nextLayer.map(changes);
      return chunks.length == 0 ? next : new _RangeSet(chunkPos, chunks, next || _RangeSet.empty, maxPoint);
    }
    /**
    Iterate over the ranges that touch the region `from` to `to`,
    calling `f` for each. There is no guarantee that the ranges will
    be reported in any specific order. When the callback returns
    `false`, iteration stops.
    */
    between(from3, to3, f2) {
      if (this.isEmpty)
        return;
      for (let i2 = 0; i2 < this.chunk.length; i2++) {
        let start3 = this.chunkPos[i2], chunk = this.chunk[i2];
        if (to3 >= start3 && from3 <= start3 + chunk.length && chunk.between(start3, from3 - start3, to3 - start3, f2) === false)
          return;
      }
      this.nextLayer.between(from3, to3, f2);
    }
    /**
    Iterate over the ranges in this set, in order, including all
    ranges that end at or after `from`.
    */
    iter(from3 = 0) {
      return HeapCursor.from([this]).goto(from3);
    }
    /**
    @internal
    */
    get isEmpty() {
      return this.nextLayer == this;
    }
    /**
    Iterate over the ranges in a collection of sets, in order,
    starting from `from`.
    */
    static iter(sets, from3 = 0) {
      return HeapCursor.from(sets).goto(from3);
    }
    /**
    Iterate over two groups of sets, calling methods on `comparator`
    to notify it of possible differences.
    */
    static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
      let a2 = oldSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
      let b2 = newSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
      let sharedChunks = findSharedChunks(a2, b2, textDiff);
      let sideA = new SpanCursor(a2, sharedChunks, minPointSize);
      let sideB = new SpanCursor(b2, sharedChunks, minPointSize);
      textDiff.iterGaps((fromA, fromB, length9) => compare3(sideA, fromA, sideB, fromB, length9, comparator));
      if (textDiff.empty && textDiff.length == 0)
        compare3(sideA, 0, sideB, 0, 0, comparator);
    }
    /**
    Compare the contents of two groups of range sets, returning true
    if they are equivalent in the given range.
    */
    static eq(oldSets, newSets, from3 = 0, to3) {
      if (to3 == null)
        to3 = 1e9 - 1;
      let a2 = oldSets.filter((set) => !set.isEmpty && newSets.indexOf(set) < 0);
      let b2 = newSets.filter((set) => !set.isEmpty && oldSets.indexOf(set) < 0);
      if (a2.length != b2.length)
        return false;
      if (!a2.length)
        return true;
      let sharedChunks = findSharedChunks(a2, b2);
      let sideA = new SpanCursor(a2, sharedChunks, 0).goto(from3), sideB = new SpanCursor(b2, sharedChunks, 0).goto(from3);
      for (; ; ) {
        if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
          return false;
        if (sideA.to > to3)
          return true;
        sideA.next();
        sideB.next();
      }
    }
    /**
    Iterate over a group of range sets at the same time, notifying
    the iterator about the ranges covering every given piece of
    content. Returns the open count (see
    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
    of the iteration.
    */
    static spans(sets, from3, to3, iterator2, minPointSize = -1) {
      let cursor = new SpanCursor(sets, null, minPointSize).goto(from3), pos = from3;
      let openRanges = cursor.openStart;
      for (; ; ) {
        let curTo = Math.min(cursor.to, to3);
        if (cursor.point) {
          let active = cursor.activeForPoint(cursor.to);
          let openCount = cursor.pointFrom < from3 ? active.length + 1 : cursor.point.startSide < 0 ? active.length : Math.min(active.length, openRanges);
          iterator2.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);
          openRanges = Math.min(cursor.openEnd(curTo), active.length);
        } else if (curTo > pos) {
          iterator2.span(pos, curTo, cursor.active, openRanges);
          openRanges = cursor.openEnd(curTo);
        }
        if (cursor.to > to3)
          return openRanges + (cursor.point && cursor.to > to3 ? 1 : 0);
        pos = cursor.to;
        cursor.next();
      }
    }
    /**
    Create a range set for the given range or array of ranges. By
    default, this expects the ranges to be _sorted_ (by start
    position and, if two start at the same position,
    `value.startSide`). You can pass `true` as second argument to
    cause the method to sort them.
    */
    static of(ranges, sort2 = false) {
      let build2 = new RangeSetBuilder();
      for (let range3 of ranges instanceof Range ? [ranges] : sort2 ? lazySort(ranges) : ranges)
        build2.add(range3.from, range3.to, range3.value);
      return build2.finish();
    }
    /**
    Join an array of range sets into a single set.
    */
    static join(sets) {
      if (!sets.length)
        return _RangeSet.empty;
      let result = sets[sets.length - 1];
      for (let i2 = sets.length - 2; i2 >= 0; i2--) {
        for (let layer2 = sets[i2]; layer2 != _RangeSet.empty; layer2 = layer2.nextLayer)
          result = new _RangeSet(layer2.chunkPos, layer2.chunk, result, Math.max(layer2.maxPoint, result.maxPoint));
      }
      return result;
    }
  };
  RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
  function lazySort(ranges) {
    if (ranges.length > 1)
      for (let prev = ranges[0], i2 = 1; i2 < ranges.length; i2++) {
        let cur2 = ranges[i2];
        if (cmpRange(prev, cur2) > 0)
          return ranges.slice().sort(cmpRange);
        prev = cur2;
      }
    return ranges;
  }
  RangeSet.empty.nextLayer = RangeSet.empty;
  var RangeSetBuilder = class _RangeSetBuilder {
    finishChunk(newArrays) {
      this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
      this.chunkPos.push(this.chunkStart);
      this.chunkStart = -1;
      this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
      this.maxPoint = -1;
      if (newArrays) {
        this.from = [];
        this.to = [];
        this.value = [];
      }
    }
    /**
    Create an empty builder.
    */
    constructor() {
      this.chunks = [];
      this.chunkPos = [];
      this.chunkStart = -1;
      this.last = null;
      this.lastFrom = -1e9;
      this.lastTo = -1e9;
      this.from = [];
      this.to = [];
      this.value = [];
      this.maxPoint = -1;
      this.setMaxPoint = -1;
      this.nextLayer = null;
    }
    /**
    Add a range. Ranges should be added in sorted (by `from` and
    `value.startSide`) order.
    */
    add(from3, to3, value12) {
      if (!this.addInner(from3, to3, value12))
        (this.nextLayer || (this.nextLayer = new _RangeSetBuilder())).add(from3, to3, value12);
    }
    /**
    @internal
    */
    addInner(from3, to3, value12) {
      let diff = from3 - this.lastTo || value12.startSide - this.last.endSide;
      if (diff <= 0 && (from3 - this.lastFrom || value12.startSide - this.last.startSide) < 0)
        throw new Error("Ranges must be added sorted by `from` position and `startSide`");
      if (diff < 0)
        return false;
      if (this.from.length == 250)
        this.finishChunk(true);
      if (this.chunkStart < 0)
        this.chunkStart = from3;
      this.from.push(from3 - this.chunkStart);
      this.to.push(to3 - this.chunkStart);
      this.last = value12;
      this.lastFrom = from3;
      this.lastTo = to3;
      this.value.push(value12);
      if (value12.point)
        this.maxPoint = Math.max(this.maxPoint, to3 - from3);
      return true;
    }
    /**
    @internal
    */
    addChunk(from3, chunk) {
      if ((from3 - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
        return false;
      if (this.from.length)
        this.finishChunk(true);
      this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
      this.chunks.push(chunk);
      this.chunkPos.push(from3);
      let last4 = chunk.value.length - 1;
      this.last = chunk.value[last4];
      this.lastFrom = chunk.from[last4] + from3;
      this.lastTo = chunk.to[last4] + from3;
      return true;
    }
    /**
    Finish the range set. Returns the new set. The builder can't be
    used anymore after this has been called.
    */
    finish() {
      return this.finishInner(RangeSet.empty);
    }
    /**
    @internal
    */
    finishInner(next) {
      if (this.from.length)
        this.finishChunk(false);
      if (this.chunks.length == 0)
        return next;
      let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
      this.from = null;
      return result;
    }
  };
  function findSharedChunks(a2, b2, textDiff) {
    let inA = /* @__PURE__ */ new Map();
    for (let set of a2)
      for (let i2 = 0; i2 < set.chunk.length; i2++)
        if (set.chunk[i2].maxPoint <= 0)
          inA.set(set.chunk[i2], set.chunkPos[i2]);
    let shared = /* @__PURE__ */ new Set();
    for (let set of b2)
      for (let i2 = 0; i2 < set.chunk.length; i2++) {
        let known = inA.get(set.chunk[i2]);
        if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i2] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i2].length)))
          shared.add(set.chunk[i2]);
      }
    return shared;
  }
  var LayerCursor = class {
    constructor(layer2, skip, minPoint, rank = 0) {
      this.layer = layer2;
      this.skip = skip;
      this.minPoint = minPoint;
      this.rank = rank;
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    get endSide() {
      return this.value ? this.value.endSide : 0;
    }
    goto(pos, side = -1e9) {
      this.chunkIndex = this.rangeIndex = 0;
      this.gotoInner(pos, side, false);
      return this;
    }
    gotoInner(pos, side, forward2) {
      while (this.chunkIndex < this.layer.chunk.length) {
        let next = this.layer.chunk[this.chunkIndex];
        if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
          break;
        this.chunkIndex++;
        forward2 = false;
      }
      if (this.chunkIndex < this.layer.chunk.length) {
        let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
        if (!forward2 || this.rangeIndex < rangeIndex)
          this.setRangeIndex(rangeIndex);
      }
      this.next();
    }
    forward(pos, side) {
      if ((this.to - pos || this.endSide - side) < 0)
        this.gotoInner(pos, side, true);
    }
    next() {
      for (; ; ) {
        if (this.chunkIndex == this.layer.chunk.length) {
          this.from = this.to = 1e9;
          this.value = null;
          break;
        } else {
          let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
          let from3 = chunkPos + chunk.from[this.rangeIndex];
          this.from = from3;
          this.to = chunkPos + chunk.to[this.rangeIndex];
          this.value = chunk.value[this.rangeIndex];
          this.setRangeIndex(this.rangeIndex + 1);
          if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
            break;
        }
      }
    }
    setRangeIndex(index6) {
      if (index6 == this.layer.chunk[this.chunkIndex].value.length) {
        this.chunkIndex++;
        if (this.skip) {
          while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
            this.chunkIndex++;
        }
        this.rangeIndex = 0;
      } else {
        this.rangeIndex = index6;
      }
    }
    nextChunk() {
      this.chunkIndex++;
      this.rangeIndex = 0;
      this.next();
    }
    compare(other) {
      return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
    }
  };
  var HeapCursor = class _HeapCursor {
    constructor(heap) {
      this.heap = heap;
    }
    static from(sets, skip = null, minPoint = -1) {
      let heap = [];
      for (let i2 = 0; i2 < sets.length; i2++) {
        for (let cur2 = sets[i2]; !cur2.isEmpty; cur2 = cur2.nextLayer) {
          if (cur2.maxPoint >= minPoint)
            heap.push(new LayerCursor(cur2, skip, minPoint, i2));
        }
      }
      return heap.length == 1 ? heap[0] : new _HeapCursor(heap);
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    goto(pos, side = -1e9) {
      for (let cur2 of this.heap)
        cur2.goto(pos, side);
      for (let i2 = this.heap.length >> 1; i2 >= 0; i2--)
        heapBubble(this.heap, i2);
      this.next();
      return this;
    }
    forward(pos, side) {
      for (let cur2 of this.heap)
        cur2.forward(pos, side);
      for (let i2 = this.heap.length >> 1; i2 >= 0; i2--)
        heapBubble(this.heap, i2);
      if ((this.to - pos || this.value.endSide - side) < 0)
        this.next();
    }
    next() {
      if (this.heap.length == 0) {
        this.from = this.to = 1e9;
        this.value = null;
        this.rank = -1;
      } else {
        let top4 = this.heap[0];
        this.from = top4.from;
        this.to = top4.to;
        this.value = top4.value;
        this.rank = top4.rank;
        if (top4.value)
          top4.next();
        heapBubble(this.heap, 0);
      }
    }
  };
  function heapBubble(heap, index6) {
    for (let cur2 = heap[index6]; ; ) {
      let childIndex = (index6 << 1) + 1;
      if (childIndex >= heap.length)
        break;
      let child = heap[childIndex];
      if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
        child = heap[childIndex + 1];
        childIndex++;
      }
      if (cur2.compare(child) < 0)
        break;
      heap[childIndex] = cur2;
      heap[index6] = child;
      index6 = childIndex;
    }
  }
  var SpanCursor = class {
    constructor(sets, skip, minPoint) {
      this.minPoint = minPoint;
      this.active = [];
      this.activeTo = [];
      this.activeRank = [];
      this.minActive = -1;
      this.point = null;
      this.pointFrom = 0;
      this.pointRank = 0;
      this.to = -1e9;
      this.endSide = 0;
      this.openStart = -1;
      this.cursor = HeapCursor.from(sets, skip, minPoint);
    }
    goto(pos, side = -1e9) {
      this.cursor.goto(pos, side);
      this.active.length = this.activeTo.length = this.activeRank.length = 0;
      this.minActive = -1;
      this.to = pos;
      this.endSide = side;
      this.openStart = -1;
      this.next();
      return this;
    }
    forward(pos, side) {
      while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
        this.removeActive(this.minActive);
      this.cursor.forward(pos, side);
    }
    removeActive(index6) {
      remove(this.active, index6);
      remove(this.activeTo, index6);
      remove(this.activeRank, index6);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    addActive(trackOpen) {
      let i2 = 0, { value: value12, to: to3, rank } = this.cursor;
      while (i2 < this.activeRank.length && (rank - this.activeRank[i2] || to3 - this.activeTo[i2]) > 0)
        i2++;
      insert9(this.active, i2, value12);
      insert9(this.activeTo, i2, to3);
      insert9(this.activeRank, i2, rank);
      if (trackOpen)
        insert9(trackOpen, i2, this.cursor.from);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    // After calling this, if `this.point` != null, the next range is a
    // point. Otherwise, it's a regular range, covered by `this.active`.
    next() {
      let from3 = this.to, wasPoint = this.point;
      this.point = null;
      let trackOpen = this.openStart < 0 ? [] : null;
      for (; ; ) {
        let a2 = this.minActive;
        if (a2 > -1 && (this.activeTo[a2] - this.cursor.from || this.active[a2].endSide - this.cursor.startSide) < 0) {
          if (this.activeTo[a2] > from3) {
            this.to = this.activeTo[a2];
            this.endSide = this.active[a2].endSide;
            break;
          }
          this.removeActive(a2);
          if (trackOpen)
            remove(trackOpen, a2);
        } else if (!this.cursor.value) {
          this.to = this.endSide = 1e9;
          break;
        } else if (this.cursor.from > from3) {
          this.to = this.cursor.from;
          this.endSide = this.cursor.startSide;
          break;
        } else {
          let nextVal = this.cursor.value;
          if (!nextVal.point) {
            this.addActive(trackOpen);
            this.cursor.next();
          } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
            this.cursor.next();
          } else {
            this.point = nextVal;
            this.pointFrom = this.cursor.from;
            this.pointRank = this.cursor.rank;
            this.to = this.cursor.to;
            this.endSide = nextVal.endSide;
            this.cursor.next();
            this.forward(this.to, this.endSide);
            break;
          }
        }
      }
      if (trackOpen) {
        this.openStart = 0;
        for (let i2 = trackOpen.length - 1; i2 >= 0 && trackOpen[i2] < from3; i2--)
          this.openStart++;
      }
    }
    activeForPoint(to3) {
      if (!this.active.length)
        return this.active;
      let active = [];
      for (let i2 = this.active.length - 1; i2 >= 0; i2--) {
        if (this.activeRank[i2] < this.pointRank)
          break;
        if (this.activeTo[i2] > to3 || this.activeTo[i2] == to3 && this.active[i2].endSide >= this.point.endSide)
          active.push(this.active[i2]);
      }
      return active.reverse();
    }
    openEnd(to3) {
      let open = 0;
      for (let i2 = this.activeTo.length - 1; i2 >= 0 && this.activeTo[i2] > to3; i2--)
        open++;
      return open;
    }
  };
  function compare3(a2, startA, b2, startB, length9, comparator) {
    a2.goto(startA);
    b2.goto(startB);
    let endB = startB + length9;
    let pos = startB, dPos = startB - startA;
    for (; ; ) {
      let diff = a2.to + dPos - b2.to || a2.endSide - b2.endSide;
      let end = diff < 0 ? a2.to + dPos : b2.to, clipEnd = Math.min(end, endB);
      if (a2.point || b2.point) {
        if (!(a2.point && b2.point && (a2.point == b2.point || a2.point.eq(b2.point)) && sameValues(a2.activeForPoint(a2.to), b2.activeForPoint(b2.to))))
          comparator.comparePoint(pos, clipEnd, a2.point, b2.point);
      } else {
        if (clipEnd > pos && !sameValues(a2.active, b2.active))
          comparator.compareRange(pos, clipEnd, a2.active, b2.active);
      }
      if (end > endB)
        break;
      pos = end;
      if (diff <= 0)
        a2.next();
      if (diff >= 0)
        b2.next();
    }
  }
  function sameValues(a2, b2) {
    if (a2.length != b2.length)
      return false;
    for (let i2 = 0; i2 < a2.length; i2++)
      if (a2[i2] != b2[i2] && !a2[i2].eq(b2[i2]))
        return false;
    return true;
  }
  function remove(array, index6) {
    for (let i2 = index6, e2 = array.length - 1; i2 < e2; i2++)
      array[i2] = array[i2 + 1];
    array.pop();
  }
  function insert9(array, index6, value12) {
    for (let i2 = array.length - 1; i2 >= index6; i2--)
      array[i2 + 1] = array[i2];
    array[index6] = value12;
  }
  function findMinIndex(value12, array) {
    let found = -1, foundPos = 1e9;
    for (let i2 = 0; i2 < array.length; i2++)
      if ((array[i2] - foundPos || value12[i2].endSide - value12[found].endSide) < 0) {
        found = i2;
        foundPos = array[i2];
      }
    return found;
  }
  function countColumn(string2, tabSize, to3 = string2.length) {
    let n2 = 0;
    for (let i2 = 0; i2 < to3; ) {
      if (string2.charCodeAt(i2) == 9) {
        n2 += tabSize - n2 % tabSize;
        i2++;
      } else {
        n2++;
        i2 = findClusterBreak(string2, i2);
      }
    }
    return n2;
  }
  function findColumn(string2, col, tabSize, strict) {
    for (let i2 = 0, n2 = 0; ; ) {
      if (n2 >= col)
        return i2;
      if (i2 == string2.length)
        break;
      n2 += string2.charCodeAt(i2) == 9 ? tabSize - n2 % tabSize : 1;
      i2 = findClusterBreak(string2, i2);
    }
    return strict === true ? -1 : string2.length;
  }

  // node_modules/style-mod/src/style-mod.js
  var C = "\u037C";
  var COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
  var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
  var top3 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
  var StyleModule = class {
    // :: (Object<Style>, ?{finish: ?(string) → string})
    // Create a style module from the given spec.
    //
    // When `finish` is given, it is called on regular (non-`@`)
    // selectors (after `&` expansion) to compute the final selector.
    constructor(spec, options2) {
      this.rules = [];
      let { finish } = options2 || {};
      function splitSelector(selector) {
        return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
      }
      function render2(selectors, spec2, target5, isKeyframes) {
        let local2 = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
        if (isAt && spec2 == null) return target5.push(selectors[0] + ";");
        for (let prop in spec2) {
          let value12 = spec2[prop];
          if (/&/.test(prop)) {
            render2(
              prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a2, b2) => a2.concat(b2)),
              value12,
              target5
            );
          } else if (value12 && typeof value12 == "object") {
            if (!isAt) throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
            render2(splitSelector(prop), value12, local2, keyframes);
          } else if (value12 != null) {
            local2.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l2) => "-" + l2.toLowerCase()) + ": " + value12 + ";");
          }
        }
        if (local2.length || keyframes) {
          target5.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local2.join(" ") + "}");
        }
      }
      for (let prop in spec) render2(splitSelector(prop), spec[prop], this.rules);
    }
    // :: () → string
    // Returns a string containing the module's CSS rules.
    getRules() {
      return this.rules.join("\n");
    }
    // :: () → string
    // Generate a new unique CSS class name.
    static newName() {
      let id5 = top3[COUNT] || 1;
      top3[COUNT] = id5 + 1;
      return C + id5.toString(36);
    }
    // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
    //
    // Mount the given set of modules in the given DOM root, which ensures
    // that the CSS rules defined by the module are available in that
    // context.
    //
    // Rules are only added to the document once per root.
    //
    // Rule order will follow the order of the modules, so that rules from
    // modules later in the array take precedence of those from earlier
    // modules. If you call this function multiple times for the same root
    // in a way that changes the order of already mounted modules, the old
    // order will be changed.
    //
    // If a Content Security Policy nonce is provided, it is added to
    // the `<style>` tag generated by the library.
    static mount(root, modules, options2) {
      let set = root[SET], nonce = options2 && options2.nonce;
      if (!set) set = new StyleSet(root, nonce);
      else if (nonce) set.setNonce(nonce);
      set.mount(Array.isArray(modules) ? modules : [modules], root);
    }
  };
  var adoptedSet = /* @__PURE__ */ new Map();
  var StyleSet = class {
    constructor(root, nonce) {
      let doc2 = root.ownerDocument || root, win = doc2.defaultView;
      if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {
        let adopted = adoptedSet.get(doc2);
        if (adopted) return root[SET] = adopted;
        this.sheet = new win.CSSStyleSheet();
        adoptedSet.set(doc2, this);
      } else {
        this.styleTag = doc2.createElement("style");
        if (nonce) this.styleTag.setAttribute("nonce", nonce);
      }
      this.modules = [];
      root[SET] = this;
    }
    mount(modules, root) {
      let sheet = this.sheet;
      let pos = 0, j2 = 0;
      for (let i2 = 0; i2 < modules.length; i2++) {
        let mod4 = modules[i2], index6 = this.modules.indexOf(mod4);
        if (index6 < j2 && index6 > -1) {
          this.modules.splice(index6, 1);
          j2--;
          index6 = -1;
        }
        if (index6 == -1) {
          this.modules.splice(j2++, 0, mod4);
          if (sheet) for (let k2 = 0; k2 < mod4.rules.length; k2++)
            sheet.insertRule(mod4.rules[k2], pos++);
        } else {
          while (j2 < index6) pos += this.modules[j2++].rules.length;
          pos += mod4.rules.length;
          j2++;
        }
      }
      if (sheet) {
        if (root.adoptedStyleSheets.indexOf(this.sheet) < 0)
          root.adoptedStyleSheets = [this.sheet, ...root.adoptedStyleSheets];
      } else {
        let text6 = "";
        for (let i2 = 0; i2 < this.modules.length; i2++)
          text6 += this.modules[i2].getRules() + "\n";
        this.styleTag.textContent = text6;
        let target5 = root.head || root;
        if (this.styleTag.parentNode != target5)
          target5.insertBefore(this.styleTag, target5.firstChild);
      }
    }
    setNonce(nonce) {
      if (this.styleTag && this.styleTag.getAttribute("nonce") != nonce)
        this.styleTag.setAttribute("nonce", nonce);
    }
  };

  // node_modules/w3c-keyname/index.js
  var base = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  };
  var shift = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
  };
  var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
  var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  for (i2 = 0; i2 < 10; i2++) base[48 + i2] = base[96 + i2] = String(i2);
  var i2;
  for (i2 = 1; i2 <= 24; i2++) base[i2 + 111] = "F" + i2;
  var i2;
  for (i2 = 65; i2 <= 90; i2++) {
    base[i2] = String.fromCharCode(i2 + 32);
    shift[i2] = String.fromCharCode(i2);
  }
  var i2;
  for (code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];
  var code;
  function keyName(event) {
    var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
    var name16 = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
    if (name16 == "Esc") name16 = "Escape";
    if (name16 == "Del") name16 = "Delete";
    if (name16 == "Left") name16 = "ArrowLeft";
    if (name16 == "Up") name16 = "ArrowUp";
    if (name16 == "Right") name16 = "ArrowRight";
    if (name16 == "Down") name16 = "ArrowDown";
    return name16;
  }

  // node_modules/@codemirror/view/dist/index.js
  function getSelection(root) {
    let target5;
    if (root.nodeType == 11) {
      target5 = root.getSelection ? root : root.ownerDocument;
    } else {
      target5 = root;
    }
    return target5.getSelection();
  }
  function contains2(dom, node) {
    return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
  }
  function hasSelection(dom, selection) {
    if (!selection.anchorNode)
      return false;
    try {
      return contains2(dom, selection.anchorNode);
    } catch (_) {
      return false;
    }
  }
  function clientRectsFor(dom) {
    if (dom.nodeType == 3)
      return textRange(dom, 0, dom.nodeValue.length).getClientRects();
    else if (dom.nodeType == 1)
      return dom.getClientRects();
    else
      return [];
  }
  function isEquivalentPosition(node, off, targetNode, targetOff) {
    return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
  }
  function domIndex(node) {
    for (var index6 = 0; ; index6++) {
      node = node.previousSibling;
      if (!node)
        return index6;
    }
  }
  function isBlockElement(node) {
    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
  }
  function scanFor(node, off, targetNode, targetOff, dir2) {
    for (; ; ) {
      if (node == targetNode && off == targetOff)
        return true;
      if (off == (dir2 < 0 ? 0 : maxOffset(node))) {
        if (node.nodeName == "DIV")
          return false;
        let parent2 = node.parentNode;
        if (!parent2 || parent2.nodeType != 1)
          return false;
        off = domIndex(node) + (dir2 < 0 ? 0 : 1);
        node = parent2;
      } else if (node.nodeType == 1) {
        node = node.childNodes[off + (dir2 < 0 ? -1 : 0)];
        if (node.nodeType == 1 && node.contentEditable == "false")
          return false;
        off = dir2 < 0 ? maxOffset(node) : 0;
      } else {
        return false;
      }
    }
  }
  function maxOffset(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
  }
  function flattenRect(rect, left) {
    let x2 = left ? rect.left : rect.right;
    return { left: x2, right: x2, top: rect.top, bottom: rect.bottom };
  }
  function windowRect(win) {
    let vp = win.visualViewport;
    if (vp)
      return {
        left: 0,
        right: vp.width,
        top: 0,
        bottom: vp.height
      };
    return {
      left: 0,
      right: win.innerWidth,
      top: 0,
      bottom: win.innerHeight
    };
  }
  function getScale(elt, rect) {
    let scaleX = rect.width / elt.offsetWidth;
    let scaleY = rect.height / elt.offsetHeight;
    if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt.offsetWidth) < 1)
      scaleX = 1;
    if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt.offsetHeight) < 1)
      scaleY = 1;
    return { scaleX, scaleY };
  }
  function scrollRectIntoView(dom, rect, side, x2, y2, xMargin, yMargin, ltr) {
    let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
    for (let cur2 = dom, stop = false; cur2 && !stop; ) {
      if (cur2.nodeType == 1) {
        let bounding, top4 = cur2 == doc2.body;
        let scaleX = 1, scaleY = 1;
        if (top4) {
          bounding = windowRect(win);
        } else {
          if (/^(fixed|sticky)$/.test(getComputedStyle(cur2).position))
            stop = true;
          if (cur2.scrollHeight <= cur2.clientHeight && cur2.scrollWidth <= cur2.clientWidth) {
            cur2 = cur2.assignedSlot || cur2.parentNode;
            continue;
          }
          let rect2 = cur2.getBoundingClientRect();
          ({ scaleX, scaleY } = getScale(cur2, rect2));
          bounding = {
            left: rect2.left,
            right: rect2.left + cur2.clientWidth * scaleX,
            top: rect2.top,
            bottom: rect2.top + cur2.clientHeight * scaleY
          };
        }
        let moveX = 0, moveY = 0;
        if (y2 == "nearest") {
          if (rect.top < bounding.top) {
            moveY = -(bounding.top - rect.top + yMargin);
            if (side > 0 && rect.bottom > bounding.bottom + moveY)
              moveY = rect.bottom - bounding.bottom + moveY + yMargin;
          } else if (rect.bottom > bounding.bottom) {
            moveY = rect.bottom - bounding.bottom + yMargin;
            if (side < 0 && rect.top - moveY < bounding.top)
              moveY = -(bounding.top + moveY - rect.top + yMargin);
          }
        } else {
          let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
          let targetTop = y2 == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y2 == "start" || y2 == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
          moveY = targetTop - bounding.top;
        }
        if (x2 == "nearest") {
          if (rect.left < bounding.left) {
            moveX = -(bounding.left - rect.left + xMargin);
            if (side > 0 && rect.right > bounding.right + moveX)
              moveX = rect.right - bounding.right + moveX + xMargin;
          } else if (rect.right > bounding.right) {
            moveX = rect.right - bounding.right + xMargin;
            if (side < 0 && rect.left < bounding.left + moveX)
              moveX = -(bounding.left + moveX - rect.left + xMargin);
          }
        } else {
          let targetLeft = x2 == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x2 == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
          moveX = targetLeft - bounding.left;
        }
        if (moveX || moveY) {
          if (top4) {
            win.scrollBy(moveX, moveY);
          } else {
            let movedX = 0, movedY = 0;
            if (moveY) {
              let start3 = cur2.scrollTop;
              cur2.scrollTop += moveY / scaleY;
              movedY = (cur2.scrollTop - start3) * scaleY;
            }
            if (moveX) {
              let start3 = cur2.scrollLeft;
              cur2.scrollLeft += moveX / scaleX;
              movedX = (cur2.scrollLeft - start3) * scaleX;
            }
            rect = {
              left: rect.left - movedX,
              top: rect.top - movedY,
              right: rect.right - movedX,
              bottom: rect.bottom - movedY
            };
            if (movedX && Math.abs(movedX - moveX) < 1)
              x2 = "nearest";
            if (movedY && Math.abs(movedY - moveY) < 1)
              y2 = "nearest";
          }
        }
        if (top4)
          break;
        cur2 = cur2.assignedSlot || cur2.parentNode;
      } else if (cur2.nodeType == 11) {
        cur2 = cur2.host;
      } else {
        break;
      }
    }
  }
  function scrollableParents(dom) {
    let doc2 = dom.ownerDocument, x2, y2;
    for (let cur2 = dom.parentNode; cur2; ) {
      if (cur2 == doc2.body || x2 && y2) {
        break;
      } else if (cur2.nodeType == 1) {
        if (!y2 && cur2.scrollHeight > cur2.clientHeight)
          y2 = cur2;
        if (!x2 && cur2.scrollWidth > cur2.clientWidth)
          x2 = cur2;
        cur2 = cur2.assignedSlot || cur2.parentNode;
      } else if (cur2.nodeType == 11) {
        cur2 = cur2.host;
      } else {
        break;
      }
    }
    return { x: x2, y: y2 };
  }
  var DOMSelectionState = class {
    constructor() {
      this.anchorNode = null;
      this.anchorOffset = 0;
      this.focusNode = null;
      this.focusOffset = 0;
    }
    eq(domSel) {
      return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
    }
    setRange(range3) {
      let { anchorNode, focusNode } = range3;
      this.set(anchorNode, Math.min(range3.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range3.focusOffset, focusNode ? maxOffset(focusNode) : 0));
    }
    set(anchorNode, anchorOffset, focusNode, focusOffset) {
      this.anchorNode = anchorNode;
      this.anchorOffset = anchorOffset;
      this.focusNode = focusNode;
      this.focusOffset = focusOffset;
    }
  };
  var preventScrollSupported = null;
  function focusPreventScroll(dom) {
    if (dom.setActive)
      return dom.setActive();
    if (preventScrollSupported)
      return dom.focus(preventScrollSupported);
    let stack = [];
    for (let cur2 = dom; cur2; cur2 = cur2.parentNode) {
      stack.push(cur2, cur2.scrollTop, cur2.scrollLeft);
      if (cur2 == cur2.ownerDocument)
        break;
    }
    dom.focus(preventScrollSupported == null ? {
      get preventScroll() {
        preventScrollSupported = { preventScroll: true };
        return true;
      }
    } : void 0);
    if (!preventScrollSupported) {
      preventScrollSupported = false;
      for (let i2 = 0; i2 < stack.length; ) {
        let elt = stack[i2++], top4 = stack[i2++], left = stack[i2++];
        if (elt.scrollTop != top4)
          elt.scrollTop = top4;
        if (elt.scrollLeft != left)
          elt.scrollLeft = left;
      }
    }
  }
  var scratchRange;
  function textRange(node, from3, to3 = from3) {
    let range3 = scratchRange || (scratchRange = document.createRange());
    range3.setEnd(node, to3);
    range3.setStart(node, from3);
    return range3;
  }
  function dispatchKey(elt, name16, code, mods) {
    let options2 = { key: name16, code: name16, keyCode: code, which: code, cancelable: true };
    if (mods)
      ({ altKey: options2.altKey, ctrlKey: options2.ctrlKey, shiftKey: options2.shiftKey, metaKey: options2.metaKey } = mods);
    let down = new KeyboardEvent("keydown", options2);
    down.synthetic = true;
    elt.dispatchEvent(down);
    let up = new KeyboardEvent("keyup", options2);
    up.synthetic = true;
    elt.dispatchEvent(up);
    return down.defaultPrevented || up.defaultPrevented;
  }
  function getRoot(node) {
    while (node) {
      if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
        return node;
      node = node.assignedSlot || node.parentNode;
    }
    return null;
  }
  function clearAttributes(node) {
    while (node.attributes.length)
      node.removeAttributeNode(node.attributes[0]);
  }
  function atElementStart(doc2, selection) {
    let node = selection.focusNode, offset = selection.focusOffset;
    if (!node || selection.anchorNode != node || selection.anchorOffset != offset)
      return false;
    offset = Math.min(offset, maxOffset(node));
    for (; ; ) {
      if (offset) {
        if (node.nodeType != 1)
          return false;
        let prev = node.childNodes[offset - 1];
        if (prev.contentEditable == "false")
          offset--;
        else {
          node = prev;
          offset = maxOffset(node);
        }
      } else if (node == doc2) {
        return true;
      } else {
        offset = domIndex(node);
        node = node.parentNode;
      }
    }
  }
  function isScrolledToBottom(elt) {
    return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);
  }
  function textNodeBefore(startNode, startOffset) {
    for (let node = startNode, offset = startOffset; ; ) {
      if (node.nodeType == 3 && offset > 0) {
        return { node, offset };
      } else if (node.nodeType == 1 && offset > 0) {
        if (node.contentEditable == "false")
          return null;
        node = node.childNodes[offset - 1];
        offset = maxOffset(node);
      } else if (node.parentNode && !isBlockElement(node)) {
        offset = domIndex(node);
        node = node.parentNode;
      } else {
        return null;
      }
    }
  }
  function textNodeAfter(startNode, startOffset) {
    for (let node = startNode, offset = startOffset; ; ) {
      if (node.nodeType == 3 && offset < node.nodeValue.length) {
        return { node, offset };
      } else if (node.nodeType == 1 && offset < node.childNodes.length) {
        if (node.contentEditable == "false")
          return null;
        node = node.childNodes[offset];
        offset = 0;
      } else if (node.parentNode && !isBlockElement(node)) {
        offset = domIndex(node) + 1;
        node = node.parentNode;
      } else {
        return null;
      }
    }
  }
  var DOMPos = class _DOMPos {
    constructor(node, offset, precise = true) {
      this.node = node;
      this.offset = offset;
      this.precise = precise;
    }
    static before(dom, precise) {
      return new _DOMPos(dom.parentNode, domIndex(dom), precise);
    }
    static after(dom, precise) {
      return new _DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
    }
  };
  var noChildren = [];
  var ContentView = class _ContentView {
    constructor() {
      this.parent = null;
      this.dom = null;
      this.flags = 2;
    }
    get overrideDOMText() {
      return null;
    }
    get posAtStart() {
      return this.parent ? this.parent.posBefore(this) : 0;
    }
    get posAtEnd() {
      return this.posAtStart + this.length;
    }
    posBefore(view2) {
      let pos = this.posAtStart;
      for (let child of this.children) {
        if (child == view2)
          return pos;
        pos += child.length + child.breakAfter;
      }
      throw new RangeError("Invalid child in posBefore");
    }
    posAfter(view2) {
      return this.posBefore(view2) + view2.length;
    }
    sync(view2, track) {
      if (this.flags & 2) {
        let parent2 = this.dom;
        let prev = null, next;
        for (let child of this.children) {
          if (child.flags & 7) {
            if (!child.dom && (next = prev ? prev.nextSibling : parent2.firstChild)) {
              let contentView = _ContentView.get(next);
              if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
                child.reuseDOM(next);
            }
            child.sync(view2, track);
            child.flags &= ~7;
          }
          next = prev ? prev.nextSibling : parent2.firstChild;
          if (track && !track.written && track.node == parent2 && next != child.dom)
            track.written = true;
          if (child.dom.parentNode == parent2) {
            while (next && next != child.dom)
              next = rm$1(next);
          } else {
            parent2.insertBefore(child.dom, next);
          }
          prev = child.dom;
        }
        next = prev ? prev.nextSibling : parent2.firstChild;
        if (next && track && track.node == parent2)
          track.written = true;
        while (next)
          next = rm$1(next);
      } else if (this.flags & 1) {
        for (let child of this.children)
          if (child.flags & 7) {
            child.sync(view2, track);
            child.flags &= ~7;
          }
      }
    }
    reuseDOM(_dom) {
    }
    localPosFromDOM(node, offset) {
      let after;
      if (node == this.dom) {
        after = this.dom.childNodes[offset];
      } else {
        let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
        for (; ; ) {
          let parent2 = node.parentNode;
          if (parent2 == this.dom)
            break;
          if (bias == 0 && parent2.firstChild != parent2.lastChild) {
            if (node == parent2.firstChild)
              bias = -1;
            else
              bias = 1;
          }
          node = parent2;
        }
        if (bias < 0)
          after = node;
        else
          after = node.nextSibling;
      }
      if (after == this.dom.firstChild)
        return 0;
      while (after && !_ContentView.get(after))
        after = after.nextSibling;
      if (!after)
        return this.length;
      for (let i2 = 0, pos = 0; ; i2++) {
        let child = this.children[i2];
        if (child.dom == after)
          return pos;
        pos += child.length + child.breakAfter;
      }
    }
    domBoundsAround(from3, to3, offset = 0) {
      let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
      for (let i2 = 0, pos = offset, prevEnd = offset; i2 < this.children.length; i2++) {
        let child = this.children[i2], end = pos + child.length;
        if (pos < from3 && end > to3)
          return child.domBoundsAround(from3, to3, pos);
        if (end >= from3 && fromI == -1) {
          fromI = i2;
          fromStart = pos;
        }
        if (pos > to3 && child.dom.parentNode == this.dom) {
          toI = i2;
          toEnd = prevEnd;
          break;
        }
        prevEnd = end;
        pos = end + child.breakAfter;
      }
      return {
        from: fromStart,
        to: toEnd < 0 ? offset + this.length : toEnd,
        startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
        endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
      };
    }
    markDirty(andParent = false) {
      this.flags |= 2;
      this.markParentsDirty(andParent);
    }
    markParentsDirty(childList) {
      for (let parent2 = this.parent; parent2; parent2 = parent2.parent) {
        if (childList)
          parent2.flags |= 2;
        if (parent2.flags & 1)
          return;
        parent2.flags |= 1;
        childList = false;
      }
    }
    setParent(parent2) {
      if (this.parent != parent2) {
        this.parent = parent2;
        if (this.flags & 7)
          this.markParentsDirty(true);
      }
    }
    setDOM(dom) {
      if (this.dom == dom)
        return;
      if (this.dom)
        this.dom.cmView = null;
      this.dom = dom;
      dom.cmView = this;
    }
    get rootView() {
      for (let v2 = this; ; ) {
        let parent2 = v2.parent;
        if (!parent2)
          return v2;
        v2 = parent2;
      }
    }
    replaceChildren(from3, to3, children2 = noChildren) {
      this.markDirty();
      for (let i2 = from3; i2 < to3; i2++) {
        let child = this.children[i2];
        if (child.parent == this && children2.indexOf(child) < 0)
          child.destroy();
      }
      if (children2.length < 250)
        this.children.splice(from3, to3 - from3, ...children2);
      else
        this.children = [].concat(this.children.slice(0, from3), children2, this.children.slice(to3));
      for (let i2 = 0; i2 < children2.length; i2++)
        children2[i2].setParent(this);
    }
    ignoreMutation(_rec) {
      return false;
    }
    ignoreEvent(_event) {
      return false;
    }
    childCursor(pos = this.length) {
      return new ChildCursor(this.children, pos, this.children.length);
    }
    childPos(pos, bias = 1) {
      return this.childCursor().findPos(pos, bias);
    }
    toString() {
      let name16 = this.constructor.name.replace("View", "");
      return name16 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name16 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
    }
    static get(node) {
      return node.cmView;
    }
    get isEditable() {
      return true;
    }
    get isWidget() {
      return false;
    }
    get isHidden() {
      return false;
    }
    merge(from3, to3, source3, hasStart, openStart, openEnd) {
      return false;
    }
    become(other) {
      return false;
    }
    canReuseDOM(other) {
      return other.constructor == this.constructor && !((this.flags | other.flags) & 8);
    }
    // When this is a zero-length view with a side, this should return a
    // number <= 0 to indicate it is before its position, or a
    // number > 0 when after its position.
    getSide() {
      return 0;
    }
    destroy() {
      for (let child of this.children)
        if (child.parent == this)
          child.destroy();
      this.parent = null;
    }
  };
  ContentView.prototype.breakAfter = 0;
  function rm$1(dom) {
    let next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
  }
  var ChildCursor = class {
    constructor(children2, pos, i2) {
      this.children = children2;
      this.pos = pos;
      this.i = i2;
      this.off = 0;
    }
    findPos(pos, bias = 1) {
      for (; ; ) {
        if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
          this.off = pos - this.pos;
          return this;
        }
        let next = this.children[--this.i];
        this.pos -= next.length + next.breakAfter;
      }
    }
  };
  function replaceRange(parent2, fromI, fromOff, toI, toOff, insert10, breakAtStart, openStart, openEnd) {
    let { children: children2 } = parent2;
    let before = children2.length ? children2[fromI] : null;
    let last4 = insert10.length ? insert10[insert10.length - 1] : null;
    let breakAtEnd = last4 ? last4.breakAfter : breakAtStart;
    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert10.length < 2 && before.merge(fromOff, toOff, insert10.length ? last4 : null, fromOff == 0, openStart, openEnd))
      return;
    if (toI < children2.length) {
      let after = children2[toI];
      if (after && (toOff < after.length || after.breakAfter && (last4 === null || last4 === void 0 ? void 0 : last4.breakAfter))) {
        if (fromI == toI) {
          after = after.split(toOff);
          toOff = 0;
        }
        if (!breakAtEnd && last4 && after.merge(0, toOff, last4, true, 0, openEnd)) {
          insert10[insert10.length - 1] = after;
        } else {
          if (toOff || after.children.length && !after.children[0].length)
            after.merge(0, toOff, null, false, 0, openEnd);
          insert10.push(after);
        }
      } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
        if (last4)
          last4.breakAfter = 1;
        else
          breakAtStart = 1;
      }
      toI++;
    }
    if (before) {
      before.breakAfter = breakAtStart;
      if (fromOff > 0) {
        if (!breakAtStart && insert10.length && before.merge(fromOff, before.length, insert10[0], false, openStart, 0)) {
          before.breakAfter = insert10.shift().breakAfter;
        } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
          before.merge(fromOff, before.length, null, false, openStart, 0);
        }
        fromI++;
      }
    }
    while (fromI < toI && insert10.length) {
      if (children2[toI - 1].become(insert10[insert10.length - 1])) {
        toI--;
        insert10.pop();
        openEnd = insert10.length ? 0 : openStart;
      } else if (children2[fromI].become(insert10[0])) {
        fromI++;
        insert10.shift();
        openStart = insert10.length ? 0 : openEnd;
      } else {
        break;
      }
    }
    if (!insert10.length && fromI && toI < children2.length && !children2[fromI - 1].breakAfter && children2[toI].merge(0, 0, children2[fromI - 1], false, openStart, openEnd))
      fromI--;
    if (fromI < toI || insert10.length)
      parent2.replaceChildren(fromI, toI, insert10);
  }
  function mergeChildrenInto(parent2, from3, to3, insert10, openStart, openEnd) {
    let cur2 = parent2.childCursor();
    let { i: toI, off: toOff } = cur2.findPos(to3, 1);
    let { i: fromI, off: fromOff } = cur2.findPos(from3, -1);
    let dLen = from3 - to3;
    for (let view2 of insert10)
      dLen += view2.length;
    parent2.length += dLen;
    replaceRange(parent2, fromI, fromOff, toI, toOff, insert10, 0, openStart, openEnd);
  }
  var nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
  var doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
  var ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent);
  var ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent);
  var ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
  var ie2 = !!(ie_upto10 || ie_11up || ie_edge);
  var gecko = !ie2 && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent);
  var chrome = !ie2 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent);
  var webkit = "webkitFontSmoothing" in doc.documentElement.style;
  var safari = !ie2 && /* @__PURE__ */ /Apple Computer/.test(nav.vendor);
  var ios = safari && (/* @__PURE__ */ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
  var browser = {
    mac: ios || /* @__PURE__ */ /Mac/.test(nav.platform),
    windows: /* @__PURE__ */ /Win/.test(nav.platform),
    linux: /* @__PURE__ */ /Linux|X11/.test(nav.platform),
    ie: ie2,
    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
    gecko,
    gecko_version: gecko ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    chrome: !!chrome,
    chrome_version: chrome ? +chrome[1] : 0,
    ios,
    android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
    webkit,
    safari,
    webkit_version: webkit ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
  };
  var MaxJoinLen = 256;
  var TextView = class _TextView extends ContentView {
    constructor(text6) {
      super();
      this.text = text6;
    }
    get length() {
      return this.text.length;
    }
    createDOM(textDOM) {
      this.setDOM(textDOM || document.createTextNode(this.text));
    }
    sync(view2, track) {
      if (!this.dom)
        this.createDOM();
      if (this.dom.nodeValue != this.text) {
        if (track && track.node == this.dom)
          track.written = true;
        this.dom.nodeValue = this.text;
      }
    }
    reuseDOM(dom) {
      if (dom.nodeType == 3)
        this.createDOM(dom);
    }
    merge(from3, to3, source3) {
      if (this.flags & 8 || source3 && (!(source3 instanceof _TextView) || this.length - (to3 - from3) + source3.length > MaxJoinLen || source3.flags & 8))
        return false;
      this.text = this.text.slice(0, from3) + (source3 ? source3.text : "") + this.text.slice(to3);
      this.markDirty();
      return true;
    }
    split(from3) {
      let result = new _TextView(this.text.slice(from3));
      this.text = this.text.slice(0, from3);
      this.markDirty();
      result.flags |= this.flags & 8;
      return result;
    }
    localPosFromDOM(node, offset) {
      return node == this.dom ? offset : offset ? this.text.length : 0;
    }
    domAtPos(pos) {
      return new DOMPos(this.dom, pos);
    }
    domBoundsAround(_from, _to, offset) {
      return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
    }
    coordsAt(pos, side) {
      return textCoords(this.dom, pos, side);
    }
  };
  var MarkView = class _MarkView extends ContentView {
    constructor(mark, children2 = [], length9 = 0) {
      super();
      this.mark = mark;
      this.children = children2;
      this.length = length9;
      for (let ch of children2)
        ch.setParent(this);
    }
    setAttrs(dom) {
      clearAttributes(dom);
      if (this.mark.class)
        dom.className = this.mark.class;
      if (this.mark.attrs)
        for (let name16 in this.mark.attrs)
          dom.setAttribute(name16, this.mark.attrs[name16]);
      return dom;
    }
    canReuseDOM(other) {
      return super.canReuseDOM(other) && !((this.flags | other.flags) & 8);
    }
    reuseDOM(node) {
      if (node.nodeName == this.mark.tagName.toUpperCase()) {
        this.setDOM(node);
        this.flags |= 4 | 2;
      }
    }
    sync(view2, track) {
      if (!this.dom)
        this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
      else if (this.flags & 4)
        this.setAttrs(this.dom);
      super.sync(view2, track);
    }
    merge(from3, to3, source3, _hasStart, openStart, openEnd) {
      if (source3 && (!(source3 instanceof _MarkView && source3.mark.eq(this.mark)) || from3 && openStart <= 0 || to3 < this.length && openEnd <= 0))
        return false;
      mergeChildrenInto(this, from3, to3, source3 ? source3.children.slice() : [], openStart - 1, openEnd - 1);
      this.markDirty();
      return true;
    }
    split(from3) {
      let result = [], off = 0, detachFrom = -1, i2 = 0;
      for (let elt of this.children) {
        let end = off + elt.length;
        if (end > from3)
          result.push(off < from3 ? elt.split(from3 - off) : elt);
        if (detachFrom < 0 && off >= from3)
          detachFrom = i2;
        off = end;
        i2++;
      }
      let length9 = this.length - from3;
      this.length = from3;
      if (detachFrom > -1) {
        this.children.length = detachFrom;
        this.markDirty();
      }
      return new _MarkView(this.mark, result, length9);
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this, pos);
    }
    coordsAt(pos, side) {
      return coordsInChildren(this, pos, side);
    }
  };
  function textCoords(text6, pos, side) {
    let length9 = text6.nodeValue.length;
    if (pos > length9)
      pos = length9;
    let from3 = pos, to3 = pos, flatten2 = 0;
    if (pos == 0 && side < 0 || pos == length9 && side >= 0) {
      if (!(browser.chrome || browser.gecko)) {
        if (pos) {
          from3--;
          flatten2 = 1;
        } else if (to3 < length9) {
          to3++;
          flatten2 = -1;
        }
      }
    } else {
      if (side < 0)
        from3--;
      else if (to3 < length9)
        to3++;
    }
    let rects = textRange(text6, from3, to3).getClientRects();
    if (!rects.length)
      return null;
    let rect = rects[(flatten2 ? flatten2 < 0 : side >= 0) ? 0 : rects.length - 1];
    if (browser.safari && !flatten2 && rect.width == 0)
      rect = Array.prototype.find.call(rects, (r2) => r2.width) || rect;
    return flatten2 ? flattenRect(rect, flatten2 < 0) : rect || null;
  }
  var WidgetView = class _WidgetView extends ContentView {
    static create(widget, length9, side) {
      return new _WidgetView(widget, length9, side);
    }
    constructor(widget, length9, side) {
      super();
      this.widget = widget;
      this.length = length9;
      this.side = side;
      this.prevWidget = null;
    }
    split(from3) {
      let result = _WidgetView.create(this.widget, this.length - from3, this.side);
      this.length -= from3;
      return result;
    }
    sync(view2) {
      if (!this.dom || !this.widget.updateDOM(this.dom, view2)) {
        if (this.dom && this.prevWidget)
          this.prevWidget.destroy(this.dom);
        this.prevWidget = null;
        this.setDOM(this.widget.toDOM(view2));
        if (!this.widget.editable)
          this.dom.contentEditable = "false";
      }
    }
    getSide() {
      return this.side;
    }
    merge(from3, to3, source3, hasStart, openStart, openEnd) {
      if (source3 && (!(source3 instanceof _WidgetView) || !this.widget.compare(source3.widget) || from3 > 0 && openStart <= 0 || to3 < this.length && openEnd <= 0))
        return false;
      this.length = from3 + (source3 ? source3.length : 0) + (this.length - to3);
      return true;
    }
    become(other) {
      if (other instanceof _WidgetView && other.side == this.side && this.widget.constructor == other.widget.constructor) {
        if (!this.widget.compare(other.widget))
          this.markDirty(true);
        if (this.dom && !this.prevWidget)
          this.prevWidget = this.widget;
        this.widget = other.widget;
        this.length = other.length;
        return true;
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event) {
      return this.widget.ignoreEvent(event);
    }
    get overrideDOMText() {
      if (this.length == 0)
        return Text2.empty;
      let top4 = this;
      while (top4.parent)
        top4 = top4.parent;
      let { view: view2 } = top4, text6 = view2 && view2.state.doc, start3 = this.posAtStart;
      return text6 ? text6.slice(start3, start3 + this.length) : Text2.empty;
    }
    domAtPos(pos) {
      return (this.length ? pos == 0 : this.side > 0) ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos, side) {
      let custom = this.widget.coordsAt(this.dom, pos, side);
      if (custom)
        return custom;
      let rects = this.dom.getClientRects(), rect = null;
      if (!rects.length)
        return null;
      let fromBack = this.side ? this.side < 0 : pos > 0;
      for (let i2 = fromBack ? rects.length - 1 : 0; ; i2 += fromBack ? -1 : 1) {
        rect = rects[i2];
        if (pos > 0 ? i2 == 0 : i2 == rects.length - 1 || rect.top < rect.bottom)
          break;
      }
      return flattenRect(rect, !fromBack);
    }
    get isEditable() {
      return false;
    }
    get isWidget() {
      return true;
    }
    get isHidden() {
      return this.widget.isHidden;
    }
    destroy() {
      super.destroy();
      if (this.dom)
        this.widget.destroy(this.dom);
    }
  };
  var WidgetBufferView = class _WidgetBufferView extends ContentView {
    constructor(side) {
      super();
      this.side = side;
    }
    get length() {
      return 0;
    }
    merge() {
      return false;
    }
    become(other) {
      return other instanceof _WidgetBufferView && other.side == this.side;
    }
    split() {
      return new _WidgetBufferView(this.side);
    }
    sync() {
      if (!this.dom) {
        let dom = document.createElement("img");
        dom.className = "cm-widgetBuffer";
        dom.setAttribute("aria-hidden", "true");
        this.setDOM(dom);
      }
    }
    getSide() {
      return this.side;
    }
    domAtPos(pos) {
      return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom);
    }
    localPosFromDOM() {
      return 0;
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos) {
      return this.dom.getBoundingClientRect();
    }
    get overrideDOMText() {
      return Text2.empty;
    }
    get isHidden() {
      return true;
    }
  };
  TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
  function inlineDOMAtPos(parent2, pos) {
    let dom = parent2.dom, { children: children2 } = parent2, i2 = 0;
    for (let off = 0; i2 < children2.length; i2++) {
      let child = children2[i2], end = off + child.length;
      if (end == off && child.getSide() <= 0)
        continue;
      if (pos > off && pos < end && child.dom.parentNode == dom)
        return child.domAtPos(pos - off);
      if (pos <= off)
        break;
      off = end;
    }
    for (let j2 = i2; j2 > 0; j2--) {
      let prev = children2[j2 - 1];
      if (prev.dom.parentNode == dom)
        return prev.domAtPos(prev.length);
    }
    for (let j2 = i2; j2 < children2.length; j2++) {
      let next = children2[j2];
      if (next.dom.parentNode == dom)
        return next.domAtPos(0);
    }
    return new DOMPos(dom, 0);
  }
  function joinInlineInto(parent2, view2, open) {
    let last4, { children: children2 } = parent2;
    if (open > 0 && view2 instanceof MarkView && children2.length && (last4 = children2[children2.length - 1]) instanceof MarkView && last4.mark.eq(view2.mark)) {
      joinInlineInto(last4, view2.children[0], open - 1);
    } else {
      children2.push(view2);
      view2.setParent(parent2);
    }
    parent2.length += view2.length;
  }
  function coordsInChildren(view2, pos, side) {
    let before = null, beforePos = -1, after = null, afterPos = -1;
    function scan(view3, pos2) {
      for (let i2 = 0, off = 0; i2 < view3.children.length && off <= pos2; i2++) {
        let child = view3.children[i2], end = off + child.length;
        if (end >= pos2) {
          if (child.children.length) {
            scan(child, pos2 - off);
          } else if ((!after || after.isHidden && side > 0) && (end > pos2 || off == end && child.getSide() > 0)) {
            after = child;
            afterPos = pos2 - off;
          } else if (off < pos2 || off == end && child.getSide() < 0 && !child.isHidden) {
            before = child;
            beforePos = pos2 - off;
          }
        }
        off = end;
      }
    }
    scan(view2, pos);
    let target5 = (side < 0 ? before : after) || before || after;
    if (target5)
      return target5.coordsAt(Math.max(0, target5 == before ? beforePos : afterPos), side);
    return fallbackRect(view2);
  }
  function fallbackRect(view2) {
    let last4 = view2.dom.lastChild;
    if (!last4)
      return view2.dom.getBoundingClientRect();
    let rects = clientRectsFor(last4);
    return rects[rects.length - 1] || null;
  }
  function combineAttrs(source3, target5) {
    for (let name16 in source3) {
      if (name16 == "class" && target5.class)
        target5.class += " " + source3.class;
      else if (name16 == "style" && target5.style)
        target5.style += ";" + source3.style;
      else
        target5[name16] = source3[name16];
    }
    return target5;
  }
  var noAttrs = /* @__PURE__ */ Object.create(null);
  function attrsEq(a2, b2, ignore) {
    if (a2 == b2)
      return true;
    if (!a2)
      a2 = noAttrs;
    if (!b2)
      b2 = noAttrs;
    let keysA = Object.keys(a2), keysB = Object.keys(b2);
    if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) != keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0))
      return false;
    for (let key of keysA) {
      if (key != ignore && (keysB.indexOf(key) == -1 || a2[key] !== b2[key]))
        return false;
    }
    return true;
  }
  function updateAttrs(dom, prev, attrs) {
    let changed = false;
    if (prev) {
      for (let name16 in prev)
        if (!(attrs && name16 in attrs)) {
          changed = true;
          if (name16 == "style")
            dom.style.cssText = "";
          else
            dom.removeAttribute(name16);
        }
    }
    if (attrs) {
      for (let name16 in attrs)
        if (!(prev && prev[name16] == attrs[name16])) {
          changed = true;
          if (name16 == "style")
            dom.style.cssText = attrs[name16];
          else
            dom.setAttribute(name16, attrs[name16]);
        }
    }
    return changed;
  }
  function getAttrs(dom) {
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let i2 = 0; i2 < dom.attributes.length; i2++) {
      let attr = dom.attributes[i2];
      attrs[attr.name] = attr.value;
    }
    return attrs;
  }
  var WidgetType = class {
    /**
    Compare this instance to another instance of the same type.
    (TypeScript can't express this, but only instances of the same
    specific class will be passed to this method.) This is used to
    avoid redrawing widgets when they are replaced by a new
    decoration of the same type. The default implementation just
    returns `false`, which will cause new instances of the widget to
    always be redrawn.
    */
    eq(widget) {
      return false;
    }
    /**
    Update a DOM element created by a widget of the same type (but
    different, non-`eq` content) to reflect this widget. May return
    true to indicate that it could update, false to indicate it
    couldn't (in which case the widget will be redrawn). The default
    implementation just returns false.
    */
    updateDOM(dom, view2) {
      return false;
    }
    /**
    @internal
    */
    compare(other) {
      return this == other || this.constructor == other.constructor && this.eq(other);
    }
    /**
    The estimated height this widget will have, to be used when
    estimating the height of content that hasn't been drawn. May
    return -1 to indicate you don't know. The default implementation
    returns -1.
    */
    get estimatedHeight() {
      return -1;
    }
    /**
    For inline widgets that are displayed inline (as opposed to
    `inline-block`) and introduce line breaks (through `<br>` tags
    or textual newlines), this must indicate the amount of line
    breaks they introduce. Defaults to 0.
    */
    get lineBreaks() {
      return 0;
    }
    /**
    Can be used to configure which kinds of events inside the widget
    should be ignored by the editor. The default is to ignore all
    events.
    */
    ignoreEvent(event) {
      return true;
    }
    /**
    Override the way screen coordinates for positions at/in the
    widget are found. `pos` will be the offset into the widget, and
    `side` the side of the position that is being queried—less than
    zero for before, greater than zero for after, and zero for
    directly at that position.
    */
    coordsAt(dom, pos, side) {
      return null;
    }
    /**
    @internal
    */
    get isHidden() {
      return false;
    }
    /**
    @internal
    */
    get editable() {
      return false;
    }
    /**
    This is called when the an instance of the widget is removed
    from the editor view.
    */
    destroy(dom) {
    }
  };
  var BlockType = /* @__PURE__ */ function(BlockType2) {
    BlockType2[BlockType2["Text"] = 0] = "Text";
    BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
    BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
    BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
    return BlockType2;
  }(BlockType || (BlockType = {}));
  var Decoration = class extends RangeValue {
    constructor(startSide, endSide, widget, spec) {
      super();
      this.startSide = startSide;
      this.endSide = endSide;
      this.widget = widget;
      this.spec = spec;
    }
    /**
    @internal
    */
    get heightRelevant() {
      return false;
    }
    /**
    Create a mark decoration, which influences the styling of the
    content in its range. Nested mark decorations will cause nested
    DOM elements to be created. Nesting order is determined by
    precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
    the higher-precedence decorations creating the inner DOM nodes.
    Such elements are split on line boundaries and on the boundaries
    of lower-precedence decorations.
    */
    static mark(spec) {
      return new MarkDecoration(spec);
    }
    /**
    Create a widget decoration, which displays a DOM element at the
    given position.
    */
    static widget(spec) {
      let side = Math.max(-1e4, Math.min(1e4, spec.side || 0)), block = !!spec.block;
      side += block && !spec.inlineOrder ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
      return new PointDecoration(spec, side, side, block, spec.widget || null, false);
    }
    /**
    Create a replace decoration which replaces the given range with
    a widget, or simply hides it.
    */
    static replace(spec) {
      let block = !!spec.block, startSide, endSide;
      if (spec.isBlockGap) {
        startSide = -5e8;
        endSide = 4e8;
      } else {
        let { start: start3, end } = getInclusive(spec, block);
        startSide = (start3 ? block ? -3e8 : -1 : 5e8) - 1;
        endSide = (end ? block ? 2e8 : 1 : -6e8) + 1;
      }
      return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
    }
    /**
    Create a line decoration, which can add DOM attributes to the
    line starting at the given position.
    */
    static line(spec) {
      return new LineDecoration(spec);
    }
    /**
    Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
    decorated range or ranges. If the ranges aren't already sorted,
    pass `true` for `sort` to make the library sort them for you.
    */
    static set(of, sort2 = false) {
      return RangeSet.of(of, sort2);
    }
    /**
    @internal
    */
    hasHeight() {
      return this.widget ? this.widget.estimatedHeight > -1 : false;
    }
  };
  Decoration.none = RangeSet.empty;
  var MarkDecoration = class _MarkDecoration extends Decoration {
    constructor(spec) {
      let { start: start3, end } = getInclusive(spec);
      super(start3 ? -1 : 5e8, end ? 1 : -6e8, null, spec);
      this.tagName = spec.tagName || "span";
      this.class = spec.class || "";
      this.attrs = spec.attributes || null;
    }
    eq(other) {
      var _a2, _b;
      return this == other || other instanceof _MarkDecoration && this.tagName == other.tagName && (this.class || ((_a2 = this.attrs) === null || _a2 === void 0 ? void 0 : _a2.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) && attrsEq(this.attrs, other.attrs, "class");
    }
    range(from3, to3 = from3) {
      if (from3 >= to3)
        throw new RangeError("Mark decorations may not be empty");
      return super.range(from3, to3);
    }
  };
  MarkDecoration.prototype.point = false;
  var LineDecoration = class _LineDecoration extends Decoration {
    constructor(spec) {
      super(-2e8, -2e8, null, spec);
    }
    eq(other) {
      return other instanceof _LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);
    }
    range(from3, to3 = from3) {
      if (to3 != from3)
        throw new RangeError("Line decoration ranges must be zero-length");
      return super.range(from3, to3);
    }
  };
  LineDecoration.prototype.mapMode = MapMode.TrackBefore;
  LineDecoration.prototype.point = true;
  var PointDecoration = class _PointDecoration extends Decoration {
    constructor(spec, startSide, endSide, block, widget, isReplace) {
      super(startSide, endSide, widget, spec);
      this.block = block;
      this.isReplace = isReplace;
      this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
    }
    // Only relevant when this.block == true
    get type() {
      return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
    }
    get heightRelevant() {
      return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
    }
    eq(other) {
      return other instanceof _PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
    }
    range(from3, to3 = from3) {
      if (this.isReplace && (from3 > to3 || from3 == to3 && this.startSide > 0 && this.endSide <= 0))
        throw new RangeError("Invalid range for replacement decoration");
      if (!this.isReplace && to3 != from3)
        throw new RangeError("Widget decorations can only have zero-length ranges");
      return super.range(from3, to3);
    }
  };
  PointDecoration.prototype.point = true;
  function getInclusive(spec, block = false) {
    let { inclusiveStart: start3, inclusiveEnd: end } = spec;
    if (start3 == null)
      start3 = spec.inclusive;
    if (end == null)
      end = spec.inclusive;
    return { start: start3 !== null && start3 !== void 0 ? start3 : block, end: end !== null && end !== void 0 ? end : block };
  }
  function widgetsEq(a2, b2) {
    return a2 == b2 || !!(a2 && b2 && a2.compare(b2));
  }
  function addRange(from3, to3, ranges, margin = 0) {
    let last4 = ranges.length - 1;
    if (last4 >= 0 && ranges[last4] + margin >= from3)
      ranges[last4] = Math.max(ranges[last4], to3);
    else
      ranges.push(from3, to3);
  }
  var LineView = class _LineView extends ContentView {
    constructor() {
      super(...arguments);
      this.children = [];
      this.length = 0;
      this.prevAttrs = void 0;
      this.attrs = null;
      this.breakAfter = 0;
    }
    // Consumes source
    merge(from3, to3, source3, hasStart, openStart, openEnd) {
      if (source3) {
        if (!(source3 instanceof _LineView))
          return false;
        if (!this.dom)
          source3.transferDOM(this);
      }
      if (hasStart)
        this.setDeco(source3 ? source3.attrs : null);
      mergeChildrenInto(this, from3, to3, source3 ? source3.children.slice() : [], openStart, openEnd);
      return true;
    }
    split(at) {
      let end = new _LineView();
      end.breakAfter = this.breakAfter;
      if (this.length == 0)
        return end;
      let { i: i2, off } = this.childPos(at);
      if (off) {
        end.append(this.children[i2].split(off), 0);
        this.children[i2].merge(off, this.children[i2].length, null, false, 0, 0);
        i2++;
      }
      for (let j2 = i2; j2 < this.children.length; j2++)
        end.append(this.children[j2], 0);
      while (i2 > 0 && this.children[i2 - 1].length == 0)
        this.children[--i2].destroy();
      this.children.length = i2;
      this.markDirty();
      this.length = at;
      return end;
    }
    transferDOM(other) {
      if (!this.dom)
        return;
      this.markDirty();
      other.setDOM(this.dom);
      other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
      this.prevAttrs = void 0;
      this.dom = null;
    }
    setDeco(attrs) {
      if (!attrsEq(this.attrs, attrs)) {
        if (this.dom) {
          this.prevAttrs = this.attrs;
          this.markDirty();
        }
        this.attrs = attrs;
      }
    }
    append(child, openStart) {
      joinInlineInto(this, child, openStart);
    }
    // Only called when building a line view in ContentBuilder
    addLineDeco(deco) {
      let attrs = deco.spec.attributes, cls = deco.spec.class;
      if (attrs)
        this.attrs = combineAttrs(attrs, this.attrs || {});
      if (cls)
        this.attrs = combineAttrs({ class: cls }, this.attrs || {});
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this, pos);
    }
    reuseDOM(node) {
      if (node.nodeName == "DIV") {
        this.setDOM(node);
        this.flags |= 4 | 2;
      }
    }
    sync(view2, track) {
      var _a2;
      if (!this.dom) {
        this.setDOM(document.createElement("div"));
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      } else if (this.flags & 4) {
        clearAttributes(this.dom);
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      }
      if (this.prevAttrs !== void 0) {
        updateAttrs(this.dom, this.prevAttrs, this.attrs);
        this.dom.classList.add("cm-line");
        this.prevAttrs = void 0;
      }
      super.sync(view2, track);
      let last4 = this.dom.lastChild;
      while (last4 && ContentView.get(last4) instanceof MarkView)
        last4 = last4.lastChild;
      if (!last4 || !this.length || last4.nodeName != "BR" && ((_a2 = ContentView.get(last4)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) == false && (!browser.ios || !this.children.some((ch) => ch instanceof TextView))) {
        let hack = document.createElement("BR");
        hack.cmIgnore = true;
        this.dom.appendChild(hack);
      }
    }
    measureTextSize() {
      if (this.children.length == 0 || this.length > 20)
        return null;
      let totalWidth = 0, textHeight;
      for (let child of this.children) {
        if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
          return null;
        let rects = clientRectsFor(child.dom);
        if (rects.length != 1)
          return null;
        totalWidth += rects[0].width;
        textHeight = rects[0].height;
      }
      return !totalWidth ? null : {
        lineHeight: this.dom.getBoundingClientRect().height,
        charWidth: totalWidth / this.length,
        textHeight
      };
    }
    coordsAt(pos, side) {
      let rect = coordsInChildren(this, pos, side);
      if (!this.children.length && rect && this.parent) {
        let { heightOracle } = this.parent.view.viewState, height8 = rect.bottom - rect.top;
        if (Math.abs(height8 - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height8) {
          let dist2 = (height8 - heightOracle.textHeight) / 2;
          return { top: rect.top + dist2, bottom: rect.bottom - dist2, left: rect.left, right: rect.left };
        }
      }
      return rect;
    }
    become(other) {
      return other instanceof _LineView && this.children.length == 0 && other.children.length == 0 && attrsEq(this.attrs, other.attrs) && this.breakAfter == other.breakAfter;
    }
    covers() {
      return true;
    }
    static find(docView, pos) {
      for (let i2 = 0, off = 0; i2 < docView.children.length; i2++) {
        let block = docView.children[i2], end = off + block.length;
        if (end >= pos) {
          if (block instanceof _LineView)
            return block;
          if (end > pos)
            break;
        }
        off = end + block.breakAfter;
      }
      return null;
    }
  };
  var BlockWidgetView = class _BlockWidgetView extends ContentView {
    constructor(widget, length9, deco) {
      super();
      this.widget = widget;
      this.length = length9;
      this.deco = deco;
      this.breakAfter = 0;
      this.prevWidget = null;
    }
    merge(from3, to3, source3, _takeDeco, openStart, openEnd) {
      if (source3 && (!(source3 instanceof _BlockWidgetView) || !this.widget.compare(source3.widget) || from3 > 0 && openStart <= 0 || to3 < this.length && openEnd <= 0))
        return false;
      this.length = from3 + (source3 ? source3.length : 0) + (this.length - to3);
      return true;
    }
    domAtPos(pos) {
      return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    split(at) {
      let len = this.length - at;
      this.length = at;
      let end = new _BlockWidgetView(this.widget, len, this.deco);
      end.breakAfter = this.breakAfter;
      return end;
    }
    get children() {
      return noChildren;
    }
    sync(view2) {
      if (!this.dom || !this.widget.updateDOM(this.dom, view2)) {
        if (this.dom && this.prevWidget)
          this.prevWidget.destroy(this.dom);
        this.prevWidget = null;
        this.setDOM(this.widget.toDOM(view2));
        if (!this.widget.editable)
          this.dom.contentEditable = "false";
      }
    }
    get overrideDOMText() {
      return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text2.empty;
    }
    domBoundsAround() {
      return null;
    }
    become(other) {
      if (other instanceof _BlockWidgetView && other.widget.constructor == this.widget.constructor) {
        if (!other.widget.compare(this.widget))
          this.markDirty(true);
        if (this.dom && !this.prevWidget)
          this.prevWidget = this.widget;
        this.widget = other.widget;
        this.length = other.length;
        this.deco = other.deco;
        this.breakAfter = other.breakAfter;
        return true;
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event) {
      return this.widget.ignoreEvent(event);
    }
    get isEditable() {
      return false;
    }
    get isWidget() {
      return true;
    }
    coordsAt(pos, side) {
      let custom = this.widget.coordsAt(this.dom, pos, side);
      if (custom)
        return custom;
      if (this.widget instanceof BlockGapWidget)
        return null;
      return flattenRect(this.dom.getBoundingClientRect(), this.length ? pos == 0 : side <= 0);
    }
    destroy() {
      super.destroy();
      if (this.dom)
        this.widget.destroy(this.dom);
    }
    covers(side) {
      let { startSide, endSide } = this.deco;
      return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;
    }
  };
  var BlockGapWidget = class extends WidgetType {
    constructor(height8) {
      super();
      this.height = height8;
    }
    toDOM() {
      let elt = document.createElement("div");
      elt.className = "cm-gap";
      this.updateDOM(elt);
      return elt;
    }
    eq(other) {
      return other.height == this.height;
    }
    updateDOM(elt) {
      elt.style.height = this.height + "px";
      return true;
    }
    get editable() {
      return true;
    }
    get estimatedHeight() {
      return this.height;
    }
    ignoreEvent() {
      return false;
    }
  };
  var ContentBuilder = class _ContentBuilder {
    constructor(doc2, pos, end, disallowBlockEffectsFor) {
      this.doc = doc2;
      this.pos = pos;
      this.end = end;
      this.disallowBlockEffectsFor = disallowBlockEffectsFor;
      this.content = [];
      this.curLine = null;
      this.breakAtStart = 0;
      this.pendingBuffer = 0;
      this.bufferMarks = [];
      this.atCursorPos = true;
      this.openStart = -1;
      this.openEnd = -1;
      this.text = "";
      this.textOff = 0;
      this.cursor = doc2.iter();
      this.skip = pos;
    }
    posCovered() {
      if (this.content.length == 0)
        return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
      let last4 = this.content[this.content.length - 1];
      return !(last4.breakAfter || last4 instanceof BlockWidgetView && last4.deco.endSide < 0);
    }
    getLine() {
      if (!this.curLine) {
        this.content.push(this.curLine = new LineView());
        this.atCursorPos = true;
      }
      return this.curLine;
    }
    flushBuffer(active = this.bufferMarks) {
      if (this.pendingBuffer) {
        this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
        this.pendingBuffer = 0;
      }
    }
    addBlockWidget(view2) {
      this.flushBuffer();
      this.curLine = null;
      this.content.push(view2);
    }
    finish(openEnd) {
      if (this.pendingBuffer && openEnd <= this.bufferMarks.length)
        this.flushBuffer();
      else
        this.pendingBuffer = 0;
      if (!this.posCovered() && !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView))
        this.getLine();
    }
    buildText(length9, active, openStart) {
      while (length9 > 0) {
        if (this.textOff == this.text.length) {
          let { value: value12, lineBreak, done } = this.cursor.next(this.skip);
          this.skip = 0;
          if (done)
            throw new Error("Ran out of text content when drawing inline views");
          if (lineBreak) {
            if (!this.posCovered())
              this.getLine();
            if (this.content.length)
              this.content[this.content.length - 1].breakAfter = 1;
            else
              this.breakAtStart = 1;
            this.flushBuffer();
            this.curLine = null;
            this.atCursorPos = true;
            length9--;
            continue;
          } else {
            this.text = value12;
            this.textOff = 0;
          }
        }
        let take5 = Math.min(
          this.text.length - this.textOff,
          length9,
          512
          /* T.Chunk */
        );
        this.flushBuffer(active.slice(active.length - openStart));
        this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take5)), active), openStart);
        this.atCursorPos = true;
        this.textOff += take5;
        length9 -= take5;
        openStart = 0;
      }
    }
    span(from3, to3, active, openStart) {
      this.buildText(to3 - from3, active, openStart);
      this.pos = to3;
      if (this.openStart < 0)
        this.openStart = openStart;
    }
    point(from3, to3, deco, active, openStart, index6) {
      if (this.disallowBlockEffectsFor[index6] && deco instanceof PointDecoration) {
        if (deco.block)
          throw new RangeError("Block decorations may not be specified via plugins");
        if (to3 > this.doc.lineAt(this.pos).to)
          throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
      }
      let len = to3 - from3;
      if (deco instanceof PointDecoration) {
        if (deco.block) {
          if (deco.startSide > 0 && !this.posCovered())
            this.getLine();
          this.addBlockWidget(new BlockWidgetView(deco.widget || NullWidget.block, len, deco));
        } else {
          let view2 = WidgetView.create(deco.widget || NullWidget.inline, len, len ? 0 : deco.startSide);
          let cursorBefore = this.atCursorPos && !view2.isEditable && openStart <= active.length && (from3 < to3 || deco.startSide > 0);
          let cursorAfter = !view2.isEditable && (from3 < to3 || openStart > active.length || deco.startSide <= 0);
          let line = this.getLine();
          if (this.pendingBuffer == 2 && !cursorBefore && !view2.isEditable)
            this.pendingBuffer = 0;
          this.flushBuffer(active);
          if (cursorBefore) {
            line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
            openStart = active.length + Math.max(0, openStart - active.length);
          }
          line.append(wrapMarks(view2, active), openStart);
          this.atCursorPos = cursorAfter;
          this.pendingBuffer = !cursorAfter ? 0 : from3 < to3 || openStart > active.length ? 1 : 2;
          if (this.pendingBuffer)
            this.bufferMarks = active.slice();
        }
      } else if (this.doc.lineAt(this.pos).from == this.pos) {
        this.getLine().addLineDeco(deco);
      }
      if (len) {
        if (this.textOff + len <= this.text.length) {
          this.textOff += len;
        } else {
          this.skip += len - (this.text.length - this.textOff);
          this.text = "";
          this.textOff = 0;
        }
        this.pos = to3;
      }
      if (this.openStart < 0)
        this.openStart = openStart;
    }
    static build(text6, from3, to3, decorations2, dynamicDecorationMap) {
      let builder = new _ContentBuilder(text6, from3, to3, dynamicDecorationMap);
      builder.openEnd = RangeSet.spans(decorations2, from3, to3, builder);
      if (builder.openStart < 0)
        builder.openStart = builder.openEnd;
      builder.finish(builder.openEnd);
      return builder;
    }
  };
  function wrapMarks(view2, active) {
    for (let mark of active)
      view2 = new MarkView(mark, [view2], view2.length);
    return view2;
  }
  var NullWidget = class extends WidgetType {
    constructor(tag) {
      super();
      this.tag = tag;
    }
    eq(other) {
      return other.tag == this.tag;
    }
    toDOM() {
      return document.createElement(this.tag);
    }
    updateDOM(elt) {
      return elt.nodeName.toLowerCase() == this.tag;
    }
    get isHidden() {
      return true;
    }
  };
  NullWidget.inline = /* @__PURE__ */ new NullWidget("span");
  NullWidget.block = /* @__PURE__ */ new NullWidget("div");
  var Direction = /* @__PURE__ */ function(Direction2) {
    Direction2[Direction2["LTR"] = 0] = "LTR";
    Direction2[Direction2["RTL"] = 1] = "RTL";
    return Direction2;
  }(Direction || (Direction = {}));
  var LTR = Direction.LTR;
  var RTL = Direction.RTL;
  function dec(str) {
    let result = [];
    for (let i2 = 0; i2 < str.length; i2++)
      result.push(1 << +str[i2]);
    return result;
  }
  var LowTypes = /* @__PURE__ */ dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
  var ArabicTypes = /* @__PURE__ */ dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
  var Brackets = /* @__PURE__ */ Object.create(null);
  var BracketStack = [];
  for (let p2 of ["()", "[]", "{}"]) {
    let l2 = /* @__PURE__ */ p2.charCodeAt(0), r2 = /* @__PURE__ */ p2.charCodeAt(1);
    Brackets[l2] = r2;
    Brackets[r2] = -l2;
  }
  function charType(ch) {
    return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8204 ? 256 : 64336 <= ch && ch <= 65023 ? 4 : 1;
  }
  var BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
  var BidiSpan = class {
    /**
    The direction of this span.
    */
    get dir() {
      return this.level % 2 ? RTL : LTR;
    }
    /**
    @internal
    */
    constructor(from3, to3, level) {
      this.from = from3;
      this.to = to3;
      this.level = level;
    }
    /**
    @internal
    */
    side(end, dir2) {
      return this.dir == dir2 == end ? this.to : this.from;
    }
    /**
    @internal
    */
    forward(forward2, dir2) {
      return forward2 == (this.dir == dir2);
    }
    /**
    @internal
    */
    static find(order, index6, level, assoc) {
      let maybe2 = -1;
      for (let i2 = 0; i2 < order.length; i2++) {
        let span4 = order[i2];
        if (span4.from <= index6 && span4.to >= index6) {
          if (span4.level == level)
            return i2;
          if (maybe2 < 0 || (assoc != 0 ? assoc < 0 ? span4.from < index6 : span4.to > index6 : order[maybe2].level > span4.level))
            maybe2 = i2;
        }
      }
      if (maybe2 < 0)
        throw new RangeError("Index out of range");
      return maybe2;
    }
  };
  function isolatesEq(a2, b2) {
    if (a2.length != b2.length)
      return false;
    for (let i2 = 0; i2 < a2.length; i2++) {
      let iA = a2[i2], iB = b2[i2];
      if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner))
        return false;
    }
    return true;
  }
  var types = [];
  function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
    for (let iI = 0; iI <= isolates.length; iI++) {
      let from3 = iI ? isolates[iI - 1].to : rFrom, to3 = iI < isolates.length ? isolates[iI].from : rTo;
      let prevType = iI ? 256 : outerType;
      for (let i2 = from3, prev = prevType, prevStrong = prevType; i2 < to3; i2++) {
        let type = charType(line.charCodeAt(i2));
        if (type == 512)
          type = prev;
        else if (type == 8 && prevStrong == 4)
          type = 16;
        types[i2] = type == 4 ? 2 : type;
        if (type & 7)
          prevStrong = type;
        prev = type;
      }
      for (let i2 = from3, prev = prevType, prevStrong = prevType; i2 < to3; i2++) {
        let type = types[i2];
        if (type == 128) {
          if (i2 < to3 - 1 && prev == types[i2 + 1] && prev & 24)
            type = types[i2] = prev;
          else
            types[i2] = 256;
        } else if (type == 64) {
          let end = i2 + 1;
          while (end < to3 && types[end] == 64)
            end++;
          let replace5 = i2 && prev == 8 || end < rTo && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
          for (let j2 = i2; j2 < end; j2++)
            types[j2] = replace5;
          i2 = end - 1;
        } else if (type == 8 && prevStrong == 1) {
          types[i2] = 1;
        }
        prev = type;
        if (type & 7)
          prevStrong = type;
      }
    }
  }
  function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
    let oppositeType = outerType == 1 ? 2 : 1;
    for (let iI = 0, sI = 0, context3 = 0; iI <= isolates.length; iI++) {
      let from3 = iI ? isolates[iI - 1].to : rFrom, to3 = iI < isolates.length ? isolates[iI].from : rTo;
      for (let i2 = from3, ch, br, type; i2 < to3; i2++) {
        if (br = Brackets[ch = line.charCodeAt(i2)]) {
          if (br < 0) {
            for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
              if (BracketStack[sJ + 1] == -br) {
                let flags = BracketStack[sJ + 2];
                let type2 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
                if (type2)
                  types[i2] = types[BracketStack[sJ]] = type2;
                sI = sJ;
                break;
              }
            }
          } else if (BracketStack.length == 189) {
            break;
          } else {
            BracketStack[sI++] = i2;
            BracketStack[sI++] = ch;
            BracketStack[sI++] = context3;
          }
        } else if ((type = types[i2]) == 2 || type == 1) {
          let embed = type == outerType;
          context3 = embed ? 0 : 1;
          for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
            let cur2 = BracketStack[sJ + 2];
            if (cur2 & 2)
              break;
            if (embed) {
              BracketStack[sJ + 2] |= 2;
            } else {
              if (cur2 & 4)
                break;
              BracketStack[sJ + 2] |= 4;
            }
          }
        }
      }
    }
  }
  function processNeutrals(rFrom, rTo, isolates, outerType) {
    for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
      let from3 = iI ? isolates[iI - 1].to : rFrom, to3 = iI < isolates.length ? isolates[iI].from : rTo;
      for (let i2 = from3; i2 < to3; ) {
        let type = types[i2];
        if (type == 256) {
          let end = i2 + 1;
          for (; ; ) {
            if (end == to3) {
              if (iI == isolates.length)
                break;
              end = isolates[iI++].to;
              to3 = iI < isolates.length ? isolates[iI].from : rTo;
            } else if (types[end] == 256) {
              end++;
            } else {
              break;
            }
          }
          let beforeL = prev == 1;
          let afterL = (end < rTo ? types[end] : outerType) == 1;
          let replace5 = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
          for (let j2 = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j2 > i2; ) {
            if (j2 == fromJ) {
              j2 = isolates[--jI].from;
              fromJ = jI ? isolates[jI - 1].to : rFrom;
            }
            types[--j2] = replace5;
          }
          i2 = end;
        } else {
          prev = type;
          i2++;
        }
      }
    }
  }
  function emitSpans(line, from3, to3, level, baseLevel, isolates, order) {
    let ourType = level % 2 ? 2 : 1;
    if (level % 2 == baseLevel % 2) {
      for (let iCh = from3, iI = 0; iCh < to3; ) {
        let sameDir = true, isNum = false;
        if (iI == isolates.length || iCh < isolates[iI].from) {
          let next = types[iCh];
          if (next != ourType) {
            sameDir = false;
            isNum = next == 16;
          }
        }
        let recurse = !sameDir && ourType == 1 ? [] : null;
        let localLevel = sameDir ? level : level + 1;
        let iScan = iCh;
        run: for (; ; ) {
          if (iI < isolates.length && iScan == isolates[iI].from) {
            if (isNum)
              break run;
            let iso = isolates[iI];
            if (!sameDir)
              for (let upto = iso.to, jI = iI + 1; ; ) {
                if (upto == to3)
                  break run;
                if (jI < isolates.length && isolates[jI].from == upto)
                  upto = isolates[jI++].to;
                else if (types[upto] == ourType)
                  break run;
                else
                  break;
              }
            iI++;
            if (recurse) {
              recurse.push(iso);
            } else {
              if (iso.from > iCh)
                order.push(new BidiSpan(iCh, iso.from, localLevel));
              let dirSwap = iso.direction == LTR != !(localLevel % 2);
              computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
              iCh = iso.to;
            }
            iScan = iso.to;
          } else if (iScan == to3 || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {
            break;
          } else {
            iScan++;
          }
        }
        if (recurse)
          emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);
        else if (iCh < iScan)
          order.push(new BidiSpan(iCh, iScan, localLevel));
        iCh = iScan;
      }
    } else {
      for (let iCh = to3, iI = isolates.length; iCh > from3; ) {
        let sameDir = true, isNum = false;
        if (!iI || iCh > isolates[iI - 1].to) {
          let next = types[iCh - 1];
          if (next != ourType) {
            sameDir = false;
            isNum = next == 16;
          }
        }
        let recurse = !sameDir && ourType == 1 ? [] : null;
        let localLevel = sameDir ? level : level + 1;
        let iScan = iCh;
        run: for (; ; ) {
          if (iI && iScan == isolates[iI - 1].to) {
            if (isNum)
              break run;
            let iso = isolates[--iI];
            if (!sameDir)
              for (let upto = iso.from, jI = iI; ; ) {
                if (upto == from3)
                  break run;
                if (jI && isolates[jI - 1].to == upto)
                  upto = isolates[--jI].from;
                else if (types[upto - 1] == ourType)
                  break run;
                else
                  break;
              }
            if (recurse) {
              recurse.push(iso);
            } else {
              if (iso.to < iCh)
                order.push(new BidiSpan(iso.to, iCh, localLevel));
              let dirSwap = iso.direction == LTR != !(localLevel % 2);
              computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
              iCh = iso.from;
            }
            iScan = iso.from;
          } else if (iScan == from3 || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {
            break;
          } else {
            iScan--;
          }
        }
        if (recurse)
          emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);
        else if (iScan < iCh)
          order.push(new BidiSpan(iScan, iCh, localLevel));
        iCh = iScan;
      }
    }
  }
  function computeSectionOrder(line, level, baseLevel, isolates, from3, to3, order) {
    let outerType = level % 2 ? 2 : 1;
    computeCharTypes(line, from3, to3, isolates, outerType);
    processBracketPairs(line, from3, to3, isolates, outerType);
    processNeutrals(from3, to3, isolates, outerType);
    emitSpans(line, from3, to3, level, baseLevel, isolates, order);
  }
  function computeOrder(line, direction, isolates) {
    if (!line)
      return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];
    if (direction == LTR && !isolates.length && !BidiRE.test(line))
      return trivialOrder(line.length);
    if (isolates.length)
      while (line.length > types.length)
        types[types.length] = 256;
    let order = [], level = direction == LTR ? 0 : 1;
    computeSectionOrder(line, level, level, isolates, 0, line.length, order);
    return order;
  }
  function trivialOrder(length9) {
    return [new BidiSpan(0, length9, 0)];
  }
  var movedOver = "";
  function moveVisually(line, order, dir2, start3, forward2) {
    var _a2;
    let startIndex = start3.head - line.from;
    let spanI = BidiSpan.find(order, startIndex, (_a2 = start3.bidiLevel) !== null && _a2 !== void 0 ? _a2 : -1, start3.assoc);
    let span4 = order[spanI], spanEnd = span4.side(forward2, dir2);
    if (startIndex == spanEnd) {
      let nextI = spanI += forward2 ? 1 : -1;
      if (nextI < 0 || nextI >= order.length)
        return null;
      span4 = order[spanI = nextI];
      startIndex = span4.side(!forward2, dir2);
      spanEnd = span4.side(forward2, dir2);
    }
    let nextIndex = findClusterBreak(line.text, startIndex, span4.forward(forward2, dir2));
    if (nextIndex < span4.from || nextIndex > span4.to)
      nextIndex = spanEnd;
    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
    let nextSpan = spanI == (forward2 ? order.length - 1 : 0) ? null : order[spanI + (forward2 ? 1 : -1)];
    if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward2 ? 0 : 1) < span4.level)
      return EditorSelection.cursor(nextSpan.side(!forward2, dir2) + line.from, nextSpan.forward(forward2, dir2) ? 1 : -1, nextSpan.level);
    return EditorSelection.cursor(nextIndex + line.from, span4.forward(forward2, dir2) ? -1 : 1, span4.level);
  }
  function autoDirection(text6, from3, to3) {
    for (let i2 = from3; i2 < to3; i2++) {
      let type = charType(text6.charCodeAt(i2));
      if (type == 1)
        return LTR;
      if (type == 2 || type == 4)
        return RTL;
    }
    return LTR;
  }
  var clickAddsSelectionRange = /* @__PURE__ */ Facet.define();
  var dragMovesSelection$1 = /* @__PURE__ */ Facet.define();
  var mouseSelectionStyle = /* @__PURE__ */ Facet.define();
  var exceptionSink = /* @__PURE__ */ Facet.define();
  var updateListener = /* @__PURE__ */ Facet.define();
  var inputHandler = /* @__PURE__ */ Facet.define();
  var focusChangeEffect = /* @__PURE__ */ Facet.define();
  var clipboardInputFilter = /* @__PURE__ */ Facet.define();
  var clipboardOutputFilter = /* @__PURE__ */ Facet.define();
  var perLineTextDirection = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((x2) => x2)
  });
  var nativeSelectionHidden = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((x2) => x2)
  });
  var scrollHandler = /* @__PURE__ */ Facet.define();
  var ScrollTarget = class _ScrollTarget {
    constructor(range3, y2 = "nearest", x2 = "nearest", yMargin = 5, xMargin = 5, isSnapshot = false) {
      this.range = range3;
      this.y = y2;
      this.x = x2;
      this.yMargin = yMargin;
      this.xMargin = xMargin;
      this.isSnapshot = isSnapshot;
    }
    map(changes) {
      return changes.empty ? this : new _ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
    }
    clip(state4) {
      return this.range.to <= state4.doc.length ? this : new _ScrollTarget(EditorSelection.cursor(state4.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
    }
  };
  var scrollIntoView = /* @__PURE__ */ StateEffect.define({ map: (t3, ch) => t3.map(ch) });
  var setEditContextFormatting = /* @__PURE__ */ StateEffect.define();
  function logException(state4, exception, context3) {
    let handler = state4.facet(exceptionSink);
    if (handler.length)
      handler[0](exception);
    else if (window.onerror)
      window.onerror(String(exception), context3, void 0, void 0, exception);
    else if (context3)
      console.error(context3 + ":", exception);
    else
      console.error(exception);
  }
  var editable = /* @__PURE__ */ Facet.define({ combine: (values) => values.length ? values[0] : true });
  var nextPluginID = 0;
  var viewPlugin = /* @__PURE__ */ Facet.define();
  var ViewPlugin = class _ViewPlugin {
    constructor(id5, create3, domEventHandlers, domEventObservers, buildExtensions) {
      this.id = id5;
      this.create = create3;
      this.domEventHandlers = domEventHandlers;
      this.domEventObservers = domEventObservers;
      this.extension = buildExtensions(this);
    }
    /**
    Define a plugin from a constructor function that creates the
    plugin's value, given an editor view.
    */
    static define(create3, spec) {
      const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};
      return new _ViewPlugin(nextPluginID++, create3, eventHandlers, eventObservers, (plugin) => {
        let ext = [viewPlugin.of(plugin)];
        if (deco)
          ext.push(decorations.of((view2) => {
            let pluginInst = view2.plugin(plugin);
            return pluginInst ? deco(pluginInst) : Decoration.none;
          }));
        if (provide)
          ext.push(provide(plugin));
        return ext;
      });
    }
    /**
    Create a plugin for a class whose constructor takes a single
    editor view as argument.
    */
    static fromClass(cls, spec) {
      return _ViewPlugin.define((view2) => new cls(view2), spec);
    }
  };
  var PluginInstance = class {
    constructor(spec) {
      this.spec = spec;
      this.mustUpdate = null;
      this.value = null;
    }
    update(view2) {
      if (!this.value) {
        if (this.spec) {
          try {
            this.value = this.spec.create(view2);
          } catch (e2) {
            logException(view2.state, e2, "CodeMirror plugin crashed");
            this.deactivate();
          }
        }
      } else if (this.mustUpdate) {
        let update3 = this.mustUpdate;
        this.mustUpdate = null;
        if (this.value.update) {
          try {
            this.value.update(update3);
          } catch (e2) {
            logException(update3.state, e2, "CodeMirror plugin crashed");
            if (this.value.destroy)
              try {
                this.value.destroy();
              } catch (_) {
              }
            this.deactivate();
          }
        }
      }
      return this;
    }
    destroy(view2) {
      var _a2;
      if ((_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.destroy) {
        try {
          this.value.destroy();
        } catch (e2) {
          logException(view2.state, e2, "CodeMirror plugin crashed");
        }
      }
    }
    deactivate() {
      this.spec = this.value = null;
    }
  };
  var editorAttributes = /* @__PURE__ */ Facet.define();
  var contentAttributes = /* @__PURE__ */ Facet.define();
  var decorations = /* @__PURE__ */ Facet.define();
  var outerDecorations = /* @__PURE__ */ Facet.define();
  var atomicRanges = /* @__PURE__ */ Facet.define();
  var bidiIsolatedRanges = /* @__PURE__ */ Facet.define();
  function getIsolatedRanges(view2, line) {
    let isolates = view2.state.facet(bidiIsolatedRanges);
    if (!isolates.length)
      return isolates;
    let sets = isolates.map((i2) => i2 instanceof Function ? i2(view2) : i2);
    let result = [];
    RangeSet.spans(sets, line.from, line.to, {
      point() {
      },
      span(fromDoc, toDoc, active, open) {
        let from3 = fromDoc - line.from, to3 = toDoc - line.from;
        let level = result;
        for (let i2 = active.length - 1; i2 >= 0; i2--, open--) {
          let direction = active[i2].spec.bidiIsolate, update3;
          if (direction == null)
            direction = autoDirection(line.text, from3, to3);
          if (open > 0 && level.length && (update3 = level[level.length - 1]).to == from3 && update3.direction == direction) {
            update3.to = to3;
            level = update3.inner;
          } else {
            let add5 = { from: from3, to: to3, direction, inner: [] };
            level.push(add5);
            level = add5.inner;
          }
        }
      }
    });
    return result;
  }
  var scrollMargins = /* @__PURE__ */ Facet.define();
  function getScrollMargins(view2) {
    let left = 0, right = 0, top4 = 0, bottom3 = 0;
    for (let source3 of view2.state.facet(scrollMargins)) {
      let m2 = source3(view2);
      if (m2) {
        if (m2.left != null)
          left = Math.max(left, m2.left);
        if (m2.right != null)
          right = Math.max(right, m2.right);
        if (m2.top != null)
          top4 = Math.max(top4, m2.top);
        if (m2.bottom != null)
          bottom3 = Math.max(bottom3, m2.bottom);
      }
    }
    return { left, right, top: top4, bottom: bottom3 };
  }
  var styleModule = /* @__PURE__ */ Facet.define();
  var ChangedRange = class _ChangedRange {
    constructor(fromA, toA, fromB, toB) {
      this.fromA = fromA;
      this.toA = toA;
      this.fromB = fromB;
      this.toB = toB;
    }
    join(other) {
      return new _ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
    }
    addToSet(set) {
      let i2 = set.length, me = this;
      for (; i2 > 0; i2--) {
        let range3 = set[i2 - 1];
        if (range3.fromA > me.toA)
          continue;
        if (range3.toA < me.fromA)
          break;
        me = me.join(range3);
        set.splice(i2 - 1, 1);
      }
      set.splice(i2, 0, me);
      return set;
    }
    static extendWithRanges(diff, ranges) {
      if (ranges.length == 0)
        return diff;
      let result = [];
      for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
        let next = dI == diff.length ? null : diff[dI], off = posA - posB;
        let end = next ? next.fromB : 1e9;
        while (rI < ranges.length && ranges[rI] < end) {
          let from3 = ranges[rI], to3 = ranges[rI + 1];
          let fromB = Math.max(posB, from3), toB = Math.min(end, to3);
          if (fromB <= toB)
            new _ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
          if (to3 > end)
            break;
          else
            rI += 2;
        }
        if (!next)
          return result;
        new _ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
        posA = next.toA;
        posB = next.toB;
      }
    }
  };
  var ViewUpdate = class _ViewUpdate {
    constructor(view2, state4, transactions) {
      this.view = view2;
      this.state = state4;
      this.transactions = transactions;
      this.flags = 0;
      this.startState = view2.state;
      this.changes = ChangeSet.empty(this.startState.doc.length);
      for (let tr of transactions)
        this.changes = this.changes.compose(tr.changes);
      let changedRanges = [];
      this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
      this.changedRanges = changedRanges;
    }
    /**
    @internal
    */
    static create(view2, state4, transactions) {
      return new _ViewUpdate(view2, state4, transactions);
    }
    /**
    Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
    [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
    update.
    */
    get viewportChanged() {
      return (this.flags & 4) > 0;
    }
    /**
    Indicates whether the height of a block element in the editor
    changed in this update.
    */
    get heightChanged() {
      return (this.flags & 2) > 0;
    }
    /**
    Returns true when the document was modified or the size of the
    editor, or elements within the editor, changed.
    */
    get geometryChanged() {
      return this.docChanged || (this.flags & (8 | 2)) > 0;
    }
    /**
    True when this update indicates a focus change.
    */
    get focusChanged() {
      return (this.flags & 1) > 0;
    }
    /**
    Whether the document changed in this update.
    */
    get docChanged() {
      return !this.changes.empty;
    }
    /**
    Whether the selection was explicitly set in this update.
    */
    get selectionSet() {
      return this.transactions.some((tr) => tr.selection);
    }
    /**
    @internal
    */
    get empty() {
      return this.flags == 0 && this.transactions.length == 0;
    }
  };
  var DocView = class extends ContentView {
    get length() {
      return this.view.state.doc.length;
    }
    constructor(view2) {
      super();
      this.view = view2;
      this.decorations = [];
      this.dynamicDecorationMap = [false];
      this.domChanged = null;
      this.hasComposition = null;
      this.markedForComposition = /* @__PURE__ */ new Set();
      this.editContextFormatting = Decoration.none;
      this.lastCompositionAfterCursor = false;
      this.minWidth = 0;
      this.minWidthFrom = 0;
      this.minWidthTo = 0;
      this.impreciseAnchor = null;
      this.impreciseHead = null;
      this.forceSelection = false;
      this.lastUpdate = Date.now();
      this.setDOM(view2.contentDOM);
      this.children = [new LineView()];
      this.children[0].setParent(this);
      this.updateDeco();
      this.updateInner([new ChangedRange(0, 0, 0, view2.state.doc.length)], 0, null);
    }
    // Update the document view to a given state.
    update(update3) {
      var _a2;
      let changedRanges = update3.changedRanges;
      if (this.minWidth > 0 && changedRanges.length) {
        if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
          this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
        } else {
          this.minWidthFrom = update3.changes.mapPos(this.minWidthFrom, 1);
          this.minWidthTo = update3.changes.mapPos(this.minWidthTo, 1);
        }
      }
      this.updateEditContextFormatting(update3);
      let readCompositionAt = -1;
      if (this.view.inputState.composing >= 0 && !this.view.observer.editContext) {
        if ((_a2 = this.domChanged) === null || _a2 === void 0 ? void 0 : _a2.newSel)
          readCompositionAt = this.domChanged.newSel.head;
        else if (!touchesComposition(update3.changes, this.hasComposition) && !update3.selectionSet)
          readCompositionAt = update3.state.selection.main.head;
      }
      let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update3.changes, readCompositionAt) : null;
      this.domChanged = null;
      if (this.hasComposition) {
        this.markedForComposition.clear();
        let { from: from3, to: to3 } = this.hasComposition;
        changedRanges = new ChangedRange(from3, to3, update3.changes.mapPos(from3, -1), update3.changes.mapPos(to3, 1)).addToSet(changedRanges.slice());
      }
      this.hasComposition = composition ? { from: composition.range.fromB, to: composition.range.toB } : null;
      if ((browser.ie || browser.chrome) && !composition && update3 && update3.state.doc.lines != update3.startState.doc.lines)
        this.forceSelection = true;
      let prevDeco = this.decorations, deco = this.updateDeco();
      let decoDiff = findChangedDeco(prevDeco, deco, update3.changes);
      changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
      if (!(this.flags & 7) && changedRanges.length == 0) {
        return false;
      } else {
        this.updateInner(changedRanges, update3.startState.doc.length, composition);
        if (update3.transactions.length)
          this.lastUpdate = Date.now();
        return true;
      }
    }
    // Used by update and the constructor do perform the actual DOM
    // update
    updateInner(changes, oldLength, composition) {
      this.view.viewState.mustMeasureContent = true;
      this.updateChildren(changes, oldLength, composition);
      let { observer } = this.view;
      observer.ignore(() => {
        this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
        this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
        let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : void 0;
        this.sync(this.view, track);
        this.flags &= ~7;
        if (track && (track.written || observer.selectionRange.focusNode != track.node))
          this.forceSelection = true;
        this.dom.style.height = "";
      });
      this.markedForComposition.forEach(
        (cView) => cView.flags &= ~8
        /* ViewFlag.Composition */
      );
      let gaps = [];
      if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
        for (let child of this.children)
          if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
            gaps.push(child.dom);
      }
      observer.updateGaps(gaps);
    }
    updateChildren(changes, oldLength, composition) {
      let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;
      let cursor = this.childCursor(oldLength);
      for (let i2 = ranges.length - 1; ; i2--) {
        let next = i2 >= 0 ? ranges[i2] : null;
        if (!next)
          break;
        let { fromA, toA, fromB, toB } = next, content4, breakAtStart, openStart, openEnd;
        if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {
          let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);
          let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);
          breakAtStart = before.breakAtStart;
          openStart = before.openStart;
          openEnd = after.openEnd;
          let compLine = this.compositionView(composition);
          if (after.breakAtStart) {
            compLine.breakAfter = 1;
          } else if (after.content.length && compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {
            compLine.breakAfter = after.content[0].breakAfter;
            after.content.shift();
          }
          if (before.content.length && compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {
            before.content.pop();
          }
          content4 = before.content.concat(compLine).concat(after.content);
        } else {
          ({ content: content4, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));
        }
        let { i: toI, off: toOff } = cursor.findPos(toA, 1);
        let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);
        replaceRange(this, fromI, fromOff, toI, toOff, content4, breakAtStart, openStart, openEnd);
      }
      if (composition)
        this.fixCompositionDOM(composition);
    }
    updateEditContextFormatting(update3) {
      this.editContextFormatting = this.editContextFormatting.map(update3.changes);
      for (let tr of update3.transactions)
        for (let effect of tr.effects)
          if (effect.is(setEditContextFormatting)) {
            this.editContextFormatting = effect.value;
          }
    }
    compositionView(composition) {
      let cur2 = new TextView(composition.text.nodeValue);
      cur2.flags |= 8;
      for (let { deco } of composition.marks)
        cur2 = new MarkView(deco, [cur2], cur2.length);
      let line = new LineView();
      line.append(cur2, 0);
      return line;
    }
    fixCompositionDOM(composition) {
      let fix = (dom, cView2) => {
        cView2.flags |= 8 | (cView2.children.some(
          (c2) => c2.flags & 7
          /* ViewFlag.Dirty */
        ) ? 1 : 0);
        this.markedForComposition.add(cView2);
        let prev = ContentView.get(dom);
        if (prev && prev != cView2)
          prev.dom = null;
        cView2.setDOM(dom);
      };
      let pos = this.childPos(composition.range.fromB, 1);
      let cView = this.children[pos.i];
      fix(composition.line, cView);
      for (let i2 = composition.marks.length - 1; i2 >= -1; i2--) {
        pos = cView.childPos(pos.off, 1);
        cView = cView.children[pos.i];
        fix(i2 >= 0 ? composition.marks[i2].node : composition.text, cView);
      }
    }
    // Sync the DOM selection to this.state.selection
    updateSelection(mustRead = false, fromPointer = false) {
      if (mustRead || !this.view.observer.selectionRange.focusNode)
        this.view.observer.readSelectionRange();
      let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;
      let selectionNotFocus = !focused && hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));
      if (!(focused || fromPointer || selectionNotFocus))
        return;
      let force2 = this.forceSelection;
      this.forceSelection = false;
      let main4 = this.view.state.selection.main;
      let anchor = this.moveToLine(this.domAtPos(main4.anchor));
      let head5 = main4.empty ? anchor : this.moveToLine(this.domAtPos(main4.head));
      if (browser.gecko && main4.empty && !this.hasComposition && betweenUneditable(anchor)) {
        let dummy = document.createTextNode("");
        this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
        anchor = head5 = new DOMPos(dummy, 0);
        force2 = true;
      }
      let domSel = this.view.observer.selectionRange;
      if (force2 || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head5.node, head5.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main4)) {
        this.view.observer.ignore(() => {
          if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
            this.dom.blur();
            this.dom.focus({ preventScroll: true });
          }
          let rawSel = getSelection(this.view.root);
          if (!rawSel) ;
          else if (main4.empty) {
            if (browser.gecko) {
              let nextTo = nextToUneditable(anchor.node, anchor.offset);
              if (nextTo && nextTo != (1 | 2)) {
                let text6 = (nextTo == 1 ? textNodeBefore : textNodeAfter)(anchor.node, anchor.offset);
                if (text6)
                  anchor = new DOMPos(text6.node, text6.offset);
              }
            }
            rawSel.collapse(anchor.node, anchor.offset);
            if (main4.bidiLevel != null && rawSel.caretBidiLevel !== void 0)
              rawSel.caretBidiLevel = main4.bidiLevel;
          } else if (rawSel.extend) {
            rawSel.collapse(anchor.node, anchor.offset);
            try {
              rawSel.extend(head5.node, head5.offset);
            } catch (_) {
            }
          } else {
            let range3 = document.createRange();
            if (main4.anchor > main4.head)
              [anchor, head5] = [head5, anchor];
            range3.setEnd(head5.node, head5.offset);
            range3.setStart(anchor.node, anchor.offset);
            rawSel.removeAllRanges();
            rawSel.addRange(range3);
          }
          if (selectionNotFocus && this.view.root.activeElement == this.dom) {
            this.dom.blur();
            if (activeElt)
              activeElt.focus();
          }
        });
        this.view.observer.setSelectionRange(anchor, head5);
      }
      this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
      this.impreciseHead = head5.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
    }
    // If a zero-length widget is inserted next to the cursor during
    // composition, avoid moving it across it and disrupting the
    // composition.
    suppressWidgetCursorChange(sel, cursor) {
      return this.hasComposition && cursor.empty && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) && this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor.head;
    }
    enforceCursorAssoc() {
      if (this.hasComposition)
        return;
      let { view: view2 } = this, cursor = view2.state.selection.main;
      let sel = getSelection(view2.root);
      let { anchorNode, anchorOffset } = view2.observer.selectionRange;
      if (!sel || !cursor.empty || !cursor.assoc || !sel.modify)
        return;
      let line = LineView.find(this, cursor.head);
      if (!line)
        return;
      let lineStart = line.posAtStart;
      if (cursor.head == lineStart || cursor.head == lineStart + line.length)
        return;
      let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
      if (!before || !after || before.bottom > after.top)
        return;
      let dom = this.domAtPos(cursor.head + cursor.assoc);
      sel.collapse(dom.node, dom.offset);
      sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
      view2.observer.readSelectionRange();
      let newRange = view2.observer.selectionRange;
      if (view2.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from)
        sel.collapse(anchorNode, anchorOffset);
    }
    // If a position is in/near a block widget, move it to a nearby text
    // line, since we don't want the cursor inside a block widget.
    moveToLine(pos) {
      let dom = this.dom, newPos;
      if (pos.node != dom)
        return pos;
      for (let i2 = pos.offset; !newPos && i2 < dom.childNodes.length; i2++) {
        let view2 = ContentView.get(dom.childNodes[i2]);
        if (view2 instanceof LineView)
          newPos = view2.domAtPos(0);
      }
      for (let i2 = pos.offset - 1; !newPos && i2 >= 0; i2--) {
        let view2 = ContentView.get(dom.childNodes[i2]);
        if (view2 instanceof LineView)
          newPos = view2.domAtPos(view2.length);
      }
      return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;
    }
    nearest(dom) {
      for (let cur2 = dom; cur2; ) {
        let domView = ContentView.get(cur2);
        if (domView && domView.rootView == this)
          return domView;
        cur2 = cur2.parentNode;
      }
      return null;
    }
    posFromDOM(node, offset) {
      let view2 = this.nearest(node);
      if (!view2)
        throw new RangeError("Trying to find position for a DOM position outside of the document");
      return view2.localPosFromDOM(node, offset) + view2.posAtStart;
    }
    domAtPos(pos) {
      let { i: i2, off } = this.childCursor().findPos(pos, -1);
      for (; i2 < this.children.length - 1; ) {
        let child = this.children[i2];
        if (off < child.length || child instanceof LineView)
          break;
        i2++;
        off = 0;
      }
      return this.children[i2].domAtPos(off);
    }
    coordsAt(pos, side) {
      let best = null, bestPos = 0;
      for (let off = this.length, i2 = this.children.length - 1; i2 >= 0; i2--) {
        let child = this.children[i2], end = off - child.breakAfter, start3 = end - child.length;
        if (end < pos)
          break;
        if (start3 <= pos && (start3 < pos || child.covers(-1)) && (end > pos || child.covers(1)) && (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {
          best = child;
          bestPos = start3;
        } else if (best && start3 == pos && end == pos && child instanceof BlockWidgetView && Math.abs(side) < 2) {
          if (child.deco.startSide < 0)
            break;
          else if (i2)
            best = null;
        }
        off = start3;
      }
      return best ? best.coordsAt(pos - bestPos, side) : null;
    }
    coordsForChar(pos) {
      let { i: i2, off } = this.childPos(pos, 1), child = this.children[i2];
      if (!(child instanceof LineView))
        return null;
      while (child.children.length) {
        let { i: i3, off: childOff } = child.childPos(off, 1);
        for (; ; i3++) {
          if (i3 == child.children.length)
            return null;
          if ((child = child.children[i3]).length)
            break;
        }
        off = childOff;
      }
      if (!(child instanceof TextView))
        return null;
      let end = findClusterBreak(child.text, off);
      if (end == off)
        return null;
      let rects = textRange(child.dom, off, end).getClientRects();
      for (let i3 = 0; i3 < rects.length; i3++) {
        let rect = rects[i3];
        if (i3 == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right)
          return rect;
      }
      return null;
    }
    measureVisibleLineHeights(viewport) {
      let result = [], { from: from3, to: to3 } = viewport;
      let contentWidth = this.view.contentDOM.clientWidth;
      let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
      let widest = -1, ltr = this.view.textDirection == Direction.LTR;
      for (let pos = 0, i2 = 0; i2 < this.children.length; i2++) {
        let child = this.children[i2], end = pos + child.length;
        if (end > to3)
          break;
        if (pos >= from3) {
          let childRect = child.dom.getBoundingClientRect();
          result.push(childRect.height);
          if (isWider) {
            let last4 = child.dom.lastChild;
            let rects = last4 ? clientRectsFor(last4) : [];
            if (rects.length) {
              let rect = rects[rects.length - 1];
              let width8 = ltr ? rect.right - childRect.left : childRect.right - rect.left;
              if (width8 > widest) {
                widest = width8;
                this.minWidth = contentWidth;
                this.minWidthFrom = pos;
                this.minWidthTo = end;
              }
            }
          }
        }
        pos = end + child.breakAfter;
      }
      return result;
    }
    textDirectionAt(pos) {
      let { i: i2 } = this.childPos(pos, 1);
      return getComputedStyle(this.children[i2].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
    }
    measureTextSize() {
      for (let child of this.children) {
        if (child instanceof LineView) {
          let measure = child.measureTextSize();
          if (measure)
            return measure;
        }
      }
      let dummy = document.createElement("div"), lineHeight, charWidth, textHeight;
      dummy.className = "cm-line";
      dummy.style.width = "99999px";
      dummy.style.position = "absolute";
      dummy.textContent = "abc def ghi jkl mno pqr stu";
      this.view.observer.ignore(() => {
        this.dom.appendChild(dummy);
        let rect = clientRectsFor(dummy.firstChild)[0];
        lineHeight = dummy.getBoundingClientRect().height;
        charWidth = rect ? rect.width / 27 : 7;
        textHeight = rect ? rect.height : lineHeight;
        dummy.remove();
      });
      return { lineHeight, charWidth, textHeight };
    }
    childCursor(pos = this.length) {
      let i2 = this.children.length;
      if (i2)
        pos -= this.children[--i2].length;
      return new ChildCursor(this.children, pos, i2);
    }
    computeBlockGapDeco() {
      let deco = [], vs = this.view.viewState;
      for (let pos = 0, i2 = 0; ; i2++) {
        let next = i2 == vs.viewports.length ? null : vs.viewports[i2];
        let end = next ? next.from - 1 : this.length;
        if (end > pos) {
          let height8 = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;
          deco.push(Decoration.replace({
            widget: new BlockGapWidget(height8),
            block: true,
            inclusive: true,
            isBlockGap: true
          }).range(pos, end));
        }
        if (!next)
          break;
        pos = next.to + 1;
      }
      return Decoration.set(deco);
    }
    updateDeco() {
      let i2 = 1;
      let allDeco = this.view.state.facet(decorations).map((d2) => {
        let dynamic = this.dynamicDecorationMap[i2++] = typeof d2 == "function";
        return dynamic ? d2(this.view) : d2;
      });
      let dynamicOuter = false, outerDeco = this.view.state.facet(outerDecorations).map((d2, i3) => {
        let dynamic = typeof d2 == "function";
        if (dynamic)
          dynamicOuter = true;
        return dynamic ? d2(this.view) : d2;
      });
      if (outerDeco.length) {
        this.dynamicDecorationMap[i2++] = dynamicOuter;
        allDeco.push(RangeSet.join(outerDeco));
      }
      this.decorations = [
        this.editContextFormatting,
        ...allDeco,
        this.computeBlockGapDeco(),
        this.view.viewState.lineGapDeco
      ];
      while (i2 < this.decorations.length)
        this.dynamicDecorationMap[i2++] = false;
      return this.decorations;
    }
    scrollIntoView(target5) {
      if (target5.isSnapshot) {
        let ref = this.view.viewState.lineBlockAt(target5.range.head);
        this.view.scrollDOM.scrollTop = ref.top - target5.yMargin;
        this.view.scrollDOM.scrollLeft = target5.xMargin;
        return;
      }
      for (let handler of this.view.state.facet(scrollHandler)) {
        try {
          if (handler(this.view, target5.range, target5))
            return true;
        } catch (e2) {
          logException(this.view.state, e2, "scroll handler");
        }
      }
      let { range: range3 } = target5;
      let rect = this.coordsAt(range3.head, range3.empty ? range3.assoc : range3.head > range3.anchor ? -1 : 1), other;
      if (!rect)
        return;
      if (!range3.empty && (other = this.coordsAt(range3.anchor, range3.anchor > range3.head ? -1 : 1)))
        rect = {
          left: Math.min(rect.left, other.left),
          top: Math.min(rect.top, other.top),
          right: Math.max(rect.right, other.right),
          bottom: Math.max(rect.bottom, other.bottom)
        };
      let margins = getScrollMargins(this.view);
      let targetRect = {
        left: rect.left - margins.left,
        top: rect.top - margins.top,
        right: rect.right + margins.right,
        bottom: rect.bottom + margins.bottom
      };
      let { offsetWidth: offsetWidth2, offsetHeight: offsetHeight2 } = this.view.scrollDOM;
      scrollRectIntoView(this.view.scrollDOM, targetRect, range3.head < range3.anchor ? -1 : 1, target5.x, target5.y, Math.max(Math.min(target5.xMargin, offsetWidth2), -offsetWidth2), Math.max(Math.min(target5.yMargin, offsetHeight2), -offsetHeight2), this.view.textDirection == Direction.LTR);
    }
  };
  function betweenUneditable(pos) {
    return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
  }
  function findCompositionNode(view2, headPos) {
    let sel = view2.observer.selectionRange;
    if (!sel.focusNode)
      return null;
    let textBefore = textNodeBefore(sel.focusNode, sel.focusOffset);
    let textAfter = textNodeAfter(sel.focusNode, sel.focusOffset);
    let textNode3 = textBefore || textAfter;
    if (textAfter && textBefore && textAfter.node != textBefore.node) {
      let descAfter = ContentView.get(textAfter.node);
      if (!descAfter || descAfter instanceof TextView && descAfter.text != textAfter.node.nodeValue) {
        textNode3 = textAfter;
      } else if (view2.docView.lastCompositionAfterCursor) {
        let descBefore = ContentView.get(textBefore.node);
        if (!(!descBefore || descBefore instanceof TextView && descBefore.text != textBefore.node.nodeValue))
          textNode3 = textAfter;
      }
    }
    view2.docView.lastCompositionAfterCursor = textNode3 != textBefore;
    if (!textNode3)
      return null;
    let from3 = headPos - textNode3.offset;
    return { from: from3, to: from3 + textNode3.node.nodeValue.length, node: textNode3.node };
  }
  function findCompositionRange(view2, changes, headPos) {
    let found = findCompositionNode(view2, headPos);
    if (!found)
      return null;
    let { node: textNode3, from: from3, to: to3 } = found, text6 = textNode3.nodeValue;
    if (/[\n\r]/.test(text6))
      return null;
    if (view2.state.doc.sliceString(found.from, found.to) != text6)
      return null;
    let inv = changes.invertedDesc;
    let range3 = new ChangedRange(inv.mapPos(from3), inv.mapPos(to3), from3, to3);
    let marks2 = [];
    for (let parent2 = textNode3.parentNode; ; parent2 = parent2.parentNode) {
      let parentView = ContentView.get(parent2);
      if (parentView instanceof MarkView)
        marks2.push({ node: parent2, deco: parentView.mark });
      else if (parentView instanceof LineView || parent2.nodeName == "DIV" && parent2.parentNode == view2.contentDOM)
        return { range: range3, text: textNode3, marks: marks2, line: parent2 };
      else if (parent2 != view2.contentDOM)
        marks2.push({ node: parent2, deco: new MarkDecoration({
          inclusive: true,
          attributes: getAttrs(parent2),
          tagName: parent2.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
  function nextToUneditable(node, offset) {
    if (node.nodeType != 1)
      return 0;
    return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
  }
  var DecorationComparator$1 = class DecorationComparator {
    constructor() {
      this.changes = [];
    }
    compareRange(from3, to3) {
      addRange(from3, to3, this.changes);
    }
    comparePoint(from3, to3) {
      addRange(from3, to3, this.changes);
    }
  };
  function findChangedDeco(a2, b2, diff) {
    let comp = new DecorationComparator$1();
    RangeSet.compare(a2, b2, diff, comp);
    return comp.changes;
  }
  function inUneditable(node, inside2) {
    for (let cur2 = node; cur2 && cur2 != inside2; cur2 = cur2.assignedSlot || cur2.parentNode) {
      if (cur2.nodeType == 1 && cur2.contentEditable == "false") {
        return true;
      }
    }
    return false;
  }
  function touchesComposition(changes, composition) {
    let touched = false;
    if (composition)
      changes.iterChangedRanges((from3, to3) => {
        if (from3 < composition.to && to3 > composition.from)
          touched = true;
      });
    return touched;
  }
  function groupAt(state4, pos, bias = 1) {
    let categorize = state4.charCategorizer(pos);
    let line = state4.doc.lineAt(pos), linePos = pos - line.from;
    if (line.length == 0)
      return EditorSelection.cursor(pos);
    if (linePos == 0)
      bias = 1;
    else if (linePos == line.length)
      bias = -1;
    let from3 = linePos, to3 = linePos;
    if (bias < 0)
      from3 = findClusterBreak(line.text, linePos, false);
    else
      to3 = findClusterBreak(line.text, linePos);
    let cat = categorize(line.text.slice(from3, to3));
    while (from3 > 0) {
      let prev = findClusterBreak(line.text, from3, false);
      if (categorize(line.text.slice(prev, from3)) != cat)
        break;
      from3 = prev;
    }
    while (to3 < line.length) {
      let next = findClusterBreak(line.text, to3);
      if (categorize(line.text.slice(to3, next)) != cat)
        break;
      to3 = next;
    }
    return EditorSelection.range(from3 + line.from, to3 + line.from);
  }
  function getdx(x2, rect) {
    return rect.left > x2 ? rect.left - x2 : Math.max(0, x2 - rect.right);
  }
  function getdy(y2, rect) {
    return rect.top > y2 ? rect.top - y2 : Math.max(0, y2 - rect.bottom);
  }
  function yOverlap(a2, b2) {
    return a2.top < b2.bottom - 1 && a2.bottom > b2.top + 1;
  }
  function upTop(rect, top4) {
    return top4 < rect.top ? { top: top4, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
  }
  function upBot(rect, bottom3) {
    return bottom3 > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom: bottom3 } : rect;
  }
  function domPosAtCoords(parent2, x2, y2) {
    let closest, closestRect, closestX, closestY, closestOverlap = false;
    let above, below, aboveRect, belowRect;
    for (let child = parent2.firstChild; child; child = child.nextSibling) {
      let rects = clientRectsFor(child);
      for (let i2 = 0; i2 < rects.length; i2++) {
        let rect = rects[i2];
        if (closestRect && yOverlap(closestRect, rect))
          rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
        let dx = getdx(x2, rect), dy = getdy(y2, rect);
        if (dx == 0 && dy == 0)
          return child.nodeType == 3 ? domPosInText(child, x2, y2) : domPosAtCoords(child, x2, y2);
        if (!closest || closestY > dy || closestY == dy && closestX > dx) {
          closest = child;
          closestRect = rect;
          closestX = dx;
          closestY = dy;
          let side = dy ? y2 < rect.top ? -1 : 1 : dx ? x2 < rect.left ? -1 : 1 : 0;
          closestOverlap = !side || (side > 0 ? i2 < rects.length - 1 : i2 > 0);
        }
        if (dx == 0) {
          if (y2 > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
            above = child;
            aboveRect = rect;
          } else if (y2 < rect.top && (!belowRect || belowRect.top > rect.top)) {
            below = child;
            belowRect = rect;
          }
        } else if (aboveRect && yOverlap(aboveRect, rect)) {
          aboveRect = upBot(aboveRect, rect.bottom);
        } else if (belowRect && yOverlap(belowRect, rect)) {
          belowRect = upTop(belowRect, rect.top);
        }
      }
    }
    if (aboveRect && aboveRect.bottom >= y2) {
      closest = above;
      closestRect = aboveRect;
    } else if (belowRect && belowRect.top <= y2) {
      closest = below;
      closestRect = belowRect;
    }
    if (!closest)
      return { node: parent2, offset: 0 };
    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x2));
    if (closest.nodeType == 3)
      return domPosInText(closest, clipX, y2);
    if (closestOverlap && closest.contentEditable != "false")
      return domPosAtCoords(closest, clipX, y2);
    let offset = Array.prototype.indexOf.call(parent2.childNodes, closest) + (x2 >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
    return { node: parent2, offset };
  }
  function domPosInText(node, x2, y2) {
    let len = node.nodeValue.length;
    let closestOffset = -1, closestDY = 1e9, generalSide = 0;
    for (let i2 = 0; i2 < len; i2++) {
      let rects = textRange(node, i2, i2 + 1).getClientRects();
      for (let j2 = 0; j2 < rects.length; j2++) {
        let rect = rects[j2];
        if (rect.top == rect.bottom)
          continue;
        if (!generalSide)
          generalSide = x2 - rect.left;
        let dy = (rect.top > y2 ? rect.top - y2 : y2 - rect.bottom) - 1;
        if (rect.left - 1 <= x2 && rect.right + 1 >= x2 && dy < closestDY) {
          let right = x2 >= (rect.left + rect.right) / 2, after = right;
          if (browser.chrome || browser.gecko) {
            let rectBefore = textRange(node, i2).getBoundingClientRect();
            if (rectBefore.left == rect.right)
              after = !right;
          }
          if (dy <= 0)
            return { node, offset: i2 + (after ? 1 : 0) };
          closestOffset = i2 + (after ? 1 : 0);
          closestDY = dy;
        }
      }
    }
    return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
  }
  function posAtCoords(view2, coords2, precise, bias = -1) {
    var _a2, _b;
    let content4 = view2.contentDOM.getBoundingClientRect(), docTop = content4.top + view2.viewState.paddingTop;
    let block, { docHeight } = view2.viewState;
    let { x: x2, y: y2 } = coords2, yOffset = y2 - docTop;
    if (yOffset < 0)
      return 0;
    if (yOffset > docHeight)
      return view2.state.doc.length;
    for (let halfLine = view2.viewState.heightOracle.textHeight / 2, bounced = false; ; ) {
      block = view2.elementAtHeight(yOffset);
      if (block.type == BlockType.Text)
        break;
      for (; ; ) {
        yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
        if (yOffset >= 0 && yOffset <= docHeight)
          break;
        if (bounced)
          return precise ? null : 0;
        bounced = true;
        bias = -bias;
      }
    }
    y2 = docTop + yOffset;
    let lineStart = block.from;
    if (lineStart < view2.viewport.from)
      return view2.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view2, content4, block, x2, y2);
    if (lineStart > view2.viewport.to)
      return view2.viewport.to == view2.state.doc.length ? view2.state.doc.length : precise ? null : posAtCoordsImprecise(view2, content4, block, x2, y2);
    let doc2 = view2.dom.ownerDocument;
    let root = view2.root.elementFromPoint ? view2.root : doc2;
    let element = root.elementFromPoint(x2, y2);
    if (element && !view2.contentDOM.contains(element))
      element = null;
    if (!element) {
      x2 = Math.max(content4.left + 1, Math.min(content4.right - 1, x2));
      element = root.elementFromPoint(x2, y2);
      if (element && !view2.contentDOM.contains(element))
        element = null;
    }
    let node, offset = -1;
    if (element && ((_a2 = view2.docView.nearest(element)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) != false) {
      if (doc2.caretPositionFromPoint) {
        let pos = doc2.caretPositionFromPoint(x2, y2);
        if (pos)
          ({ offsetNode: node, offset } = pos);
      } else if (doc2.caretRangeFromPoint) {
        let range3 = doc2.caretRangeFromPoint(x2, y2);
        if (range3) {
          ({ startContainer: node, startOffset: offset } = range3);
          if (!view2.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset, x2) || browser.chrome && isSuspiciousChromeCaretResult(node, offset, x2))
            node = void 0;
        }
      }
      if (node)
        offset = Math.min(maxOffset(node), offset);
    }
    if (!node || !view2.docView.dom.contains(node)) {
      let line = LineView.find(view2.docView, lineStart);
      if (!line)
        return yOffset > block.top + block.height / 2 ? block.to : block.from;
      ({ node, offset } = domPosAtCoords(line.dom, x2, y2));
    }
    let nearest = view2.docView.nearest(node);
    if (!nearest)
      return null;
    if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {
      let rect = nearest.dom.getBoundingClientRect();
      return coords2.y < rect.top || coords2.y <= rect.bottom && coords2.x <= (rect.left + rect.right) / 2 ? nearest.posAtStart : nearest.posAtEnd;
    } else {
      return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;
    }
  }
  function posAtCoordsImprecise(view2, contentRect, block, x2, y2) {
    let into = Math.round((x2 - contentRect.left) * view2.defaultCharacterWidth);
    if (view2.lineWrapping && block.height > view2.defaultLineHeight * 1.5) {
      let textHeight = view2.viewState.heightOracle.textHeight;
      let line = Math.floor((y2 - block.top - (view2.defaultLineHeight - textHeight) * 0.5) / textHeight);
      into += line * view2.viewState.heightOracle.lineLength;
    }
    let content4 = view2.state.sliceDoc(block.from, block.to);
    return block.from + findColumn(content4, into, view2.state.tabSize);
  }
  function isSuspiciousSafariCaretResult(node, offset, x2) {
    let len;
    if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
      return false;
    for (let next = node.nextSibling; next; next = next.nextSibling)
      if (next.nodeType != 1 || next.nodeName != "BR")
        return false;
    return textRange(node, len - 1, len).getBoundingClientRect().left > x2;
  }
  function isSuspiciousChromeCaretResult(node, offset, x2) {
    if (offset != 0)
      return false;
    for (let cur2 = node; ; ) {
      let parent2 = cur2.parentNode;
      if (!parent2 || parent2.nodeType != 1 || parent2.firstChild != cur2)
        return false;
      if (parent2.classList.contains("cm-line"))
        break;
      cur2 = parent2;
    }
    let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
    return x2 - rect.left > 5;
  }
  function blockAt(view2, pos) {
    let line = view2.lineBlockAt(pos);
    if (Array.isArray(line.type))
      for (let l2 of line.type) {
        if (l2.to > pos || l2.to == pos && (l2.to == line.to || l2.type == BlockType.Text))
          return l2;
      }
    return line;
  }
  function moveToLineBoundary(view2, start3, forward2, includeWrap) {
    let line = blockAt(view2, start3.head);
    let coords2 = !includeWrap || line.type != BlockType.Text || !(view2.lineWrapping || line.widgetLineBreaks) ? null : view2.coordsAtPos(start3.assoc < 0 && start3.head > line.from ? start3.head - 1 : start3.head);
    if (coords2) {
      let editorRect = view2.dom.getBoundingClientRect();
      let direction = view2.textDirectionAt(line.from);
      let pos = view2.posAtCoords({
        x: forward2 == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
        y: (coords2.top + coords2.bottom) / 2
      });
      if (pos != null)
        return EditorSelection.cursor(pos, forward2 ? -1 : 1);
    }
    return EditorSelection.cursor(forward2 ? line.to : line.from, forward2 ? -1 : 1);
  }
  function moveByChar(view2, start3, forward2, by) {
    let line = view2.state.doc.lineAt(start3.head), spans = view2.bidiSpans(line);
    let direction = view2.textDirectionAt(line.from);
    for (let cur2 = start3, check = null; ; ) {
      let next = moveVisually(line, spans, direction, cur2, forward2), char2 = movedOver;
      if (!next) {
        if (line.number == (forward2 ? view2.state.doc.lines : 1))
          return cur2;
        char2 = "\n";
        line = view2.state.doc.line(line.number + (forward2 ? 1 : -1));
        spans = view2.bidiSpans(line);
        next = view2.visualLineSide(line, !forward2);
      }
      if (!check) {
        if (!by)
          return next;
        check = by(char2);
      } else if (!check(char2)) {
        return cur2;
      }
      cur2 = next;
    }
  }
  function byGroup(view2, pos, start3) {
    let categorize = view2.state.charCategorizer(pos);
    let cat = categorize(start3);
    return (next) => {
      let nextCat = categorize(next);
      if (cat == CharCategory.Space)
        cat = nextCat;
      return cat == nextCat;
    };
  }
  function moveVertically(view2, start3, forward2, distance) {
    let startPos = start3.head, dir2 = forward2 ? 1 : -1;
    if (startPos == (forward2 ? view2.state.doc.length : 0))
      return EditorSelection.cursor(startPos, start3.assoc);
    let goal = start3.goalColumn, startY;
    let rect = view2.contentDOM.getBoundingClientRect();
    let startCoords = view2.coordsAtPos(startPos, start3.assoc || -1), docTop = view2.documentTop;
    if (startCoords) {
      if (goal == null)
        goal = startCoords.left - rect.left;
      startY = dir2 < 0 ? startCoords.top : startCoords.bottom;
    } else {
      let line = view2.viewState.lineBlockAt(startPos);
      if (goal == null)
        goal = Math.min(rect.right - rect.left, view2.defaultCharacterWidth * (startPos - line.from));
      startY = (dir2 < 0 ? line.top : line.bottom) + docTop;
    }
    let resolvedGoal = rect.left + goal;
    let dist2 = distance !== null && distance !== void 0 ? distance : view2.viewState.heightOracle.textHeight >> 1;
    for (let extra = 0; ; extra += 10) {
      let curY = startY + (dist2 + extra) * dir2;
      let pos = posAtCoords(view2, { x: resolvedGoal, y: curY }, false, dir2);
      if (curY < rect.top || curY > rect.bottom || (dir2 < 0 ? pos < startPos : pos > startPos)) {
        let charRect = view2.docView.coordsForChar(pos);
        let assoc = !charRect || curY < charRect.top ? -1 : 1;
        return EditorSelection.cursor(pos, assoc, void 0, goal);
      }
    }
  }
  function skipAtomicRanges(atoms, pos, bias) {
    for (; ; ) {
      let moved = 0;
      for (let set of atoms) {
        set.between(pos - 1, pos + 1, (from3, to3, value12) => {
          if (pos > from3 && pos < to3) {
            let side = moved || bias || (pos - from3 < to3 - pos ? -1 : 1);
            pos = side < 0 ? from3 : to3;
            moved = side;
          }
        });
      }
      if (!moved)
        return pos;
    }
  }
  function skipAtoms(view2, oldPos, pos) {
    let newPos = skipAtomicRanges(view2.state.facet(atomicRanges).map((f2) => f2(view2)), pos.from, oldPos.head > pos.from ? -1 : 1);
    return newPos == pos.from ? pos : EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);
  }
  var LineBreakPlaceholder = "\uFFFF";
  var DOMReader = class {
    constructor(points, state4) {
      this.points = points;
      this.text = "";
      this.lineSeparator = state4.facet(EditorState.lineSeparator);
    }
    append(text6) {
      this.text += text6;
    }
    lineBreak() {
      this.text += LineBreakPlaceholder;
    }
    readRange(start3, end) {
      if (!start3)
        return this;
      let parent2 = start3.parentNode;
      for (let cur2 = start3; ; ) {
        this.findPointBefore(parent2, cur2);
        let oldLen = this.text.length;
        this.readNode(cur2);
        let next = cur2.nextSibling;
        if (next == end)
          break;
        let view2 = ContentView.get(cur2), nextView = ContentView.get(next);
        if (view2 && nextView ? view2.breakAfter : (view2 ? view2.breakAfter : isBlockElement(cur2)) || isBlockElement(next) && (cur2.nodeName != "BR" || cur2.cmIgnore) && this.text.length > oldLen)
          this.lineBreak();
        cur2 = next;
      }
      this.findPointBefore(parent2, end);
      return this;
    }
    readTextNode(node) {
      let text6 = node.nodeValue;
      for (let point of this.points)
        if (point.node == node)
          point.pos = this.text.length + Math.min(point.offset, text6.length);
      for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
        let nextBreak = -1, breakSize = 1, m2;
        if (this.lineSeparator) {
          nextBreak = text6.indexOf(this.lineSeparator, off);
          breakSize = this.lineSeparator.length;
        } else if (m2 = re.exec(text6)) {
          nextBreak = m2.index;
          breakSize = m2[0].length;
        }
        this.append(text6.slice(off, nextBreak < 0 ? text6.length : nextBreak));
        if (nextBreak < 0)
          break;
        this.lineBreak();
        if (breakSize > 1) {
          for (let point of this.points)
            if (point.node == node && point.pos > this.text.length)
              point.pos -= breakSize - 1;
        }
        off = nextBreak + breakSize;
      }
    }
    readNode(node) {
      if (node.cmIgnore)
        return;
      let view2 = ContentView.get(node);
      let fromView = view2 && view2.overrideDOMText;
      if (fromView != null) {
        this.findPointInside(node, fromView.length);
        for (let i2 = fromView.iter(); !i2.next().done; ) {
          if (i2.lineBreak)
            this.lineBreak();
          else
            this.append(i2.value);
        }
      } else if (node.nodeType == 3) {
        this.readTextNode(node);
      } else if (node.nodeName == "BR") {
        if (node.nextSibling)
          this.lineBreak();
      } else if (node.nodeType == 1) {
        this.readRange(node.firstChild, null);
      }
    }
    findPointBefore(node, next) {
      for (let point of this.points)
        if (point.node == node && node.childNodes[point.offset] == next)
          point.pos = this.text.length;
    }
    findPointInside(node, length9) {
      for (let point of this.points)
        if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
          point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length9 : 0);
    }
  };
  function isAtEnd(parent2, node, offset) {
    for (; ; ) {
      if (!node || offset < maxOffset(node))
        return false;
      if (node == parent2)
        return true;
      offset = domIndex(node) + 1;
      node = node.parentNode;
    }
  }
  var DOMPoint = class {
    constructor(node, offset) {
      this.node = node;
      this.offset = offset;
      this.pos = -1;
    }
  };
  var DOMChange = class {
    constructor(view2, start3, end, typeOver) {
      this.typeOver = typeOver;
      this.bounds = null;
      this.text = "";
      this.domChanged = start3 > -1;
      let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view2.docView;
      if (view2.state.readOnly && start3 > -1) {
        this.newSel = null;
      } else if (start3 > -1 && (this.bounds = view2.docView.domBoundsAround(start3, end, 0))) {
        let selPoints = iHead || iAnchor ? [] : selectionPoints(view2);
        let reader = new DOMReader(selPoints, view2.state);
        reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
        this.text = reader.text;
        this.newSel = selectionFromPoints(selPoints, this.bounds.from);
      } else {
        let domSel = view2.observer.selectionRange;
        let head5 = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains2(view2.contentDOM, domSel.focusNode) ? view2.state.selection.main.head : view2.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
        let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains2(view2.contentDOM, domSel.anchorNode) ? view2.state.selection.main.anchor : view2.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
        let vp = view2.viewport;
        if ((browser.ios || browser.chrome) && view2.state.selection.main.empty && head5 != anchor && (vp.from > 0 || vp.to < view2.state.doc.length)) {
          let from3 = Math.min(head5, anchor), to3 = Math.max(head5, anchor);
          let offFrom = vp.from - from3, offTo = vp.to - to3;
          if ((offFrom == 0 || offFrom == 1 || from3 == 0) && (offTo == 0 || offTo == -1 || to3 == view2.state.doc.length)) {
            head5 = 0;
            anchor = view2.state.doc.length;
          }
        }
        this.newSel = EditorSelection.single(anchor, head5);
      }
    }
  };
  function applyDOMChange(view2, domChange) {
    let change;
    let { newSel } = domChange, sel = view2.state.selection.main;
    let lastKey = view2.inputState.lastKeyTime > Date.now() - 100 ? view2.inputState.lastKeyCode : -1;
    if (domChange.bounds) {
      let { from: from3, to: to3 } = domChange.bounds;
      let preferredPos = sel.from, preferredSide = null;
      if (lastKey === 8 || browser.android && domChange.text.length < to3 - from3) {
        preferredPos = sel.to;
        preferredSide = "end";
      }
      let diff = findDiff(view2.state.doc.sliceString(from3, to3, LineBreakPlaceholder), domChange.text, preferredPos - from3, preferredSide);
      if (diff) {
        if (browser.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
          diff.toB--;
        change = {
          from: from3 + diff.from,
          to: from3 + diff.toA,
          insert: Text2.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
        };
      }
    } else if (newSel && (!view2.hasFocus && view2.state.facet(editable) || newSel.main.eq(sel))) {
      newSel = null;
    }
    if (!change && !newSel)
      return false;
    if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
      change = { from: sel.from, to: sel.to, insert: view2.state.doc.slice(sel.from, sel.to) };
    } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
      change = {
        from: sel.from,
        to: sel.to,
        insert: view2.state.doc.slice(sel.from, change.from).append(change.insert).append(view2.state.doc.slice(change.to, sel.to))
      };
    } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString()) && view2.contentDOM.getAttribute("autocorrect") == "off") {
      if (newSel && change.insert.length == 2)
        newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
      change = { from: sel.from, to: sel.to, insert: Text2.of([" "]) };
    } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view2.lineWrapping) {
      if (newSel)
        newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
      change = { from: sel.from, to: sel.to, insert: Text2.of([" "]) };
    }
    if (change) {
      return applyDOMChangeInner(view2, change, newSel, lastKey);
    } else if (newSel && !newSel.main.eq(sel)) {
      let scrollIntoView3 = false, userEvent = "select";
      if (view2.inputState.lastSelectionTime > Date.now() - 50) {
        if (view2.inputState.lastSelectionOrigin == "select")
          scrollIntoView3 = true;
        userEvent = view2.inputState.lastSelectionOrigin;
      }
      view2.dispatch({ selection: newSel, scrollIntoView: scrollIntoView3, userEvent });
      return true;
    } else {
      return false;
    }
  }
  function applyDOMChangeInner(view2, change, newSel, lastKey = -1) {
    if (browser.ios && view2.inputState.flushIOSKey(change))
      return true;
    let sel = view2.state.selection.main;
    if (browser.android && (change.to == sel.to && // GBoard will sometimes remove a space it just inserted
    // after a completion when you press enter
    (change.from == sel.from || change.from == sel.from - 1 && view2.state.sliceDoc(change.from, sel.from) == " ") && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view2.contentDOM, "Enter", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view2.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view2.contentDOM, "Delete", 46)))
      return true;
    let text6 = change.insert.toString();
    if (view2.inputState.composing >= 0)
      view2.inputState.composing++;
    let defaultTr;
    let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view2, change, newSel));
    if (!view2.state.facet(inputHandler).some((h2) => h2(view2, change.from, change.to, text6, defaultInsert)))
      view2.dispatch(defaultInsert());
    return true;
  }
  function applyDefaultInsert(view2, change, newSel) {
    let tr, startState = view2.state, sel = startState.selection.main;
    if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view2.inputState.composing < 0) {
      let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
      let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
      tr = startState.replaceSelection(view2.state.toText(before + change.insert.sliceString(0, void 0, view2.state.lineBreak) + after));
    } else {
      let changes = startState.changes(change);
      let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : void 0;
      if (startState.selection.ranges.length > 1 && view2.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
        let replaced = view2.state.sliceDoc(change.from, change.to);
        let compositionRange, composition = newSel && findCompositionNode(view2, newSel.main.head);
        if (composition) {
          let dLen = change.insert.length - (change.to - change.from);
          compositionRange = { from: composition.from, to: composition.to - dLen };
        } else {
          compositionRange = view2.state.doc.lineAt(sel.head);
        }
        let offset = sel.to - change.to, size5 = sel.to - sel.from;
        tr = startState.changeByRange((range3) => {
          if (range3.from == sel.from && range3.to == sel.to)
            return { changes, range: mainSel || range3.map(changes) };
          let to3 = range3.to - offset, from3 = to3 - replaced.length;
          if (range3.to - range3.from != size5 || view2.state.sliceDoc(from3, to3) != replaced || // Unfortunately, there's no way to make multiple
          // changes in the same node work without aborting
          // composition, so cursors in the composition range are
          // ignored.
          range3.to >= compositionRange.from && range3.from <= compositionRange.to)
            return { range: range3 };
          let rangeChanges = startState.changes({ from: from3, to: to3, insert: change.insert }), selOff = range3.to - sel.to;
          return {
            changes: rangeChanges,
            range: !mainSel ? range3.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
          };
        });
      } else {
        tr = {
          changes,
          selection: mainSel && startState.selection.replaceRange(mainSel)
        };
      }
    }
    let userEvent = "input.type";
    if (view2.composing || view2.inputState.compositionPendingChange && view2.inputState.compositionEndedAt > Date.now() - 50) {
      view2.inputState.compositionPendingChange = false;
      userEvent += ".compose";
      if (view2.inputState.compositionFirstChange) {
        userEvent += ".start";
        view2.inputState.compositionFirstChange = false;
      }
    }
    return startState.update(tr, { userEvent, scrollIntoView: true });
  }
  function findDiff(a2, b2, preferredPos, preferredSide) {
    let minLen = Math.min(a2.length, b2.length);
    let from3 = 0;
    while (from3 < minLen && a2.charCodeAt(from3) == b2.charCodeAt(from3))
      from3++;
    if (from3 == minLen && a2.length == b2.length)
      return null;
    let toA = a2.length, toB = b2.length;
    while (toA > 0 && toB > 0 && a2.charCodeAt(toA - 1) == b2.charCodeAt(toB - 1)) {
      toA--;
      toB--;
    }
    if (preferredSide == "end") {
      let adjust = Math.max(0, from3 - Math.min(toA, toB));
      preferredPos -= toA + adjust - from3;
    }
    if (toA < from3 && a2.length < b2.length) {
      let move2 = preferredPos <= from3 && preferredPos >= toA ? from3 - preferredPos : 0;
      from3 -= move2;
      toB = from3 + (toB - toA);
      toA = from3;
    } else if (toB < from3) {
      let move2 = preferredPos <= from3 && preferredPos >= toB ? from3 - preferredPos : 0;
      from3 -= move2;
      toA = from3 + (toA - toB);
      toB = from3;
    }
    return { from: from3, toA, toB };
  }
  function selectionPoints(view2) {
    let result = [];
    if (view2.root.activeElement != view2.contentDOM)
      return result;
    let { anchorNode, anchorOffset, focusNode, focusOffset } = view2.observer.selectionRange;
    if (anchorNode) {
      result.push(new DOMPoint(anchorNode, anchorOffset));
      if (focusNode != anchorNode || focusOffset != anchorOffset)
        result.push(new DOMPoint(focusNode, focusOffset));
    }
    return result;
  }
  function selectionFromPoints(points, base2) {
    if (points.length == 0)
      return null;
    let anchor = points[0].pos, head5 = points.length == 2 ? points[1].pos : anchor;
    return anchor > -1 && head5 > -1 ? EditorSelection.single(anchor + base2, head5 + base2) : null;
  }
  var InputState = class {
    setSelectionOrigin(origin4) {
      this.lastSelectionOrigin = origin4;
      this.lastSelectionTime = Date.now();
    }
    constructor(view2) {
      this.view = view2;
      this.lastKeyCode = 0;
      this.lastKeyTime = 0;
      this.lastTouchTime = 0;
      this.lastFocusTime = 0;
      this.lastScrollTop = 0;
      this.lastScrollLeft = 0;
      this.pendingIOSKey = void 0;
      this.tabFocusMode = -1;
      this.lastSelectionOrigin = null;
      this.lastSelectionTime = 0;
      this.lastContextMenu = 0;
      this.scrollHandlers = [];
      this.handlers = /* @__PURE__ */ Object.create(null);
      this.composing = -1;
      this.compositionFirstChange = null;
      this.compositionEndedAt = 0;
      this.compositionPendingKey = false;
      this.compositionPendingChange = false;
      this.mouseSelection = null;
      this.draggedContent = null;
      this.handleEvent = this.handleEvent.bind(this);
      this.notifiedFocused = view2.hasFocus;
      if (browser.safari)
        view2.contentDOM.addEventListener("input", () => null);
      if (browser.gecko)
        firefoxCopyCutHack(view2.contentDOM.ownerDocument);
    }
    handleEvent(event) {
      if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event))
        return;
      if (event.type == "keydown" && this.keydown(event))
        return;
      this.runHandlers(event.type, event);
    }
    runHandlers(type, event) {
      let handlers2 = this.handlers[type];
      if (handlers2) {
        for (let observer of handlers2.observers)
          observer(this.view, event);
        for (let handler of handlers2.handlers) {
          if (event.defaultPrevented)
            break;
          if (handler(this.view, event)) {
            event.preventDefault();
            break;
          }
        }
      }
    }
    ensureHandlers(plugins) {
      let handlers2 = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;
      for (let type in handlers2)
        if (type != "scroll") {
          let passive = !handlers2[type].handlers.length;
          let exists = prev[type];
          if (exists && passive != !exists.handlers.length) {
            dom.removeEventListener(type, this.handleEvent);
            exists = null;
          }
          if (!exists)
            dom.addEventListener(type, this.handleEvent, { passive });
        }
      for (let type in prev)
        if (type != "scroll" && !handlers2[type])
          dom.removeEventListener(type, this.handleEvent);
      this.handlers = handlers2;
    }
    keydown(event) {
      this.lastKeyCode = event.keyCode;
      this.lastKeyTime = Date.now();
      if (event.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
        return true;
      if (this.tabFocusMode > 0 && event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0)
        this.tabFocusMode = -1;
      if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
        this.view.observer.delayAndroidKey(event.key, event.keyCode);
        return true;
      }
      let pending;
      if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find((key) => key.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
        this.pendingIOSKey = pending || event;
        setTimeout(() => this.flushIOSKey(), 250);
        return true;
      }
      if (event.keyCode != 229)
        this.view.observer.forceFlush();
      return false;
    }
    flushIOSKey(change) {
      let key = this.pendingIOSKey;
      if (!key)
        return false;
      if (key.key == "Enter" && change && change.from < change.to && /^\S+$/.test(change.insert.toString()))
        return false;
      this.pendingIOSKey = void 0;
      return dispatchKey(this.view.contentDOM, key.key, key.keyCode, key instanceof KeyboardEvent ? key : void 0);
    }
    ignoreDuringComposition(event) {
      if (!/^key/.test(event.type))
        return false;
      if (this.composing > 0)
        return true;
      if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
        this.compositionPendingKey = false;
        return true;
      }
      return false;
    }
    startMouseSelection(mouseSelection) {
      if (this.mouseSelection)
        this.mouseSelection.destroy();
      this.mouseSelection = mouseSelection;
    }
    update(update3) {
      this.view.observer.update(update3);
      if (this.mouseSelection)
        this.mouseSelection.update(update3);
      if (this.draggedContent && update3.docChanged)
        this.draggedContent = this.draggedContent.map(update3.changes);
      if (update3.transactions.length)
        this.lastKeyCode = this.lastSelectionTime = 0;
    }
    destroy() {
      if (this.mouseSelection)
        this.mouseSelection.destroy();
    }
  };
  function bindHandler(plugin, handler) {
    return (view2, event) => {
      try {
        return handler.call(plugin, event, view2);
      } catch (e2) {
        logException(view2.state, e2);
      }
    };
  }
  function computeHandlers(plugins) {
    let result = /* @__PURE__ */ Object.create(null);
    function record(type) {
      return result[type] || (result[type] = { observers: [], handlers: [] });
    }
    for (let plugin of plugins) {
      let spec = plugin.spec;
      if (spec && spec.domEventHandlers)
        for (let type in spec.domEventHandlers) {
          let f2 = spec.domEventHandlers[type];
          if (f2)
            record(type).handlers.push(bindHandler(plugin.value, f2));
        }
      if (spec && spec.domEventObservers)
        for (let type in spec.domEventObservers) {
          let f2 = spec.domEventObservers[type];
          if (f2)
            record(type).observers.push(bindHandler(plugin.value, f2));
        }
    }
    for (let type in handlers)
      record(type).handlers.push(handlers[type]);
    for (let type in observers)
      record(type).observers.push(observers[type]);
    return result;
  }
  var PendingKeys = [
    { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
    { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
    { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
    { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
  ];
  var EmacsyPendingKeys = "dthko";
  var modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
  var dragScrollMargin = 6;
  function dragScrollSpeed(dist2) {
    return Math.max(0, dist2) * 0.7 + 8;
  }
  function dist(a2, b2) {
    return Math.max(Math.abs(a2.clientX - b2.clientX), Math.abs(a2.clientY - b2.clientY));
  }
  var MouseSelection = class {
    constructor(view2, startEvent, style3, mustSelect) {
      this.view = view2;
      this.startEvent = startEvent;
      this.style = style3;
      this.mustSelect = mustSelect;
      this.scrollSpeed = { x: 0, y: 0 };
      this.scrolling = -1;
      this.lastEvent = startEvent;
      this.scrollParents = scrollableParents(view2.contentDOM);
      this.atoms = view2.state.facet(atomicRanges).map((f2) => f2(view2));
      let doc2 = view2.contentDOM.ownerDocument;
      doc2.addEventListener("mousemove", this.move = this.move.bind(this));
      doc2.addEventListener("mouseup", this.up = this.up.bind(this));
      this.extend = startEvent.shiftKey;
      this.multiple = view2.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view2, startEvent);
      this.dragging = isInPrimarySelection(view2, startEvent) && getClickType(startEvent) == 1 ? null : false;
    }
    start(event) {
      if (this.dragging === false)
        this.select(event);
    }
    move(event) {
      if (event.buttons == 0)
        return this.destroy();
      if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10)
        return;
      this.select(this.lastEvent = event);
      let sx = 0, sy = 0;
      let left = 0, top4 = 0, right = this.view.win.innerWidth, bottom3 = this.view.win.innerHeight;
      if (this.scrollParents.x)
        ({ left, right } = this.scrollParents.x.getBoundingClientRect());
      if (this.scrollParents.y)
        ({ top: top4, bottom: bottom3 } = this.scrollParents.y.getBoundingClientRect());
      let margins = getScrollMargins(this.view);
      if (event.clientX - margins.left <= left + dragScrollMargin)
        sx = -dragScrollSpeed(left - event.clientX);
      else if (event.clientX + margins.right >= right - dragScrollMargin)
        sx = dragScrollSpeed(event.clientX - right);
      if (event.clientY - margins.top <= top4 + dragScrollMargin)
        sy = -dragScrollSpeed(top4 - event.clientY);
      else if (event.clientY + margins.bottom >= bottom3 - dragScrollMargin)
        sy = dragScrollSpeed(event.clientY - bottom3);
      this.setScrollSpeed(sx, sy);
    }
    up(event) {
      if (this.dragging == null)
        this.select(this.lastEvent);
      if (!this.dragging)
        event.preventDefault();
      this.destroy();
    }
    destroy() {
      this.setScrollSpeed(0, 0);
      let doc2 = this.view.contentDOM.ownerDocument;
      doc2.removeEventListener("mousemove", this.move);
      doc2.removeEventListener("mouseup", this.up);
      this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
    }
    setScrollSpeed(sx, sy) {
      this.scrollSpeed = { x: sx, y: sy };
      if (sx || sy) {
        if (this.scrolling < 0)
          this.scrolling = setInterval(() => this.scroll(), 50);
      } else if (this.scrolling > -1) {
        clearInterval(this.scrolling);
        this.scrolling = -1;
      }
    }
    scroll() {
      let { x: x2, y: y2 } = this.scrollSpeed;
      if (x2 && this.scrollParents.x) {
        this.scrollParents.x.scrollLeft += x2;
        x2 = 0;
      }
      if (y2 && this.scrollParents.y) {
        this.scrollParents.y.scrollTop += y2;
        y2 = 0;
      }
      if (x2 || y2)
        this.view.win.scrollBy(x2, y2);
      if (this.dragging === false)
        this.select(this.lastEvent);
    }
    skipAtoms(sel) {
      let ranges = null;
      for (let i2 = 0; i2 < sel.ranges.length; i2++) {
        let range3 = sel.ranges[i2], updated = null;
        if (range3.empty) {
          let pos = skipAtomicRanges(this.atoms, range3.from, 0);
          if (pos != range3.from)
            updated = EditorSelection.cursor(pos, -1);
        } else {
          let from3 = skipAtomicRanges(this.atoms, range3.from, -1);
          let to3 = skipAtomicRanges(this.atoms, range3.to, 1);
          if (from3 != range3.from || to3 != range3.to)
            updated = EditorSelection.range(range3.from == range3.anchor ? from3 : to3, range3.from == range3.head ? from3 : to3);
        }
        if (updated) {
          if (!ranges)
            ranges = sel.ranges.slice();
          ranges[i2] = updated;
        }
      }
      return ranges ? EditorSelection.create(ranges, sel.mainIndex) : sel;
    }
    select(event) {
      let { view: view2 } = this, selection = this.skipAtoms(this.style.get(event, this.extend, this.multiple));
      if (this.mustSelect || !selection.eq(view2.state.selection, this.dragging === false))
        this.view.dispatch({
          selection,
          userEvent: "select.pointer"
        });
      this.mustSelect = false;
    }
    update(update3) {
      if (update3.transactions.some((tr) => tr.isUserEvent("input.type")))
        this.destroy();
      else if (this.style.update(update3))
        setTimeout(() => this.select(this.lastEvent), 20);
    }
  };
  function addsSelectionRange(view2, event) {
    let facet = view2.state.facet(clickAddsSelectionRange);
    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
  }
  function dragMovesSelection(view2, event) {
    let facet = view2.state.facet(dragMovesSelection$1);
    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
  }
  function isInPrimarySelection(view2, event) {
    let { main: main4 } = view2.state.selection;
    if (main4.empty)
      return false;
    let sel = getSelection(view2.root);
    if (!sel || sel.rangeCount == 0)
      return true;
    let rects = sel.getRangeAt(0).getClientRects();
    for (let i2 = 0; i2 < rects.length; i2++) {
      let rect = rects[i2];
      if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY)
        return true;
    }
    return false;
  }
  function eventBelongsToEditor(view2, event) {
    if (!event.bubbles)
      return true;
    if (event.defaultPrevented)
      return false;
    for (let node = event.target, cView; node != view2.contentDOM; node = node.parentNode)
      if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event))
        return false;
    return true;
  }
  var handlers = /* @__PURE__ */ Object.create(null);
  var observers = /* @__PURE__ */ Object.create(null);
  var brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
  function capturePaste(view2) {
    let parent2 = view2.dom.parentNode;
    if (!parent2)
      return;
    let target5 = parent2.appendChild(document.createElement("textarea"));
    target5.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target5.focus();
    setTimeout(() => {
      view2.focus();
      target5.remove();
      doPaste(view2, target5.value);
    }, 50);
  }
  function textFilter(state4, facet, text6) {
    for (let filter3 of state4.facet(facet))
      text6 = filter3(text6, state4);
    return text6;
  }
  function doPaste(view2, input) {
    input = textFilter(view2.state, clipboardInputFilter, input);
    let { state: state4 } = view2, changes, i2 = 1, text6 = state4.toText(input);
    let byLine = text6.lines == state4.selection.ranges.length;
    let linewise = lastLinewiseCopy != null && state4.selection.ranges.every((r2) => r2.empty) && lastLinewiseCopy == text6.toString();
    if (linewise) {
      let lastLine = -1;
      changes = state4.changeByRange((range3) => {
        let line = state4.doc.lineAt(range3.from);
        if (line.from == lastLine)
          return { range: range3 };
        lastLine = line.from;
        let insert10 = state4.toText((byLine ? text6.line(i2++).text : input) + state4.lineBreak);
        return {
          changes: { from: line.from, insert: insert10 },
          range: EditorSelection.cursor(range3.from + insert10.length)
        };
      });
    } else if (byLine) {
      changes = state4.changeByRange((range3) => {
        let line = text6.line(i2++);
        return {
          changes: { from: range3.from, to: range3.to, insert: line.text },
          range: EditorSelection.cursor(range3.from + line.length)
        };
      });
    } else {
      changes = state4.replaceSelection(text6);
    }
    view2.dispatch(changes, {
      userEvent: "input.paste",
      scrollIntoView: true
    });
  }
  observers.scroll = (view2) => {
    view2.inputState.lastScrollTop = view2.scrollDOM.scrollTop;
    view2.inputState.lastScrollLeft = view2.scrollDOM.scrollLeft;
  };
  handlers.keydown = (view2, event) => {
    view2.inputState.setSelectionOrigin("select");
    if (event.keyCode == 27 && view2.inputState.tabFocusMode != 0)
      view2.inputState.tabFocusMode = Date.now() + 2e3;
    return false;
  };
  observers.touchstart = (view2, e2) => {
    view2.inputState.lastTouchTime = Date.now();
    view2.inputState.setSelectionOrigin("select.pointer");
  };
  observers.touchmove = (view2) => {
    view2.inputState.setSelectionOrigin("select.pointer");
  };
  handlers.mousedown = (view2, event) => {
    view2.observer.flush();
    if (view2.inputState.lastTouchTime > Date.now() - 2e3)
      return false;
    let style3 = null;
    for (let makeStyle of view2.state.facet(mouseSelectionStyle)) {
      style3 = makeStyle(view2, event);
      if (style3)
        break;
    }
    if (!style3 && event.button == 0)
      style3 = basicMouseSelection(view2, event);
    if (style3) {
      let mustFocus = !view2.hasFocus;
      view2.inputState.startMouseSelection(new MouseSelection(view2, event, style3, mustFocus));
      if (mustFocus)
        view2.observer.ignore(() => {
          focusPreventScroll(view2.contentDOM);
          let active = view2.root.activeElement;
          if (active && !active.contains(view2.contentDOM))
            active.blur();
        });
      let mouseSel = view2.inputState.mouseSelection;
      if (mouseSel) {
        mouseSel.start(event);
        return mouseSel.dragging === false;
      }
    }
    return false;
  };
  function rangeForClick(view2, pos, bias, type) {
    if (type == 1) {
      return EditorSelection.cursor(pos, bias);
    } else if (type == 2) {
      return groupAt(view2.state, pos, bias);
    } else {
      let visual = LineView.find(view2.docView, pos), line = view2.state.doc.lineAt(visual ? visual.posAtEnd : pos);
      let from3 = visual ? visual.posAtStart : line.from, to3 = visual ? visual.posAtEnd : line.to;
      if (to3 < view2.state.doc.length && to3 == line.to)
        to3++;
      return EditorSelection.range(from3, to3);
    }
  }
  var inside = (x2, y2, rect) => y2 >= rect.top && y2 <= rect.bottom && x2 >= rect.left && x2 <= rect.right;
  function findPositionSide(view2, pos, x2, y2) {
    let line = LineView.find(view2.docView, pos);
    if (!line)
      return 1;
    let off = pos - line.posAtStart;
    if (off == 0)
      return 1;
    if (off == line.length)
      return -1;
    let before = line.coordsAt(off, -1);
    if (before && inside(x2, y2, before))
      return -1;
    let after = line.coordsAt(off, 1);
    if (after && inside(x2, y2, after))
      return 1;
    return before && before.bottom >= y2 ? -1 : 1;
  }
  function queryPos(view2, event) {
    let pos = view2.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    return { pos, bias: findPositionSide(view2, pos, event.clientX, event.clientY) };
  }
  var BadMouseDetail = browser.ie && browser.ie_version <= 11;
  var lastMouseDown = null;
  var lastMouseDownCount = 0;
  var lastMouseDownTime = 0;
  function getClickType(event) {
    if (!BadMouseDetail)
      return event.detail;
    let last4 = lastMouseDown, lastTime = lastMouseDownTime;
    lastMouseDown = event;
    lastMouseDownTime = Date.now();
    return lastMouseDownCount = !last4 || lastTime > Date.now() - 400 && Math.abs(last4.clientX - event.clientX) < 2 && Math.abs(last4.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
  }
  function basicMouseSelection(view2, event) {
    let start3 = queryPos(view2, event), type = getClickType(event);
    let startSel = view2.state.selection;
    return {
      update(update3) {
        if (update3.docChanged) {
          start3.pos = update3.changes.mapPos(start3.pos);
          startSel = startSel.map(update3.changes);
        }
      },
      get(event2, extend3, multiple3) {
        let cur2 = queryPos(view2, event2), removed;
        let range3 = rangeForClick(view2, cur2.pos, cur2.bias, type);
        if (start3.pos != cur2.pos && !extend3) {
          let startRange = rangeForClick(view2, start3.pos, start3.bias, type);
          let from3 = Math.min(startRange.from, range3.from), to3 = Math.max(startRange.to, range3.to);
          range3 = from3 < range3.from ? EditorSelection.range(from3, to3) : EditorSelection.range(to3, from3);
        }
        if (extend3)
          return startSel.replaceRange(startSel.main.extend(range3.from, range3.to));
        else if (multiple3 && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur2.pos)))
          return removed;
        else if (multiple3)
          return startSel.addRange(range3);
        else
          return EditorSelection.create([range3]);
      }
    };
  }
  function removeRangeAround(sel, pos) {
    for (let i2 = 0; i2 < sel.ranges.length; i2++) {
      let { from: from3, to: to3 } = sel.ranges[i2];
      if (from3 <= pos && to3 >= pos)
        return EditorSelection.create(sel.ranges.slice(0, i2).concat(sel.ranges.slice(i2 + 1)), sel.mainIndex == i2 ? 0 : sel.mainIndex - (sel.mainIndex > i2 ? 1 : 0));
    }
    return null;
  }
  handlers.dragstart = (view2, event) => {
    let { selection: { main: range3 } } = view2.state;
    if (event.target.draggable) {
      let cView = view2.docView.nearest(event.target);
      if (cView && cView.isWidget) {
        let from3 = cView.posAtStart, to3 = from3 + cView.length;
        if (from3 >= range3.to || to3 <= range3.from)
          range3 = EditorSelection.range(from3, to3);
      }
    }
    let { inputState } = view2;
    if (inputState.mouseSelection)
      inputState.mouseSelection.dragging = true;
    inputState.draggedContent = range3;
    if (event.dataTransfer) {
      event.dataTransfer.setData("Text", textFilter(view2.state, clipboardOutputFilter, view2.state.sliceDoc(range3.from, range3.to)));
      event.dataTransfer.effectAllowed = "copyMove";
    }
    return false;
  };
  handlers.dragend = (view2) => {
    view2.inputState.draggedContent = null;
    return false;
  };
  function dropText(view2, event, text6, direct) {
    text6 = textFilter(view2.state, clipboardInputFilter, text6);
    if (!text6)
      return;
    let dropPos = view2.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    let { draggedContent } = view2.inputState;
    let del = direct && draggedContent && dragMovesSelection(view2, event) ? { from: draggedContent.from, to: draggedContent.to } : null;
    let ins = { from: dropPos, insert: text6 };
    let changes = view2.state.changes(del ? [del, ins] : ins);
    view2.focus();
    view2.dispatch({
      changes,
      selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
      userEvent: del ? "move.drop" : "input.drop"
    });
    view2.inputState.draggedContent = null;
  }
  handlers.drop = (view2, event) => {
    if (!event.dataTransfer)
      return false;
    if (view2.state.readOnly)
      return true;
    let files = event.dataTransfer.files;
    if (files && files.length) {
      let text6 = Array(files.length), read3 = 0;
      let finishFile = () => {
        if (++read3 == files.length)
          dropText(view2, event, text6.filter((s2) => s2 != null).join(view2.state.lineBreak), false);
      };
      for (let i2 = 0; i2 < files.length; i2++) {
        let reader = new FileReader();
        reader.onerror = finishFile;
        reader.onload = () => {
          if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
            text6[i2] = reader.result;
          finishFile();
        };
        reader.readAsText(files[i2]);
      }
      return true;
    } else {
      let text6 = event.dataTransfer.getData("Text");
      if (text6) {
        dropText(view2, event, text6, true);
        return true;
      }
    }
    return false;
  };
  handlers.paste = (view2, event) => {
    if (view2.state.readOnly)
      return true;
    view2.observer.flush();
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
      doPaste(view2, data.getData("text/plain") || data.getData("text/uri-list"));
      return true;
    } else {
      capturePaste(view2);
      return false;
    }
  };
  function captureCopy(view2, text6) {
    let parent2 = view2.dom.parentNode;
    if (!parent2)
      return;
    let target5 = parent2.appendChild(document.createElement("textarea"));
    target5.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target5.value = text6;
    target5.focus();
    target5.selectionEnd = text6.length;
    target5.selectionStart = 0;
    setTimeout(() => {
      target5.remove();
      view2.focus();
    }, 50);
  }
  function copiedRange(state4) {
    let content4 = [], ranges = [], linewise = false;
    for (let range3 of state4.selection.ranges)
      if (!range3.empty) {
        content4.push(state4.sliceDoc(range3.from, range3.to));
        ranges.push(range3);
      }
    if (!content4.length) {
      let upto = -1;
      for (let { from: from3 } of state4.selection.ranges) {
        let line = state4.doc.lineAt(from3);
        if (line.number > upto) {
          content4.push(line.text);
          ranges.push({ from: line.from, to: Math.min(state4.doc.length, line.to + 1) });
        }
        upto = line.number;
      }
      linewise = true;
    }
    return { text: textFilter(state4, clipboardOutputFilter, content4.join(state4.lineBreak)), ranges, linewise };
  }
  var lastLinewiseCopy = null;
  handlers.copy = handlers.cut = (view2, event) => {
    let { text: text6, ranges, linewise } = copiedRange(view2.state);
    if (!text6 && !linewise)
      return false;
    lastLinewiseCopy = linewise ? text6 : null;
    if (event.type == "cut" && !view2.state.readOnly)
      view2.dispatch({
        changes: ranges,
        scrollIntoView: true,
        userEvent: "delete.cut"
      });
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
      data.clearData();
      data.setData("text/plain", text6);
      return true;
    } else {
      captureCopy(view2, text6);
      return false;
    }
  };
  var isFocusChange = /* @__PURE__ */ Annotation.define();
  function focusChangeTransaction(state4, focus2) {
    let effects = [];
    for (let getEffect of state4.facet(focusChangeEffect)) {
      let effect = getEffect(state4, focus2);
      if (effect)
        effects.push(effect);
    }
    return effects ? state4.update({ effects, annotations: isFocusChange.of(true) }) : null;
  }
  function updateForFocusChange(view2) {
    setTimeout(() => {
      let focus2 = view2.hasFocus;
      if (focus2 != view2.inputState.notifiedFocused) {
        let tr = focusChangeTransaction(view2.state, focus2);
        if (tr)
          view2.dispatch(tr);
        else
          view2.update([]);
      }
    }, 10);
  }
  observers.focus = (view2) => {
    view2.inputState.lastFocusTime = Date.now();
    if (!view2.scrollDOM.scrollTop && (view2.inputState.lastScrollTop || view2.inputState.lastScrollLeft)) {
      view2.scrollDOM.scrollTop = view2.inputState.lastScrollTop;
      view2.scrollDOM.scrollLeft = view2.inputState.lastScrollLeft;
    }
    updateForFocusChange(view2);
  };
  observers.blur = (view2) => {
    view2.observer.clearSelectionRange();
    updateForFocusChange(view2);
  };
  observers.compositionstart = observers.compositionupdate = (view2) => {
    if (view2.observer.editContext)
      return;
    if (view2.inputState.compositionFirstChange == null)
      view2.inputState.compositionFirstChange = true;
    if (view2.inputState.composing < 0) {
      view2.inputState.composing = 0;
    }
  };
  observers.compositionend = (view2) => {
    if (view2.observer.editContext)
      return;
    view2.inputState.composing = -1;
    view2.inputState.compositionEndedAt = Date.now();
    view2.inputState.compositionPendingKey = true;
    view2.inputState.compositionPendingChange = view2.observer.pendingRecords().length > 0;
    view2.inputState.compositionFirstChange = null;
    if (browser.chrome && browser.android) {
      view2.observer.flushSoon();
    } else if (view2.inputState.compositionPendingChange) {
      Promise.resolve().then(() => view2.observer.flush());
    } else {
      setTimeout(() => {
        if (view2.inputState.composing < 0 && view2.docView.hasComposition)
          view2.update([]);
      }, 50);
    }
  };
  observers.contextmenu = (view2) => {
    view2.inputState.lastContextMenu = Date.now();
  };
  handlers.beforeinput = (view2, event) => {
    var _a2, _b;
    if (event.inputType == "insertReplacementText" && view2.observer.editContext) {
      let text6 = (_a2 = event.dataTransfer) === null || _a2 === void 0 ? void 0 : _a2.getData("text/plain"), ranges = event.getTargetRanges();
      if (text6 && ranges.length) {
        let r2 = ranges[0];
        let from3 = view2.posAtDOM(r2.startContainer, r2.startOffset), to3 = view2.posAtDOM(r2.endContainer, r2.endOffset);
        applyDOMChangeInner(view2, { from: from3, to: to3, insert: view2.state.toText(text6) }, null);
        return true;
      }
    }
    let pending;
    if (browser.chrome && browser.android && (pending = PendingKeys.find((key) => key.inputType == event.inputType))) {
      view2.observer.delayAndroidKey(pending.key, pending.keyCode);
      if (pending.key == "Backspace" || pending.key == "Delete") {
        let startViewHeight = ((_b = window.visualViewport) === null || _b === void 0 ? void 0 : _b.height) || 0;
        setTimeout(() => {
          var _a3;
          if ((((_a3 = window.visualViewport) === null || _a3 === void 0 ? void 0 : _a3.height) || 0) > startViewHeight + 10 && view2.hasFocus) {
            view2.contentDOM.blur();
            view2.focus();
          }
        }, 100);
      }
    }
    if (browser.ios && event.inputType == "deleteContentForward") {
      view2.observer.flushSoon();
    }
    if (browser.safari && event.inputType == "insertText" && view2.inputState.composing >= 0) {
      setTimeout(() => observers.compositionend(view2, event), 20);
    }
    return false;
  };
  var appliedFirefoxHack = /* @__PURE__ */ new Set();
  function firefoxCopyCutHack(doc2) {
    if (!appliedFirefoxHack.has(doc2)) {
      appliedFirefoxHack.add(doc2);
      doc2.addEventListener("copy", () => {
      });
      doc2.addEventListener("cut", () => {
      });
    }
  }
  var wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
  var heightChangeFlag = false;
  function clearHeightChangeFlag() {
    heightChangeFlag = false;
  }
  var HeightOracle = class {
    constructor(lineWrapping) {
      this.lineWrapping = lineWrapping;
      this.doc = Text2.empty;
      this.heightSamples = {};
      this.lineHeight = 14;
      this.charWidth = 7;
      this.textHeight = 14;
      this.lineLength = 30;
    }
    heightForGap(from3, to3) {
      let lines = this.doc.lineAt(to3).number - this.doc.lineAt(from3).number + 1;
      if (this.lineWrapping)
        lines += Math.max(0, Math.ceil((to3 - from3 - lines * this.lineLength * 0.5) / this.lineLength));
      return this.lineHeight * lines;
    }
    heightForLine(length9) {
      if (!this.lineWrapping)
        return this.lineHeight;
      let lines = 1 + Math.max(0, Math.ceil((length9 - this.lineLength) / (this.lineLength - 5)));
      return lines * this.lineHeight;
    }
    setDoc(doc2) {
      this.doc = doc2;
      return this;
    }
    mustRefreshForWrapping(whiteSpace) {
      return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
    }
    mustRefreshForHeights(lineHeights) {
      let newHeight = false;
      for (let i2 = 0; i2 < lineHeights.length; i2++) {
        let h2 = lineHeights[i2];
        if (h2 < 0) {
          i2++;
        } else if (!this.heightSamples[Math.floor(h2 * 10)]) {
          newHeight = true;
          this.heightSamples[Math.floor(h2 * 10)] = true;
        }
      }
      return newHeight;
    }
    refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
      let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
      let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
      this.lineWrapping = lineWrapping;
      this.lineHeight = lineHeight;
      this.charWidth = charWidth;
      this.textHeight = textHeight;
      this.lineLength = lineLength;
      if (changed) {
        this.heightSamples = {};
        for (let i2 = 0; i2 < knownHeights.length; i2++) {
          let h2 = knownHeights[i2];
          if (h2 < 0)
            i2++;
          else
            this.heightSamples[Math.floor(h2 * 10)] = true;
        }
      }
      return changed;
    }
  };
  var MeasuredHeights = class {
    constructor(from3, heights) {
      this.from = from3;
      this.heights = heights;
      this.index = 0;
    }
    get more() {
      return this.index < this.heights.length;
    }
  };
  var BlockInfo = class _BlockInfo {
    /**
    @internal
    */
    constructor(from3, length9, top4, height8, _content) {
      this.from = from3;
      this.length = length9;
      this.top = top4;
      this.height = height8;
      this._content = _content;
    }
    /**
    The type of element this is. When querying lines, this may be
    an array of all the blocks that make up the line.
    */
    get type() {
      return typeof this._content == "number" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;
    }
    /**
    The end of the element as a document position.
    */
    get to() {
      return this.from + this.length;
    }
    /**
    The bottom position of the element.
    */
    get bottom() {
      return this.top + this.height;
    }
    /**
    If this is a widget block, this will return the widget
    associated with it.
    */
    get widget() {
      return this._content instanceof PointDecoration ? this._content.widget : null;
    }
    /**
    If this is a textblock, this holds the number of line breaks
    that appear in widgets inside the block.
    */
    get widgetLineBreaks() {
      return typeof this._content == "number" ? this._content : 0;
    }
    /**
    @internal
    */
    join(other) {
      let content4 = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(other._content) ? other._content : [other]);
      return new _BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content4);
    }
  };
  var QueryType = /* @__PURE__ */ function(QueryType3) {
    QueryType3[QueryType3["ByPos"] = 0] = "ByPos";
    QueryType3[QueryType3["ByHeight"] = 1] = "ByHeight";
    QueryType3[QueryType3["ByPosNoHeight"] = 2] = "ByPosNoHeight";
    return QueryType3;
  }(QueryType || (QueryType = {}));
  var Epsilon = 1e-3;
  var HeightMap = class _HeightMap {
    constructor(length9, height8, flags = 2) {
      this.length = length9;
      this.height = height8;
      this.flags = flags;
    }
    get outdated() {
      return (this.flags & 2) > 0;
    }
    set outdated(value12) {
      this.flags = (value12 ? 2 : 0) | this.flags & ~2;
    }
    setHeight(height8) {
      if (this.height != height8) {
        if (Math.abs(this.height - height8) > Epsilon)
          heightChangeFlag = true;
        this.height = height8;
      }
    }
    // Base case is to replace a leaf node, which simply builds a tree
    // from the new nodes and returns that (HeightMapBranch and
    // HeightMapGap override this to actually use from/to)
    replace(_from, _to, nodes) {
      return _HeightMap.of(nodes);
    }
    // Again, these are base cases, and are overridden for branch and gap nodes.
    decomposeLeft(_to, result) {
      result.push(this);
    }
    decomposeRight(_from, result) {
      result.push(this);
    }
    applyChanges(decorations2, oldDoc, oracle, changes) {
      let me = this, doc2 = oracle.doc;
      for (let i2 = changes.length - 1; i2 >= 0; i2--) {
        let { fromA, toA, fromB, toB } = changes[i2];
        let start3 = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
        let end = start3.to >= toA ? start3 : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);
        toB += end.to - toA;
        toA = end.to;
        while (i2 > 0 && start3.from <= changes[i2 - 1].toA) {
          fromA = changes[i2 - 1].fromA;
          fromB = changes[i2 - 1].fromB;
          i2--;
          if (fromA < start3.from)
            start3 = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);
        }
        fromB += start3.from - fromA;
        fromA = start3.from;
        let nodes = NodeBuilder.build(oracle.setDoc(doc2), decorations2, fromB, toB);
        me = replace3(me, me.replace(fromA, toA, nodes));
      }
      return me.updateHeight(oracle, 0);
    }
    static empty() {
      return new HeightMapText(0, 0);
    }
    // nodes uses null values to indicate the position of line breaks.
    // There are never line breaks at the start or end of the array, or
    // two line breaks next to each other, and the array isn't allowed
    // to be empty (same restrictions as return value from the builder).
    static of(nodes) {
      if (nodes.length == 1)
        return nodes[0];
      let i2 = 0, j2 = nodes.length, before = 0, after = 0;
      for (; ; ) {
        if (i2 == j2) {
          if (before > after * 2) {
            let split3 = nodes[i2 - 1];
            if (split3.break)
              nodes.splice(--i2, 1, split3.left, null, split3.right);
            else
              nodes.splice(--i2, 1, split3.left, split3.right);
            j2 += 1 + split3.break;
            before -= split3.size;
          } else if (after > before * 2) {
            let split3 = nodes[j2];
            if (split3.break)
              nodes.splice(j2, 1, split3.left, null, split3.right);
            else
              nodes.splice(j2, 1, split3.left, split3.right);
            j2 += 2 + split3.break;
            after -= split3.size;
          } else {
            break;
          }
        } else if (before < after) {
          let next = nodes[i2++];
          if (next)
            before += next.size;
        } else {
          let next = nodes[--j2];
          if (next)
            after += next.size;
        }
      }
      let brk = 0;
      if (nodes[i2 - 1] == null) {
        brk = 1;
        i2--;
      } else if (nodes[i2] == null) {
        brk = 1;
        j2++;
      }
      return new HeightMapBranch(_HeightMap.of(nodes.slice(0, i2)), brk, _HeightMap.of(nodes.slice(j2)));
    }
  };
  function replace3(old, val) {
    if (old == val)
      return old;
    if (old.constructor != val.constructor)
      heightChangeFlag = true;
    return val;
  }
  HeightMap.prototype.size = 1;
  var HeightMapBlock = class extends HeightMap {
    constructor(length9, height8, deco) {
      super(length9, height8);
      this.deco = deco;
    }
    blockAt(_height, _oracle, top4, offset) {
      return new BlockInfo(offset, this.length, top4, this.height, this.deco || 0);
    }
    lineAt(_value, _type, oracle, top4, offset) {
      return this.blockAt(0, oracle, top4, offset);
    }
    forEachLine(from3, to3, oracle, top4, offset, f2) {
      if (from3 <= offset + this.length && to3 >= offset)
        f2(this.blockAt(0, oracle, top4, offset));
    }
    updateHeight(oracle, offset = 0, _force = false, measured) {
      if (measured && measured.from <= offset && measured.more)
        this.setHeight(measured.heights[measured.index++]);
      this.outdated = false;
      return this;
    }
    toString() {
      return `block(${this.length})`;
    }
  };
  var HeightMapText = class _HeightMapText extends HeightMapBlock {
    constructor(length9, height8) {
      super(length9, height8, null);
      this.collapsed = 0;
      this.widgetHeight = 0;
      this.breaks = 0;
    }
    blockAt(_height, _oracle, top4, offset) {
      return new BlockInfo(offset, this.length, top4, this.height, this.breaks);
    }
    replace(_from, _to, nodes) {
      let node = nodes[0];
      if (nodes.length == 1 && (node instanceof _HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
        if (node instanceof HeightMapGap)
          node = new _HeightMapText(node.length, this.height);
        else
          node.height = this.height;
        if (!this.outdated)
          node.outdated = false;
        return node;
      } else {
        return HeightMap.of(nodes);
      }
    }
    updateHeight(oracle, offset = 0, force2 = false, measured) {
      if (measured && measured.from <= offset && measured.more)
        this.setHeight(measured.heights[measured.index++]);
      else if (force2 || this.outdated)
        this.setHeight(Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);
      this.outdated = false;
      return this;
    }
    toString() {
      return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
    }
  };
  var HeightMapGap = class _HeightMapGap extends HeightMap {
    constructor(length9) {
      super(length9, 0);
    }
    heightMetrics(oracle, offset) {
      let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;
      let lines = lastLine - firstLine + 1;
      let perLine, perChar = 0;
      if (oracle.lineWrapping) {
        let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
        perLine = totalPerLine / lines;
        if (this.length > lines + 1)
          perChar = (this.height - totalPerLine) / (this.length - lines - 1);
      } else {
        perLine = this.height / lines;
      }
      return { firstLine, lastLine, perLine, perChar };
    }
    blockAt(height8, oracle, top4, offset) {
      let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);
      if (oracle.lineWrapping) {
        let guess = offset + (height8 < oracle.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (height8 - top4) / this.height)) * this.length));
        let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;
        let lineTop = Math.max(top4, height8 - lineHeight / 2);
        return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);
      } else {
        let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height8 - top4) / perLine)));
        let { from: from3, length: length9 } = oracle.doc.line(firstLine + line);
        return new BlockInfo(from3, length9, top4 + perLine * line, perLine, 0);
      }
    }
    lineAt(value12, type, oracle, top4, offset) {
      if (type == QueryType.ByHeight)
        return this.blockAt(value12, oracle, top4, offset);
      if (type == QueryType.ByPosNoHeight) {
        let { from: from3, to: to3 } = oracle.doc.lineAt(value12);
        return new BlockInfo(from3, to3 - from3, 0, 0, 0);
      }
      let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
      let line = oracle.doc.lineAt(value12), lineHeight = perLine + line.length * perChar;
      let linesAbove = line.number - firstLine;
      let lineTop = top4 + perLine * linesAbove + perChar * (line.from - offset - linesAbove);
      return new BlockInfo(line.from, line.length, Math.max(top4, Math.min(lineTop, top4 + this.height - lineHeight)), lineHeight, 0);
    }
    forEachLine(from3, to3, oracle, top4, offset, f2) {
      from3 = Math.max(from3, offset);
      to3 = Math.min(to3, offset + this.length);
      let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
      for (let pos = from3, lineTop = top4; pos <= to3; ) {
        let line = oracle.doc.lineAt(pos);
        if (pos == from3) {
          let linesAbove = line.number - firstLine;
          lineTop += perLine * linesAbove + perChar * (from3 - offset - linesAbove);
        }
        let lineHeight = perLine + perChar * line.length;
        f2(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));
        lineTop += lineHeight;
        pos = line.to + 1;
      }
    }
    replace(from3, to3, nodes) {
      let after = this.length - to3;
      if (after > 0) {
        let last4 = nodes[nodes.length - 1];
        if (last4 instanceof _HeightMapGap)
          nodes[nodes.length - 1] = new _HeightMapGap(last4.length + after);
        else
          nodes.push(null, new _HeightMapGap(after - 1));
      }
      if (from3 > 0) {
        let first = nodes[0];
        if (first instanceof _HeightMapGap)
          nodes[0] = new _HeightMapGap(from3 + first.length);
        else
          nodes.unshift(new _HeightMapGap(from3 - 1), null);
      }
      return HeightMap.of(nodes);
    }
    decomposeLeft(to3, result) {
      result.push(new _HeightMapGap(to3 - 1), null);
    }
    decomposeRight(from3, result) {
      result.push(null, new _HeightMapGap(this.length - from3 - 1));
    }
    updateHeight(oracle, offset = 0, force2 = false, measured) {
      let end = offset + this.length;
      if (measured && measured.from <= offset + this.length && measured.more) {
        let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
        if (measured.from > offset)
          nodes.push(new _HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
        while (pos <= end && measured.more) {
          let len = oracle.doc.lineAt(pos).length;
          if (nodes.length)
            nodes.push(null);
          let height8 = measured.heights[measured.index++];
          if (singleHeight == -1)
            singleHeight = height8;
          else if (Math.abs(height8 - singleHeight) >= Epsilon)
            singleHeight = -2;
          let line = new HeightMapText(len, height8);
          line.outdated = false;
          nodes.push(line);
          pos += len + 1;
        }
        if (pos <= end)
          nodes.push(null, new _HeightMapGap(end - pos).updateHeight(oracle, pos));
        let result = HeightMap.of(nodes);
        if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon)
          heightChangeFlag = true;
        return replace3(this, result);
      } else if (force2 || this.outdated) {
        this.setHeight(oracle.heightForGap(offset, offset + this.length));
        this.outdated = false;
      }
      return this;
    }
    toString() {
      return `gap(${this.length})`;
    }
  };
  var HeightMapBranch = class extends HeightMap {
    constructor(left, brk, right) {
      super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
      this.left = left;
      this.right = right;
      this.size = left.size + right.size;
    }
    get break() {
      return this.flags & 1;
    }
    blockAt(height8, oracle, top4, offset) {
      let mid = top4 + this.left.height;
      return height8 < mid ? this.left.blockAt(height8, oracle, top4, offset) : this.right.blockAt(height8, oracle, mid, offset + this.left.length + this.break);
    }
    lineAt(value12, type, oracle, top4, offset) {
      let rightTop = top4 + this.left.height, rightOffset = offset + this.left.length + this.break;
      let left = type == QueryType.ByHeight ? value12 < rightTop : value12 < rightOffset;
      let base2 = left ? this.left.lineAt(value12, type, oracle, top4, offset) : this.right.lineAt(value12, type, oracle, rightTop, rightOffset);
      if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset))
        return base2;
      let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
      if (left)
        return base2.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
      else
        return this.left.lineAt(rightOffset, subQuery, oracle, top4, offset).join(base2);
    }
    forEachLine(from3, to3, oracle, top4, offset, f2) {
      let rightTop = top4 + this.left.height, rightOffset = offset + this.left.length + this.break;
      if (this.break) {
        if (from3 < rightOffset)
          this.left.forEachLine(from3, to3, oracle, top4, offset, f2);
        if (to3 >= rightOffset)
          this.right.forEachLine(from3, to3, oracle, rightTop, rightOffset, f2);
      } else {
        let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top4, offset);
        if (from3 < mid.from)
          this.left.forEachLine(from3, mid.from - 1, oracle, top4, offset, f2);
        if (mid.to >= from3 && mid.from <= to3)
          f2(mid);
        if (to3 > mid.to)
          this.right.forEachLine(mid.to + 1, to3, oracle, rightTop, rightOffset, f2);
      }
    }
    replace(from3, to3, nodes) {
      let rightStart = this.left.length + this.break;
      if (to3 < rightStart)
        return this.balanced(this.left.replace(from3, to3, nodes), this.right);
      if (from3 > this.left.length)
        return this.balanced(this.left, this.right.replace(from3 - rightStart, to3 - rightStart, nodes));
      let result = [];
      if (from3 > 0)
        this.decomposeLeft(from3, result);
      let left = result.length;
      for (let node of nodes)
        result.push(node);
      if (from3 > 0)
        mergeGaps(result, left - 1);
      if (to3 < this.length) {
        let right = result.length;
        this.decomposeRight(to3, result);
        mergeGaps(result, right);
      }
      return HeightMap.of(result);
    }
    decomposeLeft(to3, result) {
      let left = this.left.length;
      if (to3 <= left)
        return this.left.decomposeLeft(to3, result);
      result.push(this.left);
      if (this.break) {
        left++;
        if (to3 >= left)
          result.push(null);
      }
      if (to3 > left)
        this.right.decomposeLeft(to3 - left, result);
    }
    decomposeRight(from3, result) {
      let left = this.left.length, right = left + this.break;
      if (from3 >= right)
        return this.right.decomposeRight(from3 - right, result);
      if (from3 < left)
        this.left.decomposeRight(from3, result);
      if (this.break && from3 < right)
        result.push(null);
      result.push(this.right);
    }
    balanced(left, right) {
      if (left.size > 2 * right.size || right.size > 2 * left.size)
        return HeightMap.of(this.break ? [left, null, right] : [left, right]);
      this.left = replace3(this.left, left);
      this.right = replace3(this.right, right);
      this.setHeight(left.height + right.height);
      this.outdated = left.outdated || right.outdated;
      this.size = left.size + right.size;
      this.length = left.length + this.break + right.length;
      return this;
    }
    updateHeight(oracle, offset = 0, force2 = false, measured) {
      let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
      if (measured && measured.from <= offset + left.length && measured.more)
        rebalance = left = left.updateHeight(oracle, offset, force2, measured);
      else
        left.updateHeight(oracle, offset, force2);
      if (measured && measured.from <= rightStart + right.length && measured.more)
        rebalance = right = right.updateHeight(oracle, rightStart, force2, measured);
      else
        right.updateHeight(oracle, rightStart, force2);
      if (rebalance)
        return this.balanced(left, right);
      this.height = this.left.height + this.right.height;
      this.outdated = false;
      return this;
    }
    toString() {
      return this.left + (this.break ? " " : "-") + this.right;
    }
  };
  function mergeGaps(nodes, around) {
    let before, after;
    if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
      nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
  }
  var relevantWidgetHeight = 5;
  var NodeBuilder = class _NodeBuilder {
    constructor(pos, oracle) {
      this.pos = pos;
      this.oracle = oracle;
      this.nodes = [];
      this.lineStart = -1;
      this.lineEnd = -1;
      this.covering = null;
      this.writtenTo = pos;
    }
    get isCovered() {
      return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
    }
    span(_from, to3) {
      if (this.lineStart > -1) {
        let end = Math.min(to3, this.lineEnd), last4 = this.nodes[this.nodes.length - 1];
        if (last4 instanceof HeightMapText)
          last4.length += end - this.pos;
        else if (end > this.pos || !this.isCovered)
          this.nodes.push(new HeightMapText(end - this.pos, -1));
        this.writtenTo = end;
        if (to3 > end) {
          this.nodes.push(null);
          this.writtenTo++;
          this.lineStart = -1;
        }
      }
      this.pos = to3;
    }
    point(from3, to3, deco) {
      if (from3 < to3 || deco.heightRelevant) {
        let height8 = deco.widget ? deco.widget.estimatedHeight : 0;
        let breaks = deco.widget ? deco.widget.lineBreaks : 0;
        if (height8 < 0)
          height8 = this.oracle.lineHeight;
        let len = to3 - from3;
        if (deco.block) {
          this.addBlock(new HeightMapBlock(len, height8, deco));
        } else if (len || breaks || height8 >= relevantWidgetHeight) {
          this.addLineDeco(height8, breaks, len);
        }
      } else if (to3 > from3) {
        this.span(from3, to3);
      }
      if (this.lineEnd > -1 && this.lineEnd < this.pos)
        this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
    }
    enterLine() {
      if (this.lineStart > -1)
        return;
      let { from: from3, to: to3 } = this.oracle.doc.lineAt(this.pos);
      this.lineStart = from3;
      this.lineEnd = to3;
      if (this.writtenTo < from3) {
        if (this.writtenTo < from3 - 1 || this.nodes[this.nodes.length - 1] == null)
          this.nodes.push(this.blankContent(this.writtenTo, from3 - 1));
        this.nodes.push(null);
      }
      if (this.pos > from3)
        this.nodes.push(new HeightMapText(this.pos - from3, -1));
      this.writtenTo = this.pos;
    }
    blankContent(from3, to3) {
      let gap = new HeightMapGap(to3 - from3);
      if (this.oracle.doc.lineAt(from3).to == to3)
        gap.flags |= 4;
      return gap;
    }
    ensureLine() {
      this.enterLine();
      let last4 = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
      if (last4 instanceof HeightMapText)
        return last4;
      let line = new HeightMapText(0, -1);
      this.nodes.push(line);
      return line;
    }
    addBlock(block) {
      this.enterLine();
      let deco = block.deco;
      if (deco && deco.startSide > 0 && !this.isCovered)
        this.ensureLine();
      this.nodes.push(block);
      this.writtenTo = this.pos = this.pos + block.length;
      if (deco && deco.endSide > 0)
        this.covering = block;
    }
    addLineDeco(height8, breaks, length9) {
      let line = this.ensureLine();
      line.length += length9;
      line.collapsed += length9;
      line.widgetHeight = Math.max(line.widgetHeight, height8);
      line.breaks += breaks;
      this.writtenTo = this.pos = this.pos + length9;
    }
    finish(from3) {
      let last4 = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
      if (this.lineStart > -1 && !(last4 instanceof HeightMapText) && !this.isCovered)
        this.nodes.push(new HeightMapText(0, -1));
      else if (this.writtenTo < this.pos || last4 == null)
        this.nodes.push(this.blankContent(this.writtenTo, this.pos));
      let pos = from3;
      for (let node of this.nodes) {
        if (node instanceof HeightMapText)
          node.updateHeight(this.oracle, pos);
        pos += node ? node.length : 1;
      }
      return this.nodes;
    }
    // Always called with a region that on both sides either stretches
    // to a line break or the end of the document.
    // The returned array uses null to indicate line breaks, but never
    // starts or ends in a line break, or has multiple line breaks next
    // to each other.
    static build(oracle, decorations2, from3, to3) {
      let builder = new _NodeBuilder(from3, oracle);
      RangeSet.spans(decorations2, from3, to3, builder, 0);
      return builder.finish(from3);
    }
  };
  function heightRelevantDecoChanges(a2, b2, diff) {
    let comp = new DecorationComparator2();
    RangeSet.compare(a2, b2, diff, comp, 0);
    return comp.changes;
  }
  var DecorationComparator2 = class {
    constructor() {
      this.changes = [];
    }
    compareRange() {
    }
    comparePoint(from3, to3, a2, b2) {
      if (from3 < to3 || a2 && a2.heightRelevant || b2 && b2.heightRelevant)
        addRange(from3, to3, this.changes, 5);
    }
  };
  function visiblePixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
    let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
    let top4 = Math.max(0, rect.top), bottom3 = Math.min(win.innerHeight, rect.bottom);
    for (let parent2 = dom.parentNode; parent2 && parent2 != doc2.body; ) {
      if (parent2.nodeType == 1) {
        let elt = parent2;
        let style3 = window.getComputedStyle(elt);
        if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style3.overflow != "visible") {
          let parentRect = elt.getBoundingClientRect();
          left = Math.max(left, parentRect.left);
          right = Math.min(right, parentRect.right);
          top4 = Math.max(top4, parentRect.top);
          bottom3 = Math.min(parent2 == dom.parentNode ? win.innerHeight : bottom3, parentRect.bottom);
        }
        parent2 = style3.position == "absolute" || style3.position == "fixed" ? elt.offsetParent : elt.parentNode;
      } else if (parent2.nodeType == 11) {
        parent2 = parent2.host;
      } else {
        break;
      }
    }
    return {
      left: left - rect.left,
      right: Math.max(left, right) - rect.left,
      top: top4 - (rect.top + paddingTop),
      bottom: Math.max(top4, bottom3) - (rect.top + paddingTop)
    };
  }
  function fullPixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    return {
      left: 0,
      right: rect.right - rect.left,
      top: paddingTop,
      bottom: rect.bottom - (rect.top + paddingTop)
    };
  }
  var LineGap = class {
    constructor(from3, to3, size5, displaySize) {
      this.from = from3;
      this.to = to3;
      this.size = size5;
      this.displaySize = displaySize;
    }
    static same(a2, b2) {
      if (a2.length != b2.length)
        return false;
      for (let i2 = 0; i2 < a2.length; i2++) {
        let gA = a2[i2], gB = b2[i2];
        if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
          return false;
      }
      return true;
    }
    draw(viewState, wrapping) {
      return Decoration.replace({
        widget: new LineGapWidget(this.displaySize * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
      }).range(this.from, this.to);
    }
  };
  var LineGapWidget = class extends WidgetType {
    constructor(size5, vertical) {
      super();
      this.size = size5;
      this.vertical = vertical;
    }
    eq(other) {
      return other.size == this.size && other.vertical == this.vertical;
    }
    toDOM() {
      let elt = document.createElement("div");
      if (this.vertical) {
        elt.style.height = this.size + "px";
      } else {
        elt.style.width = this.size + "px";
        elt.style.height = "2px";
        elt.style.display = "inline-block";
      }
      return elt;
    }
    get estimatedHeight() {
      return this.vertical ? this.size : -1;
    }
  };
  var ViewState = class {
    constructor(state4) {
      this.state = state4;
      this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
      this.inView = true;
      this.paddingTop = 0;
      this.paddingBottom = 0;
      this.contentDOMWidth = 0;
      this.contentDOMHeight = 0;
      this.editorHeight = 0;
      this.editorWidth = 0;
      this.scrollTop = 0;
      this.scrolledToBottom = false;
      this.scaleX = 1;
      this.scaleY = 1;
      this.scrollAnchorPos = 0;
      this.scrollAnchorHeight = -1;
      this.scaler = IdScaler;
      this.scrollTarget = null;
      this.printing = false;
      this.mustMeasureContent = true;
      this.defaultTextDirection = Direction.LTR;
      this.visibleRanges = [];
      this.mustEnforceCursorAssoc = false;
      let guessWrapping = state4.facet(contentAttributes).some((v2) => typeof v2 != "function" && v2.class == "cm-lineWrapping");
      this.heightOracle = new HeightOracle(guessWrapping);
      this.stateDeco = state4.facet(decorations).filter((d2) => typeof d2 != "function");
      this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text2.empty, this.heightOracle.setDoc(state4.doc), [new ChangedRange(0, 0, 0, state4.doc.length)]);
      for (let i2 = 0; i2 < 2; i2++) {
        this.viewport = this.getViewport(0, null);
        if (!this.updateForViewport())
          break;
      }
      this.updateViewportLines();
      this.lineGaps = this.ensureLineGaps([]);
      this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(this, false)));
      this.computeVisibleRanges();
    }
    updateForViewport() {
      let viewports = [this.viewport], { main: main4 } = this.state.selection;
      for (let i2 = 0; i2 <= 1; i2++) {
        let pos = i2 ? main4.head : main4.anchor;
        if (!viewports.some(({ from: from3, to: to3 }) => pos >= from3 && pos <= to3)) {
          let { from: from3, to: to3 } = this.lineBlockAt(pos);
          viewports.push(new Viewport(from3, to3));
        }
      }
      this.viewports = viewports.sort((a2, b2) => a2.from - b2.from);
      return this.updateScaler();
    }
    updateScaler() {
      let scaler = this.scaler;
      this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);
      return scaler.eq(this.scaler) ? 0 : 2;
    }
    updateViewportLines() {
      this.viewportLines = [];
      this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block) => {
        this.viewportLines.push(scaleBlock(block, this.scaler));
      });
    }
    update(update3, scrollTarget = null) {
      this.state = update3.state;
      let prevDeco = this.stateDeco;
      this.stateDeco = this.state.facet(decorations).filter((d2) => typeof d2 != "function");
      let contentChanges = update3.changedRanges;
      let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update3 ? update3.changes : ChangeSet.empty(this.state.doc.length)));
      let prevHeight = this.heightMap.height;
      let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
      clearHeightChangeFlag();
      this.heightMap = this.heightMap.applyChanges(this.stateDeco, update3.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
      if (this.heightMap.height != prevHeight || heightChangeFlag)
        update3.flags |= 2;
      if (scrollAnchor) {
        this.scrollAnchorPos = update3.changes.mapPos(scrollAnchor.from, -1);
        this.scrollAnchorHeight = scrollAnchor.top;
      } else {
        this.scrollAnchorPos = -1;
        this.scrollAnchorHeight = this.heightMap.height;
      }
      let viewport = heightChanges.length ? this.mapViewport(this.viewport, update3.changes) : this.viewport;
      if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
        viewport = this.getViewport(0, scrollTarget);
      let viewportChange = viewport.from != this.viewport.from || viewport.to != this.viewport.to;
      this.viewport = viewport;
      update3.flags |= this.updateForViewport();
      if (viewportChange || !update3.changes.empty || update3.flags & 2)
        this.updateViewportLines();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
        this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update3.changes)));
      update3.flags |= this.computeVisibleRanges();
      if (scrollTarget)
        this.scrollTarget = scrollTarget;
      if (!this.mustEnforceCursorAssoc && update3.selectionSet && update3.view.lineWrapping && update3.state.selection.main.empty && update3.state.selection.main.assoc && !update3.state.facet(nativeSelectionHidden))
        this.mustEnforceCursorAssoc = true;
    }
    measure(view2) {
      let dom = view2.contentDOM, style3 = window.getComputedStyle(dom);
      let oracle = this.heightOracle;
      let whiteSpace = style3.whiteSpace;
      this.defaultTextDirection = style3.direction == "rtl" ? Direction.RTL : Direction.LTR;
      let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
      let domRect = dom.getBoundingClientRect();
      let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
      this.contentDOMHeight = domRect.height;
      this.mustMeasureContent = false;
      let result = 0, bias = 0;
      if (domRect.width && domRect.height) {
        let { scaleX, scaleY } = getScale(dom, domRect);
        if (scaleX > 5e-3 && Math.abs(this.scaleX - scaleX) > 5e-3 || scaleY > 5e-3 && Math.abs(this.scaleY - scaleY) > 5e-3) {
          this.scaleX = scaleX;
          this.scaleY = scaleY;
          result |= 8;
          refresh = measureContent = true;
        }
      }
      let paddingTop = (parseInt(style3.paddingTop) || 0) * this.scaleY;
      let paddingBottom = (parseInt(style3.paddingBottom) || 0) * this.scaleY;
      if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
        this.paddingTop = paddingTop;
        this.paddingBottom = paddingBottom;
        result |= 8 | 2;
      }
      if (this.editorWidth != view2.scrollDOM.clientWidth) {
        if (oracle.lineWrapping)
          measureContent = true;
        this.editorWidth = view2.scrollDOM.clientWidth;
        result |= 8;
      }
      let scrollTop2 = view2.scrollDOM.scrollTop * this.scaleY;
      if (this.scrollTop != scrollTop2) {
        this.scrollAnchorHeight = -1;
        this.scrollTop = scrollTop2;
      }
      this.scrolledToBottom = isScrolledToBottom(view2.scrollDOM);
      let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
      let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
      this.pixelViewport = pixelViewport;
      let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
      if (inView != this.inView) {
        this.inView = inView;
        if (inView)
          measureContent = true;
      }
      if (!this.inView && !this.scrollTarget)
        return 0;
      let contentWidth = domRect.width;
      if (this.contentDOMWidth != contentWidth || this.editorHeight != view2.scrollDOM.clientHeight) {
        this.contentDOMWidth = domRect.width;
        this.editorHeight = view2.scrollDOM.clientHeight;
        result |= 8;
      }
      if (measureContent) {
        let lineHeights = view2.docView.measureVisibleLineHeights(this.viewport);
        if (oracle.mustRefreshForHeights(lineHeights))
          refresh = true;
        if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
          let { lineHeight, charWidth, textHeight } = view2.docView.measureTextSize();
          refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);
          if (refresh) {
            view2.docView.minWidth = 0;
            result |= 8;
          }
        }
        if (dTop > 0 && dBottom > 0)
          bias = Math.max(dTop, dBottom);
        else if (dTop < 0 && dBottom < 0)
          bias = Math.min(dTop, dBottom);
        clearHeightChangeFlag();
        for (let vp of this.viewports) {
          let heights = vp.from == this.viewport.from ? lineHeights : view2.docView.measureVisibleLineHeights(vp);
          this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text2.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view2.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
        }
        if (heightChangeFlag)
          result |= 2;
      }
      let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
      if (viewportChange) {
        if (result & 2)
          result |= this.updateScaler();
        this.viewport = this.getViewport(bias, this.scrollTarget);
        result |= this.updateForViewport();
      }
      if (result & 2 || viewportChange)
        this.updateViewportLines();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
        this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view2));
      result |= this.computeVisibleRanges();
      if (this.mustEnforceCursorAssoc) {
        this.mustEnforceCursorAssoc = false;
        view2.docView.enforceCursorAssoc();
      }
      return result;
    }
    get visibleTop() {
      return this.scaler.fromDOM(this.pixelViewport.top);
    }
    get visibleBottom() {
      return this.scaler.fromDOM(this.pixelViewport.bottom);
    }
    getViewport(bias, scrollTarget) {
      let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
      let map27 = this.heightMap, oracle = this.heightOracle;
      let { visibleTop, visibleBottom } = this;
      let viewport = new Viewport(map27.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, oracle, 0, 0).from, map27.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, oracle, 0, 0).to);
      if (scrollTarget) {
        let { head: head5 } = scrollTarget.range;
        if (head5 < viewport.from || head5 > viewport.to) {
          let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
          let block = map27.lineAt(head5, QueryType.ByPos, oracle, 0, 0), topPos;
          if (scrollTarget.y == "center")
            topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
          else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head5 < viewport.from)
            topPos = block.top;
          else
            topPos = block.bottom - viewHeight;
          viewport = new Viewport(map27.lineAt(topPos - 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).from, map27.lineAt(topPos + viewHeight + 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).to);
        }
      }
      return viewport;
    }
    mapViewport(viewport, changes) {
      let from3 = changes.mapPos(viewport.from, -1), to3 = changes.mapPos(viewport.to, 1);
      return new Viewport(this.heightMap.lineAt(from3, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to3, QueryType.ByPos, this.heightOracle, 0, 0).to);
    }
    // Checks if a given viewport covers the visible part of the
    // document and not too much beyond that.
    viewportIsAppropriate({ from: from3, to: to3 }, bias = 0) {
      if (!this.inView)
        return true;
      let { top: top4 } = this.heightMap.lineAt(from3, QueryType.ByPos, this.heightOracle, 0, 0);
      let { bottom: bottom3 } = this.heightMap.lineAt(to3, QueryType.ByPos, this.heightOracle, 0, 0);
      let { visibleTop, visibleBottom } = this;
      return (from3 == 0 || top4 <= visibleTop - Math.max(10, Math.min(
        -bias,
        250
        /* VP.MaxCoverMargin */
      ))) && (to3 == this.state.doc.length || bottom3 >= visibleBottom + Math.max(10, Math.min(
        bias,
        250
        /* VP.MaxCoverMargin */
      ))) && (top4 > visibleTop - 2 * 1e3 && bottom3 < visibleBottom + 2 * 1e3);
    }
    mapLineGaps(gaps, changes) {
      if (!gaps.length || changes.empty)
        return gaps;
      let mapped = [];
      for (let gap of gaps)
        if (!changes.touchesRange(gap.from, gap.to))
          mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size, gap.displaySize));
      return mapped;
    }
    // Computes positions in the viewport where the start or end of a
    // line should be hidden, trying to reuse existing line gaps when
    // appropriate to avoid unneccesary redraws.
    // Uses crude character-counting for the positioning and sizing,
    // since actual DOM coordinates aren't always available and
    // predictable. Relies on generous margins (see LG.Margin) to hide
    // the artifacts this might produce from the user.
    ensureLineGaps(current, mayMeasure) {
      let wrapping = this.heightOracle.lineWrapping;
      let margin = wrapping ? 1e4 : 2e3, halfMargin = margin >> 1, doubleMargin = margin << 1;
      if (this.defaultTextDirection != Direction.LTR && !wrapping)
        return [];
      let gaps = [];
      let addGap = (from3, to3, line, structure) => {
        if (to3 - from3 < halfMargin)
          return;
        let sel = this.state.selection.main, avoid = [sel.from];
        if (!sel.empty)
          avoid.push(sel.to);
        for (let pos of avoid) {
          if (pos > from3 && pos < to3) {
            addGap(from3, pos - 10, line, structure);
            addGap(pos + 10, to3, line, structure);
            return;
          }
        }
        let gap = find3(current, (gap2) => gap2.from >= line.from && gap2.to <= line.to && Math.abs(gap2.from - from3) < halfMargin && Math.abs(gap2.to - to3) < halfMargin && !avoid.some((pos) => gap2.from < pos && gap2.to > pos));
        if (!gap) {
          if (to3 < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r2) => r2.from <= to3 && r2.to >= to3)) {
            let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to3), false, true).head;
            if (lineStart > from3)
              to3 = lineStart;
          }
          let size5 = this.gapSize(line, from3, to3, structure);
          let displaySize = wrapping || size5 < 2e6 ? size5 : 2e6;
          gap = new LineGap(from3, to3, size5, displaySize);
        }
        gaps.push(gap);
      };
      let checkLine = (line) => {
        if (line.length < doubleMargin || line.type != BlockType.Text)
          return;
        let structure = lineStructure(line.from, line.to, this.stateDeco);
        if (structure.total < doubleMargin)
          return;
        let target5 = this.scrollTarget ? this.scrollTarget.range.head : null;
        let viewFrom, viewTo;
        if (wrapping) {
          let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
          let top4, bot;
          if (target5 != null) {
            let targetFrac = findFraction(structure, target5);
            let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
            top4 = targetFrac - spaceFrac;
            bot = targetFrac + spaceFrac;
          } else {
            top4 = (this.visibleTop - line.top - marginHeight) / line.height;
            bot = (this.visibleBottom - line.top + marginHeight) / line.height;
          }
          viewFrom = findPosition(structure, top4);
          viewTo = findPosition(structure, bot);
        } else {
          let totalWidth = structure.total * this.heightOracle.charWidth;
          let marginWidth = margin * this.heightOracle.charWidth;
          let horizOffset = 0;
          if (totalWidth > 2e6)
            for (let old of current) {
              if (old.from >= line.from && old.from < line.to && old.size != old.displaySize && old.from * this.heightOracle.charWidth + horizOffset < this.pixelViewport.left)
                horizOffset = old.size - old.displaySize;
            }
          let pxLeft = this.pixelViewport.left + horizOffset, pxRight = this.pixelViewport.right + horizOffset;
          let left, right;
          if (target5 != null) {
            let targetFrac = findFraction(structure, target5);
            let spaceFrac = ((pxRight - pxLeft) / 2 + marginWidth) / totalWidth;
            left = targetFrac - spaceFrac;
            right = targetFrac + spaceFrac;
          } else {
            left = (pxLeft - marginWidth) / totalWidth;
            right = (pxRight + marginWidth) / totalWidth;
          }
          viewFrom = findPosition(structure, left);
          viewTo = findPosition(structure, right);
        }
        if (viewFrom > line.from)
          addGap(line.from, viewFrom, line, structure);
        if (viewTo < line.to)
          addGap(viewTo, line.to, line, structure);
      };
      for (let line of this.viewportLines) {
        if (Array.isArray(line.type))
          line.type.forEach(checkLine);
        else
          checkLine(line);
      }
      return gaps;
    }
    gapSize(line, from3, to3, structure) {
      let fraction = findFraction(structure, to3) - findFraction(structure, from3);
      if (this.heightOracle.lineWrapping) {
        return line.height * fraction;
      } else {
        return structure.total * this.heightOracle.charWidth * fraction;
      }
    }
    updateLineGaps(gaps) {
      if (!LineGap.same(gaps, this.lineGaps)) {
        this.lineGaps = gaps;
        this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this, this.heightOracle.lineWrapping)));
      }
    }
    computeVisibleRanges() {
      let deco = this.stateDeco;
      if (this.lineGaps.length)
        deco = deco.concat(this.lineGapDeco);
      let ranges = [];
      RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
        span(from3, to3) {
          ranges.push({ from: from3, to: to3 });
        },
        point() {
        }
      }, 20);
      let changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r2, i2) => r2.from != ranges[i2].from || r2.to != ranges[i2].to);
      this.visibleRanges = ranges;
      return changed ? 4 : 0;
    }
    lineBlockAt(pos) {
      return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b2) => b2.from <= pos && b2.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);
    }
    lineBlockAtHeight(height8) {
      return height8 >= this.viewportLines[0].top && height8 <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((l2) => l2.top <= height8 && l2.bottom >= height8) || scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height8), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);
    }
    scrollAnchorAt(scrollTop2) {
      let block = this.lineBlockAtHeight(scrollTop2 + 8);
      return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop2 > 200 ? block : this.viewportLines[0];
    }
    elementAtHeight(height8) {
      return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height8), this.heightOracle, 0, 0), this.scaler);
    }
    get docHeight() {
      return this.scaler.toDOM(this.heightMap.height);
    }
    get contentHeight() {
      return this.docHeight + this.paddingTop + this.paddingBottom;
    }
  };
  var Viewport = class {
    constructor(from3, to3) {
      this.from = from3;
      this.to = to3;
    }
  };
  function lineStructure(from3, to3, stateDeco) {
    let ranges = [], pos = from3, total = 0;
    RangeSet.spans(stateDeco, from3, to3, {
      span() {
      },
      point(from4, to4) {
        if (from4 > pos) {
          ranges.push({ from: pos, to: from4 });
          total += from4 - pos;
        }
        pos = to4;
      }
    }, 20);
    if (pos < to3) {
      ranges.push({ from: pos, to: to3 });
      total += to3 - pos;
    }
    return { total, ranges };
  }
  function findPosition({ total, ranges }, ratio) {
    if (ratio <= 0)
      return ranges[0].from;
    if (ratio >= 1)
      return ranges[ranges.length - 1].to;
    let dist2 = Math.floor(total * ratio);
    for (let i2 = 0; ; i2++) {
      let { from: from3, to: to3 } = ranges[i2], size5 = to3 - from3;
      if (dist2 <= size5)
        return from3 + dist2;
      dist2 -= size5;
    }
  }
  function findFraction(structure, pos) {
    let counted = 0;
    for (let { from: from3, to: to3 } of structure.ranges) {
      if (pos <= to3) {
        counted += pos - from3;
        break;
      }
      counted += to3 - from3;
    }
    return counted / structure.total;
  }
  function find3(array, f2) {
    for (let val of array)
      if (f2(val))
        return val;
    return void 0;
  }
  var IdScaler = {
    toDOM(n2) {
      return n2;
    },
    fromDOM(n2) {
      return n2;
    },
    scale: 1,
    eq(other) {
      return other == this;
    }
  };
  var BigScaler = class _BigScaler {
    constructor(oracle, heightMap, viewports) {
      let vpHeight = 0, base2 = 0, domBase = 0;
      this.viewports = viewports.map(({ from: from3, to: to3 }) => {
        let top4 = heightMap.lineAt(from3, QueryType.ByPos, oracle, 0, 0).top;
        let bottom3 = heightMap.lineAt(to3, QueryType.ByPos, oracle, 0, 0).bottom;
        vpHeight += bottom3 - top4;
        return { from: from3, to: to3, top: top4, bottom: bottom3, domTop: 0, domBottom: 0 };
      });
      this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
      for (let obj of this.viewports) {
        obj.domTop = domBase + (obj.top - base2) * this.scale;
        domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
        base2 = obj.bottom;
      }
    }
    toDOM(n2) {
      for (let i2 = 0, base2 = 0, domBase = 0; ; i2++) {
        let vp = i2 < this.viewports.length ? this.viewports[i2] : null;
        if (!vp || n2 < vp.top)
          return domBase + (n2 - base2) * this.scale;
        if (n2 <= vp.bottom)
          return vp.domTop + (n2 - vp.top);
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
    fromDOM(n2) {
      for (let i2 = 0, base2 = 0, domBase = 0; ; i2++) {
        let vp = i2 < this.viewports.length ? this.viewports[i2] : null;
        if (!vp || n2 < vp.domTop)
          return base2 + (n2 - domBase) / this.scale;
        if (n2 <= vp.domBottom)
          return vp.top + (n2 - vp.domTop);
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
    eq(other) {
      if (!(other instanceof _BigScaler))
        return false;
      return this.scale == other.scale && this.viewports.length == other.viewports.length && this.viewports.every((vp, i2) => vp.from == other.viewports[i2].from && vp.to == other.viewports[i2].to);
    }
  };
  function scaleBlock(block, scaler) {
    if (scaler.scale == 1)
      return block;
    let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map((b2) => scaleBlock(b2, scaler)) : block._content);
  }
  var theme = /* @__PURE__ */ Facet.define({ combine: (strs) => strs.join(" ") });
  var darkTheme = /* @__PURE__ */ Facet.define({ combine: (values) => values.indexOf(true) > -1 });
  var baseThemeID = /* @__PURE__ */ StyleModule.newName();
  var baseLightID = /* @__PURE__ */ StyleModule.newName();
  var baseDarkID = /* @__PURE__ */ StyleModule.newName();
  var lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
  function buildTheme(main4, spec, scopes) {
    return new StyleModule(spec, {
      finish(sel) {
        return /&/.test(sel) ? sel.replace(/&\w*/, (m2) => {
          if (m2 == "&")
            return main4;
          if (!scopes || !scopes[m2])
            throw new RangeError(`Unsupported selector: ${m2}`);
          return scopes[m2];
        }) : main4 + " " + sel;
      }
    });
  }
  var baseTheme$1 = /* @__PURE__ */ buildTheme("." + baseThemeID, {
    "&": {
      position: "relative !important",
      boxSizing: "border-box",
      "&.cm-focused": {
        // Provide a simple default outline to make sure a focused
        // editor is visually distinct. Can't leave the default behavior
        // because that will apply to the content element, which is
        // inside the scrollable container and doesn't include the
        // gutters. We also can't use an 'auto' outline, since those
        // are, for some reason, drawn behind the element content, which
        // will cause things like the active line background to cover
        // the outline (#297).
        outline: "1px dotted #212121"
      },
      display: "flex !important",
      flexDirection: "column"
    },
    ".cm-scroller": {
      display: "flex !important",
      alignItems: "flex-start !important",
      fontFamily: "monospace",
      lineHeight: 1.4,
      height: "100%",
      overflowX: "auto",
      position: "relative",
      zIndex: 0,
      overflowAnchor: "none"
    },
    ".cm-content": {
      margin: 0,
      flexGrow: 2,
      flexShrink: 0,
      display: "block",
      whiteSpace: "pre",
      wordWrap: "normal",
      // https://github.com/codemirror/dev/issues/456
      boxSizing: "border-box",
      minHeight: "100%",
      padding: "4px 0",
      outline: "none",
      "&[contenteditable=true]": {
        WebkitUserModify: "read-write-plaintext-only"
      }
    },
    ".cm-lineWrapping": {
      whiteSpace_fallback: "pre-wrap",
      // For IE
      whiteSpace: "break-spaces",
      wordBreak: "break-word",
      // For Safari, which doesn't support overflow-wrap: anywhere
      overflowWrap: "anywhere",
      flexShrink: 1
    },
    "&light .cm-content": { caretColor: "black" },
    "&dark .cm-content": { caretColor: "white" },
    ".cm-line": {
      display: "block",
      padding: "0 2px 0 6px"
    },
    ".cm-layer": {
      position: "absolute",
      left: 0,
      top: 0,
      contain: "size style",
      "& > *": {
        position: "absolute"
      }
    },
    "&light .cm-selectionBackground": {
      background: "#d9d9d9"
    },
    "&dark .cm-selectionBackground": {
      background: "#222"
    },
    "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
      background: "#d7d4f0"
    },
    "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
      background: "#233"
    },
    ".cm-cursorLayer": {
      pointerEvents: "none"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
      animation: "steps(1) cm-blink 1.2s infinite"
    },
    // Two animations defined so that we can switch between them to
    // restart the animation without forcing another style
    // recomputation.
    "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    ".cm-cursor, .cm-dropCursor": {
      borderLeft: "1.2px solid black",
      marginLeft: "-0.6px",
      pointerEvents: "none"
    },
    ".cm-cursor": {
      display: "none"
    },
    "&dark .cm-cursor": {
      borderLeftColor: "#ddd"
    },
    ".cm-dropCursor": {
      position: "absolute"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
      display: "block"
    },
    ".cm-iso": {
      unicodeBidi: "isolate"
    },
    ".cm-announced": {
      position: "fixed",
      top: "-10000px"
    },
    "@media print": {
      ".cm-announced": { display: "none" }
    },
    "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
    "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
    "&light .cm-specialChar": { color: "red" },
    "&dark .cm-specialChar": { color: "#f78" },
    ".cm-gutters": {
      flexShrink: 0,
      display: "flex",
      height: "100%",
      boxSizing: "border-box",
      insetInlineStart: 0,
      zIndex: 200
    },
    "&light .cm-gutters": {
      backgroundColor: "#f5f5f5",
      color: "#6c6c6c",
      borderRight: "1px solid #ddd"
    },
    "&dark .cm-gutters": {
      backgroundColor: "#333338",
      color: "#ccc"
    },
    ".cm-gutter": {
      display: "flex !important",
      // Necessary -- prevents margin collapsing
      flexDirection: "column",
      flexShrink: 0,
      boxSizing: "border-box",
      minHeight: "100%",
      overflow: "hidden"
    },
    ".cm-gutterElement": {
      boxSizing: "border-box"
    },
    ".cm-lineNumbers .cm-gutterElement": {
      padding: "0 3px 0 5px",
      minWidth: "20px",
      textAlign: "right",
      whiteSpace: "nowrap"
    },
    "&light .cm-activeLineGutter": {
      backgroundColor: "#e2f2ff"
    },
    "&dark .cm-activeLineGutter": {
      backgroundColor: "#222227"
    },
    ".cm-panels": {
      boxSizing: "border-box",
      position: "sticky",
      left: 0,
      right: 0,
      zIndex: 300
    },
    "&light .cm-panels": {
      backgroundColor: "#f5f5f5",
      color: "black"
    },
    "&light .cm-panels-top": {
      borderBottom: "1px solid #ddd"
    },
    "&light .cm-panels-bottom": {
      borderTop: "1px solid #ddd"
    },
    "&dark .cm-panels": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tab": {
      display: "inline-block",
      overflow: "hidden",
      verticalAlign: "bottom"
    },
    ".cm-widgetBuffer": {
      verticalAlign: "text-top",
      height: "1em",
      width: 0,
      display: "inline"
    },
    ".cm-placeholder": {
      color: "#888",
      display: "inline-block",
      verticalAlign: "top"
    },
    ".cm-highlightSpace": {
      backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
      backgroundPosition: "center"
    },
    ".cm-highlightTab": {
      backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
      backgroundSize: "auto 100%",
      backgroundPosition: "right 90%",
      backgroundRepeat: "no-repeat"
    },
    ".cm-trailingSpace": {
      backgroundColor: "#ff332255"
    },
    ".cm-button": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      padding: ".2em 1em",
      borderRadius: "1px"
    },
    "&light .cm-button": {
      backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
      }
    },
    "&dark .cm-button": {
      backgroundImage: "linear-gradient(#393939, #111)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#111, #333)"
      }
    },
    ".cm-textfield": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      border: "1px solid silver",
      padding: ".2em .5em"
    },
    "&light .cm-textfield": {
      backgroundColor: "white"
    },
    "&dark .cm-textfield": {
      border: "1px solid #555",
      backgroundColor: "inherit"
    }
  }, lightDarkIDs);
  var observeOptions = {
    childList: true,
    characterData: true,
    subtree: true,
    attributes: true,
    characterDataOldValue: true
  };
  var useCharData = browser.ie && browser.ie_version <= 11;
  var DOMObserver = class {
    constructor(view2) {
      this.view = view2;
      this.active = false;
      this.editContext = null;
      this.selectionRange = new DOMSelectionState();
      this.selectionChanged = false;
      this.delayedFlush = -1;
      this.resizeTimeout = -1;
      this.queue = [];
      this.delayedAndroidKey = null;
      this.flushingAndroidKey = -1;
      this.lastChange = 0;
      this.scrollTargets = [];
      this.intersection = null;
      this.resizeScroll = null;
      this.intersecting = false;
      this.gapIntersection = null;
      this.gaps = [];
      this.printQuery = null;
      this.parentCheck = -1;
      this.dom = view2.contentDOM;
      this.observer = new MutationObserver((mutations) => {
        for (let mut of mutations)
          this.queue.push(mut);
        if ((browser.ie && browser.ie_version <= 11 || browser.ios && view2.composing) && mutations.some((m2) => m2.type == "childList" && m2.removedNodes.length || m2.type == "characterData" && m2.oldValue.length > m2.target.nodeValue.length))
          this.flushSoon();
        else
          this.flush();
      });
      if (window.EditContext && view2.constructor.EDIT_CONTEXT !== false && // Chrome <126 doesn't support inverted selections in edit context (#1392)
      !(browser.chrome && browser.chrome_version < 126)) {
        this.editContext = new EditContextManager(view2);
        if (view2.state.facet(editable))
          view2.contentDOM.editContext = this.editContext.editContext;
      }
      if (useCharData)
        this.onCharData = (event) => {
          this.queue.push({
            target: event.target,
            type: "characterData",
            oldValue: event.prevValue
          });
          this.flushSoon();
        };
      this.onSelectionChange = this.onSelectionChange.bind(this);
      this.onResize = this.onResize.bind(this);
      this.onPrint = this.onPrint.bind(this);
      this.onScroll = this.onScroll.bind(this);
      if (window.matchMedia)
        this.printQuery = window.matchMedia("print");
      if (typeof ResizeObserver == "function") {
        this.resizeScroll = new ResizeObserver(() => {
          var _a2;
          if (((_a2 = this.view.docView) === null || _a2 === void 0 ? void 0 : _a2.lastUpdate) < Date.now() - 75)
            this.onResize();
        });
        this.resizeScroll.observe(view2.scrollDOM);
      }
      this.addWindowListeners(this.win = view2.win);
      this.start();
      if (typeof IntersectionObserver == "function") {
        this.intersection = new IntersectionObserver((entries) => {
          if (this.parentCheck < 0)
            this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
          if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
            this.intersecting = !this.intersecting;
            if (this.intersecting != this.view.inView)
              this.onScrollChanged(document.createEvent("Event"));
          }
        }, { threshold: [0, 1e-3] });
        this.intersection.observe(this.dom);
        this.gapIntersection = new IntersectionObserver((entries) => {
          if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
            this.onScrollChanged(document.createEvent("Event"));
        }, {});
      }
      this.listenForScroll();
      this.readSelectionRange();
    }
    onScrollChanged(e2) {
      this.view.inputState.runHandlers("scroll", e2);
      if (this.intersecting)
        this.view.measure();
    }
    onScroll(e2) {
      if (this.intersecting)
        this.flush(false);
      if (this.editContext)
        this.view.requestMeasure(this.editContext.measureReq);
      this.onScrollChanged(e2);
    }
    onResize() {
      if (this.resizeTimeout < 0)
        this.resizeTimeout = setTimeout(() => {
          this.resizeTimeout = -1;
          this.view.requestMeasure();
        }, 50);
    }
    onPrint(event) {
      if ((event.type == "change" || !event.type) && !event.matches)
        return;
      this.view.viewState.printing = true;
      this.view.measure();
      setTimeout(() => {
        this.view.viewState.printing = false;
        this.view.requestMeasure();
      }, 500);
    }
    updateGaps(gaps) {
      if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g2, i2) => g2 != gaps[i2]))) {
        this.gapIntersection.disconnect();
        for (let gap of gaps)
          this.gapIntersection.observe(gap);
        this.gaps = gaps;
      }
    }
    onSelectionChange(event) {
      let wasChanged = this.selectionChanged;
      if (!this.readSelectionRange() || this.delayedAndroidKey)
        return;
      let { view: view2 } = this, sel = this.selectionRange;
      if (view2.state.facet(editable) ? view2.root.activeElement != this.dom : !hasSelection(this.dom, sel))
        return;
      let context3 = sel.anchorNode && view2.docView.nearest(sel.anchorNode);
      if (context3 && context3.ignoreEvent(event)) {
        if (!wasChanged)
          this.selectionChanged = false;
        return;
      }
      if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view2.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
      sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        this.flushSoon();
      else
        this.flush(false);
    }
    readSelectionRange() {
      let { view: view2 } = this;
      let selection = getSelection(view2.root);
      if (!selection)
        return false;
      let range3 = browser.safari && view2.root.nodeType == 11 && view2.root.activeElement == this.dom && safariSelectionRangeHack(this.view, selection) || selection;
      if (!range3 || this.selectionRange.eq(range3))
        return false;
      let local2 = hasSelection(this.dom, range3);
      if (local2 && !this.selectionChanged && view2.inputState.lastFocusTime > Date.now() - 200 && view2.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range3)) {
        this.view.inputState.lastFocusTime = 0;
        view2.docView.updateSelection();
        return false;
      }
      this.selectionRange.setRange(range3);
      if (local2)
        this.selectionChanged = true;
      return true;
    }
    setSelectionRange(anchor, head5) {
      this.selectionRange.set(anchor.node, anchor.offset, head5.node, head5.offset);
      this.selectionChanged = false;
    }
    clearSelectionRange() {
      this.selectionRange.set(null, 0, null, 0);
    }
    listenForScroll() {
      this.parentCheck = -1;
      let i2 = 0, changed = null;
      for (let dom = this.dom; dom; ) {
        if (dom.nodeType == 1) {
          if (!changed && i2 < this.scrollTargets.length && this.scrollTargets[i2] == dom)
            i2++;
          else if (!changed)
            changed = this.scrollTargets.slice(0, i2);
          if (changed)
            changed.push(dom);
          dom = dom.assignedSlot || dom.parentNode;
        } else if (dom.nodeType == 11) {
          dom = dom.host;
        } else {
          break;
        }
      }
      if (i2 < this.scrollTargets.length && !changed)
        changed = this.scrollTargets.slice(0, i2);
      if (changed) {
        for (let dom of this.scrollTargets)
          dom.removeEventListener("scroll", this.onScroll);
        for (let dom of this.scrollTargets = changed)
          dom.addEventListener("scroll", this.onScroll);
      }
    }
    ignore(f2) {
      if (!this.active)
        return f2();
      try {
        this.stop();
        return f2();
      } finally {
        this.start();
        this.clear();
      }
    }
    start() {
      if (this.active)
        return;
      this.observer.observe(this.dom, observeOptions);
      if (useCharData)
        this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      this.active = true;
    }
    stop() {
      if (!this.active)
        return;
      this.active = false;
      this.observer.disconnect();
      if (useCharData)
        this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    }
    // Throw away any pending changes
    clear() {
      this.processRecords();
      this.queue.length = 0;
      this.selectionChanged = false;
    }
    // Chrome Android, especially in combination with GBoard, not only
    // doesn't reliably fire regular key events, but also often
    // surrounds the effect of enter or backspace with a bunch of
    // composition events that, when interrupted, cause text duplication
    // or other kinds of corruption. This hack makes the editor back off
    // from handling DOM changes for a moment when such a key is
    // detected (via beforeinput or keydown), and then tries to flush
    // them or, if that has no effect, dispatches the given key.
    delayAndroidKey(key, keyCode) {
      var _a2;
      if (!this.delayedAndroidKey) {
        let flush = () => {
          let key2 = this.delayedAndroidKey;
          if (key2) {
            this.clearDelayedAndroidKey();
            this.view.inputState.lastKeyCode = key2.keyCode;
            this.view.inputState.lastKeyTime = Date.now();
            let flushed = this.flush();
            if (!flushed && key2.force)
              dispatchKey(this.dom, key2.key, key2.keyCode);
          }
        };
        this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
      }
      if (!this.delayedAndroidKey || key == "Enter")
        this.delayedAndroidKey = {
          key,
          keyCode,
          // Only run the key handler when no changes are detected if
          // this isn't coming right after another change, in which case
          // it is probably part of a weird chain of updates, and should
          // be ignored if it returns the DOM to its previous state.
          force: this.lastChange < Date.now() - 50 || !!((_a2 = this.delayedAndroidKey) === null || _a2 === void 0 ? void 0 : _a2.force)
        };
    }
    clearDelayedAndroidKey() {
      this.win.cancelAnimationFrame(this.flushingAndroidKey);
      this.delayedAndroidKey = null;
      this.flushingAndroidKey = -1;
    }
    flushSoon() {
      if (this.delayedFlush < 0)
        this.delayedFlush = this.view.win.requestAnimationFrame(() => {
          this.delayedFlush = -1;
          this.flush();
        });
    }
    forceFlush() {
      if (this.delayedFlush >= 0) {
        this.view.win.cancelAnimationFrame(this.delayedFlush);
        this.delayedFlush = -1;
      }
      this.flush();
    }
    pendingRecords() {
      for (let mut of this.observer.takeRecords())
        this.queue.push(mut);
      return this.queue;
    }
    processRecords() {
      let records = this.pendingRecords();
      if (records.length)
        this.queue = [];
      let from3 = -1, to3 = -1, typeOver = false;
      for (let record of records) {
        let range3 = this.readMutation(record);
        if (!range3)
          continue;
        if (range3.typeOver)
          typeOver = true;
        if (from3 == -1) {
          ({ from: from3, to: to3 } = range3);
        } else {
          from3 = Math.min(range3.from, from3);
          to3 = Math.max(range3.to, to3);
        }
      }
      return { from: from3, to: to3, typeOver };
    }
    readChange() {
      let { from: from3, to: to3, typeOver } = this.processRecords();
      let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
      if (from3 < 0 && !newSel)
        return null;
      if (from3 > -1)
        this.lastChange = Date.now();
      this.view.inputState.lastFocusTime = 0;
      this.selectionChanged = false;
      let change = new DOMChange(this.view, from3, to3, typeOver);
      this.view.docView.domChanged = { newSel: change.newSel ? change.newSel.main : null };
      return change;
    }
    // Apply pending changes, if any
    flush(readSelection = true) {
      if (this.delayedFlush >= 0 || this.delayedAndroidKey)
        return false;
      if (readSelection)
        this.readSelectionRange();
      let domChange = this.readChange();
      if (!domChange) {
        this.view.requestMeasure();
        return false;
      }
      let startState = this.view.state;
      let handled = applyDOMChange(this.view, domChange);
      if (this.view.state == startState && (domChange.domChanged || domChange.newSel && !domChange.newSel.main.eq(this.view.state.selection.main)))
        this.view.update([]);
      return handled;
    }
    readMutation(rec) {
      let cView = this.view.docView.nearest(rec.target);
      if (!cView || cView.ignoreMutation(rec))
        return null;
      cView.markDirty(rec.type == "attributes");
      if (rec.type == "attributes")
        cView.flags |= 4;
      if (rec.type == "childList") {
        let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
        let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
        return {
          from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
          to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
          typeOver: false
        };
      } else if (rec.type == "characterData") {
        return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
      } else {
        return null;
      }
    }
    setWindow(win) {
      if (win != this.win) {
        this.removeWindowListeners(this.win);
        this.win = win;
        this.addWindowListeners(this.win);
      }
    }
    addWindowListeners(win) {
      win.addEventListener("resize", this.onResize);
      if (this.printQuery) {
        if (this.printQuery.addEventListener)
          this.printQuery.addEventListener("change", this.onPrint);
        else
          this.printQuery.addListener(this.onPrint);
      } else
        win.addEventListener("beforeprint", this.onPrint);
      win.addEventListener("scroll", this.onScroll);
      win.document.addEventListener("selectionchange", this.onSelectionChange);
    }
    removeWindowListeners(win) {
      win.removeEventListener("scroll", this.onScroll);
      win.removeEventListener("resize", this.onResize);
      if (this.printQuery) {
        if (this.printQuery.removeEventListener)
          this.printQuery.removeEventListener("change", this.onPrint);
        else
          this.printQuery.removeListener(this.onPrint);
      } else
        win.removeEventListener("beforeprint", this.onPrint);
      win.document.removeEventListener("selectionchange", this.onSelectionChange);
    }
    update(update3) {
      if (this.editContext) {
        this.editContext.update(update3);
        if (update3.startState.facet(editable) != update3.state.facet(editable))
          update3.view.contentDOM.editContext = update3.state.facet(editable) ? this.editContext.editContext : null;
      }
    }
    destroy() {
      var _a2, _b, _c;
      this.stop();
      (_a2 = this.intersection) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
      (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
      (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();
      for (let dom of this.scrollTargets)
        dom.removeEventListener("scroll", this.onScroll);
      this.removeWindowListeners(this.win);
      clearTimeout(this.parentCheck);
      clearTimeout(this.resizeTimeout);
      this.win.cancelAnimationFrame(this.delayedFlush);
      this.win.cancelAnimationFrame(this.flushingAndroidKey);
      if (this.editContext) {
        this.view.contentDOM.editContext = null;
        this.editContext.destroy();
      }
    }
  };
  function findChild(cView, dom, dir2) {
    while (dom) {
      let curView = ContentView.get(dom);
      if (curView && curView.parent == cView)
        return curView;
      let parent2 = dom.parentNode;
      dom = parent2 != cView.dom ? parent2 : dir2 > 0 ? dom.nextSibling : dom.previousSibling;
    }
    return null;
  }
  function buildSelectionRangeFromRange(view2, range3) {
    let anchorNode = range3.startContainer, anchorOffset = range3.startOffset;
    let focusNode = range3.endContainer, focusOffset = range3.endOffset;
    let curAnchor = view2.docView.domAtPos(view2.state.selection.main.anchor);
    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
      [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
    return { anchorNode, anchorOffset, focusNode, focusOffset };
  }
  function safariSelectionRangeHack(view2, selection) {
    if (selection.getComposedRanges) {
      let range3 = selection.getComposedRanges(view2.root)[0];
      if (range3)
        return buildSelectionRangeFromRange(view2, range3);
    }
    let found = null;
    function read3(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
      found = event.getTargetRanges()[0];
    }
    view2.contentDOM.addEventListener("beforeinput", read3, true);
    view2.dom.ownerDocument.execCommand("indent");
    view2.contentDOM.removeEventListener("beforeinput", read3, true);
    return found ? buildSelectionRangeFromRange(view2, found) : null;
  }
  var EditContextManager = class {
    constructor(view2) {
      this.from = 0;
      this.to = 0;
      this.pendingContextChange = null;
      this.handlers = /* @__PURE__ */ Object.create(null);
      this.resetRange(view2.state);
      let context3 = this.editContext = new window.EditContext({
        text: view2.state.doc.sliceString(this.from, this.to),
        selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, view2.state.selection.main.anchor))),
        selectionEnd: this.toContextPos(view2.state.selection.main.head)
      });
      this.handlers.textupdate = (e2) => {
        let { anchor } = view2.state.selection.main;
        let change = {
          from: this.toEditorPos(e2.updateRangeStart),
          to: this.toEditorPos(e2.updateRangeEnd),
          insert: Text2.of(e2.text.split("\n"))
        };
        if (change.from == this.from && anchor < this.from)
          change.from = anchor;
        else if (change.to == this.to && anchor > this.to)
          change.to = anchor;
        if (change.from == change.to && !change.insert.length)
          return;
        this.pendingContextChange = change;
        if (!view2.state.readOnly)
          applyDOMChangeInner(view2, change, EditorSelection.single(this.toEditorPos(e2.selectionStart), this.toEditorPos(e2.selectionEnd)));
        if (this.pendingContextChange) {
          this.revertPending(view2.state);
          this.setSelection(view2.state);
        }
      };
      this.handlers.characterboundsupdate = (e2) => {
        let rects = [], prev = null;
        for (let i2 = this.toEditorPos(e2.rangeStart), end = this.toEditorPos(e2.rangeEnd); i2 < end; i2++) {
          let rect = view2.coordsForChar(i2);
          prev = rect && new DOMRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top) || prev || new DOMRect();
          rects.push(prev);
        }
        context3.updateCharacterBounds(e2.rangeStart, rects);
      };
      this.handlers.textformatupdate = (e2) => {
        let deco = [];
        for (let format of e2.getTextFormats()) {
          let lineStyle = format.underlineStyle, thickness = format.underlineThickness;
          if (lineStyle != "None" && thickness != "None") {
            let style3 = `text-decoration: underline ${lineStyle == "Dashed" ? "dashed " : lineStyle == "Squiggle" ? "wavy " : ""}${thickness == "Thin" ? 1 : 2}px`;
            deco.push(Decoration.mark({ attributes: { style: style3 } }).range(this.toEditorPos(format.rangeStart), this.toEditorPos(format.rangeEnd)));
          }
        }
        view2.dispatch({ effects: setEditContextFormatting.of(Decoration.set(deco)) });
      };
      this.handlers.compositionstart = () => {
        if (view2.inputState.composing < 0) {
          view2.inputState.composing = 0;
          view2.inputState.compositionFirstChange = true;
        }
      };
      this.handlers.compositionend = () => {
        view2.inputState.composing = -1;
        view2.inputState.compositionFirstChange = null;
      };
      for (let event in this.handlers)
        context3.addEventListener(event, this.handlers[event]);
      this.measureReq = { read: (view3) => {
        this.editContext.updateControlBounds(view3.contentDOM.getBoundingClientRect());
        let sel = getSelection(view3.root);
        if (sel && sel.rangeCount)
          this.editContext.updateSelectionBounds(sel.getRangeAt(0).getBoundingClientRect());
      } };
    }
    applyEdits(update3) {
      let off = 0, abort = false, pending = this.pendingContextChange;
      update3.changes.iterChanges((fromA, toA, _fromB, _toB, insert10) => {
        if (abort)
          return;
        let dLen = insert10.length - (toA - fromA);
        if (pending && toA >= pending.to) {
          if (pending.from == fromA && pending.to == toA && pending.insert.eq(insert10)) {
            pending = this.pendingContextChange = null;
            off += dLen;
            this.to += dLen;
            return;
          } else {
            pending = null;
            this.revertPending(update3.state);
          }
        }
        fromA += off;
        toA += off;
        if (toA <= this.from) {
          this.from += dLen;
          this.to += dLen;
        } else if (fromA < this.to) {
          if (fromA < this.from || toA > this.to || this.to - this.from + insert10.length > 3e4) {
            abort = true;
            return;
          }
          this.editContext.updateText(this.toContextPos(fromA), this.toContextPos(toA), insert10.toString());
          this.to += dLen;
        }
        off += dLen;
      });
      if (pending && !abort)
        this.revertPending(update3.state);
      return !abort;
    }
    update(update3) {
      let reverted = this.pendingContextChange;
      if (!this.applyEdits(update3) || !this.rangeIsValid(update3.state)) {
        this.pendingContextChange = null;
        this.resetRange(update3.state);
        this.editContext.updateText(0, this.editContext.text.length, update3.state.doc.sliceString(this.from, this.to));
        this.setSelection(update3.state);
      } else if (update3.docChanged || update3.selectionSet || reverted) {
        this.setSelection(update3.state);
      }
      if (update3.geometryChanged || update3.docChanged || update3.selectionSet)
        update3.view.requestMeasure(this.measureReq);
    }
    resetRange(state4) {
      let { head: head5 } = state4.selection.main;
      this.from = Math.max(
        0,
        head5 - 1e4
        /* CxVp.Margin */
      );
      this.to = Math.min(
        state4.doc.length,
        head5 + 1e4
        /* CxVp.Margin */
      );
    }
    revertPending(state4) {
      let pending = this.pendingContextChange;
      this.pendingContextChange = null;
      this.editContext.updateText(this.toContextPos(pending.from), this.toContextPos(pending.from + pending.insert.length), state4.doc.sliceString(pending.from, pending.to));
    }
    setSelection(state4) {
      let { main: main4 } = state4.selection;
      let start3 = this.toContextPos(Math.max(this.from, Math.min(this.to, main4.anchor)));
      let end = this.toContextPos(main4.head);
      if (this.editContext.selectionStart != start3 || this.editContext.selectionEnd != end)
        this.editContext.updateSelection(start3, end);
    }
    rangeIsValid(state4) {
      let { head: head5 } = state4.selection.main;
      return !(this.from > 0 && head5 - this.from < 500 || this.to < state4.doc.length && this.to - head5 < 500 || this.to - this.from > 1e4 * 3);
    }
    toEditorPos(contextPos) {
      return contextPos + this.from;
    }
    toContextPos(editorPos) {
      return editorPos - this.from;
    }
    destroy() {
      for (let event in this.handlers)
        this.editContext.removeEventListener(event, this.handlers[event]);
    }
  };
  var EditorView = class _EditorView {
    /**
    The current editor state.
    */
    get state() {
      return this.viewState.state;
    }
    /**
    To be able to display large documents without consuming too much
    memory or overloading the browser, CodeMirror only draws the
    code that is visible (plus a margin around it) to the DOM. This
    property tells you the extent of the current drawn viewport, in
    document positions.
    */
    get viewport() {
      return this.viewState.viewport;
    }
    /**
    When there are, for example, large collapsed ranges in the
    viewport, its size can be a lot bigger than the actual visible
    content. Thus, if you are doing something like styling the
    content in the viewport, it is preferable to only do so for
    these ranges, which are the subset of the viewport that is
    actually drawn.
    */
    get visibleRanges() {
      return this.viewState.visibleRanges;
    }
    /**
    Returns false when the editor is entirely scrolled out of view
    or otherwise hidden.
    */
    get inView() {
      return this.viewState.inView;
    }
    /**
    Indicates whether the user is currently composing text via
    [IME](https://en.wikipedia.org/wiki/Input_method), and at least
    one change has been made in the current composition.
    */
    get composing() {
      return this.inputState.composing > 0;
    }
    /**
    Indicates whether the user is currently in composing state. Note
    that on some platforms, like Android, this will be the case a
    lot, since just putting the cursor on a word starts a
    composition there.
    */
    get compositionStarted() {
      return this.inputState.composing >= 0;
    }
    /**
    The document or shadow root that the view lives in.
    */
    get root() {
      return this._root;
    }
    /**
    @internal
    */
    get win() {
      return this.dom.ownerDocument.defaultView || window;
    }
    /**
    Construct a new view. You'll want to either provide a `parent`
    option, or put `view.dom` into your document after creating a
    view, so that the user can see the editor.
    */
    constructor(config2 = {}) {
      var _a2;
      this.plugins = [];
      this.pluginMap = /* @__PURE__ */ new Map();
      this.editorAttrs = {};
      this.contentAttrs = {};
      this.bidiCache = [];
      this.destroyed = false;
      this.updateState = 2;
      this.measureScheduled = -1;
      this.measureRequests = [];
      this.contentDOM = document.createElement("div");
      this.scrollDOM = document.createElement("div");
      this.scrollDOM.tabIndex = -1;
      this.scrollDOM.className = "cm-scroller";
      this.scrollDOM.appendChild(this.contentDOM);
      this.announceDOM = document.createElement("div");
      this.announceDOM.className = "cm-announced";
      this.announceDOM.setAttribute("aria-live", "polite");
      this.dom = document.createElement("div");
      this.dom.appendChild(this.announceDOM);
      this.dom.appendChild(this.scrollDOM);
      if (config2.parent)
        config2.parent.appendChild(this.dom);
      let { dispatch } = config2;
      this.dispatchTransactions = config2.dispatchTransactions || dispatch && ((trs) => trs.forEach((tr) => dispatch(tr, this))) || ((trs) => this.update(trs));
      this.dispatch = this.dispatch.bind(this);
      this._root = config2.root || getRoot(config2.parent) || document;
      this.viewState = new ViewState(config2.state || EditorState.create(config2));
      if (config2.scrollTo && config2.scrollTo.is(scrollIntoView))
        this.viewState.scrollTarget = config2.scrollTo.value.clip(this.viewState.state);
      this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
      for (let plugin of this.plugins)
        plugin.update(this);
      this.observer = new DOMObserver(this);
      this.inputState = new InputState(this);
      this.inputState.ensureHandlers(this.plugins);
      this.docView = new DocView(this);
      this.mountStyles();
      this.updateAttrs();
      this.updateState = 0;
      this.requestMeasure();
      if ((_a2 = document.fonts) === null || _a2 === void 0 ? void 0 : _a2.ready)
        document.fonts.ready.then(() => this.requestMeasure());
    }
    dispatch(...input) {
      let trs = input.length == 1 && input[0] instanceof Transaction ? input : input.length == 1 && Array.isArray(input[0]) ? input[0] : [this.state.update(...input)];
      this.dispatchTransactions(trs, this);
    }
    /**
    Update the view for the given array of transactions. This will
    update the visible document and selection to match the state
    produced by the transactions, and notify view plugins of the
    change. You should usually call
    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
    as a primitive.
    */
    update(transactions) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
      let redrawn = false, attrsChanged = false, update3;
      let state4 = this.state;
      for (let tr of transactions) {
        if (tr.startState != state4)
          throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
        state4 = tr.state;
      }
      if (this.destroyed) {
        this.viewState.state = state4;
        return;
      }
      let focus2 = this.hasFocus, focusFlag = 0, dispatchFocus = null;
      if (transactions.some((tr) => tr.annotation(isFocusChange))) {
        this.inputState.notifiedFocused = focus2;
        focusFlag = 1;
      } else if (focus2 != this.inputState.notifiedFocused) {
        this.inputState.notifiedFocused = focus2;
        dispatchFocus = focusChangeTransaction(state4, focus2);
        if (!dispatchFocus)
          focusFlag = 1;
      }
      let pendingKey = this.observer.delayedAndroidKey, domChange = null;
      if (pendingKey) {
        this.observer.clearDelayedAndroidKey();
        domChange = this.observer.readChange();
        if (domChange && !this.state.doc.eq(state4.doc) || !this.state.selection.eq(state4.selection))
          domChange = null;
      } else {
        this.observer.clear();
      }
      if (state4.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
        return this.setState(state4);
      update3 = ViewUpdate.create(this, state4, transactions);
      update3.flags |= focusFlag;
      let scrollTarget = this.viewState.scrollTarget;
      try {
        this.updateState = 2;
        for (let tr of transactions) {
          if (scrollTarget)
            scrollTarget = scrollTarget.map(tr.changes);
          if (tr.scrollIntoView) {
            let { main: main4 } = tr.state.selection;
            scrollTarget = new ScrollTarget(main4.empty ? main4 : EditorSelection.cursor(main4.head, main4.head > main4.anchor ? -1 : 1));
          }
          for (let e2 of tr.effects)
            if (e2.is(scrollIntoView))
              scrollTarget = e2.value.clip(this.state);
        }
        this.viewState.update(update3, scrollTarget);
        this.bidiCache = CachedOrder.update(this.bidiCache, update3.changes);
        if (!update3.empty) {
          this.updatePlugins(update3);
          this.inputState.update(update3);
        }
        redrawn = this.docView.update(update3);
        if (this.state.facet(styleModule) != this.styleModules)
          this.mountStyles();
        attrsChanged = this.updateAttrs();
        this.showAnnouncements(transactions);
        this.docView.updateSelection(redrawn, transactions.some((tr) => tr.isUserEvent("select.pointer")));
      } finally {
        this.updateState = 0;
      }
      if (update3.startState.facet(theme) != update3.state.facet(theme))
        this.viewState.mustMeasureContent = true;
      if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
        this.requestMeasure();
      if (redrawn)
        this.docViewUpdate();
      if (!update3.empty)
        for (let listener of this.state.facet(updateListener)) {
          try {
            listener(update3);
          } catch (e2) {
            logException(this.state, e2, "update listener");
          }
        }
      if (dispatchFocus || domChange)
        Promise.resolve().then(() => {
          if (dispatchFocus && this.state == dispatchFocus.startState)
            this.dispatch(dispatchFocus);
          if (domChange) {
            if (!applyDOMChange(this, domChange) && pendingKey.force)
              dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
          }
        });
    }
    /**
    Reset the view to the given state. (This will cause the entire
    document to be redrawn and all view plugins to be reinitialized,
    so you should probably only use it when the new state isn't
    derived from the old state. Otherwise, use
    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
    */
    setState(newState) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
      if (this.destroyed) {
        this.viewState.state = newState;
        return;
      }
      this.updateState = 2;
      let hadFocus = this.hasFocus;
      try {
        for (let plugin of this.plugins)
          plugin.destroy(this);
        this.viewState = new ViewState(newState);
        this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
        this.pluginMap.clear();
        for (let plugin of this.plugins)
          plugin.update(this);
        this.docView.destroy();
        this.docView = new DocView(this);
        this.inputState.ensureHandlers(this.plugins);
        this.mountStyles();
        this.updateAttrs();
        this.bidiCache = [];
      } finally {
        this.updateState = 0;
      }
      if (hadFocus)
        this.focus();
      this.requestMeasure();
    }
    updatePlugins(update3) {
      let prevSpecs = update3.startState.facet(viewPlugin), specs = update3.state.facet(viewPlugin);
      if (prevSpecs != specs) {
        let newPlugins = [];
        for (let spec of specs) {
          let found = prevSpecs.indexOf(spec);
          if (found < 0) {
            newPlugins.push(new PluginInstance(spec));
          } else {
            let plugin = this.plugins[found];
            plugin.mustUpdate = update3;
            newPlugins.push(plugin);
          }
        }
        for (let plugin of this.plugins)
          if (plugin.mustUpdate != update3)
            plugin.destroy(this);
        this.plugins = newPlugins;
        this.pluginMap.clear();
      } else {
        for (let p2 of this.plugins)
          p2.mustUpdate = update3;
      }
      for (let i2 = 0; i2 < this.plugins.length; i2++)
        this.plugins[i2].update(this);
      if (prevSpecs != specs)
        this.inputState.ensureHandlers(this.plugins);
    }
    docViewUpdate() {
      for (let plugin of this.plugins) {
        let val = plugin.value;
        if (val && val.docViewUpdate) {
          try {
            val.docViewUpdate(this);
          } catch (e2) {
            logException(this.state, e2, "doc view update listener");
          }
        }
      }
    }
    /**
    @internal
    */
    measure(flush = true) {
      if (this.destroyed)
        return;
      if (this.measureScheduled > -1)
        this.win.cancelAnimationFrame(this.measureScheduled);
      if (this.observer.delayedAndroidKey) {
        this.measureScheduled = -1;
        this.requestMeasure();
        return;
      }
      this.measureScheduled = 0;
      if (flush)
        this.observer.forceFlush();
      let updated = null;
      let sDOM = this.scrollDOM, scrollTop2 = sDOM.scrollTop * this.scaleY;
      let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;
      if (Math.abs(scrollTop2 - this.viewState.scrollTop) > 1)
        scrollAnchorHeight = -1;
      this.viewState.scrollAnchorHeight = -1;
      try {
        for (let i2 = 0; ; i2++) {
          if (scrollAnchorHeight < 0) {
            if (isScrolledToBottom(sDOM)) {
              scrollAnchorPos = -1;
              scrollAnchorHeight = this.viewState.heightMap.height;
            } else {
              let block = this.viewState.scrollAnchorAt(scrollTop2);
              scrollAnchorPos = block.from;
              scrollAnchorHeight = block.top;
            }
          }
          this.updateState = 1;
          let changed = this.viewState.measure(this);
          if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
            break;
          if (i2 > 5) {
            console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
            break;
          }
          let measuring = [];
          if (!(changed & 4))
            [this.measureRequests, measuring] = [measuring, this.measureRequests];
          let measured = measuring.map((m2) => {
            try {
              return m2.read(this);
            } catch (e2) {
              logException(this.state, e2);
              return BadMeasure;
            }
          });
          let update3 = ViewUpdate.create(this, this.state, []), redrawn = false;
          update3.flags |= changed;
          if (!updated)
            updated = update3;
          else
            updated.flags |= changed;
          this.updateState = 2;
          if (!update3.empty) {
            this.updatePlugins(update3);
            this.inputState.update(update3);
            this.updateAttrs();
            redrawn = this.docView.update(update3);
            if (redrawn)
              this.docViewUpdate();
          }
          for (let i3 = 0; i3 < measuring.length; i3++)
            if (measured[i3] != BadMeasure) {
              try {
                let m2 = measuring[i3];
                if (m2.write)
                  m2.write(measured[i3], this);
              } catch (e2) {
                logException(this.state, e2);
              }
            }
          if (redrawn)
            this.docView.updateSelection(true);
          if (!update3.viewportChanged && this.measureRequests.length == 0) {
            if (this.viewState.editorHeight) {
              if (this.viewState.scrollTarget) {
                this.docView.scrollIntoView(this.viewState.scrollTarget);
                this.viewState.scrollTarget = null;
                scrollAnchorHeight = -1;
                continue;
              } else {
                let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;
                let diff = newAnchorHeight - scrollAnchorHeight;
                if (diff > 1 || diff < -1) {
                  scrollTop2 = scrollTop2 + diff;
                  sDOM.scrollTop = scrollTop2 / this.scaleY;
                  scrollAnchorHeight = -1;
                  continue;
                }
              }
            }
            break;
          }
        }
      } finally {
        this.updateState = 0;
        this.measureScheduled = -1;
      }
      if (updated && !updated.empty)
        for (let listener of this.state.facet(updateListener))
          listener(updated);
    }
    /**
    Get the CSS classes for the currently active editor themes.
    */
    get themeClasses() {
      return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
    }
    updateAttrs() {
      let editorAttrs = attrsFromFacet(this, editorAttributes, {
        class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
      });
      let contentAttrs = {
        spellcheck: "false",
        autocorrect: "off",
        autocapitalize: "off",
        translate: "no",
        contenteditable: !this.state.facet(editable) ? "false" : "true",
        class: "cm-content",
        style: `${browser.tabSize}: ${this.state.tabSize}`,
        role: "textbox",
        "aria-multiline": "true"
      };
      if (this.state.readOnly)
        contentAttrs["aria-readonly"] = "true";
      attrsFromFacet(this, contentAttributes, contentAttrs);
      let changed = this.observer.ignore(() => {
        let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
        let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
        return changedContent || changedEditor;
      });
      this.editorAttrs = editorAttrs;
      this.contentAttrs = contentAttrs;
      return changed;
    }
    showAnnouncements(trs) {
      let first = true;
      for (let tr of trs)
        for (let effect of tr.effects)
          if (effect.is(_EditorView.announce)) {
            if (first)
              this.announceDOM.textContent = "";
            first = false;
            let div5 = this.announceDOM.appendChild(document.createElement("div"));
            div5.textContent = effect.value;
          }
    }
    mountStyles() {
      this.styleModules = this.state.facet(styleModule);
      let nonce = this.state.facet(_EditorView.cspNonce);
      StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? { nonce } : void 0);
    }
    readMeasured() {
      if (this.updateState == 2)
        throw new Error("Reading the editor layout isn't allowed during an update");
      if (this.updateState == 0 && this.measureScheduled > -1)
        this.measure(false);
    }
    /**
    Schedule a layout measurement, optionally providing callbacks to
    do custom DOM measuring followed by a DOM write phase. Using
    this is preferable reading DOM layout directly from, for
    example, an event handler, because it'll make sure measuring and
    drawing done by other components is synchronized, avoiding
    unnecessary DOM layout computations.
    */
    requestMeasure(request) {
      if (this.measureScheduled < 0)
        this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
      if (request) {
        if (this.measureRequests.indexOf(request) > -1)
          return;
        if (request.key != null)
          for (let i2 = 0; i2 < this.measureRequests.length; i2++) {
            if (this.measureRequests[i2].key === request.key) {
              this.measureRequests[i2] = request;
              return;
            }
          }
        this.measureRequests.push(request);
      }
    }
    /**
    Get the value of a specific plugin, if present. Note that
    plugins that crash can be dropped from a view, so even when you
    know you registered a given plugin, it is recommended to check
    the return value of this method.
    */
    plugin(plugin) {
      let known = this.pluginMap.get(plugin);
      if (known === void 0 || known && known.spec != plugin)
        this.pluginMap.set(plugin, known = this.plugins.find((p2) => p2.spec == plugin) || null);
      return known && known.update(this).value;
    }
    /**
    The top position of the document, in screen coordinates. This
    may be negative when the editor is scrolled down. Points
    directly to the top of the first line, not above the padding.
    */
    get documentTop() {
      return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
    }
    /**
    Reports the padding above and below the document.
    */
    get documentPadding() {
      return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
    }
    /**
    If the editor is transformed with CSS, this provides the scale
    along the X axis. Otherwise, it will just be 1. Note that
    transforms other than translation and scaling are not supported.
    */
    get scaleX() {
      return this.viewState.scaleX;
    }
    /**
    Provide the CSS transformed scale along the Y axis.
    */
    get scaleY() {
      return this.viewState.scaleY;
    }
    /**
    Find the text line or block widget at the given vertical
    position (which is interpreted as relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
    */
    elementAtHeight(height8) {
      this.readMeasured();
      return this.viewState.elementAtHeight(height8);
    }
    /**
    Find the line block (see
    [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
    height, again interpreted relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
    */
    lineBlockAtHeight(height8) {
      this.readMeasured();
      return this.viewState.lineBlockAtHeight(height8);
    }
    /**
    Get the extent and vertical position of all [line
    blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
    are relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
    */
    get viewportLineBlocks() {
      return this.viewState.viewportLines;
    }
    /**
    Find the line block around the given document position. A line
    block is a range delimited on both sides by either a
    non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
    start/end of the document. It will usually just hold a line of
    text, but may be broken into multiple textblocks by block
    widgets.
    */
    lineBlockAt(pos) {
      return this.viewState.lineBlockAt(pos);
    }
    /**
    The editor's total content height.
    */
    get contentHeight() {
      return this.viewState.contentHeight;
    }
    /**
    Move a cursor position by [grapheme
    cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
    the motion is away from the line start, or towards it. In
    bidirectional text, the line is traversed in visual order, using
    the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
    When the start position was the last one on the line, the
    returned position will be across the line break. If there is no
    further line, the original position is returned.
    
    By default, this method moves over a single cluster. The
    optional `by` argument can be used to move across more. It will
    be called with the first cluster as argument, and should return
    a predicate that determines, for each subsequent cluster,
    whether it should also be moved over.
    */
    moveByChar(start3, forward2, by) {
      return skipAtoms(this, start3, moveByChar(this, start3, forward2, by));
    }
    /**
    Move a cursor position across the next group of either
    [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
    non-whitespace characters.
    */
    moveByGroup(start3, forward2) {
      return skipAtoms(this, start3, moveByChar(this, start3, forward2, (initial) => byGroup(this, start3.head, initial)));
    }
    /**
    Get the cursor position visually at the start or end of a line.
    Note that this may differ from the _logical_ position at its
    start or end (which is simply at `line.from`/`line.to`) if text
    at the start or end goes against the line's base text direction.
    */
    visualLineSide(line, end) {
      let order = this.bidiSpans(line), dir2 = this.textDirectionAt(line.from);
      let span4 = order[end ? order.length - 1 : 0];
      return EditorSelection.cursor(span4.side(end, dir2) + line.from, span4.forward(!end, dir2) ? 1 : -1);
    }
    /**
    Move to the next line boundary in the given direction. If
    `includeWrap` is true, line wrapping is on, and there is a
    further wrap point on the current line, the wrap point will be
    returned. Otherwise this function will return the start or end
    of the line.
    */
    moveToLineBoundary(start3, forward2, includeWrap = true) {
      return moveToLineBoundary(this, start3, forward2, includeWrap);
    }
    /**
    Move a cursor position vertically. When `distance` isn't given,
    it defaults to moving to the next line (including wrapped
    lines). Otherwise, `distance` should provide a positive distance
    in pixels.
    
    When `start` has a
    [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
    motion will use that as a target horizontal position. Otherwise,
    the cursor's own horizontal position is used. The returned
    cursor will have its goal column set to whichever column was
    used.
    */
    moveVertically(start3, forward2, distance) {
      return skipAtoms(this, start3, moveVertically(this, start3, forward2, distance));
    }
    /**
    Find the DOM parent node and offset (child offset if `node` is
    an element, character offset when it is a text node) at the
    given document position.
    
    Note that for positions that aren't currently in
    `visibleRanges`, the resulting DOM position isn't necessarily
    meaningful (it may just point before or after a placeholder
    element).
    */
    domAtPos(pos) {
      return this.docView.domAtPos(pos);
    }
    /**
    Find the document position at the given DOM node. Can be useful
    for associating positions with DOM events. Will raise an error
    when `node` isn't part of the editor content.
    */
    posAtDOM(node, offset = 0) {
      return this.docView.posFromDOM(node, offset);
    }
    posAtCoords(coords2, precise = true) {
      this.readMeasured();
      return posAtCoords(this, coords2, precise);
    }
    /**
    Get the screen coordinates at the given document position.
    `side` determines whether the coordinates are based on the
    element before (-1) or after (1) the position (if no element is
    available on the given side, the method will transparently use
    another strategy to get reasonable coordinates).
    */
    coordsAtPos(pos, side = 1) {
      this.readMeasured();
      let rect = this.docView.coordsAt(pos, side);
      if (!rect || rect.left == rect.right)
        return rect;
      let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
      let span4 = order[BidiSpan.find(order, pos - line.from, -1, side)];
      return flattenRect(rect, span4.dir == Direction.LTR == side > 0);
    }
    /**
    Return the rectangle around a given character. If `pos` does not
    point in front of a character that is in the viewport and
    rendered (i.e. not replaced, not a line break), this will return
    null. For space characters that are a line wrap point, this will
    return the position before the line break.
    */
    coordsForChar(pos) {
      this.readMeasured();
      return this.docView.coordsForChar(pos);
    }
    /**
    The default width of a character in the editor. May not
    accurately reflect the width of all characters (given variable
    width fonts or styling of invididual ranges).
    */
    get defaultCharacterWidth() {
      return this.viewState.heightOracle.charWidth;
    }
    /**
    The default height of a line in the editor. May not be accurate
    for all lines.
    */
    get defaultLineHeight() {
      return this.viewState.heightOracle.lineHeight;
    }
    /**
    The text direction
    ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
    CSS property) of the editor's content element.
    */
    get textDirection() {
      return this.viewState.defaultTextDirection;
    }
    /**
    Find the text direction of the block at the given position, as
    assigned by CSS. If
    [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
    isn't enabled, or the given position is outside of the viewport,
    this will always return the same as
    [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
    this may trigger a DOM layout.
    */
    textDirectionAt(pos) {
      let perLine = this.state.facet(perLineTextDirection);
      if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
        return this.textDirection;
      this.readMeasured();
      return this.docView.textDirectionAt(pos);
    }
    /**
    Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
    (as determined by the
    [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
    CSS property of its content element).
    */
    get lineWrapping() {
      return this.viewState.heightOracle.lineWrapping;
    }
    /**
    Returns the bidirectional text structure of the given line
    (which should be in the current document) as an array of span
    objects. The order of these spans matches the [text
    direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
    left-to-right, the leftmost spans come first, otherwise the
    rightmost spans come first.
    */
    bidiSpans(line) {
      if (line.length > MaxBidiLine)
        return trivialOrder(line.length);
      let dir2 = this.textDirectionAt(line.from), isolates;
      for (let entry of this.bidiCache) {
        if (entry.from == line.from && entry.dir == dir2 && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line))))
          return entry.order;
      }
      if (!isolates)
        isolates = getIsolatedRanges(this, line);
      let order = computeOrder(line.text, dir2, isolates);
      this.bidiCache.push(new CachedOrder(line.from, line.to, dir2, isolates, true, order));
      return order;
    }
    /**
    Check whether the editor has focus.
    */
    get hasFocus() {
      var _a2;
      return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a2 = this.inputState) === null || _a2 === void 0 ? void 0 : _a2.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
    }
    /**
    Put focus on the editor.
    */
    focus() {
      this.observer.ignore(() => {
        focusPreventScroll(this.contentDOM);
        this.docView.updateSelection();
      });
    }
    /**
    Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
    necessary when moving the editor's existing DOM to a new window or shadow root.
    */
    setRoot(root) {
      if (this._root != root) {
        this._root = root;
        this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
        this.mountStyles();
      }
    }
    /**
    Clean up this editor view, removing its element from the
    document, unregistering event handlers, and notifying
    plugins. The view instance can no longer be used after
    calling this.
    */
    destroy() {
      if (this.root.activeElement == this.contentDOM)
        this.contentDOM.blur();
      for (let plugin of this.plugins)
        plugin.destroy(this);
      this.plugins = [];
      this.inputState.destroy();
      this.docView.destroy();
      this.dom.remove();
      this.observer.destroy();
      if (this.measureScheduled > -1)
        this.win.cancelAnimationFrame(this.measureScheduled);
      this.destroyed = true;
    }
    /**
    Returns an effect that can be
    [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
    cause it to scroll the given position or range into view.
    */
    static scrollIntoView(pos, options2 = {}) {
      return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options2.y, options2.x, options2.yMargin, options2.xMargin));
    }
    /**
    Return an effect that resets the editor to its current (at the
    time this method was called) scroll position. Note that this
    only affects the editor's own scrollable element, not parents.
    See also
    [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
    
    The effect should be used with a document identical to the one
    it was created for. Failing to do so is not an error, but may
    not scroll to the expected position. You can
    [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
    */
    scrollSnapshot() {
      let { scrollTop: scrollTop2, scrollLeft: scrollLeft2 } = this.scrollDOM;
      let ref = this.viewState.scrollAnchorAt(scrollTop2);
      return scrollIntoView.of(new ScrollTarget(EditorSelection.cursor(ref.from), "start", "start", ref.top - scrollTop2, scrollLeft2, true));
    }
    /**
    Enable or disable tab-focus mode, which disables key bindings
    for Tab and Shift-Tab, letting the browser's default
    focus-changing behavior go through instead. This is useful to
    prevent trapping keyboard users in your editor.
    
    Without argument, this toggles the mode. With a boolean, it
    enables (true) or disables it (false). Given a number, it
    temporarily enables the mode until that number of milliseconds
    have passed or another non-Tab key is pressed.
    */
    setTabFocusMode(to3) {
      if (to3 == null)
        this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1;
      else if (typeof to3 == "boolean")
        this.inputState.tabFocusMode = to3 ? 0 : -1;
      else if (this.inputState.tabFocusMode != 0)
        this.inputState.tabFocusMode = Date.now() + to3;
    }
    /**
    Returns an extension that can be used to add DOM event handlers.
    The value should be an object mapping event names to handler
    functions. For any given event, such functions are ordered by
    extension precedence, and the first handler to return true will
    be assumed to have handled that event, and no other handlers or
    built-in behavior will be activated for it. These are registered
    on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
    for `scroll` handlers, which will be called any time the
    editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
    its parent nodes is scrolled.
    */
    static domEventHandlers(handlers2) {
      return ViewPlugin.define(() => ({}), { eventHandlers: handlers2 });
    }
    /**
    Create an extension that registers DOM event observers. Contrary
    to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
    observers can't be prevented from running by a higher-precedence
    handler returning true. They also don't prevent other handlers
    and observers from running when they return true, and should not
    call `preventDefault`.
    */
    static domEventObservers(observers2) {
      return ViewPlugin.define(() => ({}), { eventObservers: observers2 });
    }
    /**
    Create a theme extension. The first argument can be a
    [`style-mod`](https://github.com/marijnh/style-mod#documentation)
    style spec providing the styles for the theme. These will be
    prefixed with a generated class for the style.
    
    Because the selectors will be prefixed with a scope class, rule
    that directly match the editor's [wrapper
    element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
    added—need to be explicitly differentiated by adding an `&` to
    the selector for that element—for example
    `&.cm-focused`.
    
    When `dark` is set to true, the theme will be marked as dark,
    which will cause the `&dark` rules from [base
    themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
    `&light` when a light theme is active).
    */
    static theme(spec, options2) {
      let prefix = StyleModule.newName();
      let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
      if (options2 && options2.dark)
        result.push(darkTheme.of(true));
      return result;
    }
    /**
    Create an extension that adds styles to the base theme. Like
    with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
    place of the editor wrapper element when directly targeting
    that. You can also use `&dark` or `&light` instead to only
    target editors with a dark or light theme.
    */
    static baseTheme(spec) {
      return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
    }
    /**
    Retrieve an editor view instance from the view's DOM
    representation.
    */
    static findFromDOM(dom) {
      var _a2;
      let content4 = dom.querySelector(".cm-content");
      let cView = content4 && ContentView.get(content4) || ContentView.get(dom);
      return ((_a2 = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a2 === void 0 ? void 0 : _a2.view) || null;
    }
  };
  EditorView.styleModule = styleModule;
  EditorView.inputHandler = inputHandler;
  EditorView.clipboardInputFilter = clipboardInputFilter;
  EditorView.clipboardOutputFilter = clipboardOutputFilter;
  EditorView.scrollHandler = scrollHandler;
  EditorView.focusChangeEffect = focusChangeEffect;
  EditorView.perLineTextDirection = perLineTextDirection;
  EditorView.exceptionSink = exceptionSink;
  EditorView.updateListener = updateListener;
  EditorView.editable = editable;
  EditorView.mouseSelectionStyle = mouseSelectionStyle;
  EditorView.dragMovesSelection = dragMovesSelection$1;
  EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
  EditorView.decorations = decorations;
  EditorView.outerDecorations = outerDecorations;
  EditorView.atomicRanges = atomicRanges;
  EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
  EditorView.scrollMargins = scrollMargins;
  EditorView.darkTheme = darkTheme;
  EditorView.cspNonce = /* @__PURE__ */ Facet.define({ combine: (values) => values.length ? values[0] : "" });
  EditorView.contentAttributes = contentAttributes;
  EditorView.editorAttributes = editorAttributes;
  EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
  EditorView.announce = /* @__PURE__ */ StateEffect.define();
  var MaxBidiLine = 4096;
  var BadMeasure = {};
  var CachedOrder = class _CachedOrder {
    constructor(from3, to3, dir2, isolates, fresh, order) {
      this.from = from3;
      this.to = to3;
      this.dir = dir2;
      this.isolates = isolates;
      this.fresh = fresh;
      this.order = order;
    }
    static update(cache2, changes) {
      if (changes.empty && !cache2.some((c2) => c2.fresh))
        return cache2;
      let result = [], lastDir = cache2.length ? cache2[cache2.length - 1].dir : Direction.LTR;
      for (let i2 = Math.max(0, cache2.length - 10); i2 < cache2.length; i2++) {
        let entry = cache2[i2];
        if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
          result.push(new _CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
      }
      return result;
    }
  };
  function attrsFromFacet(view2, facet, base2) {
    for (let sources2 = view2.state.facet(facet), i2 = sources2.length - 1; i2 >= 0; i2--) {
      let source3 = sources2[i2], value12 = typeof source3 == "function" ? source3(view2) : source3;
      if (value12)
        combineAttrs(value12, base2);
    }
    return base2;
  }
  var currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
  function normalizeKeyName(name16, platform2) {
    const parts = name16.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result == "Space")
      result = " ";
    let alt6, ctrl, shift2, meta2;
    for (let i2 = 0; i2 < parts.length - 1; ++i2) {
      const mod4 = parts[i2];
      if (/^(cmd|meta|m)$/i.test(mod4))
        meta2 = true;
      else if (/^a(lt)?$/i.test(mod4))
        alt6 = true;
      else if (/^(c|ctrl|control)$/i.test(mod4))
        ctrl = true;
      else if (/^s(hift)?$/i.test(mod4))
        shift2 = true;
      else if (/^mod$/i.test(mod4)) {
        if (platform2 == "mac")
          meta2 = true;
        else
          ctrl = true;
      } else
        throw new Error("Unrecognized modifier name: " + mod4);
    }
    if (alt6)
      result = "Alt-" + result;
    if (ctrl)
      result = "Ctrl-" + result;
    if (meta2)
      result = "Meta-" + result;
    if (shift2)
      result = "Shift-" + result;
    return result;
  }
  function modifiers(name16, event, shift2) {
    if (event.altKey)
      name16 = "Alt-" + name16;
    if (event.ctrlKey)
      name16 = "Ctrl-" + name16;
    if (event.metaKey)
      name16 = "Meta-" + name16;
    if (shift2 !== false && event.shiftKey)
      name16 = "Shift-" + name16;
    return name16;
  }
  var handleKeyEvents = /* @__PURE__ */ Prec.default(/* @__PURE__ */ EditorView.domEventHandlers({
    keydown(event, view2) {
      return runHandlers(getKeymap(view2.state), event, view2, "editor");
    }
  }));
  var keymap = /* @__PURE__ */ Facet.define({ enables: handleKeyEvents });
  var Keymaps = /* @__PURE__ */ new WeakMap();
  function getKeymap(state4) {
    let bindings = state4.facet(keymap);
    let map27 = Keymaps.get(bindings);
    if (!map27)
      Keymaps.set(bindings, map27 = buildKeymap(bindings.reduce((a2, b2) => a2.concat(b2), [])));
    return map27;
  }
  function runScopeHandlers(view2, event, scope2) {
    return runHandlers(getKeymap(view2.state), event, view2, scope2);
  }
  var storedPrefix = null;
  var PrefixTimeout = 4e3;
  function buildKeymap(bindings, platform2 = currentPlatform) {
    let bound = /* @__PURE__ */ Object.create(null);
    let isPrefix = /* @__PURE__ */ Object.create(null);
    let checkPrefix = (name16, is) => {
      let current = isPrefix[name16];
      if (current == null)
        isPrefix[name16] = is;
      else if (current != is)
        throw new Error("Key binding " + name16 + " is used both as a regular binding and as a multi-stroke prefix");
    };
    let add5 = (scope2, key, command2, preventDefault, stopPropagation) => {
      var _a2, _b;
      let scopeObj = bound[scope2] || (bound[scope2] = /* @__PURE__ */ Object.create(null));
      let parts = key.split(/ (?!$)/).map((k2) => normalizeKeyName(k2, platform2));
      for (let i2 = 1; i2 < parts.length; i2++) {
        let prefix = parts.slice(0, i2).join(" ");
        checkPrefix(prefix, true);
        if (!scopeObj[prefix])
          scopeObj[prefix] = {
            preventDefault: true,
            stopPropagation: false,
            run: [(view2) => {
              let ourObj = storedPrefix = { view: view2, prefix, scope: scope2 };
              setTimeout(() => {
                if (storedPrefix == ourObj)
                  storedPrefix = null;
              }, PrefixTimeout);
              return true;
            }]
          };
      }
      let full = parts.join(" ");
      checkPrefix(full, false);
      let binding = scopeObj[full] || (scopeObj[full] = {
        preventDefault: false,
        stopPropagation: false,
        run: ((_b = (_a2 = scopeObj._any) === null || _a2 === void 0 ? void 0 : _a2.run) === null || _b === void 0 ? void 0 : _b.slice()) || []
      });
      if (command2)
        binding.run.push(command2);
      if (preventDefault)
        binding.preventDefault = true;
      if (stopPropagation)
        binding.stopPropagation = true;
    };
    for (let b2 of bindings) {
      let scopes = b2.scope ? b2.scope.split(" ") : ["editor"];
      if (b2.any)
        for (let scope2 of scopes) {
          let scopeObj = bound[scope2] || (bound[scope2] = /* @__PURE__ */ Object.create(null));
          if (!scopeObj._any)
            scopeObj._any = { preventDefault: false, stopPropagation: false, run: [] };
          let { any: any3 } = b2;
          for (let key in scopeObj)
            scopeObj[key].run.push((view2) => any3(view2, currentKeyEvent));
        }
      let name16 = b2[platform2] || b2.key;
      if (!name16)
        continue;
      for (let scope2 of scopes) {
        add5(scope2, name16, b2.run, b2.preventDefault, b2.stopPropagation);
        if (b2.shift)
          add5(scope2, "Shift-" + name16, b2.shift, b2.preventDefault, b2.stopPropagation);
      }
    }
    return bound;
  }
  var currentKeyEvent = null;
  function runHandlers(map27, event, view2, scope2) {
    currentKeyEvent = event;
    let name16 = keyName(event);
    let charCode = codePointAt2(name16, 0), isChar = codePointSize(charCode) == name16.length && name16 != " ";
    let prefix = "", handled = false, prevented = false, stopPropagation = false;
    if (storedPrefix && storedPrefix.view == view2 && storedPrefix.scope == scope2) {
      prefix = storedPrefix.prefix + " ";
      if (modifierCodes.indexOf(event.keyCode) < 0) {
        prevented = true;
        storedPrefix = null;
      }
    }
    let ran = /* @__PURE__ */ new Set();
    let runFor = (binding) => {
      if (binding) {
        for (let cmd2 of binding.run)
          if (!ran.has(cmd2)) {
            ran.add(cmd2);
            if (cmd2(view2)) {
              if (binding.stopPropagation)
                stopPropagation = true;
              return true;
            }
          }
        if (binding.preventDefault) {
          if (binding.stopPropagation)
            stopPropagation = true;
          prevented = true;
        }
      }
      return false;
    };
    let scopeObj = map27[scope2], baseName, shiftName;
    if (scopeObj) {
      if (runFor(scopeObj[prefix + modifiers(name16, event, !isChar)])) {
        handled = true;
      } else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(browser.windows && event.ctrlKey && event.altKey) && (baseName = base[event.keyCode]) && baseName != name16) {
        if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {
          handled = true;
        } else if (event.shiftKey && (shiftName = shift[event.keyCode]) != name16 && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {
          handled = true;
        }
      } else if (isChar && event.shiftKey && runFor(scopeObj[prefix + modifiers(name16, event, true)])) {
        handled = true;
      }
      if (!handled && runFor(scopeObj._any))
        handled = true;
    }
    if (prevented)
      handled = true;
    if (handled && stopPropagation)
      event.stopPropagation();
    currentKeyEvent = null;
    return handled;
  }
  var RectangleMarker = class _RectangleMarker {
    /**
    Create a marker with the given class and dimensions. If `width`
    is null, the DOM element will get no width style.
    */
    constructor(className2, left, top4, width8, height8) {
      this.className = className2;
      this.left = left;
      this.top = top4;
      this.width = width8;
      this.height = height8;
    }
    draw() {
      let elt = document.createElement("div");
      elt.className = this.className;
      this.adjust(elt);
      return elt;
    }
    update(elt, prev) {
      if (prev.className != this.className)
        return false;
      this.adjust(elt);
      return true;
    }
    adjust(elt) {
      elt.style.left = this.left + "px";
      elt.style.top = this.top + "px";
      if (this.width != null)
        elt.style.width = this.width + "px";
      elt.style.height = this.height + "px";
    }
    eq(p2) {
      return this.left == p2.left && this.top == p2.top && this.width == p2.width && this.height == p2.height && this.className == p2.className;
    }
    /**
    Create a set of rectangles for the given selection range,
    assigning them theclass`className`. Will create a single
    rectangle for empty ranges, and a set of selection-style
    rectangles covering the range's content (in a bidi-aware
    way) for non-empty ones.
    */
    static forRange(view2, className2, range3) {
      if (range3.empty) {
        let pos = view2.coordsAtPos(range3.head, range3.assoc || 1);
        if (!pos)
          return [];
        let base2 = getBase(view2);
        return [new _RectangleMarker(className2, pos.left - base2.left, pos.top - base2.top, null, pos.bottom - pos.top)];
      } else {
        return rectanglesForRange(view2, className2, range3);
      }
    }
  };
  function getBase(view2) {
    let rect = view2.scrollDOM.getBoundingClientRect();
    let left = view2.textDirection == Direction.LTR ? rect.left : rect.right - view2.scrollDOM.clientWidth * view2.scaleX;
    return { left: left - view2.scrollDOM.scrollLeft * view2.scaleX, top: rect.top - view2.scrollDOM.scrollTop * view2.scaleY };
  }
  function wrappedLine(view2, pos, side, inside2) {
    let coords2 = view2.coordsAtPos(pos, side * 2);
    if (!coords2)
      return inside2;
    let editorRect = view2.dom.getBoundingClientRect();
    let y2 = (coords2.top + coords2.bottom) / 2;
    let left = view2.posAtCoords({ x: editorRect.left + 1, y: y2 });
    let right = view2.posAtCoords({ x: editorRect.right - 1, y: y2 });
    if (left == null || right == null)
      return inside2;
    return { from: Math.max(inside2.from, Math.min(left, right)), to: Math.min(inside2.to, Math.max(left, right)) };
  }
  function rectanglesForRange(view2, className2, range3) {
    if (range3.to <= view2.viewport.from || range3.from >= view2.viewport.to)
      return [];
    let from3 = Math.max(range3.from, view2.viewport.from), to3 = Math.min(range3.to, view2.viewport.to);
    let ltr = view2.textDirection == Direction.LTR;
    let content4 = view2.contentDOM, contentRect = content4.getBoundingClientRect(), base2 = getBase(view2);
    let lineElt = content4.querySelector(".cm-line"), lineStyle = lineElt && window.getComputedStyle(lineElt);
    let leftSide = contentRect.left + (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);
    let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);
    let startBlock = blockAt(view2, from3), endBlock = blockAt(view2, to3);
    let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
    let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
    if (visualStart && (view2.lineWrapping || startBlock.widgetLineBreaks))
      visualStart = wrappedLine(view2, from3, 1, visualStart);
    if (visualEnd && (view2.lineWrapping || endBlock.widgetLineBreaks))
      visualEnd = wrappedLine(view2, to3, -1, visualEnd);
    if (visualStart && visualEnd && visualStart.from == visualEnd.from && visualStart.to == visualEnd.to) {
      return pieces(drawForLine(range3.from, range3.to, visualStart));
    } else {
      let top4 = visualStart ? drawForLine(range3.from, null, visualStart) : drawForWidget(startBlock, false);
      let bottom3 = visualEnd ? drawForLine(null, range3.to, visualEnd) : drawForWidget(endBlock, true);
      let between = [];
      if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) || startBlock.widgetLineBreaks > 1 && top4.bottom + view2.defaultLineHeight / 2 < bottom3.top)
        between.push(piece(leftSide, top4.bottom, rightSide, bottom3.top));
      else if (top4.bottom < bottom3.top && view2.elementAtHeight((top4.bottom + bottom3.top) / 2).type == BlockType.Text)
        top4.bottom = bottom3.top = (top4.bottom + bottom3.top) / 2;
      return pieces(top4).concat(between).concat(pieces(bottom3));
    }
    function piece(left, top4, right, bottom3) {
      return new RectangleMarker(
        className2,
        left - base2.left,
        top4 - base2.top - 0.01,
        right - left,
        bottom3 - top4 + 0.01
        /* C.Epsilon */
      );
    }
    function pieces({ top: top4, bottom: bottom3, horizontal }) {
      let pieces2 = [];
      for (let i2 = 0; i2 < horizontal.length; i2 += 2)
        pieces2.push(piece(horizontal[i2], top4, horizontal[i2 + 1], bottom3));
      return pieces2;
    }
    function drawForLine(from4, to4, line) {
      let top4 = 1e9, bottom3 = -1e9, horizontal = [];
      function addSpan(from5, fromOpen, to5, toOpen, dir2) {
        let fromCoords = view2.coordsAtPos(from5, from5 == line.to ? -2 : 2);
        let toCoords = view2.coordsAtPos(to5, to5 == line.from ? 2 : -2);
        if (!fromCoords || !toCoords)
          return;
        top4 = Math.min(fromCoords.top, toCoords.top, top4);
        bottom3 = Math.max(fromCoords.bottom, toCoords.bottom, bottom3);
        if (dir2 == Direction.LTR)
          horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
        else
          horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
      }
      let start3 = from4 !== null && from4 !== void 0 ? from4 : line.from, end = to4 !== null && to4 !== void 0 ? to4 : line.to;
      for (let r2 of view2.visibleRanges)
        if (r2.to > start3 && r2.from < end) {
          for (let pos = Math.max(r2.from, start3), endPos = Math.min(r2.to, end); ; ) {
            let docLine = view2.state.doc.lineAt(pos);
            for (let span4 of view2.bidiSpans(docLine)) {
              let spanFrom = span4.from + docLine.from, spanTo = span4.to + docLine.from;
              if (spanFrom >= endPos)
                break;
              if (spanTo > pos)
                addSpan(Math.max(spanFrom, pos), from4 == null && spanFrom <= start3, Math.min(spanTo, endPos), to4 == null && spanTo >= end, span4.dir);
            }
            pos = docLine.to + 1;
            if (pos >= endPos)
              break;
          }
        }
      if (horizontal.length == 0)
        addSpan(start3, from4 == null, end, to4 == null, view2.textDirection);
      return { top: top4, bottom: bottom3, horizontal };
    }
    function drawForWidget(block, top4) {
      let y2 = contentRect.top + (top4 ? block.top : block.bottom);
      return { top: y2, bottom: y2, horizontal: [] };
    }
  }
  function sameMarker(a2, b2) {
    return a2.constructor == b2.constructor && a2.eq(b2);
  }
  var LayerView = class {
    constructor(view2, layer2) {
      this.view = view2;
      this.layer = layer2;
      this.drawn = [];
      this.scaleX = 1;
      this.scaleY = 1;
      this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) };
      this.dom = view2.scrollDOM.appendChild(document.createElement("div"));
      this.dom.classList.add("cm-layer");
      if (layer2.above)
        this.dom.classList.add("cm-layer-above");
      if (layer2.class)
        this.dom.classList.add(layer2.class);
      this.scale();
      this.dom.setAttribute("aria-hidden", "true");
      this.setOrder(view2.state);
      view2.requestMeasure(this.measureReq);
      if (layer2.mount)
        layer2.mount(this.dom, view2);
    }
    update(update3) {
      if (update3.startState.facet(layerOrder) != update3.state.facet(layerOrder))
        this.setOrder(update3.state);
      if (this.layer.update(update3, this.dom) || update3.geometryChanged) {
        this.scale();
        update3.view.requestMeasure(this.measureReq);
      }
    }
    docViewUpdate(view2) {
      if (this.layer.updateOnDocViewUpdate !== false)
        view2.requestMeasure(this.measureReq);
    }
    setOrder(state4) {
      let pos = 0, order = state4.facet(layerOrder);
      while (pos < order.length && order[pos] != this.layer)
        pos++;
      this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);
    }
    measure() {
      return this.layer.markers(this.view);
    }
    scale() {
      let { scaleX, scaleY } = this.view;
      if (scaleX != this.scaleX || scaleY != this.scaleY) {
        this.scaleX = scaleX;
        this.scaleY = scaleY;
        this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;
      }
    }
    draw(markers) {
      if (markers.length != this.drawn.length || markers.some((p2, i2) => !sameMarker(p2, this.drawn[i2]))) {
        let old = this.dom.firstChild, oldI = 0;
        for (let marker of markers) {
          if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {
            old = old.nextSibling;
            oldI++;
          } else {
            this.dom.insertBefore(marker.draw(), old);
          }
        }
        while (old) {
          let next = old.nextSibling;
          old.remove();
          old = next;
        }
        this.drawn = markers;
      }
    }
    destroy() {
      if (this.layer.destroy)
        this.layer.destroy(this.dom, this.view);
      this.dom.remove();
    }
  };
  var layerOrder = /* @__PURE__ */ Facet.define();
  function layer(config2) {
    return [
      ViewPlugin.define((v2) => new LayerView(v2, config2)),
      layerOrder.of(config2)
    ];
  }
  var CanHidePrimary = !browser.ios;
  var selectionConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        cursorBlinkRate: 1200,
        drawRangeCursor: true
      }, {
        cursorBlinkRate: (a2, b2) => Math.min(a2, b2),
        drawRangeCursor: (a2, b2) => a2 || b2
      });
    }
  });
  function drawSelection(config2 = {}) {
    return [
      selectionConfig.of(config2),
      cursorLayer,
      selectionLayer,
      hideNativeSelection,
      nativeSelectionHidden.of(true)
    ];
  }
  function configChanged(update3) {
    return update3.startState.facet(selectionConfig) != update3.state.facet(selectionConfig);
  }
  var cursorLayer = /* @__PURE__ */ layer({
    above: true,
    markers(view2) {
      let { state: state4 } = view2, conf = state4.facet(selectionConfig);
      let cursors = [];
      for (let r2 of state4.selection.ranges) {
        let prim = r2 == state4.selection.main;
        if (r2.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
          let className2 = prim ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary";
          let cursor = r2.empty ? r2 : EditorSelection.cursor(r2.head, r2.head > r2.anchor ? -1 : 1);
          for (let piece of RectangleMarker.forRange(view2, className2, cursor))
            cursors.push(piece);
        }
      }
      return cursors;
    },
    update(update3, dom) {
      if (update3.transactions.some((tr) => tr.selection))
        dom.style.animationName = dom.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
      let confChange = configChanged(update3);
      if (confChange)
        setBlinkRate(update3.state, dom);
      return update3.docChanged || update3.selectionSet || confChange;
    },
    mount(dom, view2) {
      setBlinkRate(view2.state, dom);
    },
    class: "cm-cursorLayer"
  });
  function setBlinkRate(state4, dom) {
    dom.style.animationDuration = state4.facet(selectionConfig).cursorBlinkRate + "ms";
  }
  var selectionLayer = /* @__PURE__ */ layer({
    above: false,
    markers(view2) {
      return view2.state.selection.ranges.map((r2) => r2.empty ? [] : RectangleMarker.forRange(view2, "cm-selectionBackground", r2)).reduce((a2, b2) => a2.concat(b2));
    },
    update(update3, dom) {
      return update3.docChanged || update3.selectionSet || update3.viewportChanged || configChanged(update3);
    },
    class: "cm-selectionLayer"
  });
  var themeSpec = {
    ".cm-line": {
      "& ::selection, &::selection": { backgroundColor: "transparent !important" }
    },
    ".cm-content": {
      "& :focus": {
        caretColor: "initial !important",
        "&::selection, & ::selection": {
          backgroundColor: "Highlight !important"
        }
      }
    }
  };
  if (CanHidePrimary)
    themeSpec[".cm-line"].caretColor = themeSpec[".cm-content"].caretColor = "transparent !important";
  var hideNativeSelection = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ EditorView.theme(themeSpec));
  var setDropCursorPos = /* @__PURE__ */ StateEffect.define({
    map(pos, mapping) {
      return pos == null ? null : mapping.mapPos(pos);
    }
  });
  var dropCursorPos = /* @__PURE__ */ StateField.define({
    create() {
      return null;
    },
    update(pos, tr) {
      if (pos != null)
        pos = tr.changes.mapPos(pos);
      return tr.effects.reduce((pos2, e2) => e2.is(setDropCursorPos) ? e2.value : pos2, pos);
    }
  });
  var drawDropCursor = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view2) {
      this.view = view2;
      this.cursor = null;
      this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
    }
    update(update3) {
      var _a2;
      let cursorPos = update3.state.field(dropCursorPos);
      if (cursorPos == null) {
        if (this.cursor != null) {
          (_a2 = this.cursor) === null || _a2 === void 0 ? void 0 : _a2.remove();
          this.cursor = null;
        }
      } else {
        if (!this.cursor) {
          this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
          this.cursor.className = "cm-dropCursor";
        }
        if (update3.startState.field(dropCursorPos) != cursorPos || update3.docChanged || update3.geometryChanged)
          this.view.requestMeasure(this.measureReq);
      }
    }
    readPos() {
      let { view: view2 } = this;
      let pos = view2.state.field(dropCursorPos);
      let rect = pos != null && view2.coordsAtPos(pos);
      if (!rect)
        return null;
      let outer = view2.scrollDOM.getBoundingClientRect();
      return {
        left: rect.left - outer.left + view2.scrollDOM.scrollLeft * view2.scaleX,
        top: rect.top - outer.top + view2.scrollDOM.scrollTop * view2.scaleY,
        height: rect.bottom - rect.top
      };
    }
    drawCursor(pos) {
      if (this.cursor) {
        let { scaleX, scaleY } = this.view;
        if (pos) {
          this.cursor.style.left = pos.left / scaleX + "px";
          this.cursor.style.top = pos.top / scaleY + "px";
          this.cursor.style.height = pos.height / scaleY + "px";
        } else {
          this.cursor.style.left = "-100000px";
        }
      }
    }
    destroy() {
      if (this.cursor)
        this.cursor.remove();
    }
    setDropPos(pos) {
      if (this.view.state.field(dropCursorPos) != pos)
        this.view.dispatch({ effects: setDropCursorPos.of(pos) });
    }
  }, {
    eventObservers: {
      dragover(event) {
        this.setDropPos(this.view.posAtCoords({ x: event.clientX, y: event.clientY }));
      },
      dragleave(event) {
        if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget))
          this.setDropPos(null);
      },
      dragend() {
        this.setDropPos(null);
      },
      drop() {
        this.setDropPos(null);
      }
    }
  });
  function dropCursor() {
    return [dropCursorPos, drawDropCursor];
  }
  function iterMatches(doc2, re, from3, to3, f2) {
    re.lastIndex = 0;
    for (let cursor = doc2.iterRange(from3, to3), pos = from3, m2; !cursor.next().done; pos += cursor.value.length) {
      if (!cursor.lineBreak)
        while (m2 = re.exec(cursor.value))
          f2(pos + m2.index, m2);
    }
  }
  function matchRanges(view2, maxLength3) {
    let visible = view2.visibleRanges;
    if (visible.length == 1 && visible[0].from == view2.viewport.from && visible[0].to == view2.viewport.to)
      return visible;
    let result = [];
    for (let { from: from3, to: to3 } of visible) {
      from3 = Math.max(view2.state.doc.lineAt(from3).from, from3 - maxLength3);
      to3 = Math.min(view2.state.doc.lineAt(to3).to, to3 + maxLength3);
      if (result.length && result[result.length - 1].to >= from3)
        result[result.length - 1].to = to3;
      else
        result.push({ from: from3, to: to3 });
    }
    return result;
  }
  var MatchDecorator = class {
    /**
    Create a decorator.
    */
    constructor(config2) {
      const { regexp, decoration, decorate, boundary, maxLength: maxLength3 = 1e3 } = config2;
      if (!regexp.global)
        throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
      this.regexp = regexp;
      if (decorate) {
        this.addMatch = (match2, view2, from3, add5) => decorate(add5, from3, from3 + match2[0].length, match2, view2);
      } else if (typeof decoration == "function") {
        this.addMatch = (match2, view2, from3, add5) => {
          let deco = decoration(match2, view2, from3);
          if (deco)
            add5(from3, from3 + match2[0].length, deco);
        };
      } else if (decoration) {
        this.addMatch = (match2, _view, from3, add5) => add5(from3, from3 + match2[0].length, decoration);
      } else {
        throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
      }
      this.boundary = boundary;
      this.maxLength = maxLength3;
    }
    /**
    Compute the full set of decorations for matches in the given
    view's viewport. You'll want to call this when initializing your
    plugin.
    */
    createDeco(view2) {
      let build2 = new RangeSetBuilder(), add5 = build2.add.bind(build2);
      for (let { from: from3, to: to3 } of matchRanges(view2, this.maxLength))
        iterMatches(view2.state.doc, this.regexp, from3, to3, (from4, m2) => this.addMatch(m2, view2, from4, add5));
      return build2.finish();
    }
    /**
    Update a set of decorations for a view update. `deco` _must_ be
    the set of decorations produced by _this_ `MatchDecorator` for
    the view state before the update.
    */
    updateDeco(update3, deco) {
      let changeFrom = 1e9, changeTo = -1;
      if (update3.docChanged)
        update3.changes.iterChanges((_f, _t, from3, to3) => {
          if (to3 > update3.view.viewport.from && from3 < update3.view.viewport.to) {
            changeFrom = Math.min(from3, changeFrom);
            changeTo = Math.max(to3, changeTo);
          }
        });
      if (update3.viewportChanged || changeTo - changeFrom > 1e3)
        return this.createDeco(update3.view);
      if (changeTo > -1)
        return this.updateRange(update3.view, deco.map(update3.changes), changeFrom, changeTo);
      return deco;
    }
    updateRange(view2, deco, updateFrom, updateTo) {
      for (let r2 of view2.visibleRanges) {
        let from3 = Math.max(r2.from, updateFrom), to3 = Math.min(r2.to, updateTo);
        if (to3 > from3) {
          let fromLine = view2.state.doc.lineAt(from3), toLine = fromLine.to < to3 ? view2.state.doc.lineAt(to3) : fromLine;
          let start3 = Math.max(r2.from, fromLine.from), end = Math.min(r2.to, toLine.to);
          if (this.boundary) {
            for (; from3 > fromLine.from; from3--)
              if (this.boundary.test(fromLine.text[from3 - 1 - fromLine.from])) {
                start3 = from3;
                break;
              }
            for (; to3 < toLine.to; to3++)
              if (this.boundary.test(toLine.text[to3 - toLine.from])) {
                end = to3;
                break;
              }
          }
          let ranges = [], m2;
          let add5 = (from4, to4, deco2) => ranges.push(deco2.range(from4, to4));
          if (fromLine == toLine) {
            this.regexp.lastIndex = start3 - fromLine.from;
            while ((m2 = this.regexp.exec(fromLine.text)) && m2.index < end - fromLine.from)
              this.addMatch(m2, view2, m2.index + fromLine.from, add5);
          } else {
            iterMatches(view2.state.doc, this.regexp, start3, end, (from4, m3) => this.addMatch(m3, view2, from4, add5));
          }
          deco = deco.update({ filterFrom: start3, filterTo: end, filter: (from4, to4) => from4 < start3 || to4 > end, add: ranges });
        }
      }
      return deco;
    }
  };
  var UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
  var Specials = /* @__PURE__ */ new RegExp("[\0-\b\n-\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\u202D\u202E\u2066\u2067\u2069\uFEFF\uFFF9-\uFFFC]", UnicodeRegexpSupport);
  var Names = {
    0: "null",
    7: "bell",
    8: "backspace",
    10: "newline",
    11: "vertical tab",
    13: "carriage return",
    27: "escape",
    8203: "zero width space",
    8204: "zero width non-joiner",
    8205: "zero width joiner",
    8206: "left-to-right mark",
    8207: "right-to-left mark",
    8232: "line separator",
    8237: "left-to-right override",
    8238: "right-to-left override",
    8294: "left-to-right isolate",
    8295: "right-to-left isolate",
    8297: "pop directional isolate",
    8233: "paragraph separator",
    65279: "zero width no-break space",
    65532: "object replacement"
  };
  var _supportsTabSize = null;
  function supportsTabSize() {
    var _a2;
    if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
      let styles = document.body.style;
      _supportsTabSize = ((_a2 = styles.tabSize) !== null && _a2 !== void 0 ? _a2 : styles.MozTabSize) != null;
    }
    return _supportsTabSize || false;
  }
  var specialCharConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      let config2 = combineConfig(configs, {
        render: null,
        specialChars: Specials,
        addSpecialChars: null
      });
      if (config2.replaceTabs = !supportsTabSize())
        config2.specialChars = new RegExp("	|" + config2.specialChars.source, UnicodeRegexpSupport);
      if (config2.addSpecialChars)
        config2.specialChars = new RegExp(config2.specialChars.source + "|" + config2.addSpecialChars.source, UnicodeRegexpSupport);
      return config2;
    }
  });
  function highlightSpecialChars(config2 = {}) {
    return [specialCharConfig.of(config2), specialCharPlugin()];
  }
  var _plugin = null;
  function specialCharPlugin() {
    return _plugin || (_plugin = ViewPlugin.fromClass(class {
      constructor(view2) {
        this.view = view2;
        this.decorations = Decoration.none;
        this.decorationCache = /* @__PURE__ */ Object.create(null);
        this.decorator = this.makeDecorator(view2.state.facet(specialCharConfig));
        this.decorations = this.decorator.createDeco(view2);
      }
      makeDecorator(conf) {
        return new MatchDecorator({
          regexp: conf.specialChars,
          decoration: (m2, view2, pos) => {
            let { doc: doc2 } = view2.state;
            let code = codePointAt2(m2[0], 0);
            if (code == 9) {
              let line = doc2.lineAt(pos);
              let size5 = view2.state.tabSize, col = countColumn(line.text, size5, pos - line.from);
              return Decoration.replace({
                widget: new TabWidget((size5 - col % size5) * this.view.defaultCharacterWidth / this.view.scaleX)
              });
            }
            return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(conf, code) }));
          },
          boundary: conf.replaceTabs ? void 0 : /[^]/
        });
      }
      update(update3) {
        let conf = update3.state.facet(specialCharConfig);
        if (update3.startState.facet(specialCharConfig) != conf) {
          this.decorator = this.makeDecorator(conf);
          this.decorations = this.decorator.createDeco(update3.view);
        } else {
          this.decorations = this.decorator.updateDeco(update3, this.decorations);
        }
      }
    }, {
      decorations: (v2) => v2.decorations
    }));
  }
  var DefaultPlaceholder = "\u2022";
  function placeholder$1(code) {
    if (code >= 32)
      return DefaultPlaceholder;
    if (code == 10)
      return "\u2424";
    return String.fromCharCode(9216 + code);
  }
  var SpecialCharWidget = class extends WidgetType {
    constructor(options2, code) {
      super();
      this.options = options2;
      this.code = code;
    }
    eq(other) {
      return other.code == this.code;
    }
    toDOM(view2) {
      let ph = placeholder$1(this.code);
      let desc = view2.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
      let custom = this.options.render && this.options.render(this.code, desc, ph);
      if (custom)
        return custom;
      let span4 = document.createElement("span");
      span4.textContent = ph;
      span4.title = desc;
      span4.setAttribute("aria-label", desc);
      span4.className = "cm-specialChar";
      return span4;
    }
    ignoreEvent() {
      return false;
    }
  };
  var TabWidget = class extends WidgetType {
    constructor(width8) {
      super();
      this.width = width8;
    }
    eq(other) {
      return other.width == this.width;
    }
    toDOM() {
      let span4 = document.createElement("span");
      span4.textContent = "	";
      span4.className = "cm-tab";
      span4.style.width = this.width + "px";
      return span4;
    }
    ignoreEvent() {
      return false;
    }
  };
  function highlightActiveLine() {
    return activeLineHighlighter;
  }
  var lineDeco = /* @__PURE__ */ Decoration.line({ class: "cm-activeLine" });
  var activeLineHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view2) {
      this.decorations = this.getDeco(view2);
    }
    update(update3) {
      if (update3.docChanged || update3.selectionSet)
        this.decorations = this.getDeco(update3.view);
    }
    getDeco(view2) {
      let lastLineStart = -1, deco = [];
      for (let r2 of view2.state.selection.ranges) {
        let line = view2.lineBlockAt(r2.head);
        if (line.from > lastLineStart) {
          deco.push(lineDeco.range(line.from));
          lastLineStart = line.from;
        }
      }
      return Decoration.set(deco);
    }
  }, {
    decorations: (v2) => v2.decorations
  });
  var MaxOff = 2e3;
  function rectangleFor(state4, a2, b2) {
    let startLine = Math.min(a2.line, b2.line), endLine = Math.max(a2.line, b2.line);
    let ranges = [];
    if (a2.off > MaxOff || b2.off > MaxOff || a2.col < 0 || b2.col < 0) {
      let startOff = Math.min(a2.off, b2.off), endOff = Math.max(a2.off, b2.off);
      for (let i2 = startLine; i2 <= endLine; i2++) {
        let line = state4.doc.line(i2);
        if (line.length <= endOff)
          ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));
      }
    } else {
      let startCol = Math.min(a2.col, b2.col), endCol = Math.max(a2.col, b2.col);
      for (let i2 = startLine; i2 <= endLine; i2++) {
        let line = state4.doc.line(i2);
        let start3 = findColumn(line.text, startCol, state4.tabSize, true);
        if (start3 < 0) {
          ranges.push(EditorSelection.cursor(line.to));
        } else {
          let end = findColumn(line.text, endCol, state4.tabSize);
          ranges.push(EditorSelection.range(line.from + start3, line.from + end));
        }
      }
    }
    return ranges;
  }
  function absoluteColumn(view2, x2) {
    let ref = view2.coordsAtPos(view2.viewport.from);
    return ref ? Math.round(Math.abs((ref.left - x2) / view2.defaultCharacterWidth)) : -1;
  }
  function getPos(view2, event) {
    let offset = view2.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    let line = view2.state.doc.lineAt(offset), off = offset - line.from;
    let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view2, event.clientX) : countColumn(line.text, view2.state.tabSize, offset - line.from);
    return { line: line.number, col, off };
  }
  function rectangleSelectionStyle(view2, event) {
    let start3 = getPos(view2, event), startSel = view2.state.selection;
    if (!start3)
      return null;
    return {
      update(update3) {
        if (update3.docChanged) {
          let newStart = update3.changes.mapPos(update3.startState.doc.line(start3.line).from);
          let newLine = update3.state.doc.lineAt(newStart);
          start3 = { line: newLine.number, col: start3.col, off: Math.min(start3.off, newLine.length) };
          startSel = startSel.map(update3.changes);
        }
      },
      get(event2, _extend, multiple3) {
        let cur2 = getPos(view2, event2);
        if (!cur2)
          return startSel;
        let ranges = rectangleFor(view2.state, start3, cur2);
        if (!ranges.length)
          return startSel;
        if (multiple3)
          return EditorSelection.create(ranges.concat(startSel.ranges));
        else
          return EditorSelection.create(ranges);
      }
    };
  }
  function rectangularSelection(options2) {
    let filter3 = (options2 === null || options2 === void 0 ? void 0 : options2.eventFilter) || ((e2) => e2.altKey && e2.button == 0);
    return EditorView.mouseSelectionStyle.of((view2, event) => filter3(event) ? rectangleSelectionStyle(view2, event) : null);
  }
  var keys5 = {
    Alt: [18, (e2) => !!e2.altKey],
    Control: [17, (e2) => !!e2.ctrlKey],
    Shift: [16, (e2) => !!e2.shiftKey],
    Meta: [91, (e2) => !!e2.metaKey]
  };
  var showCrosshair = { style: "cursor: crosshair" };
  function crosshairCursor(options2 = {}) {
    let [code, getter] = keys5[options2.key || "Alt"];
    let plugin = ViewPlugin.fromClass(class {
      constructor(view2) {
        this.view = view2;
        this.isDown = false;
      }
      set(isDown) {
        if (this.isDown != isDown) {
          this.isDown = isDown;
          this.view.update([]);
        }
      }
    }, {
      eventObservers: {
        keydown(e2) {
          this.set(e2.keyCode == code || getter(e2));
        },
        keyup(e2) {
          if (e2.keyCode == code || !getter(e2))
            this.set(false);
        },
        mousemove(e2) {
          this.set(getter(e2));
        }
      }
    });
    return [
      plugin,
      EditorView.contentAttributes.of((view2) => {
        var _a2;
        return ((_a2 = view2.plugin(plugin)) === null || _a2 === void 0 ? void 0 : _a2.isDown) ? showCrosshair : null;
      })
    ];
  }
  var Outside = "-10000px";
  var TooltipViewManager = class {
    constructor(view2, facet, createTooltipView, removeTooltipView) {
      this.facet = facet;
      this.createTooltipView = createTooltipView;
      this.removeTooltipView = removeTooltipView;
      this.input = view2.state.facet(facet);
      this.tooltips = this.input.filter((t3) => t3);
      let prev = null;
      this.tooltipViews = this.tooltips.map((t3) => prev = createTooltipView(t3, prev));
    }
    update(update3, above) {
      var _a2;
      let input = update3.state.facet(this.facet);
      let tooltips = input.filter((x2) => x2);
      if (input === this.input) {
        for (let t3 of this.tooltipViews)
          if (t3.update)
            t3.update(update3);
        return false;
      }
      let tooltipViews = [], newAbove = above ? [] : null;
      for (let i2 = 0; i2 < tooltips.length; i2++) {
        let tip = tooltips[i2], known = -1;
        if (!tip)
          continue;
        for (let i3 = 0; i3 < this.tooltips.length; i3++) {
          let other = this.tooltips[i3];
          if (other && other.create == tip.create)
            known = i3;
        }
        if (known < 0) {
          tooltipViews[i2] = this.createTooltipView(tip, i2 ? tooltipViews[i2 - 1] : null);
          if (newAbove)
            newAbove[i2] = !!tip.above;
        } else {
          let tooltipView = tooltipViews[i2] = this.tooltipViews[known];
          if (newAbove)
            newAbove[i2] = above[known];
          if (tooltipView.update)
            tooltipView.update(update3);
        }
      }
      for (let t3 of this.tooltipViews)
        if (tooltipViews.indexOf(t3) < 0) {
          this.removeTooltipView(t3);
          (_a2 = t3.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t3);
        }
      if (above) {
        newAbove.forEach((val, i2) => above[i2] = val);
        above.length = newAbove.length;
      }
      this.input = input;
      this.tooltips = tooltips;
      this.tooltipViews = tooltipViews;
      return true;
    }
  };
  function windowSpace(view2) {
    let { win } = view2;
    return { top: 0, left: 0, bottom: win.innerHeight, right: win.innerWidth };
  }
  var tooltipConfig = /* @__PURE__ */ Facet.define({
    combine: (values) => {
      var _a2, _b, _c;
      return {
        position: browser.ios ? "absolute" : ((_a2 = values.find((conf) => conf.position)) === null || _a2 === void 0 ? void 0 : _a2.position) || "fixed",
        parent: ((_b = values.find((conf) => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
        tooltipSpace: ((_c = values.find((conf) => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace
      };
    }
  });
  var knownHeight = /* @__PURE__ */ new WeakMap();
  var tooltipPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view2) {
      this.view = view2;
      this.above = [];
      this.inView = true;
      this.madeAbsolute = false;
      this.lastTransaction = 0;
      this.measureTimeout = -1;
      let config2 = view2.state.facet(tooltipConfig);
      this.position = config2.position;
      this.parent = config2.parent;
      this.classes = view2.themeClasses;
      this.createContainer();
      this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
      this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null;
      this.manager = new TooltipViewManager(view2, showTooltip, (t3, p2) => this.createTooltip(t3, p2), (t3) => {
        if (this.resizeObserver)
          this.resizeObserver.unobserve(t3.dom);
        t3.dom.remove();
      });
      this.above = this.manager.tooltips.map((t3) => !!t3.above);
      this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((entries) => {
        if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
          this.measureSoon();
      }, { threshold: [1] }) : null;
      this.observeIntersection();
      view2.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
      this.maybeMeasure();
    }
    createContainer() {
      if (this.parent) {
        this.container = document.createElement("div");
        this.container.style.position = "relative";
        this.container.className = this.view.themeClasses;
        this.parent.appendChild(this.container);
      } else {
        this.container = this.view.dom;
      }
    }
    observeIntersection() {
      if (this.intersectionObserver) {
        this.intersectionObserver.disconnect();
        for (let tooltip of this.manager.tooltipViews)
          this.intersectionObserver.observe(tooltip.dom);
      }
    }
    measureSoon() {
      if (this.measureTimeout < 0)
        this.measureTimeout = setTimeout(() => {
          this.measureTimeout = -1;
          this.maybeMeasure();
        }, 50);
    }
    update(update3) {
      if (update3.transactions.length)
        this.lastTransaction = Date.now();
      let updated = this.manager.update(update3, this.above);
      if (updated)
        this.observeIntersection();
      let shouldMeasure = updated || update3.geometryChanged;
      let newConfig = update3.state.facet(tooltipConfig);
      if (newConfig.position != this.position && !this.madeAbsolute) {
        this.position = newConfig.position;
        for (let t3 of this.manager.tooltipViews)
          t3.dom.style.position = this.position;
        shouldMeasure = true;
      }
      if (newConfig.parent != this.parent) {
        if (this.parent)
          this.container.remove();
        this.parent = newConfig.parent;
        this.createContainer();
        for (let t3 of this.manager.tooltipViews)
          this.container.appendChild(t3.dom);
        shouldMeasure = true;
      } else if (this.parent && this.view.themeClasses != this.classes) {
        this.classes = this.container.className = this.view.themeClasses;
      }
      if (shouldMeasure)
        this.maybeMeasure();
    }
    createTooltip(tooltip, prev) {
      let tooltipView = tooltip.create(this.view);
      let before = prev ? prev.dom : null;
      tooltipView.dom.classList.add("cm-tooltip");
      if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
        let arrow = document.createElement("div");
        arrow.className = "cm-tooltip-arrow";
        tooltipView.dom.appendChild(arrow);
      }
      tooltipView.dom.style.position = this.position;
      tooltipView.dom.style.top = Outside;
      tooltipView.dom.style.left = "0px";
      this.container.insertBefore(tooltipView.dom, before);
      if (tooltipView.mount)
        tooltipView.mount(this.view);
      if (this.resizeObserver)
        this.resizeObserver.observe(tooltipView.dom);
      return tooltipView;
    }
    destroy() {
      var _a2, _b, _c;
      this.view.win.removeEventListener("resize", this.measureSoon);
      for (let tooltipView of this.manager.tooltipViews) {
        tooltipView.dom.remove();
        (_a2 = tooltipView.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(tooltipView);
      }
      if (this.parent)
        this.container.remove();
      (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
      (_c = this.intersectionObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
      clearTimeout(this.measureTimeout);
    }
    readMeasure() {
      let editor2 = this.view.dom.getBoundingClientRect();
      let scaleX = 1, scaleY = 1, makeAbsolute = false;
      if (this.position == "fixed" && this.manager.tooltipViews.length) {
        let { dom } = this.manager.tooltipViews[0];
        if (browser.gecko) {
          makeAbsolute = dom.offsetParent != this.container.ownerDocument.body;
        } else if (dom.style.top == Outside && dom.style.left == "0px") {
          let rect = dom.getBoundingClientRect();
          makeAbsolute = Math.abs(rect.top + 1e4) > 1 || Math.abs(rect.left) > 1;
        }
      }
      if (makeAbsolute || this.position == "absolute") {
        if (this.parent) {
          let rect = this.parent.getBoundingClientRect();
          if (rect.width && rect.height) {
            scaleX = rect.width / this.parent.offsetWidth;
            scaleY = rect.height / this.parent.offsetHeight;
          }
        } else {
          ({ scaleX, scaleY } = this.view.viewState);
        }
      }
      return {
        editor: editor2,
        parent: this.parent ? this.container.getBoundingClientRect() : editor2,
        pos: this.manager.tooltips.map((t3, i2) => {
          let tv = this.manager.tooltipViews[i2];
          return tv.getCoords ? tv.getCoords(t3.pos) : this.view.coordsAtPos(t3.pos);
        }),
        size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
        space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
        scaleX,
        scaleY,
        makeAbsolute
      };
    }
    writeMeasure(measured) {
      var _a2;
      if (measured.makeAbsolute) {
        this.madeAbsolute = true;
        this.position = "absolute";
        for (let t3 of this.manager.tooltipViews)
          t3.dom.style.position = "absolute";
      }
      let { editor: editor2, space: space2, scaleX, scaleY } = measured;
      let others = [];
      for (let i2 = 0; i2 < this.manager.tooltips.length; i2++) {
        let tooltip = this.manager.tooltips[i2], tView = this.manager.tooltipViews[i2], { dom } = tView;
        let pos = measured.pos[i2], size5 = measured.size[i2];
        if (!pos || pos.bottom <= Math.max(editor2.top, space2.top) || pos.top >= Math.min(editor2.bottom, space2.bottom) || pos.right < Math.max(editor2.left, space2.left) - 0.1 || pos.left > Math.min(editor2.right, space2.right) + 0.1) {
          dom.style.top = Outside;
          continue;
        }
        let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
        let arrowHeight = arrow ? 7 : 0;
        let width8 = size5.right - size5.left, height8 = (_a2 = knownHeight.get(tView)) !== null && _a2 !== void 0 ? _a2 : size5.bottom - size5.top;
        let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
        let left = size5.width > space2.right - space2.left ? ltr ? space2.left : space2.right - size5.width : ltr ? Math.max(space2.left, Math.min(pos.left - (arrow ? 14 : 0) + offset.x, space2.right - width8)) : Math.min(Math.max(space2.left, pos.left - width8 + (arrow ? 14 : 0) - offset.x), space2.right - width8);
        let above = this.above[i2];
        if (!tooltip.strictSide && (above ? pos.top - (size5.bottom - size5.top) - offset.y < space2.top : pos.bottom + (size5.bottom - size5.top) + offset.y > space2.bottom) && above == space2.bottom - pos.bottom > pos.top - space2.top)
          above = this.above[i2] = !above;
        let spaceVert = (above ? pos.top - space2.top : space2.bottom - pos.bottom) - arrowHeight;
        if (spaceVert < height8 && tView.resize !== false) {
          if (spaceVert < this.view.defaultLineHeight) {
            dom.style.top = Outside;
            continue;
          }
          knownHeight.set(tView, height8);
          dom.style.height = (height8 = spaceVert) / scaleY + "px";
        } else if (dom.style.height) {
          dom.style.height = "";
        }
        let top4 = above ? pos.top - height8 - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
        let right = left + width8;
        if (tView.overlap !== true) {
          for (let r2 of others)
            if (r2.left < right && r2.right > left && r2.top < top4 + height8 && r2.bottom > top4)
              top4 = above ? r2.top - height8 - 2 - arrowHeight : r2.bottom + arrowHeight + 2;
        }
        if (this.position == "absolute") {
          dom.style.top = (top4 - measured.parent.top) / scaleY + "px";
          dom.style.left = (left - measured.parent.left) / scaleX + "px";
        } else {
          dom.style.top = top4 / scaleY + "px";
          dom.style.left = left / scaleX + "px";
        }
        if (arrow) {
          let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 - 7);
          arrow.style.left = arrowLeft / scaleX + "px";
        }
        if (tView.overlap !== true)
          others.push({ left, top: top4, right, bottom: top4 + height8 });
        dom.classList.toggle("cm-tooltip-above", above);
        dom.classList.toggle("cm-tooltip-below", !above);
        if (tView.positioned)
          tView.positioned(measured.space);
      }
    }
    maybeMeasure() {
      if (this.manager.tooltips.length) {
        if (this.view.inView)
          this.view.requestMeasure(this.measureReq);
        if (this.inView != this.view.inView) {
          this.inView = this.view.inView;
          if (!this.inView)
            for (let tv of this.manager.tooltipViews)
              tv.dom.style.top = Outside;
        }
      }
    }
  }, {
    eventObservers: {
      scroll() {
        this.maybeMeasure();
      }
    }
  });
  var baseTheme = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-tooltip": {
      zIndex: 100,
      boxSizing: "border-box"
    },
    "&light .cm-tooltip": {
      border: "1px solid #bbb",
      backgroundColor: "#f5f5f5"
    },
    "&light .cm-tooltip-section:not(:first-child)": {
      borderTop: "1px solid #bbb"
    },
    "&dark .cm-tooltip": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tooltip-arrow": {
      height: `${7}px`,
      width: `${7 * 2}px`,
      position: "absolute",
      zIndex: -1,
      overflow: "hidden",
      "&:before, &:after": {
        content: "''",
        position: "absolute",
        width: 0,
        height: 0,
        borderLeft: `${7}px solid transparent`,
        borderRight: `${7}px solid transparent`
      },
      ".cm-tooltip-above &": {
        bottom: `-${7}px`,
        "&:before": {
          borderTop: `${7}px solid #bbb`
        },
        "&:after": {
          borderTop: `${7}px solid #f5f5f5`,
          bottom: "1px"
        }
      },
      ".cm-tooltip-below &": {
        top: `-${7}px`,
        "&:before": {
          borderBottom: `${7}px solid #bbb`
        },
        "&:after": {
          borderBottom: `${7}px solid #f5f5f5`,
          top: "1px"
        }
      }
    },
    "&dark .cm-tooltip .cm-tooltip-arrow": {
      "&:before": {
        borderTopColor: "#333338",
        borderBottomColor: "#333338"
      },
      "&:after": {
        borderTopColor: "transparent",
        borderBottomColor: "transparent"
      }
    }
  });
  var noOffset = { x: 0, y: 0 };
  var showTooltip = /* @__PURE__ */ Facet.define({
    enables: [tooltipPlugin, baseTheme]
  });
  var showHoverTooltip = /* @__PURE__ */ Facet.define({
    combine: (inputs) => inputs.reduce((a2, i2) => a2.concat(i2), [])
  });
  var HoverTooltipHost = class _HoverTooltipHost {
    // Needs to be static so that host tooltip instances always match
    static create(view2) {
      return new _HoverTooltipHost(view2);
    }
    constructor(view2) {
      this.view = view2;
      this.mounted = false;
      this.dom = document.createElement("div");
      this.dom.classList.add("cm-tooltip-hover");
      this.manager = new TooltipViewManager(view2, showHoverTooltip, (t3, p2) => this.createHostedView(t3, p2), (t3) => t3.dom.remove());
    }
    createHostedView(tooltip, prev) {
      let hostedView = tooltip.create(this.view);
      hostedView.dom.classList.add("cm-tooltip-section");
      this.dom.insertBefore(hostedView.dom, prev ? prev.dom.nextSibling : this.dom.firstChild);
      if (this.mounted && hostedView.mount)
        hostedView.mount(this.view);
      return hostedView;
    }
    mount(view2) {
      for (let hostedView of this.manager.tooltipViews) {
        if (hostedView.mount)
          hostedView.mount(view2);
      }
      this.mounted = true;
    }
    positioned(space2) {
      for (let hostedView of this.manager.tooltipViews) {
        if (hostedView.positioned)
          hostedView.positioned(space2);
      }
    }
    update(update3) {
      this.manager.update(update3);
    }
    destroy() {
      var _a2;
      for (let t3 of this.manager.tooltipViews)
        (_a2 = t3.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t3);
    }
    passProp(name16) {
      let value12 = void 0;
      for (let view2 of this.manager.tooltipViews) {
        let given = view2[name16];
        if (given !== void 0) {
          if (value12 === void 0)
            value12 = given;
          else if (value12 !== given)
            return void 0;
        }
      }
      return value12;
    }
    get offset() {
      return this.passProp("offset");
    }
    get getCoords() {
      return this.passProp("getCoords");
    }
    get overlap() {
      return this.passProp("overlap");
    }
    get resize() {
      return this.passProp("resize");
    }
  };
  var showHoverTooltipHost = /* @__PURE__ */ showTooltip.compute([showHoverTooltip], (state4) => {
    let tooltips = state4.facet(showHoverTooltip);
    if (tooltips.length === 0)
      return null;
    return {
      pos: Math.min(...tooltips.map((t3) => t3.pos)),
      end: Math.max(...tooltips.map((t3) => {
        var _a2;
        return (_a2 = t3.end) !== null && _a2 !== void 0 ? _a2 : t3.pos;
      })),
      create: HoverTooltipHost.create,
      above: tooltips[0].above,
      arrow: tooltips.some((t3) => t3.arrow)
    };
  });
  var HoverPlugin = class {
    constructor(view2, source3, field, setHover, hoverTime) {
      this.view = view2;
      this.source = source3;
      this.field = field;
      this.setHover = setHover;
      this.hoverTime = hoverTime;
      this.hoverTimeout = -1;
      this.restartTimeout = -1;
      this.pending = null;
      this.lastMove = { x: 0, y: 0, target: view2.dom, time: 0 };
      this.checkHover = this.checkHover.bind(this);
      view2.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
      view2.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
    }
    update() {
      if (this.pending) {
        this.pending = null;
        clearTimeout(this.restartTimeout);
        this.restartTimeout = setTimeout(() => this.startHover(), 20);
      }
    }
    get active() {
      return this.view.state.field(this.field);
    }
    checkHover() {
      this.hoverTimeout = -1;
      if (this.active.length)
        return;
      let hovered = Date.now() - this.lastMove.time;
      if (hovered < this.hoverTime)
        this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
      else
        this.startHover();
    }
    startHover() {
      clearTimeout(this.restartTimeout);
      let { view: view2, lastMove } = this;
      let desc = view2.docView.nearest(lastMove.target);
      if (!desc)
        return;
      let pos, side = 1;
      if (desc instanceof WidgetView) {
        pos = desc.posAtStart;
      } else {
        pos = view2.posAtCoords(lastMove);
        if (pos == null)
          return;
        let posCoords = view2.coordsAtPos(pos);
        if (!posCoords || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - view2.defaultCharacterWidth || lastMove.x > posCoords.right + view2.defaultCharacterWidth)
          return;
        let bidi = view2.bidiSpans(view2.state.doc.lineAt(pos)).find((s2) => s2.from <= pos && s2.to >= pos);
        let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
        side = lastMove.x < posCoords.left ? -rtl : rtl;
      }
      let open = this.source(view2, pos, side);
      if (open === null || open === void 0 ? void 0 : open.then) {
        let pending = this.pending = { pos };
        open.then((result) => {
          if (this.pending == pending) {
            this.pending = null;
            if (result && !(Array.isArray(result) && !result.length))
              view2.dispatch({ effects: this.setHover.of(Array.isArray(result) ? result : [result]) });
          }
        }, (e2) => logException(view2.state, e2, "hover tooltip"));
      } else if (open && !(Array.isArray(open) && !open.length)) {
        view2.dispatch({ effects: this.setHover.of(Array.isArray(open) ? open : [open]) });
      }
    }
    get tooltip() {
      let plugin = this.view.plugin(tooltipPlugin);
      let index6 = plugin ? plugin.manager.tooltips.findIndex((t3) => t3.create == HoverTooltipHost.create) : -1;
      return index6 > -1 ? plugin.manager.tooltipViews[index6] : null;
    }
    mousemove(event) {
      var _a2, _b;
      this.lastMove = { x: event.clientX, y: event.clientY, target: event.target, time: Date.now() };
      if (this.hoverTimeout < 0)
        this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
      let { active, tooltip } = this;
      if (active.length && tooltip && !isInTooltip(tooltip.dom, event) || this.pending) {
        let { pos } = active[0] || this.pending, end = (_b = (_a2 = active[0]) === null || _a2 === void 0 ? void 0 : _a2.end) !== null && _b !== void 0 ? _b : pos;
        if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY)) {
          this.view.dispatch({ effects: this.setHover.of([]) });
          this.pending = null;
        }
      }
    }
    mouseleave(event) {
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = -1;
      let { active } = this;
      if (active.length) {
        let { tooltip } = this;
        let inTooltip = tooltip && tooltip.dom.contains(event.relatedTarget);
        if (!inTooltip)
          this.view.dispatch({ effects: this.setHover.of([]) });
        else
          this.watchTooltipLeave(tooltip.dom);
      }
    }
    watchTooltipLeave(tooltip) {
      let watch = (event) => {
        tooltip.removeEventListener("mouseleave", watch);
        if (this.active.length && !this.view.dom.contains(event.relatedTarget))
          this.view.dispatch({ effects: this.setHover.of([]) });
      };
      tooltip.addEventListener("mouseleave", watch);
    }
    destroy() {
      clearTimeout(this.hoverTimeout);
      this.view.dom.removeEventListener("mouseleave", this.mouseleave);
      this.view.dom.removeEventListener("mousemove", this.mousemove);
    }
  };
  var tooltipMargin = 4;
  function isInTooltip(tooltip, event) {
    let { left, right, top: top4, bottom: bottom3 } = tooltip.getBoundingClientRect(), arrow;
    if (arrow = tooltip.querySelector(".cm-tooltip-arrow")) {
      let arrowRect = arrow.getBoundingClientRect();
      top4 = Math.min(arrowRect.top, top4);
      bottom3 = Math.max(arrowRect.bottom, bottom3);
    }
    return event.clientX >= left - tooltipMargin && event.clientX <= right + tooltipMargin && event.clientY >= top4 - tooltipMargin && event.clientY <= bottom3 + tooltipMargin;
  }
  function isOverRange(view2, from3, to3, x2, y2, margin) {
    let rect = view2.scrollDOM.getBoundingClientRect();
    let docBottom = view2.documentTop + view2.documentPadding.top + view2.contentHeight;
    if (rect.left > x2 || rect.right < x2 || rect.top > y2 || Math.min(rect.bottom, docBottom) < y2)
      return false;
    let pos = view2.posAtCoords({ x: x2, y: y2 }, false);
    return pos >= from3 && pos <= to3;
  }
  function hoverTooltip(source3, options2 = {}) {
    let setHover = StateEffect.define();
    let hoverState = StateField.define({
      create() {
        return [];
      },
      update(value12, tr) {
        if (value12.length) {
          if (options2.hideOnChange && (tr.docChanged || tr.selection))
            value12 = [];
          else if (options2.hideOn)
            value12 = value12.filter((v2) => !options2.hideOn(tr, v2));
          if (tr.docChanged) {
            let mapped = [];
            for (let tooltip of value12) {
              let newPos = tr.changes.mapPos(tooltip.pos, -1, MapMode.TrackDel);
              if (newPos != null) {
                let copy = Object.assign(/* @__PURE__ */ Object.create(null), tooltip);
                copy.pos = newPos;
                if (copy.end != null)
                  copy.end = tr.changes.mapPos(copy.end);
                mapped.push(copy);
              }
            }
            value12 = mapped;
          }
        }
        for (let effect of tr.effects) {
          if (effect.is(setHover))
            value12 = effect.value;
          if (effect.is(closeHoverTooltipEffect))
            value12 = [];
        }
        return value12;
      },
      provide: (f2) => showHoverTooltip.from(f2)
    });
    return {
      active: hoverState,
      extension: [
        hoverState,
        ViewPlugin.define((view2) => new HoverPlugin(
          view2,
          source3,
          hoverState,
          setHover,
          options2.hoverTime || 300
          /* Hover.Time */
        )),
        showHoverTooltipHost
      ]
    };
  }
  function getTooltip(view2, tooltip) {
    let plugin = view2.plugin(tooltipPlugin);
    if (!plugin)
      return null;
    let found = plugin.manager.tooltips.indexOf(tooltip);
    return found < 0 ? null : plugin.manager.tooltipViews[found];
  }
  var closeHoverTooltipEffect = /* @__PURE__ */ StateEffect.define();
  var panelConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      let topContainer, bottomContainer;
      for (let c2 of configs) {
        topContainer = topContainer || c2.topContainer;
        bottomContainer = bottomContainer || c2.bottomContainer;
      }
      return { topContainer, bottomContainer };
    }
  });
  function getPanel(view2, panel) {
    let plugin = view2.plugin(panelPlugin);
    let index6 = plugin ? plugin.specs.indexOf(panel) : -1;
    return index6 > -1 ? plugin.panels[index6] : null;
  }
  var panelPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view2) {
      this.input = view2.state.facet(showPanel);
      this.specs = this.input.filter((s2) => s2);
      this.panels = this.specs.map((spec) => spec(view2));
      let conf = view2.state.facet(panelConfig);
      this.top = new PanelGroup(view2, true, conf.topContainer);
      this.bottom = new PanelGroup(view2, false, conf.bottomContainer);
      this.top.sync(this.panels.filter((p2) => p2.top));
      this.bottom.sync(this.panels.filter((p2) => !p2.top));
      for (let p2 of this.panels) {
        p2.dom.classList.add("cm-panel");
        if (p2.mount)
          p2.mount();
      }
    }
    update(update3) {
      let conf = update3.state.facet(panelConfig);
      if (this.top.container != conf.topContainer) {
        this.top.sync([]);
        this.top = new PanelGroup(update3.view, true, conf.topContainer);
      }
      if (this.bottom.container != conf.bottomContainer) {
        this.bottom.sync([]);
        this.bottom = new PanelGroup(update3.view, false, conf.bottomContainer);
      }
      this.top.syncClasses();
      this.bottom.syncClasses();
      let input = update3.state.facet(showPanel);
      if (input != this.input) {
        let specs = input.filter((x2) => x2);
        let panels = [], top4 = [], bottom3 = [], mount2 = [];
        for (let spec of specs) {
          let known = this.specs.indexOf(spec), panel;
          if (known < 0) {
            panel = spec(update3.view);
            mount2.push(panel);
          } else {
            panel = this.panels[known];
            if (panel.update)
              panel.update(update3);
          }
          panels.push(panel);
          (panel.top ? top4 : bottom3).push(panel);
        }
        this.specs = specs;
        this.panels = panels;
        this.top.sync(top4);
        this.bottom.sync(bottom3);
        for (let p2 of mount2) {
          p2.dom.classList.add("cm-panel");
          if (p2.mount)
            p2.mount();
        }
      } else {
        for (let p2 of this.panels)
          if (p2.update)
            p2.update(update3);
      }
    }
    destroy() {
      this.top.sync([]);
      this.bottom.sync([]);
    }
  }, {
    provide: (plugin) => EditorView.scrollMargins.of((view2) => {
      let value12 = view2.plugin(plugin);
      return value12 && { top: value12.top.scrollMargin(), bottom: value12.bottom.scrollMargin() };
    })
  });
  var PanelGroup = class {
    constructor(view2, top4, container) {
      this.view = view2;
      this.top = top4;
      this.container = container;
      this.dom = void 0;
      this.classes = "";
      this.panels = [];
      this.syncClasses();
    }
    sync(panels) {
      for (let p2 of this.panels)
        if (p2.destroy && panels.indexOf(p2) < 0)
          p2.destroy();
      this.panels = panels;
      this.syncDOM();
    }
    syncDOM() {
      if (this.panels.length == 0) {
        if (this.dom) {
          this.dom.remove();
          this.dom = void 0;
        }
        return;
      }
      if (!this.dom) {
        this.dom = document.createElement("div");
        this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
        this.dom.style[this.top ? "top" : "bottom"] = "0";
        let parent2 = this.container || this.view.dom;
        parent2.insertBefore(this.dom, this.top ? parent2.firstChild : null);
      }
      let curDOM = this.dom.firstChild;
      for (let panel of this.panels) {
        if (panel.dom.parentNode == this.dom) {
          while (curDOM != panel.dom)
            curDOM = rm(curDOM);
          curDOM = curDOM.nextSibling;
        } else {
          this.dom.insertBefore(panel.dom, curDOM);
        }
      }
      while (curDOM)
        curDOM = rm(curDOM);
    }
    scrollMargin() {
      return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
    }
    syncClasses() {
      if (!this.container || this.classes == this.view.themeClasses)
        return;
      for (let cls of this.classes.split(" "))
        if (cls)
          this.container.classList.remove(cls);
      for (let cls of (this.classes = this.view.themeClasses).split(" "))
        if (cls)
          this.container.classList.add(cls);
    }
  };
  function rm(node) {
    let next = node.nextSibling;
    node.remove();
    return next;
  }
  var showPanel = /* @__PURE__ */ Facet.define({
    enables: panelPlugin
  });
  var GutterMarker = class extends RangeValue {
    /**
    @internal
    */
    compare(other) {
      return this == other || this.constructor == other.constructor && this.eq(other);
    }
    /**
    Compare this marker to another marker of the same type.
    */
    eq(other) {
      return false;
    }
    /**
    Called if the marker has a `toDOM` method and its representation
    was removed from a gutter.
    */
    destroy(dom) {
    }
  };
  GutterMarker.prototype.elementClass = "";
  GutterMarker.prototype.toDOM = void 0;
  GutterMarker.prototype.mapMode = MapMode.TrackBefore;
  GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
  GutterMarker.prototype.point = true;
  var gutterLineClass = /* @__PURE__ */ Facet.define();
  var gutterWidgetClass = /* @__PURE__ */ Facet.define();
  var defaults = {
    class: "",
    renderEmptyElements: false,
    elementStyle: "",
    markers: () => RangeSet.empty,
    lineMarker: () => null,
    widgetMarker: () => null,
    lineMarkerChange: null,
    initialSpacer: null,
    updateSpacer: null,
    domEventHandlers: {}
  };
  var activeGutters = /* @__PURE__ */ Facet.define();
  function gutter(config2) {
    return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config2))];
  }
  var unfixGutters = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((x2) => x2)
  });
  function gutters(config2) {
    let result = [
      gutterView
    ];
    if (config2 && config2.fixed === false)
      result.push(unfixGutters.of(true));
    return result;
  }
  var gutterView = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view2) {
      this.view = view2;
      this.prevViewport = view2.viewport;
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutters";
      this.dom.setAttribute("aria-hidden", "true");
      this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
      this.gutters = view2.state.facet(activeGutters).map((conf) => new SingleGutterView(view2, conf));
      for (let gutter2 of this.gutters)
        this.dom.appendChild(gutter2.dom);
      this.fixed = !view2.state.facet(unfixGutters);
      if (this.fixed) {
        this.dom.style.position = "sticky";
      }
      this.syncGutters(false);
      view2.scrollDOM.insertBefore(this.dom, view2.contentDOM);
    }
    update(update3) {
      if (this.updateGutters(update3)) {
        let vpA = this.prevViewport, vpB = update3.view.viewport;
        let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
        this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
      }
      if (update3.geometryChanged) {
        this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
      }
      if (this.view.state.facet(unfixGutters) != !this.fixed) {
        this.fixed = !this.fixed;
        this.dom.style.position = this.fixed ? "sticky" : "";
      }
      this.prevViewport = update3.view.viewport;
    }
    syncGutters(detach) {
      let after = this.dom.nextSibling;
      if (detach)
        this.dom.remove();
      let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
      let classSet = [];
      let contexts = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport, -this.view.documentPadding.top));
      for (let line of this.view.viewportLineBlocks) {
        if (classSet.length)
          classSet = [];
        if (Array.isArray(line.type)) {
          let first = true;
          for (let b2 of line.type) {
            if (b2.type == BlockType.Text && first) {
              advanceCursor(lineClasses, classSet, b2.from);
              for (let cx of contexts)
                cx.line(this.view, b2, classSet);
              first = false;
            } else if (b2.widget) {
              for (let cx of contexts)
                cx.widget(this.view, b2);
            }
          }
        } else if (line.type == BlockType.Text) {
          advanceCursor(lineClasses, classSet, line.from);
          for (let cx of contexts)
            cx.line(this.view, line, classSet);
        } else if (line.widget) {
          for (let cx of contexts)
            cx.widget(this.view, line);
        }
      }
      for (let cx of contexts)
        cx.finish();
      if (detach)
        this.view.scrollDOM.insertBefore(this.dom, after);
    }
    updateGutters(update3) {
      let prev = update3.startState.facet(activeGutters), cur2 = update3.state.facet(activeGutters);
      let change = update3.docChanged || update3.heightChanged || update3.viewportChanged || !RangeSet.eq(update3.startState.facet(gutterLineClass), update3.state.facet(gutterLineClass), update3.view.viewport.from, update3.view.viewport.to);
      if (prev == cur2) {
        for (let gutter2 of this.gutters)
          if (gutter2.update(update3))
            change = true;
      } else {
        change = true;
        let gutters2 = [];
        for (let conf of cur2) {
          let known = prev.indexOf(conf);
          if (known < 0) {
            gutters2.push(new SingleGutterView(this.view, conf));
          } else {
            this.gutters[known].update(update3);
            gutters2.push(this.gutters[known]);
          }
        }
        for (let g2 of this.gutters) {
          g2.dom.remove();
          if (gutters2.indexOf(g2) < 0)
            g2.destroy();
        }
        for (let g2 of gutters2)
          this.dom.appendChild(g2.dom);
        this.gutters = gutters2;
      }
      return change;
    }
    destroy() {
      for (let view2 of this.gutters)
        view2.destroy();
      this.dom.remove();
    }
  }, {
    provide: (plugin) => EditorView.scrollMargins.of((view2) => {
      let value12 = view2.plugin(plugin);
      if (!value12 || value12.gutters.length == 0 || !value12.fixed)
        return null;
      return view2.textDirection == Direction.LTR ? { left: value12.dom.offsetWidth * view2.scaleX } : { right: value12.dom.offsetWidth * view2.scaleX };
    })
  });
  function asArray2(val) {
    return Array.isArray(val) ? val : [val];
  }
  function advanceCursor(cursor, collect2, pos) {
    while (cursor.value && cursor.from <= pos) {
      if (cursor.from == pos)
        collect2.push(cursor.value);
      cursor.next();
    }
  }
  var UpdateContext = class {
    constructor(gutter2, viewport, height8) {
      this.gutter = gutter2;
      this.height = height8;
      this.i = 0;
      this.cursor = RangeSet.iter(gutter2.markers, viewport.from);
    }
    addElement(view2, block, markers) {
      let { gutter: gutter2 } = this, above = (block.top - this.height) / view2.scaleY, height8 = block.height / view2.scaleY;
      if (this.i == gutter2.elements.length) {
        let newElt = new GutterElement(view2, height8, above, markers);
        gutter2.elements.push(newElt);
        gutter2.dom.appendChild(newElt.dom);
      } else {
        gutter2.elements[this.i].update(view2, height8, above, markers);
      }
      this.height = block.bottom;
      this.i++;
    }
    line(view2, line, extraMarkers) {
      let localMarkers = [];
      advanceCursor(this.cursor, localMarkers, line.from);
      if (extraMarkers.length)
        localMarkers = localMarkers.concat(extraMarkers);
      let forLine = this.gutter.config.lineMarker(view2, line, localMarkers);
      if (forLine)
        localMarkers.unshift(forLine);
      let gutter2 = this.gutter;
      if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements)
        return;
      this.addElement(view2, line, localMarkers);
    }
    widget(view2, block) {
      let marker = this.gutter.config.widgetMarker(view2, block.widget, block), markers = marker ? [marker] : null;
      for (let cls of view2.state.facet(gutterWidgetClass)) {
        let marker2 = cls(view2, block.widget, block);
        if (marker2)
          (markers || (markers = [])).push(marker2);
      }
      if (markers)
        this.addElement(view2, block, markers);
    }
    finish() {
      let gutter2 = this.gutter;
      while (gutter2.elements.length > this.i) {
        let last4 = gutter2.elements.pop();
        gutter2.dom.removeChild(last4.dom);
        last4.destroy();
      }
    }
  };
  var SingleGutterView = class {
    constructor(view2, config2) {
      this.view = view2;
      this.config = config2;
      this.elements = [];
      this.spacer = null;
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
      for (let prop in config2.domEventHandlers) {
        this.dom.addEventListener(prop, (event) => {
          let target5 = event.target, y2;
          if (target5 != this.dom && this.dom.contains(target5)) {
            while (target5.parentNode != this.dom)
              target5 = target5.parentNode;
            let rect = target5.getBoundingClientRect();
            y2 = (rect.top + rect.bottom) / 2;
          } else {
            y2 = event.clientY;
          }
          let line = view2.lineBlockAtHeight(y2 - view2.documentTop);
          if (config2.domEventHandlers[prop](view2, line, event))
            event.preventDefault();
        });
      }
      this.markers = asArray2(config2.markers(view2));
      if (config2.initialSpacer) {
        this.spacer = new GutterElement(view2, 0, 0, [config2.initialSpacer(view2)]);
        this.dom.appendChild(this.spacer.dom);
        this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
      }
    }
    update(update3) {
      let prevMarkers = this.markers;
      this.markers = asArray2(this.config.markers(update3.view));
      if (this.spacer && this.config.updateSpacer) {
        let updated = this.config.updateSpacer(this.spacer.markers[0], update3);
        if (updated != this.spacer.markers[0])
          this.spacer.update(update3.view, 0, 0, [updated]);
      }
      let vp = update3.view.viewport;
      return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update3) : false);
    }
    destroy() {
      for (let elt of this.elements)
        elt.destroy();
    }
  };
  var GutterElement = class {
    constructor(view2, height8, above, markers) {
      this.height = -1;
      this.above = 0;
      this.markers = [];
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutterElement";
      this.update(view2, height8, above, markers);
    }
    update(view2, height8, above, markers) {
      if (this.height != height8) {
        this.height = height8;
        this.dom.style.height = height8 + "px";
      }
      if (this.above != above)
        this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
      if (!sameMarkers(this.markers, markers))
        this.setMarkers(view2, markers);
    }
    setMarkers(view2, markers) {
      let cls = "cm-gutterElement", domPos = this.dom.firstChild;
      for (let iNew = 0, iOld = 0; ; ) {
        let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
        if (marker) {
          let c2 = marker.elementClass;
          if (c2)
            cls += " " + c2;
          for (let i2 = iOld; i2 < this.markers.length; i2++)
            if (this.markers[i2].compare(marker)) {
              skipTo = i2;
              matched = true;
              break;
            }
        } else {
          skipTo = this.markers.length;
        }
        while (iOld < skipTo) {
          let next = this.markers[iOld++];
          if (next.toDOM) {
            next.destroy(domPos);
            let after = domPos.nextSibling;
            domPos.remove();
            domPos = after;
          }
        }
        if (!marker)
          break;
        if (marker.toDOM) {
          if (matched)
            domPos = domPos.nextSibling;
          else
            this.dom.insertBefore(marker.toDOM(view2), domPos);
        }
        if (matched)
          iOld++;
      }
      this.dom.className = cls;
      this.markers = markers;
    }
    destroy() {
      this.setMarkers(null, []);
    }
  };
  function sameMarkers(a2, b2) {
    if (a2.length != b2.length)
      return false;
    for (let i2 = 0; i2 < a2.length; i2++)
      if (!a2[i2].compare(b2[i2]))
        return false;
    return true;
  }
  var lineNumberMarkers = /* @__PURE__ */ Facet.define();
  var lineNumberWidgetMarker = /* @__PURE__ */ Facet.define();
  var lineNumberConfig = /* @__PURE__ */ Facet.define({
    combine(values) {
      return combineConfig(values, { formatNumber: String, domEventHandlers: {} }, {
        domEventHandlers(a2, b2) {
          let result = Object.assign({}, a2);
          for (let event in b2) {
            let exists = result[event], add5 = b2[event];
            result[event] = exists ? (view2, line, event2) => exists(view2, line, event2) || add5(view2, line, event2) : add5;
          }
          return result;
        }
      });
    }
  });
  var NumberMarker = class extends GutterMarker {
    constructor(number2) {
      super();
      this.number = number2;
    }
    eq(other) {
      return this.number == other.number;
    }
    toDOM() {
      return document.createTextNode(this.number);
    }
  };
  function formatNumber(view2, number2) {
    return view2.state.facet(lineNumberConfig).formatNumber(number2, view2.state);
  }
  var lineNumberGutter = /* @__PURE__ */ activeGutters.compute([lineNumberConfig], (state4) => ({
    class: "cm-lineNumbers",
    renderEmptyElements: false,
    markers(view2) {
      return view2.state.facet(lineNumberMarkers);
    },
    lineMarker(view2, line, others) {
      if (others.some((m2) => m2.toDOM))
        return null;
      return new NumberMarker(formatNumber(view2, view2.state.doc.lineAt(line.from).number));
    },
    widgetMarker: (view2, widget, block) => {
      for (let m2 of view2.state.facet(lineNumberWidgetMarker)) {
        let result = m2(view2, widget, block);
        if (result)
          return result;
      }
      return null;
    },
    lineMarkerChange: (update3) => update3.startState.facet(lineNumberConfig) != update3.state.facet(lineNumberConfig),
    initialSpacer(view2) {
      return new NumberMarker(formatNumber(view2, maxLineNumber(view2.state.doc.lines)));
    },
    updateSpacer(spacer, update3) {
      let max7 = formatNumber(update3.view, maxLineNumber(update3.view.state.doc.lines));
      return max7 == spacer.number ? spacer : new NumberMarker(max7);
    },
    domEventHandlers: state4.facet(lineNumberConfig).domEventHandlers
  }));
  function lineNumbers(config2 = {}) {
    return [
      lineNumberConfig.of(config2),
      gutters(),
      lineNumberGutter
    ];
  }
  function maxLineNumber(lines) {
    let last4 = 9;
    while (last4 < lines)
      last4 = last4 * 10 + 9;
    return last4;
  }
  var activeLineGutterMarker = /* @__PURE__ */ new class extends GutterMarker {
    constructor() {
      super(...arguments);
      this.elementClass = "cm-activeLineGutter";
    }
  }();
  var activeLineGutterHighlighter = /* @__PURE__ */ gutterLineClass.compute(["selection"], (state4) => {
    let marks2 = [], last4 = -1;
    for (let range3 of state4.selection.ranges) {
      let linePos = state4.doc.lineAt(range3.head).from;
      if (linePos > last4) {
        last4 = linePos;
        marks2.push(activeLineGutterMarker.range(linePos));
      }
    }
    return RangeSet.of(marks2);
  });
  function highlightActiveLineGutter() {
    return activeLineGutterHighlighter;
  }

  // node_modules/@lezer/common/dist/index.js
  var DefaultBufferLength = 1024;
  var nextPropID = 0;
  var Range2 = class {
    constructor(from3, to3) {
      this.from = from3;
      this.to = to3;
    }
  };
  var NodeProp = class {
    /**
    Create a new node prop type.
    */
    constructor(config2 = {}) {
      this.id = nextPropID++;
      this.perNode = !!config2.perNode;
      this.deserialize = config2.deserialize || (() => {
        throw new Error("This node type doesn't define a deserialize function");
      });
    }
    /**
    This is meant to be used with
    [`NodeSet.extend`](#common.NodeSet.extend) or
    [`LRParser.configure`](#lr.ParserConfig.props) to compute
    prop values for each node type in the set. Takes a [match
    object](#common.NodeType^match) or function that returns undefined
    if the node type doesn't get this prop, and the prop's value if
    it does.
    */
    add(match2) {
      if (this.perNode)
        throw new RangeError("Can't add per-node props to node types");
      if (typeof match2 != "function")
        match2 = NodeType.match(match2);
      return (type) => {
        let result = match2(type);
        return result === void 0 ? null : [this, result];
      };
    }
  };
  NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.isolate = new NodeProp({ deserialize: (value12) => {
    if (value12 && value12 != "rtl" && value12 != "ltr" && value12 != "auto")
      throw new RangeError("Invalid value for isolate: " + value12);
    return value12 || "auto";
  } });
  NodeProp.contextHash = new NodeProp({ perNode: true });
  NodeProp.lookAhead = new NodeProp({ perNode: true });
  NodeProp.mounted = new NodeProp({ perNode: true });
  var MountedTree = class {
    constructor(tree, overlay, parser2) {
      this.tree = tree;
      this.overlay = overlay;
      this.parser = parser2;
    }
    /**
    @internal
    */
    static get(tree) {
      return tree && tree.props && tree.props[NodeProp.mounted.id];
    }
  };
  var noProps = /* @__PURE__ */ Object.create(null);
  var NodeType = class _NodeType {
    /**
    @internal
    */
    constructor(name16, props, id5, flags = 0) {
      this.name = name16;
      this.props = props;
      this.id = id5;
      this.flags = flags;
    }
    /**
    Define a node type.
    */
    static define(spec) {
      let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
      let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
      let type = new _NodeType(spec.name || "", props, spec.id, flags);
      if (spec.props)
        for (let src9 of spec.props) {
          if (!Array.isArray(src9))
            src9 = src9(type);
          if (src9) {
            if (src9[0].perNode)
              throw new RangeError("Can't store a per-node prop on a node type");
            props[src9[0].id] = src9[1];
          }
        }
      return type;
    }
    /**
    Retrieves a node prop for this type. Will return `undefined` if
    the prop isn't present on this node.
    */
    prop(prop) {
      return this.props[prop.id];
    }
    /**
    True when this is the top node of a grammar.
    */
    get isTop() {
      return (this.flags & 1) > 0;
    }
    /**
    True when this node is produced by a skip rule.
    */
    get isSkipped() {
      return (this.flags & 2) > 0;
    }
    /**
    Indicates whether this is an error node.
    */
    get isError() {
      return (this.flags & 4) > 0;
    }
    /**
    When true, this node type doesn't correspond to a user-declared
    named node, for example because it is used to cache repetition.
    */
    get isAnonymous() {
      return (this.flags & 8) > 0;
    }
    /**
    Returns true when this node's name or one of its
    [groups](#common.NodeProp^group) matches the given string.
    */
    is(name16) {
      if (typeof name16 == "string") {
        if (this.name == name16)
          return true;
        let group4 = this.prop(NodeProp.group);
        return group4 ? group4.indexOf(name16) > -1 : false;
      }
      return this.id == name16;
    }
    /**
    Create a function from node types to arbitrary values by
    specifying an object whose property names are node or
    [group](#common.NodeProp^group) names. Often useful with
    [`NodeProp.add`](#common.NodeProp.add). You can put multiple
    names, separated by spaces, in a single property name to map
    multiple node names to a single value.
    */
    static match(map27) {
      let direct = /* @__PURE__ */ Object.create(null);
      for (let prop in map27)
        for (let name16 of prop.split(" "))
          direct[name16] = map27[prop];
      return (node) => {
        for (let groups = node.prop(NodeProp.group), i2 = -1; i2 < (groups ? groups.length : 0); i2++) {
          let found = direct[i2 < 0 ? node.name : groups[i2]];
          if (found)
            return found;
        }
      };
    }
  };
  NodeType.none = new NodeType(
    "",
    /* @__PURE__ */ Object.create(null),
    0,
    8
    /* NodeFlag.Anonymous */
  );
  var NodeSet = class _NodeSet {
    /**
    Create a set with the given types. The `id` property of each
    type should correspond to its position within the array.
    */
    constructor(types2) {
      this.types = types2;
      for (let i2 = 0; i2 < types2.length; i2++)
        if (types2[i2].id != i2)
          throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    /**
    Create a copy of this set with some node properties added. The
    arguments to this method can be created with
    [`NodeProp.add`](#common.NodeProp.add).
    */
    extend(...props) {
      let newTypes = [];
      for (let type of this.types) {
        let newProps = null;
        for (let source3 of props) {
          let add5 = source3(type);
          if (add5) {
            if (!newProps)
              newProps = Object.assign({}, type.props);
            newProps[add5[0].id] = add5[1];
          }
        }
        newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
      }
      return new _NodeSet(newTypes);
    }
  };
  var CachedNode = /* @__PURE__ */ new WeakMap();
  var CachedInnerNode = /* @__PURE__ */ new WeakMap();
  var IterMode;
  (function(IterMode2) {
    IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
    IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
    IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
    IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
  })(IterMode || (IterMode = {}));
  var Tree = class _Tree {
    /**
    Construct a new tree. See also [`Tree.build`](#common.Tree^build).
    */
    constructor(type, children2, positions, length9, props) {
      this.type = type;
      this.children = children2;
      this.positions = positions;
      this.length = length9;
      this.props = null;
      if (props && props.length) {
        this.props = /* @__PURE__ */ Object.create(null);
        for (let [prop, value12] of props)
          this.props[typeof prop == "number" ? prop : prop.id] = value12;
      }
    }
    /**
    @internal
    */
    toString() {
      let mounted = MountedTree.get(this);
      if (mounted && !mounted.overlay)
        return mounted.tree.toString();
      let children2 = "";
      for (let ch of this.children) {
        let str = ch.toString();
        if (str) {
          if (children2)
            children2 += ",";
          children2 += str;
        }
      }
      return !this.type.name ? children2 : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children2.length ? "(" + children2 + ")" : "");
    }
    /**
    Get a [tree cursor](#common.TreeCursor) positioned at the top of
    the tree. Mode can be used to [control](#common.IterMode) which
    nodes the cursor visits.
    */
    cursor(mode = 0) {
      return new TreeCursor(this.topNode, mode);
    }
    /**
    Get a [tree cursor](#common.TreeCursor) pointing into this tree
    at the given position and side (see
    [`moveTo`](#common.TreeCursor.moveTo).
    */
    cursorAt(pos, side = 0, mode = 0) {
      let scope2 = CachedNode.get(this) || this.topNode;
      let cursor = new TreeCursor(scope2);
      cursor.moveTo(pos, side);
      CachedNode.set(this, cursor._tree);
      return cursor;
    }
    /**
    Get a [syntax node](#common.SyntaxNode) object for the top of the
    tree.
    */
    get topNode() {
      return new TreeNode(this, 0, 0, null);
    }
    /**
    Get the [syntax node](#common.SyntaxNode) at the given position.
    If `side` is -1, this will move into nodes that end at the
    position. If 1, it'll move into nodes that start at the
    position. With 0, it'll only enter nodes that cover the position
    from both sides.
    
    Note that this will not enter
    [overlays](#common.MountedTree.overlay), and you often want
    [`resolveInner`](#common.Tree.resolveInner) instead.
    */
    resolve(pos, side = 0) {
      let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
      CachedNode.set(this, node);
      return node;
    }
    /**
    Like [`resolve`](#common.Tree.resolve), but will enter
    [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
    pointing into the innermost overlaid tree at the given position
    (with parent links going through all parent structure, including
    the host trees).
    */
    resolveInner(pos, side = 0) {
      let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
      CachedInnerNode.set(this, node);
      return node;
    }
    /**
    In some situations, it can be useful to iterate through all
    nodes around a position, including those in overlays that don't
    directly cover the position. This method gives you an iterator
    that will produce all nodes, from small to big, around the given
    position.
    */
    resolveStack(pos, side = 0) {
      return stackIterator(this, pos, side);
    }
    /**
    Iterate over the tree and its children, calling `enter` for any
    node that touches the `from`/`to` region (if given) before
    running over such a node's children, and `leave` (if given) when
    leaving the node. When `enter` returns `false`, that node will
    not have its children iterated over (or `leave` called).
    */
    iterate(spec) {
      let { enter, leave, from: from3 = 0, to: to3 = this.length } = spec;
      let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;
      for (let c2 = this.cursor(mode | IterMode.IncludeAnonymous); ; ) {
        let entered = false;
        if (c2.from <= to3 && c2.to >= from3 && (!anon && c2.type.isAnonymous || enter(c2) !== false)) {
          if (c2.firstChild())
            continue;
          entered = true;
        }
        for (; ; ) {
          if (entered && leave && (anon || !c2.type.isAnonymous))
            leave(c2);
          if (c2.nextSibling())
            break;
          if (!c2.parent())
            return;
          entered = true;
        }
      }
    }
    /**
    Get the value of the given [node prop](#common.NodeProp) for this
    node. Works with both per-node and per-type props.
    */
    prop(prop) {
      return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
    }
    /**
    Returns the node's [per-node props](#common.NodeProp.perNode) in a
    format that can be passed to the [`Tree`](#common.Tree)
    constructor.
    */
    get propValues() {
      let result = [];
      if (this.props)
        for (let id5 in this.props)
          result.push([+id5, this.props[id5]]);
      return result;
    }
    /**
    Balance the direct children of this tree, producing a copy of
    which may have children grouped into subtrees with type
    [`NodeType.none`](#common.NodeType^none).
    */
    balance(config2 = {}) {
      return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children2, positions, length9) => new _Tree(this.type, children2, positions, length9, this.propValues), config2.makeTree || ((children2, positions, length9) => new _Tree(NodeType.none, children2, positions, length9)));
    }
    /**
    Build a tree from a postfix-ordered buffer of node information,
    or a cursor over such a buffer.
    */
    static build(data) {
      return buildTree(data);
    }
  };
  Tree.empty = new Tree(NodeType.none, [], [], 0);
  var FlatBufferCursor = class _FlatBufferCursor {
    constructor(buffer, index6) {
      this.buffer = buffer;
      this.index = index6;
    }
    get id() {
      return this.buffer[this.index - 4];
    }
    get start() {
      return this.buffer[this.index - 3];
    }
    get end() {
      return this.buffer[this.index - 2];
    }
    get size() {
      return this.buffer[this.index - 1];
    }
    get pos() {
      return this.index;
    }
    next() {
      this.index -= 4;
    }
    fork() {
      return new _FlatBufferCursor(this.buffer, this.index);
    }
  };
  var TreeBuffer = class _TreeBuffer {
    /**
    Create a tree buffer.
    */
    constructor(buffer, length9, set) {
      this.buffer = buffer;
      this.length = length9;
      this.set = set;
    }
    /**
    @internal
    */
    get type() {
      return NodeType.none;
    }
    /**
    @internal
    */
    toString() {
      let result = [];
      for (let index6 = 0; index6 < this.buffer.length; ) {
        result.push(this.childString(index6));
        index6 = this.buffer[index6 + 3];
      }
      return result.join(",");
    }
    /**
    @internal
    */
    childString(index6) {
      let id5 = this.buffer[index6], endIndex = this.buffer[index6 + 3];
      let type = this.set.types[id5], result = type.name;
      if (/\W/.test(result) && !type.isError)
        result = JSON.stringify(result);
      index6 += 4;
      if (endIndex == index6)
        return result;
      let children2 = [];
      while (index6 < endIndex) {
        children2.push(this.childString(index6));
        index6 = this.buffer[index6 + 3];
      }
      return result + "(" + children2.join(",") + ")";
    }
    /**
    @internal
    */
    findChild(startIndex, endIndex, dir2, pos, side) {
      let { buffer } = this, pick = -1;
      for (let i2 = startIndex; i2 != endIndex; i2 = buffer[i2 + 3]) {
        if (checkSide(side, pos, buffer[i2 + 1], buffer[i2 + 2])) {
          pick = i2;
          if (dir2 > 0)
            break;
        }
      }
      return pick;
    }
    /**
    @internal
    */
    slice(startI, endI, from3) {
      let b2 = this.buffer;
      let copy = new Uint16Array(endI - startI), len = 0;
      for (let i2 = startI, j2 = 0; i2 < endI; ) {
        copy[j2++] = b2[i2++];
        copy[j2++] = b2[i2++] - from3;
        let to3 = copy[j2++] = b2[i2++] - from3;
        copy[j2++] = b2[i2++] - startI;
        len = Math.max(len, to3);
      }
      return new _TreeBuffer(copy, len, this.set);
    }
  };
  function checkSide(side, pos, from3, to3) {
    switch (side) {
      case -2:
        return from3 < pos;
      case -1:
        return to3 >= pos && from3 < pos;
      case 0:
        return from3 < pos && to3 > pos;
      case 1:
        return from3 <= pos && to3 > pos;
      case 2:
        return to3 > pos;
      case 4:
        return true;
    }
  }
  function resolveNode(node, pos, side, overlays) {
    var _a2;
    while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
      let parent2 = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
      if (!parent2)
        return node;
      node = parent2;
    }
    let mode = overlays ? 0 : IterMode.IgnoreOverlays;
    if (overlays)
      for (let scan = node, parent2 = scan.parent; parent2; scan = parent2, parent2 = scan.parent) {
        if (scan instanceof TreeNode && scan.index < 0 && ((_a2 = parent2.enter(pos, side, mode)) === null || _a2 === void 0 ? void 0 : _a2.from) != scan.from)
          node = parent2;
      }
    for (; ; ) {
      let inner = node.enter(pos, side, mode);
      if (!inner)
        return node;
      node = inner;
    }
  }
  var BaseNode = class {
    cursor(mode = 0) {
      return new TreeCursor(this, mode);
    }
    getChild(type, before = null, after = null) {
      let r2 = getChildren(this, type, before, after);
      return r2.length ? r2[0] : null;
    }
    getChildren(type, before = null, after = null) {
      return getChildren(this, type, before, after);
    }
    resolve(pos, side = 0) {
      return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
      return resolveNode(this, pos, side, true);
    }
    matchContext(context3) {
      return matchNodeContext(this.parent, context3);
    }
    enterUnfinishedNodesBefore(pos) {
      let scan = this.childBefore(pos), node = this;
      while (scan) {
        let last4 = scan.lastChild;
        if (!last4 || last4.to != scan.to)
          break;
        if (last4.type.isError && last4.from == last4.to) {
          node = scan;
          scan = last4.prevSibling;
        } else {
          scan = last4;
        }
      }
      return node;
    }
    get node() {
      return this;
    }
    get next() {
      return this.parent;
    }
  };
  var TreeNode = class _TreeNode extends BaseNode {
    constructor(_tree, from3, index6, _parent) {
      super();
      this._tree = _tree;
      this.from = from3;
      this.index = index6;
      this._parent = _parent;
    }
    get type() {
      return this._tree.type;
    }
    get name() {
      return this._tree.type.name;
    }
    get to() {
      return this.from + this._tree.length;
    }
    nextChild(i2, dir2, pos, side, mode = 0) {
      for (let parent2 = this; ; ) {
        for (let { children: children2, positions } = parent2._tree, e2 = dir2 > 0 ? children2.length : -1; i2 != e2; i2 += dir2) {
          let next = children2[i2], start3 = positions[i2] + parent2.from;
          if (!checkSide(side, pos, start3, start3 + next.length))
            continue;
          if (next instanceof TreeBuffer) {
            if (mode & IterMode.ExcludeBuffers)
              continue;
            let index6 = next.findChild(0, next.buffer.length, dir2, pos - start3, side);
            if (index6 > -1)
              return new BufferNode(new BufferContext(parent2, next, i2, start3), null, index6);
          } else if (mode & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
            let mounted;
            if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay)
              return new _TreeNode(mounted.tree, start3, i2, parent2);
            let inner = new _TreeNode(next, start3, i2, parent2);
            return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir2 < 0 ? next.children.length - 1 : 0, dir2, pos, side);
          }
        }
        if (mode & IterMode.IncludeAnonymous || !parent2.type.isAnonymous)
          return null;
        if (parent2.index >= 0)
          i2 = parent2.index + dir2;
        else
          i2 = dir2 < 0 ? -1 : parent2._parent._tree.children.length;
        parent2 = parent2._parent;
        if (!parent2)
          return null;
      }
    }
    get firstChild() {
      return this.nextChild(
        0,
        1,
        0,
        4
        /* Side.DontCare */
      );
    }
    get lastChild() {
      return this.nextChild(
        this._tree.children.length - 1,
        -1,
        0,
        4
        /* Side.DontCare */
      );
    }
    childAfter(pos) {
      return this.nextChild(
        0,
        1,
        pos,
        2
        /* Side.After */
      );
    }
    childBefore(pos) {
      return this.nextChild(
        this._tree.children.length - 1,
        -1,
        pos,
        -2
        /* Side.Before */
      );
    }
    enter(pos, side, mode = 0) {
      let mounted;
      if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
        let rPos = pos - this.from;
        for (let { from: from3, to: to3 } of mounted.overlay) {
          if ((side > 0 ? from3 <= rPos : from3 < rPos) && (side < 0 ? to3 >= rPos : to3 > rPos))
            return new _TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
        }
      }
      return this.nextChild(0, 1, pos, side, mode);
    }
    nextSignificantParent() {
      let val = this;
      while (val.type.isAnonymous && val._parent)
        val = val._parent;
      return val;
    }
    get parent() {
      return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(
        this.index + 1,
        1,
        0,
        4
        /* Side.DontCare */
      ) : null;
    }
    get prevSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(
        this.index - 1,
        -1,
        0,
        4
        /* Side.DontCare */
      ) : null;
    }
    get tree() {
      return this._tree;
    }
    toTree() {
      return this._tree;
    }
    /**
    @internal
    */
    toString() {
      return this._tree.toString();
    }
  };
  function getChildren(node, type, before, after) {
    let cur2 = node.cursor(), result = [];
    if (!cur2.firstChild())
      return result;
    if (before != null)
      for (let found = false; !found; ) {
        found = cur2.type.is(before);
        if (!cur2.nextSibling())
          return result;
      }
    for (; ; ) {
      if (after != null && cur2.type.is(after))
        return result;
      if (cur2.type.is(type))
        result.push(cur2.node);
      if (!cur2.nextSibling())
        return after == null ? result : [];
    }
  }
  function matchNodeContext(node, context3, i2 = context3.length - 1) {
    for (let p2 = node; i2 >= 0; p2 = p2.parent) {
      if (!p2)
        return false;
      if (!p2.type.isAnonymous) {
        if (context3[i2] && context3[i2] != p2.name)
          return false;
        i2--;
      }
    }
    return true;
  }
  var BufferContext = class {
    constructor(parent2, buffer, index6, start3) {
      this.parent = parent2;
      this.buffer = buffer;
      this.index = index6;
      this.start = start3;
    }
  };
  var BufferNode = class _BufferNode extends BaseNode {
    get name() {
      return this.type.name;
    }
    get from() {
      return this.context.start + this.context.buffer.buffer[this.index + 1];
    }
    get to() {
      return this.context.start + this.context.buffer.buffer[this.index + 2];
    }
    constructor(context3, _parent, index6) {
      super();
      this.context = context3;
      this._parent = _parent;
      this.index = index6;
      this.type = context3.buffer.set.types[context3.buffer.buffer[index6]];
    }
    child(dir2, pos, side) {
      let { buffer } = this.context;
      let index6 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir2, pos - this.context.start, side);
      return index6 < 0 ? null : new _BufferNode(this.context, this, index6);
    }
    get firstChild() {
      return this.child(
        1,
        0,
        4
        /* Side.DontCare */
      );
    }
    get lastChild() {
      return this.child(
        -1,
        0,
        4
        /* Side.DontCare */
      );
    }
    childAfter(pos) {
      return this.child(
        1,
        pos,
        2
        /* Side.After */
      );
    }
    childBefore(pos) {
      return this.child(
        -1,
        pos,
        -2
        /* Side.Before */
      );
    }
    enter(pos, side, mode = 0) {
      if (mode & IterMode.ExcludeBuffers)
        return null;
      let { buffer } = this.context;
      let index6 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
      return index6 < 0 ? null : new _BufferNode(this.context, this, index6);
    }
    get parent() {
      return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir2) {
      return this._parent ? null : this.context.parent.nextChild(
        this.context.index + dir2,
        dir2,
        0,
        4
        /* Side.DontCare */
      );
    }
    get nextSibling() {
      let { buffer } = this.context;
      let after = buffer.buffer[this.index + 3];
      if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
        return new _BufferNode(this.context, this._parent, after);
      return this.externalSibling(1);
    }
    get prevSibling() {
      let { buffer } = this.context;
      let parentStart = this._parent ? this._parent.index + 4 : 0;
      if (this.index == parentStart)
        return this.externalSibling(-1);
      return new _BufferNode(this.context, this._parent, buffer.findChild(
        parentStart,
        this.index,
        -1,
        0,
        4
        /* Side.DontCare */
      ));
    }
    get tree() {
      return null;
    }
    toTree() {
      let children2 = [], positions = [];
      let { buffer } = this.context;
      let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
      if (endI > startI) {
        let from3 = buffer.buffer[this.index + 1];
        children2.push(buffer.slice(startI, endI, from3));
        positions.push(0);
      }
      return new Tree(this.type, children2, positions, this.to - this.from);
    }
    /**
    @internal
    */
    toString() {
      return this.context.buffer.childString(this.index);
    }
  };
  function iterStack(heads) {
    if (!heads.length)
      return null;
    let pick = 0, picked = heads[0];
    for (let i2 = 1; i2 < heads.length; i2++) {
      let node = heads[i2];
      if (node.from > picked.from || node.to < picked.to) {
        picked = node;
        pick = i2;
      }
    }
    let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;
    let newHeads = heads.slice();
    if (next)
      newHeads[pick] = next;
    else
      newHeads.splice(pick, 1);
    return new StackIterator(newHeads, picked);
  }
  var StackIterator = class {
    constructor(heads, node) {
      this.heads = heads;
      this.node = node;
    }
    get next() {
      return iterStack(this.heads);
    }
  };
  function stackIterator(tree, pos, side) {
    let inner = tree.resolveInner(pos, side), layers = null;
    for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {
      if (scan.index < 0) {
        let parent2 = scan.parent;
        (layers || (layers = [inner])).push(parent2.resolve(pos, side));
        scan = parent2;
      } else {
        let mount2 = MountedTree.get(scan.tree);
        if (mount2 && mount2.overlay && mount2.overlay[0].from <= pos && mount2.overlay[mount2.overlay.length - 1].to >= pos) {
          let root = new TreeNode(mount2.tree, mount2.overlay[0].from + scan.from, -1, scan);
          (layers || (layers = [inner])).push(resolveNode(root, pos, side, false));
        }
      }
    }
    return layers ? iterStack(layers) : inner;
  }
  var TreeCursor = class {
    /**
    Shorthand for `.type.name`.
    */
    get name() {
      return this.type.name;
    }
    /**
    @internal
    */
    constructor(node, mode = 0) {
      this.mode = mode;
      this.buffer = null;
      this.stack = [];
      this.index = 0;
      this.bufferNode = null;
      if (node instanceof TreeNode) {
        this.yieldNode(node);
      } else {
        this._tree = node.context.parent;
        this.buffer = node.context;
        for (let n2 = node._parent; n2; n2 = n2._parent)
          this.stack.unshift(n2.index);
        this.bufferNode = node;
        this.yieldBuf(node.index);
      }
    }
    yieldNode(node) {
      if (!node)
        return false;
      this._tree = node;
      this.type = node.type;
      this.from = node.from;
      this.to = node.to;
      return true;
    }
    yieldBuf(index6, type) {
      this.index = index6;
      let { start: start3, buffer } = this.buffer;
      this.type = type || buffer.set.types[buffer.buffer[index6]];
      this.from = start3 + buffer.buffer[index6 + 1];
      this.to = start3 + buffer.buffer[index6 + 2];
      return true;
    }
    /**
    @internal
    */
    yield(node) {
      if (!node)
        return false;
      if (node instanceof TreeNode) {
        this.buffer = null;
        return this.yieldNode(node);
      }
      this.buffer = node.context;
      return this.yieldBuf(node.index, node.type);
    }
    /**
    @internal
    */
    toString() {
      return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    /**
    @internal
    */
    enterChild(dir2, pos, side) {
      if (!this.buffer)
        return this.yield(this._tree.nextChild(dir2 < 0 ? this._tree._tree.children.length - 1 : 0, dir2, pos, side, this.mode));
      let { buffer } = this.buffer;
      let index6 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir2, pos - this.buffer.start, side);
      if (index6 < 0)
        return false;
      this.stack.push(this.index);
      return this.yieldBuf(index6);
    }
    /**
    Move the cursor to this node's first child. When this returns
    false, the node has no child, and the cursor has not been moved.
    */
    firstChild() {
      return this.enterChild(
        1,
        0,
        4
        /* Side.DontCare */
      );
    }
    /**
    Move the cursor to this node's last child.
    */
    lastChild() {
      return this.enterChild(
        -1,
        0,
        4
        /* Side.DontCare */
      );
    }
    /**
    Move the cursor to the first child that ends after `pos`.
    */
    childAfter(pos) {
      return this.enterChild(
        1,
        pos,
        2
        /* Side.After */
      );
    }
    /**
    Move to the last child that starts before `pos`.
    */
    childBefore(pos) {
      return this.enterChild(
        -1,
        pos,
        -2
        /* Side.Before */
      );
    }
    /**
    Move the cursor to the child around `pos`. If side is -1 the
    child may end at that position, when 1 it may start there. This
    will also enter [overlaid](#common.MountedTree.overlay)
    [mounted](#common.NodeProp^mounted) trees unless `overlays` is
    set to false.
    */
    enter(pos, side, mode = this.mode) {
      if (!this.buffer)
        return this.yield(this._tree.enter(pos, side, mode));
      return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
    }
    /**
    Move to the node's parent node, if this isn't the top node.
    */
    parent() {
      if (!this.buffer)
        return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
      if (this.stack.length)
        return this.yieldBuf(this.stack.pop());
      let parent2 = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
      this.buffer = null;
      return this.yieldNode(parent2);
    }
    /**
    @internal
    */
    sibling(dir2) {
      if (!this.buffer)
        return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir2, dir2, 0, 4, this.mode));
      let { buffer } = this.buffer, d2 = this.stack.length - 1;
      if (dir2 < 0) {
        let parentStart = d2 < 0 ? 0 : this.stack[d2] + 4;
        if (this.index != parentStart)
          return this.yieldBuf(buffer.findChild(
            parentStart,
            this.index,
            -1,
            0,
            4
            /* Side.DontCare */
          ));
      } else {
        let after = buffer.buffer[this.index + 3];
        if (after < (d2 < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d2] + 3]))
          return this.yieldBuf(after);
      }
      return d2 < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir2, dir2, 0, 4, this.mode)) : false;
    }
    /**
    Move to this node's next sibling, if any.
    */
    nextSibling() {
      return this.sibling(1);
    }
    /**
    Move to this node's previous sibling, if any.
    */
    prevSibling() {
      return this.sibling(-1);
    }
    atLastNode(dir2) {
      let index6, parent2, { buffer } = this;
      if (buffer) {
        if (dir2 > 0) {
          if (this.index < buffer.buffer.buffer.length)
            return false;
        } else {
          for (let i2 = 0; i2 < this.index; i2++)
            if (buffer.buffer.buffer[i2 + 3] < this.index)
              return false;
        }
        ({ index: index6, parent: parent2 } = buffer);
      } else {
        ({ index: index6, _parent: parent2 } = this._tree);
      }
      for (; parent2; { index: index6, _parent: parent2 } = parent2) {
        if (index6 > -1)
          for (let i2 = index6 + dir2, e2 = dir2 < 0 ? -1 : parent2._tree.children.length; i2 != e2; i2 += dir2) {
            let child = parent2._tree.children[i2];
            if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
              return false;
          }
      }
      return true;
    }
    move(dir2, enter) {
      if (enter && this.enterChild(
        dir2,
        0,
        4
        /* Side.DontCare */
      ))
        return true;
      for (; ; ) {
        if (this.sibling(dir2))
          return true;
        if (this.atLastNode(dir2) || !this.parent())
          return false;
      }
    }
    /**
    Move to the next node in a
    [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
    traversal, going from a node to its first child or, if the
    current node is empty or `enter` is false, its next sibling or
    the next sibling of the first parent node that has one.
    */
    next(enter = true) {
      return this.move(1, enter);
    }
    /**
    Move to the next node in a last-to-first pre-order traversal. A
    node is followed by its last child or, if it has none, its
    previous sibling or the previous sibling of the first parent
    node that has one.
    */
    prev(enter = true) {
      return this.move(-1, enter);
    }
    /**
    Move the cursor to the innermost node that covers `pos`. If
    `side` is -1, it will enter nodes that end at `pos`. If it is 1,
    it will enter nodes that start at `pos`.
    */
    moveTo(pos, side = 0) {
      while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
        if (!this.parent())
          break;
      while (this.enterChild(1, pos, side)) {
      }
      return this;
    }
    /**
    Get a [syntax node](#common.SyntaxNode) at the cursor's current
    position.
    */
    get node() {
      if (!this.buffer)
        return this._tree;
      let cache2 = this.bufferNode, result = null, depth = 0;
      if (cache2 && cache2.context == this.buffer) {
        scan: for (let index6 = this.index, d2 = this.stack.length; d2 >= 0; ) {
          for (let c2 = cache2; c2; c2 = c2._parent)
            if (c2.index == index6) {
              if (index6 == this.index)
                return c2;
              result = c2;
              depth = d2 + 1;
              break scan;
            }
          index6 = this.stack[--d2];
        }
      }
      for (let i2 = depth; i2 < this.stack.length; i2++)
        result = new BufferNode(this.buffer, result, this.stack[i2]);
      return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    /**
    Get the [tree](#common.Tree) that represents the current node, if
    any. Will return null when the node is in a [tree
    buffer](#common.TreeBuffer).
    */
    get tree() {
      return this.buffer ? null : this._tree._tree;
    }
    /**
    Iterate over the current node and all its descendants, calling
    `enter` when entering a node and `leave`, if given, when leaving
    one. When `enter` returns `false`, any children of that node are
    skipped, and `leave` isn't called for it.
    */
    iterate(enter, leave) {
      for (let depth = 0; ; ) {
        let mustLeave = false;
        if (this.type.isAnonymous || enter(this) !== false) {
          if (this.firstChild()) {
            depth++;
            continue;
          }
          if (!this.type.isAnonymous)
            mustLeave = true;
        }
        for (; ; ) {
          if (mustLeave && leave)
            leave(this);
          mustLeave = this.type.isAnonymous;
          if (!depth)
            return;
          if (this.nextSibling())
            break;
          this.parent();
          depth--;
          mustLeave = true;
        }
      }
    }
    /**
    Test whether the current node matches a given context—a sequence
    of direct parent node names. Empty strings in the context array
    are treated as wildcards.
    */
    matchContext(context3) {
      if (!this.buffer)
        return matchNodeContext(this.node.parent, context3);
      let { buffer } = this.buffer, { types: types2 } = buffer.set;
      for (let i2 = context3.length - 1, d2 = this.stack.length - 1; i2 >= 0; d2--) {
        if (d2 < 0)
          return matchNodeContext(this._tree, context3, i2);
        let type = types2[buffer.buffer[this.stack[d2]]];
        if (!type.isAnonymous) {
          if (context3[i2] && context3[i2] != type.name)
            return false;
          i2--;
        }
      }
      return true;
    }
  };
  function hasChild(tree) {
    return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
  }
  function buildTree(data) {
    var _a2;
    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types2 = nodeSet.types;
    let contextHash = 0, lookAhead = 0;
    function takeNode(parentStart, minPos, children3, positions2, inRepeat, depth) {
      let { id: id5, start: start3, end, size: size5 } = cursor;
      let lookAheadAtStart = lookAhead, contextAtStart = contextHash;
      while (size5 < 0) {
        cursor.next();
        if (size5 == -1) {
          let node2 = reused[id5];
          children3.push(node2);
          positions2.push(start3 - parentStart);
          return;
        } else if (size5 == -3) {
          contextHash = id5;
          return;
        } else if (size5 == -4) {
          lookAhead = id5;
          return;
        } else {
          throw new RangeError(`Unrecognized record size: ${size5}`);
        }
      }
      let type = types2[id5], node, buffer2;
      let startPos = start3 - parentStart;
      if (end - start3 <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
        let data2 = new Uint16Array(buffer2.size - buffer2.skip);
        let endPos = cursor.pos - buffer2.size, index6 = data2.length;
        while (cursor.pos > endPos)
          index6 = copyToBuffer(buffer2.start, data2, index6);
        node = new TreeBuffer(data2, end - buffer2.start, nodeSet);
        startPos = buffer2.start - parentStart;
      } else {
        let endPos = cursor.pos - size5;
        cursor.next();
        let localChildren = [], localPositions = [];
        let localInRepeat = id5 >= minRepeatType ? id5 : -1;
        let lastGroup = 0, lastEnd = end;
        while (cursor.pos > endPos) {
          if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
            if (cursor.end <= lastEnd - maxBufferLength) {
              makeRepeatLeaf(localChildren, localPositions, start3, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
              lastGroup = localChildren.length;
              lastEnd = cursor.end;
            }
            cursor.next();
          } else if (depth > 2500) {
            takeFlatNode(start3, endPos, localChildren, localPositions);
          } else {
            takeNode(start3, endPos, localChildren, localPositions, localInRepeat, depth + 1);
          }
        }
        if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
          makeRepeatLeaf(localChildren, localPositions, start3, lastGroup, start3, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
        localChildren.reverse();
        localPositions.reverse();
        if (localInRepeat > -1 && lastGroup > 0) {
          let make = makeBalanced(type, contextAtStart);
          node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start3, make, make);
        } else {
          node = makeTree(type, localChildren, localPositions, end - start3, lookAheadAtStart - end, contextAtStart);
        }
      }
      children3.push(node);
      positions2.push(startPos);
    }
    function takeFlatNode(parentStart, minPos, children3, positions2) {
      let nodes = [];
      let nodeCount = 0, stopAt = -1;
      while (cursor.pos > minPos) {
        let { id: id5, start: start3, end, size: size5 } = cursor;
        if (size5 > 4) {
          cursor.next();
        } else if (stopAt > -1 && start3 < stopAt) {
          break;
        } else {
          if (stopAt < 0)
            stopAt = end - maxBufferLength;
          nodes.push(id5, start3, end);
          nodeCount++;
          cursor.next();
        }
      }
      if (nodeCount) {
        let buffer2 = new Uint16Array(nodeCount * 4);
        let start3 = nodes[nodes.length - 2];
        for (let i2 = nodes.length - 3, j2 = 0; i2 >= 0; i2 -= 3) {
          buffer2[j2++] = nodes[i2];
          buffer2[j2++] = nodes[i2 + 1] - start3;
          buffer2[j2++] = nodes[i2 + 2] - start3;
          buffer2[j2++] = j2;
        }
        children3.push(new TreeBuffer(buffer2, nodes[2] - start3, nodeSet));
        positions2.push(start3 - parentStart);
      }
    }
    function makeBalanced(type, contextHash2) {
      return (children3, positions2, length10) => {
        let lookAhead2 = 0, lastI = children3.length - 1, last4, lookAheadProp;
        if (lastI >= 0 && (last4 = children3[lastI]) instanceof Tree) {
          if (!lastI && last4.type == type && last4.length == length10)
            return last4;
          if (lookAheadProp = last4.prop(NodeProp.lookAhead))
            lookAhead2 = positions2[lastI] + last4.length + lookAheadProp;
        }
        return makeTree(type, children3, positions2, length10, lookAhead2, contextHash2);
      };
    }
    function makeRepeatLeaf(children3, positions2, base2, i2, from3, to3, type, lookAhead2, contextHash2) {
      let localChildren = [], localPositions = [];
      while (children3.length > i2) {
        localChildren.push(children3.pop());
        localPositions.push(positions2.pop() + base2 - from3);
      }
      children3.push(makeTree(nodeSet.types[type], localChildren, localPositions, to3 - from3, lookAhead2 - to3, contextHash2));
      positions2.push(from3 - base2);
    }
    function makeTree(type, children3, positions2, length10, lookAhead2, contextHash2, props) {
      if (contextHash2) {
        let pair2 = [NodeProp.contextHash, contextHash2];
        props = props ? [pair2].concat(props) : [pair2];
      }
      if (lookAhead2 > 25) {
        let pair2 = [NodeProp.lookAhead, lookAhead2];
        props = props ? [pair2].concat(props) : [pair2];
      }
      return new Tree(type, children3, positions2, length10, props);
    }
    function findBufferSize(maxSize, inRepeat) {
      let fork = cursor.fork();
      let size5 = 0, start3 = 0, skip = 0, minStart = fork.end - maxBufferLength;
      let result = { size: 0, start: 0, skip: 0 };
      scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
        let nodeSize2 = fork.size;
        if (fork.id == inRepeat && nodeSize2 >= 0) {
          result.size = size5;
          result.start = start3;
          result.skip = skip;
          skip += 4;
          size5 += 4;
          fork.next();
          continue;
        }
        let startPos = fork.pos - nodeSize2;
        if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
          break;
        let localSkipped = fork.id >= minRepeatType ? 4 : 0;
        let nodeStart2 = fork.start;
        fork.next();
        while (fork.pos > startPos) {
          if (fork.size < 0) {
            if (fork.size == -3)
              localSkipped += 4;
            else
              break scan;
          } else if (fork.id >= minRepeatType) {
            localSkipped += 4;
          }
          fork.next();
        }
        start3 = nodeStart2;
        size5 += nodeSize2;
        skip += localSkipped;
      }
      if (inRepeat < 0 || size5 == maxSize) {
        result.size = size5;
        result.start = start3;
        result.skip = skip;
      }
      return result.size > 4 ? result : void 0;
    }
    function copyToBuffer(bufferStart, buffer2, index6) {
      let { id: id5, start: start3, end, size: size5 } = cursor;
      cursor.next();
      if (size5 >= 0 && id5 < minRepeatType) {
        let startIndex = index6;
        if (size5 > 4) {
          let endPos = cursor.pos - (size5 - 4);
          while (cursor.pos > endPos)
            index6 = copyToBuffer(bufferStart, buffer2, index6);
        }
        buffer2[--index6] = startIndex;
        buffer2[--index6] = end - bufferStart;
        buffer2[--index6] = start3 - bufferStart;
        buffer2[--index6] = id5;
      } else if (size5 == -3) {
        contextHash = id5;
      } else if (size5 == -4) {
        lookAhead = id5;
      }
      return index6;
    }
    let children2 = [], positions = [];
    while (cursor.pos > 0)
      takeNode(data.start || 0, data.bufferStart || 0, children2, positions, -1, 0);
    let length9 = (_a2 = data.length) !== null && _a2 !== void 0 ? _a2 : children2.length ? positions[0] + children2[0].length : 0;
    return new Tree(types2[data.topID], children2.reverse(), positions.reverse(), length9);
  }
  var nodeSizeCache = /* @__PURE__ */ new WeakMap();
  function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
      return 1;
    let size5 = nodeSizeCache.get(node);
    if (size5 == null) {
      size5 = 1;
      for (let child of node.children) {
        if (child.type != balanceType || !(child instanceof Tree)) {
          size5 = 1;
          break;
        }
        size5 += nodeSize(balanceType, child);
      }
      nodeSizeCache.set(node, size5);
    }
    return size5;
  }
  function balanceRange(balanceType, children2, positions, from3, to3, start3, length9, mkTop, mkTree2) {
    let total = 0;
    for (let i2 = from3; i2 < to3; i2++)
      total += nodeSize(balanceType, children2[i2]);
    let maxChild = Math.ceil(
      total * 1.5 / 8
      /* Balance.BranchFactor */
    );
    let localChildren = [], localPositions = [];
    function divide(children3, positions2, from4, to4, offset) {
      for (let i2 = from4; i2 < to4; ) {
        let groupFrom = i2, groupStart = positions2[i2], groupSize = nodeSize(balanceType, children3[i2]);
        i2++;
        for (; i2 < to4; i2++) {
          let nextSize = nodeSize(balanceType, children3[i2]);
          if (groupSize + nextSize >= maxChild)
            break;
          groupSize += nextSize;
        }
        if (i2 == groupFrom + 1) {
          if (groupSize > maxChild) {
            let only = children3[groupFrom];
            divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
            continue;
          }
          localChildren.push(children3[groupFrom]);
        } else {
          let length10 = positions2[i2 - 1] + children3[i2 - 1].length - groupStart;
          localChildren.push(balanceRange(balanceType, children3, positions2, groupFrom, i2, groupStart, length10, null, mkTree2));
        }
        localPositions.push(groupStart + offset - start3);
      }
    }
    divide(children2, positions, from3, to3, 0);
    return (mkTop || mkTree2)(localChildren, localPositions, length9);
  }
  var NodeWeakMap = class {
    constructor() {
      this.map = /* @__PURE__ */ new WeakMap();
    }
    setBuffer(buffer, index6, value12) {
      let inner = this.map.get(buffer);
      if (!inner)
        this.map.set(buffer, inner = /* @__PURE__ */ new Map());
      inner.set(index6, value12);
    }
    getBuffer(buffer, index6) {
      let inner = this.map.get(buffer);
      return inner && inner.get(index6);
    }
    /**
    Set the value for this syntax node.
    */
    set(node, value12) {
      if (node instanceof BufferNode)
        this.setBuffer(node.context.buffer, node.index, value12);
      else if (node instanceof TreeNode)
        this.map.set(node.tree, value12);
    }
    /**
    Retrieve value for this syntax node, if it exists in the map.
    */
    get(node) {
      return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index) : node instanceof TreeNode ? this.map.get(node.tree) : void 0;
    }
    /**
    Set the value for the node that a cursor currently points to.
    */
    cursorSet(cursor, value12) {
      if (cursor.buffer)
        this.setBuffer(cursor.buffer.buffer, cursor.index, value12);
      else
        this.map.set(cursor.tree, value12);
    }
    /**
    Retrieve the value for the node that a cursor currently points
    to.
    */
    cursorGet(cursor) {
      return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);
    }
  };
  var TreeFragment = class _TreeFragment {
    /**
    Construct a tree fragment. You'll usually want to use
    [`addTree`](#common.TreeFragment^addTree) and
    [`applyChanges`](#common.TreeFragment^applyChanges) instead of
    calling this directly.
    */
    constructor(from3, to3, tree, offset, openStart = false, openEnd = false) {
      this.from = from3;
      this.to = to3;
      this.tree = tree;
      this.offset = offset;
      this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
    }
    /**
    Whether the start of the fragment represents the start of a
    parse, or the end of a change. (In the second case, it may not
    be safe to reuse some nodes at the start, depending on the
    parsing algorithm.)
    */
    get openStart() {
      return (this.open & 1) > 0;
    }
    /**
    Whether the end of the fragment represents the end of a
    full-document parse, or the start of a change.
    */
    get openEnd() {
      return (this.open & 2) > 0;
    }
    /**
    Create a set of fragments from a freshly parsed tree, or update
    an existing set of fragments by replacing the ones that overlap
    with a tree with content from the new tree. When `partial` is
    true, the parse is treated as incomplete, and the resulting
    fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
    true.
    */
    static addTree(tree, fragments = [], partial = false) {
      let result = [new _TreeFragment(0, tree.length, tree, 0, false, partial)];
      for (let f2 of fragments)
        if (f2.to > tree.length)
          result.push(f2);
      return result;
    }
    /**
    Apply a set of edits to an array of fragments, removing or
    splitting fragments as necessary to remove edited ranges, and
    adjusting offsets for fragments that moved.
    */
    static applyChanges(fragments, changes, minGap = 128) {
      if (!changes.length)
        return fragments;
      let result = [];
      let fI = 1, nextF = fragments.length ? fragments[0] : null;
      for (let cI = 0, pos = 0, off = 0; ; cI++) {
        let nextC = cI < changes.length ? changes[cI] : null;
        let nextPos = nextC ? nextC.fromA : 1e9;
        if (nextPos - pos >= minGap)
          while (nextF && nextF.from < nextPos) {
            let cut = nextF;
            if (pos >= cut.from || nextPos <= cut.to || off) {
              let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
              cut = fFrom >= fTo ? null : new _TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
            }
            if (cut)
              result.push(cut);
            if (nextF.to > nextPos)
              break;
            nextF = fI < fragments.length ? fragments[fI++] : null;
          }
        if (!nextC)
          break;
        pos = nextC.toA;
        off = nextC.toA - nextC.toB;
      }
      return result;
    }
  };
  var Parser = class {
    /**
    Start a parse, returning a [partial parse](#common.PartialParse)
    object. [`fragments`](#common.TreeFragment) can be passed in to
    make the parse incremental.
    
    By default, the entire input is parsed. You can pass `ranges`,
    which should be a sorted array of non-empty, non-overlapping
    ranges, to parse only those ranges. The tree returned in that
    case will start at `ranges[0].from`.
    */
    startParse(input, fragments, ranges) {
      if (typeof input == "string")
        input = new StringInput(input);
      ranges = !ranges ? [new Range2(0, input.length)] : ranges.length ? ranges.map((r2) => new Range2(r2.from, r2.to)) : [new Range2(0, 0)];
      return this.createParse(input, fragments || [], ranges);
    }
    /**
    Run a full parse, returning the resulting tree.
    */
    parse(input, fragments, ranges) {
      let parse9 = this.startParse(input, fragments, ranges);
      for (; ; ) {
        let done = parse9.advance();
        if (done)
          return done;
      }
    }
  };
  var StringInput = class {
    constructor(string2) {
      this.string = string2;
    }
    get length() {
      return this.string.length;
    }
    chunk(from3) {
      return this.string.slice(from3);
    }
    get lineChunks() {
      return false;
    }
    read(from3, to3) {
      return this.string.slice(from3, to3);
    }
  };
  var stoppedInner = new NodeProp({ perNode: true });

  // node_modules/@lezer/highlight/dist/index.js
  var nextTagID = 0;
  var Tag = class _Tag {
    /**
    @internal
    */
    constructor(name16, set, base2, modified) {
      this.name = name16;
      this.set = set;
      this.base = base2;
      this.modified = modified;
      this.id = nextTagID++;
    }
    toString() {
      let { name: name16 } = this;
      for (let mod4 of this.modified)
        if (mod4.name)
          name16 = `${mod4.name}(${name16})`;
      return name16;
    }
    static define(nameOrParent, parent2) {
      let name16 = typeof nameOrParent == "string" ? nameOrParent : "?";
      if (nameOrParent instanceof _Tag)
        parent2 = nameOrParent;
      if (parent2 === null || parent2 === void 0 ? void 0 : parent2.base)
        throw new Error("Can not derive from a modified tag");
      let tag = new _Tag(name16, [], null, []);
      tag.set.push(tag);
      if (parent2)
        for (let t3 of parent2.set)
          tag.set.push(t3);
      return tag;
    }
    /**
    Define a tag _modifier_, which is a function that, given a tag,
    will return a tag that is a subtag of the original. Applying the
    same modifier to a twice tag will return the same value (`m1(t1)
    == m1(t1)`) and applying multiple modifiers will, regardless or
    order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
    
    When multiple modifiers are applied to a given base tag, each
    smaller set of modifiers is registered as a parent, so that for
    example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
    `m1(m3(t1)`, and so on.
    */
    static defineModifier(name16) {
      let mod4 = new Modifier(name16);
      return (tag) => {
        if (tag.modified.indexOf(mod4) > -1)
          return tag;
        return Modifier.get(tag.base || tag, tag.modified.concat(mod4).sort((a2, b2) => a2.id - b2.id));
      };
    }
  };
  var nextModifierID = 0;
  var Modifier = class _Modifier {
    constructor(name16) {
      this.name = name16;
      this.instances = [];
      this.id = nextModifierID++;
    }
    static get(base2, mods) {
      if (!mods.length)
        return base2;
      let exists = mods[0].instances.find((t3) => t3.base == base2 && sameArray2(mods, t3.modified));
      if (exists)
        return exists;
      let set = [], tag = new Tag(base2.name, set, base2, mods);
      for (let m2 of mods)
        m2.instances.push(tag);
      let configs = powerSet(mods);
      for (let parent2 of base2.set)
        if (!parent2.modified.length)
          for (let config2 of configs)
            set.push(_Modifier.get(parent2, config2));
      return tag;
    }
  };
  function sameArray2(a2, b2) {
    return a2.length == b2.length && a2.every((x2, i2) => x2 == b2[i2]);
  }
  function powerSet(array) {
    let sets = [[]];
    for (let i2 = 0; i2 < array.length; i2++) {
      for (let j2 = 0, e2 = sets.length; j2 < e2; j2++) {
        sets.push(sets[j2].concat(array[i2]));
      }
    }
    return sets.sort((a2, b2) => b2.length - a2.length);
  }
  function styleTags(spec) {
    let byName = /* @__PURE__ */ Object.create(null);
    for (let prop in spec) {
      let tags2 = spec[prop];
      if (!Array.isArray(tags2))
        tags2 = [tags2];
      for (let part of prop.split(" "))
        if (part) {
          let pieces = [], mode = 2, rest = part;
          for (let pos = 0; ; ) {
            if (rest == "..." && pos > 0 && pos + 3 == part.length) {
              mode = 1;
              break;
            }
            let m2 = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
            if (!m2)
              throw new RangeError("Invalid path: " + part);
            pieces.push(m2[0] == "*" ? "" : m2[0][0] == '"' ? JSON.parse(m2[0]) : m2[0]);
            pos += m2[0].length;
            if (pos == part.length)
              break;
            let next = part[pos++];
            if (pos == part.length && next == "!") {
              mode = 0;
              break;
            }
            if (next != "/")
              throw new RangeError("Invalid path: " + part);
            rest = part.slice(pos);
          }
          let last4 = pieces.length - 1, inner = pieces[last4];
          if (!inner)
            throw new RangeError("Invalid path: " + part);
          let rule = new Rule(tags2, mode, last4 > 0 ? pieces.slice(0, last4) : null);
          byName[inner] = rule.sort(byName[inner]);
        }
    }
    return ruleNodeProp.add(byName);
  }
  var ruleNodeProp = new NodeProp();
  var Rule = class {
    constructor(tags2, mode, context3, next) {
      this.tags = tags2;
      this.mode = mode;
      this.context = context3;
      this.next = next;
    }
    get opaque() {
      return this.mode == 0;
    }
    get inherit() {
      return this.mode == 1;
    }
    sort(other) {
      if (!other || other.depth < this.depth) {
        this.next = other;
        return this;
      }
      other.next = this.sort(other.next);
      return other;
    }
    get depth() {
      return this.context ? this.context.length : 0;
    }
  };
  Rule.empty = new Rule([], 2, null);
  function tagHighlighter(tags2, options2) {
    let map27 = /* @__PURE__ */ Object.create(null);
    for (let style3 of tags2) {
      if (!Array.isArray(style3.tag))
        map27[style3.tag.id] = style3.class;
      else
        for (let tag of style3.tag)
          map27[tag.id] = style3.class;
    }
    let { scope: scope2, all: all4 = null } = options2 || {};
    return {
      style: (tags3) => {
        let cls = all4;
        for (let tag of tags3) {
          for (let sub2 of tag.set) {
            let tagClass = map27[sub2.id];
            if (tagClass) {
              cls = cls ? cls + " " + tagClass : tagClass;
              break;
            }
          }
        }
        return cls;
      },
      scope: scope2
    };
  }
  function highlightTags(highlighters, tags2) {
    let result = null;
    for (let highlighter of highlighters) {
      let value12 = highlighter.style(tags2);
      if (value12)
        result = result ? result + " " + value12 : value12;
    }
    return result;
  }
  function highlightTree(tree, highlighter, putStyle, from3 = 0, to3 = tree.length) {
    let builder = new HighlightBuilder(from3, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
    builder.highlightRange(tree.cursor(), from3, to3, "", builder.highlighters);
    builder.flush(to3);
  }
  var HighlightBuilder = class {
    constructor(at, highlighters, span4) {
      this.at = at;
      this.highlighters = highlighters;
      this.span = span4;
      this.class = "";
    }
    startSpan(at, cls) {
      if (cls != this.class) {
        this.flush(at);
        if (at > this.at)
          this.at = at;
        this.class = cls;
      }
    }
    flush(to3) {
      if (to3 > this.at && this.class)
        this.span(this.at, to3, this.class);
    }
    highlightRange(cursor, from3, to3, inheritedClass, highlighters) {
      let { type, from: start3, to: end } = cursor;
      if (start3 >= to3 || end <= from3)
        return;
      if (type.isTop)
        highlighters = this.highlighters.filter((h2) => !h2.scope || h2.scope(type));
      let cls = inheritedClass;
      let rule = getStyleTags(cursor) || Rule.empty;
      let tagCls = highlightTags(highlighters, rule.tags);
      if (tagCls) {
        if (cls)
          cls += " ";
        cls += tagCls;
        if (rule.mode == 1)
          inheritedClass += (inheritedClass ? " " : "") + tagCls;
      }
      this.startSpan(Math.max(from3, start3), cls);
      if (rule.opaque)
        return;
      let mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);
      if (mounted && mounted.overlay) {
        let inner = cursor.node.enter(mounted.overlay[0].from + start3, 1);
        let innerHighlighters = this.highlighters.filter((h2) => !h2.scope || h2.scope(mounted.tree.type));
        let hasChild2 = cursor.firstChild();
        for (let i2 = 0, pos = start3; ; i2++) {
          let next = i2 < mounted.overlay.length ? mounted.overlay[i2] : null;
          let nextPos = next ? next.from + start3 : end;
          let rangeFrom = Math.max(from3, pos), rangeTo = Math.min(to3, nextPos);
          if (rangeFrom < rangeTo && hasChild2) {
            while (cursor.from < rangeTo) {
              this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);
              this.startSpan(Math.min(rangeTo, cursor.to), cls);
              if (cursor.to >= nextPos || !cursor.nextSibling())
                break;
            }
          }
          if (!next || nextPos > to3)
            break;
          pos = next.to + start3;
          if (pos > from3) {
            this.highlightRange(inner.cursor(), Math.max(from3, next.from + start3), Math.min(to3, pos), "", innerHighlighters);
            this.startSpan(Math.min(to3, pos), cls);
          }
        }
        if (hasChild2)
          cursor.parent();
      } else if (cursor.firstChild()) {
        if (mounted)
          inheritedClass = "";
        do {
          if (cursor.to <= from3)
            continue;
          if (cursor.from >= to3)
            break;
          this.highlightRange(cursor, from3, to3, inheritedClass, highlighters);
          this.startSpan(Math.min(to3, cursor.to), cls);
        } while (cursor.nextSibling());
        cursor.parent();
      }
    }
  };
  function getStyleTags(node) {
    let rule = node.type.prop(ruleNodeProp);
    while (rule && rule.context && !node.matchContext(rule.context))
      rule = rule.next;
    return rule || null;
  }
  var t2 = Tag.define;
  var comment = t2();
  var name2 = t2();
  var typeName = t2(name2);
  var propertyName = t2(name2);
  var literal = t2();
  var string = t2(literal);
  var number = t2(literal);
  var content = t2();
  var heading = t2(content);
  var keyword = t2();
  var operator = t2();
  var punctuation = t2();
  var bracket = t2(punctuation);
  var meta = t2();
  var tags = {
    /**
    A comment.
    */
    comment,
    /**
    A line [comment](#highlight.tags.comment).
    */
    lineComment: t2(comment),
    /**
    A block [comment](#highlight.tags.comment).
    */
    blockComment: t2(comment),
    /**
    A documentation [comment](#highlight.tags.comment).
    */
    docComment: t2(comment),
    /**
    Any kind of identifier.
    */
    name: name2,
    /**
    The [name](#highlight.tags.name) of a variable.
    */
    variableName: t2(name2),
    /**
    A type [name](#highlight.tags.name).
    */
    typeName,
    /**
    A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
    */
    tagName: t2(typeName),
    /**
    A property or field [name](#highlight.tags.name).
    */
    propertyName,
    /**
    An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
    */
    attributeName: t2(propertyName),
    /**
    The [name](#highlight.tags.name) of a class.
    */
    className: t2(name2),
    /**
    A label [name](#highlight.tags.name).
    */
    labelName: t2(name2),
    /**
    A namespace [name](#highlight.tags.name).
    */
    namespace: t2(name2),
    /**
    The [name](#highlight.tags.name) of a macro.
    */
    macroName: t2(name2),
    /**
    A literal value.
    */
    literal,
    /**
    A string [literal](#highlight.tags.literal).
    */
    string,
    /**
    A documentation [string](#highlight.tags.string).
    */
    docString: t2(string),
    /**
    A character literal (subtag of [string](#highlight.tags.string)).
    */
    character: t2(string),
    /**
    An attribute value (subtag of [string](#highlight.tags.string)).
    */
    attributeValue: t2(string),
    /**
    A number [literal](#highlight.tags.literal).
    */
    number,
    /**
    An integer [number](#highlight.tags.number) literal.
    */
    integer: t2(number),
    /**
    A floating-point [number](#highlight.tags.number) literal.
    */
    float: t2(number),
    /**
    A boolean [literal](#highlight.tags.literal).
    */
    bool: t2(literal),
    /**
    Regular expression [literal](#highlight.tags.literal).
    */
    regexp: t2(literal),
    /**
    An escape [literal](#highlight.tags.literal), for example a
    backslash escape in a string.
    */
    escape: t2(literal),
    /**
    A color [literal](#highlight.tags.literal).
    */
    color: t2(literal),
    /**
    A URL [literal](#highlight.tags.literal).
    */
    url: t2(literal),
    /**
    A language keyword.
    */
    keyword,
    /**
    The [keyword](#highlight.tags.keyword) for the self or this
    object.
    */
    self: t2(keyword),
    /**
    The [keyword](#highlight.tags.keyword) for null.
    */
    null: t2(keyword),
    /**
    A [keyword](#highlight.tags.keyword) denoting some atomic value.
    */
    atom: t2(keyword),
    /**
    A [keyword](#highlight.tags.keyword) that represents a unit.
    */
    unit: t2(keyword),
    /**
    A modifier [keyword](#highlight.tags.keyword).
    */
    modifier: t2(keyword),
    /**
    A [keyword](#highlight.tags.keyword) that acts as an operator.
    */
    operatorKeyword: t2(keyword),
    /**
    A control-flow related [keyword](#highlight.tags.keyword).
    */
    controlKeyword: t2(keyword),
    /**
    A [keyword](#highlight.tags.keyword) that defines something.
    */
    definitionKeyword: t2(keyword),
    /**
    A [keyword](#highlight.tags.keyword) related to defining or
    interfacing with modules.
    */
    moduleKeyword: t2(keyword),
    /**
    An operator.
    */
    operator,
    /**
    An [operator](#highlight.tags.operator) that dereferences something.
    */
    derefOperator: t2(operator),
    /**
    Arithmetic-related [operator](#highlight.tags.operator).
    */
    arithmeticOperator: t2(operator),
    /**
    Logical [operator](#highlight.tags.operator).
    */
    logicOperator: t2(operator),
    /**
    Bit [operator](#highlight.tags.operator).
    */
    bitwiseOperator: t2(operator),
    /**
    Comparison [operator](#highlight.tags.operator).
    */
    compareOperator: t2(operator),
    /**
    [Operator](#highlight.tags.operator) that updates its operand.
    */
    updateOperator: t2(operator),
    /**
    [Operator](#highlight.tags.operator) that defines something.
    */
    definitionOperator: t2(operator),
    /**
    Type-related [operator](#highlight.tags.operator).
    */
    typeOperator: t2(operator),
    /**
    Control-flow [operator](#highlight.tags.operator).
    */
    controlOperator: t2(operator),
    /**
    Program or markup punctuation.
    */
    punctuation,
    /**
    [Punctuation](#highlight.tags.punctuation) that separates
    things.
    */
    separator: t2(punctuation),
    /**
    Bracket-style [punctuation](#highlight.tags.punctuation).
    */
    bracket,
    /**
    Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
    tokens).
    */
    angleBracket: t2(bracket),
    /**
    Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
    tokens).
    */
    squareBracket: t2(bracket),
    /**
    Parentheses (usually `(` and `)` tokens). Subtag of
    [bracket](#highlight.tags.bracket).
    */
    paren: t2(bracket),
    /**
    Braces (usually `{` and `}` tokens). Subtag of
    [bracket](#highlight.tags.bracket).
    */
    brace: t2(bracket),
    /**
    Content, for example plain text in XML or markup documents.
    */
    content,
    /**
    [Content](#highlight.tags.content) that represents a heading.
    */
    heading,
    /**
    A level 1 [heading](#highlight.tags.heading).
    */
    heading1: t2(heading),
    /**
    A level 2 [heading](#highlight.tags.heading).
    */
    heading2: t2(heading),
    /**
    A level 3 [heading](#highlight.tags.heading).
    */
    heading3: t2(heading),
    /**
    A level 4 [heading](#highlight.tags.heading).
    */
    heading4: t2(heading),
    /**
    A level 5 [heading](#highlight.tags.heading).
    */
    heading5: t2(heading),
    /**
    A level 6 [heading](#highlight.tags.heading).
    */
    heading6: t2(heading),
    /**
    A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
    */
    contentSeparator: t2(content),
    /**
    [Content](#highlight.tags.content) that represents a list.
    */
    list: t2(content),
    /**
    [Content](#highlight.tags.content) that represents a quote.
    */
    quote: t2(content),
    /**
    [Content](#highlight.tags.content) that is emphasized.
    */
    emphasis: t2(content),
    /**
    [Content](#highlight.tags.content) that is styled strong.
    */
    strong: t2(content),
    /**
    [Content](#highlight.tags.content) that is part of a link.
    */
    link: t2(content),
    /**
    [Content](#highlight.tags.content) that is styled as code or
    monospace.
    */
    monospace: t2(content),
    /**
    [Content](#highlight.tags.content) that has a strike-through
    style.
    */
    strikethrough: t2(content),
    /**
    Inserted text in a change-tracking format.
    */
    inserted: t2(),
    /**
    Deleted text.
    */
    deleted: t2(),
    /**
    Changed text.
    */
    changed: t2(),
    /**
    An invalid or unsyntactic element.
    */
    invalid: t2(),
    /**
    Metadata or meta-instruction.
    */
    meta,
    /**
    [Metadata](#highlight.tags.meta) that applies to the entire
    document.
    */
    documentMeta: t2(meta),
    /**
    [Metadata](#highlight.tags.meta) that annotates or adds
    attributes to a given syntactic element.
    */
    annotation: t2(meta),
    /**
    Processing instruction or preprocessor directive. Subtag of
    [meta](#highlight.tags.meta).
    */
    processingInstruction: t2(meta),
    /**
    [Modifier](#highlight.Tag^defineModifier) that indicates that a
    given element is being defined. Expected to be used with the
    various [name](#highlight.tags.name) tags.
    */
    definition: Tag.defineModifier("definition"),
    /**
    [Modifier](#highlight.Tag^defineModifier) that indicates that
    something is constant. Mostly expected to be used with
    [variable names](#highlight.tags.variableName).
    */
    constant: Tag.defineModifier("constant"),
    /**
    [Modifier](#highlight.Tag^defineModifier) used to indicate that
    a [variable](#highlight.tags.variableName) or [property
    name](#highlight.tags.propertyName) is being called or defined
    as a function.
    */
    function: Tag.defineModifier("function"),
    /**
    [Modifier](#highlight.Tag^defineModifier) that can be applied to
    [names](#highlight.tags.name) to indicate that they belong to
    the language's standard environment.
    */
    standard: Tag.defineModifier("standard"),
    /**
    [Modifier](#highlight.Tag^defineModifier) that indicates a given
    [names](#highlight.tags.name) is local to some scope.
    */
    local: Tag.defineModifier("local"),
    /**
    A generic variant [modifier](#highlight.Tag^defineModifier) that
    can be used to tag language-specific alternative variants of
    some common tag. It is recommended for themes to define special
    forms of at least the [string](#highlight.tags.string) and
    [variable name](#highlight.tags.variableName) tags, since those
    come up a lot.
    */
    special: Tag.defineModifier("special")
  };
  for (let name16 in tags) {
    let val = tags[name16];
    if (val instanceof Tag)
      val.name = name16;
  }
  var classHighlighter = tagHighlighter([
    { tag: tags.link, class: "tok-link" },
    { tag: tags.heading, class: "tok-heading" },
    { tag: tags.emphasis, class: "tok-emphasis" },
    { tag: tags.strong, class: "tok-strong" },
    { tag: tags.keyword, class: "tok-keyword" },
    { tag: tags.atom, class: "tok-atom" },
    { tag: tags.bool, class: "tok-bool" },
    { tag: tags.url, class: "tok-url" },
    { tag: tags.labelName, class: "tok-labelName" },
    { tag: tags.inserted, class: "tok-inserted" },
    { tag: tags.deleted, class: "tok-deleted" },
    { tag: tags.literal, class: "tok-literal" },
    { tag: tags.string, class: "tok-string" },
    { tag: tags.number, class: "tok-number" },
    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
    { tag: tags.variableName, class: "tok-variableName" },
    { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
    { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
    { tag: tags.special(tags.variableName), class: "tok-variableName2" },
    { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
    { tag: tags.typeName, class: "tok-typeName" },
    { tag: tags.namespace, class: "tok-namespace" },
    { tag: tags.className, class: "tok-className" },
    { tag: tags.macroName, class: "tok-macroName" },
    { tag: tags.propertyName, class: "tok-propertyName" },
    { tag: tags.operator, class: "tok-operator" },
    { tag: tags.comment, class: "tok-comment" },
    { tag: tags.meta, class: "tok-meta" },
    { tag: tags.invalid, class: "tok-invalid" },
    { tag: tags.punctuation, class: "tok-punctuation" }
  ]);

  // node_modules/@codemirror/language/dist/index.js
  var _a;
  var languageDataProp = /* @__PURE__ */ new NodeProp();
  function defineLanguageFacet(baseData) {
    return Facet.define({
      combine: baseData ? (values) => values.concat(baseData) : void 0
    });
  }
  var sublanguageProp = /* @__PURE__ */ new NodeProp();
  var Language = class {
    /**
    Construct a language object. If you need to invoke this
    directly, first define a data facet with
    [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
    configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
    to the language's outer syntax node.
    */
    constructor(data, parser2, extraExtensions = [], name16 = "") {
      this.data = data;
      this.name = name16;
      if (!EditorState.prototype.hasOwnProperty("tree"))
        Object.defineProperty(EditorState.prototype, "tree", { get() {
          return syntaxTree(this);
        } });
      this.parser = parser2;
      this.extension = [
        language.of(this),
        EditorState.languageData.of((state4, pos, side) => {
          let top4 = topNodeAt(state4, pos, side), data2 = top4.type.prop(languageDataProp);
          if (!data2)
            return [];
          let base2 = state4.facet(data2), sub2 = top4.type.prop(sublanguageProp);
          if (sub2) {
            let innerNode = top4.resolve(pos - top4.from, side);
            for (let sublang of sub2)
              if (sublang.test(innerNode, state4)) {
                let data3 = state4.facet(sublang.facet);
                return sublang.type == "replace" ? data3 : data3.concat(base2);
              }
          }
          return base2;
        })
      ].concat(extraExtensions);
    }
    /**
    Query whether this language is active at the given position.
    */
    isActiveAt(state4, pos, side = -1) {
      return topNodeAt(state4, pos, side).type.prop(languageDataProp) == this.data;
    }
    /**
    Find the document regions that were parsed using this language.
    The returned regions will _include_ any nested languages rooted
    in this language, when those exist.
    */
    findRegions(state4) {
      let lang2 = state4.facet(language);
      if ((lang2 === null || lang2 === void 0 ? void 0 : lang2.data) == this.data)
        return [{ from: 0, to: state4.doc.length }];
      if (!lang2 || !lang2.allowsNesting)
        return [];
      let result = [];
      let explore = (tree, from3) => {
        if (tree.prop(languageDataProp) == this.data) {
          result.push({ from: from3, to: from3 + tree.length });
          return;
        }
        let mount2 = tree.prop(NodeProp.mounted);
        if (mount2) {
          if (mount2.tree.prop(languageDataProp) == this.data) {
            if (mount2.overlay)
              for (let r2 of mount2.overlay)
                result.push({ from: r2.from + from3, to: r2.to + from3 });
            else
              result.push({ from: from3, to: from3 + tree.length });
            return;
          } else if (mount2.overlay) {
            let size5 = result.length;
            explore(mount2.tree, mount2.overlay[0].from + from3);
            if (result.length > size5)
              return;
          }
        }
        for (let i2 = 0; i2 < tree.children.length; i2++) {
          let ch = tree.children[i2];
          if (ch instanceof Tree)
            explore(ch, tree.positions[i2] + from3);
        }
      };
      explore(syntaxTree(state4), 0);
      return result;
    }
    /**
    Indicates whether this language allows nested languages. The
    default implementation returns true.
    */
    get allowsNesting() {
      return true;
    }
  };
  Language.setState = /* @__PURE__ */ StateEffect.define();
  function topNodeAt(state4, pos, side) {
    let topLang = state4.facet(language), tree = syntaxTree(state4).topNode;
    if (!topLang || topLang.allowsNesting) {
      for (let node = tree; node; node = node.enter(pos, side, IterMode.ExcludeBuffers))
        if (node.type.isTop)
          tree = node;
    }
    return tree;
  }
  var LRLanguage = class _LRLanguage extends Language {
    constructor(data, parser2, name16) {
      super(data, parser2, [], name16);
      this.parser = parser2;
    }
    /**
    Define a language from a parser.
    */
    static define(spec) {
      let data = defineLanguageFacet(spec.languageData);
      return new _LRLanguage(data, spec.parser.configure({
        props: [languageDataProp.add((type) => type.isTop ? data : void 0)]
      }), spec.name);
    }
    /**
    Create a new instance of this language with a reconfigured
    version of its parser and optionally a new name.
    */
    configure(options2, name16) {
      return new _LRLanguage(this.data, this.parser.configure(options2), name16 || this.name);
    }
    get allowsNesting() {
      return this.parser.hasWrappers();
    }
  };
  function syntaxTree(state4) {
    let field = state4.field(Language.state, false);
    return field ? field.tree : Tree.empty;
  }
  var DocInput = class {
    /**
    Create an input object for the given document.
    */
    constructor(doc2) {
      this.doc = doc2;
      this.cursorPos = 0;
      this.string = "";
      this.cursor = doc2.iter();
    }
    get length() {
      return this.doc.length;
    }
    syncTo(pos) {
      this.string = this.cursor.next(pos - this.cursorPos).value;
      this.cursorPos = pos + this.string.length;
      return this.cursorPos - this.string.length;
    }
    chunk(pos) {
      this.syncTo(pos);
      return this.string;
    }
    get lineChunks() {
      return true;
    }
    read(from3, to3) {
      let stringStart = this.cursorPos - this.string.length;
      if (from3 < stringStart || to3 >= this.cursorPos)
        return this.doc.sliceString(from3, to3);
      else
        return this.string.slice(from3 - stringStart, to3 - stringStart);
    }
  };
  var currentContext = null;
  var ParseContext = class _ParseContext {
    constructor(parser2, state4, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
      this.parser = parser2;
      this.state = state4;
      this.fragments = fragments;
      this.tree = tree;
      this.treeLen = treeLen;
      this.viewport = viewport;
      this.skipped = skipped;
      this.scheduleOn = scheduleOn;
      this.parse = null;
      this.tempSkipped = [];
    }
    /**
    @internal
    */
    static create(parser2, state4, viewport) {
      return new _ParseContext(parser2, state4, [], Tree.empty, 0, viewport, [], null);
    }
    startParse() {
      return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
    }
    /**
    @internal
    */
    work(until, upto) {
      if (upto != null && upto >= this.state.doc.length)
        upto = void 0;
      if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
        this.takeTree();
        return true;
      }
      return this.withContext(() => {
        var _a2;
        if (typeof until == "number") {
          let endTime = Date.now() + until;
          until = () => Date.now() > endTime;
        }
        if (!this.parse)
          this.parse = this.startParse();
        if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
          this.parse.stopAt(upto);
        for (; ; ) {
          let done = this.parse.advance();
          if (done) {
            this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
            this.treeLen = (_a2 = this.parse.stoppedAt) !== null && _a2 !== void 0 ? _a2 : this.state.doc.length;
            this.tree = done;
            this.parse = null;
            if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
              this.parse = this.startParse();
            else
              return true;
          }
          if (until())
            return false;
        }
      });
    }
    /**
    @internal
    */
    takeTree() {
      let pos, tree;
      if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
        if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
          this.parse.stopAt(pos);
        this.withContext(() => {
          while (!(tree = this.parse.advance())) {
          }
        });
        this.treeLen = pos;
        this.tree = tree;
        this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
        this.parse = null;
      }
    }
    withContext(f2) {
      let prev = currentContext;
      currentContext = this;
      try {
        return f2();
      } finally {
        currentContext = prev;
      }
    }
    withoutTempSkipped(fragments) {
      for (let r2; r2 = this.tempSkipped.pop(); )
        fragments = cutFragments(fragments, r2.from, r2.to);
      return fragments;
    }
    /**
    @internal
    */
    changes(changes, newState) {
      let { fragments, tree, treeLen, viewport, skipped } = this;
      this.takeTree();
      if (!changes.empty) {
        let ranges = [];
        changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
        fragments = TreeFragment.applyChanges(fragments, ranges);
        tree = Tree.empty;
        treeLen = 0;
        viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
        if (this.skipped.length) {
          skipped = [];
          for (let r2 of this.skipped) {
            let from3 = changes.mapPos(r2.from, 1), to3 = changes.mapPos(r2.to, -1);
            if (from3 < to3)
              skipped.push({ from: from3, to: to3 });
          }
        }
      }
      return new _ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
    }
    /**
    @internal
    */
    updateViewport(viewport) {
      if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
        return false;
      this.viewport = viewport;
      let startLen = this.skipped.length;
      for (let i2 = 0; i2 < this.skipped.length; i2++) {
        let { from: from3, to: to3 } = this.skipped[i2];
        if (from3 < viewport.to && to3 > viewport.from) {
          this.fragments = cutFragments(this.fragments, from3, to3);
          this.skipped.splice(i2--, 1);
        }
      }
      if (this.skipped.length >= startLen)
        return false;
      this.reset();
      return true;
    }
    /**
    @internal
    */
    reset() {
      if (this.parse) {
        this.takeTree();
        this.parse = null;
      }
    }
    /**
    Notify the parse scheduler that the given region was skipped
    because it wasn't in view, and the parse should be restarted
    when it comes into view.
    */
    skipUntilInView(from3, to3) {
      this.skipped.push({ from: from3, to: to3 });
    }
    /**
    Returns a parser intended to be used as placeholder when
    asynchronously loading a nested parser. It'll skip its input and
    mark it as not-really-parsed, so that the next update will parse
    it again.
    
    When `until` is given, a reparse will be scheduled when that
    promise resolves.
    */
    static getSkippingParser(until) {
      return new class extends Parser {
        createParse(input, fragments, ranges) {
          let from3 = ranges[0].from, to3 = ranges[ranges.length - 1].to;
          let parser2 = {
            parsedPos: from3,
            advance() {
              let cx = currentContext;
              if (cx) {
                for (let r2 of ranges)
                  cx.tempSkipped.push(r2);
                if (until)
                  cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
              }
              this.parsedPos = to3;
              return new Tree(NodeType.none, [], [], to3 - from3);
            },
            stoppedAt: null,
            stopAt() {
            }
          };
          return parser2;
        }
      }();
    }
    /**
    @internal
    */
    isDone(upto) {
      upto = Math.min(upto, this.state.doc.length);
      let frags = this.fragments;
      return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
    }
    /**
    Get the context for the current parse, or `null` if no editor
    parse is in progress.
    */
    static get() {
      return currentContext;
    }
  };
  function cutFragments(fragments, from3, to3) {
    return TreeFragment.applyChanges(fragments, [{ fromA: from3, toA: to3, fromB: from3, toB: to3 }]);
  }
  var LanguageState = class _LanguageState {
    constructor(context3) {
      this.context = context3;
      this.tree = context3.tree;
    }
    apply(tr) {
      if (!tr.docChanged && this.tree == this.context.tree)
        return this;
      let newCx = this.context.changes(tr.changes, tr.state);
      let upto = this.context.treeLen == tr.startState.doc.length ? void 0 : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
      if (!newCx.work(20, upto))
        newCx.takeTree();
      return new _LanguageState(newCx);
    }
    static init(state4) {
      let vpTo = Math.min(3e3, state4.doc.length);
      let parseState = ParseContext.create(state4.facet(language).parser, state4, { from: 0, to: vpTo });
      if (!parseState.work(20, vpTo))
        parseState.takeTree();
      return new _LanguageState(parseState);
    }
  };
  Language.state = /* @__PURE__ */ StateField.define({
    create: LanguageState.init,
    update(value12, tr) {
      for (let e2 of tr.effects)
        if (e2.is(Language.setState))
          return e2.value;
      if (tr.startState.facet(language) != tr.state.facet(language))
        return LanguageState.init(tr.state);
      return value12.apply(tr);
    }
  });
  var requestIdle = (callback) => {
    let timeout = setTimeout(
      () => callback(),
      500
      /* Work.MaxPause */
    );
    return () => clearTimeout(timeout);
  };
  if (typeof requestIdleCallback != "undefined")
    requestIdle = (callback) => {
      let idle = -1, timeout = setTimeout(
        () => {
          idle = requestIdleCallback(callback, {
            timeout: 500 - 100
            /* Work.MinPause */
          });
        },
        100
        /* Work.MinPause */
      );
      return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
    };
  var isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
  var parseWorker = /* @__PURE__ */ ViewPlugin.fromClass(class ParseWorker {
    constructor(view2) {
      this.view = view2;
      this.working = null;
      this.workScheduled = 0;
      this.chunkEnd = -1;
      this.chunkBudget = -1;
      this.work = this.work.bind(this);
      this.scheduleWork();
    }
    update(update3) {
      let cx = this.view.state.field(Language.state).context;
      if (cx.updateViewport(update3.view.viewport) || this.view.viewport.to > cx.treeLen)
        this.scheduleWork();
      if (update3.docChanged || update3.selectionSet) {
        if (this.view.hasFocus)
          this.chunkBudget += 50;
        this.scheduleWork();
      }
      this.checkAsyncSchedule(cx);
    }
    scheduleWork() {
      if (this.working)
        return;
      let { state: state4 } = this.view, field = state4.field(Language.state);
      if (field.tree != field.context.tree || !field.context.isDone(state4.doc.length))
        this.working = requestIdle(this.work);
    }
    work(deadline) {
      this.working = null;
      let now3 = Date.now();
      if (this.chunkEnd < now3 && (this.chunkEnd < 0 || this.view.hasFocus)) {
        this.chunkEnd = now3 + 3e4;
        this.chunkBudget = 3e3;
      }
      if (this.chunkBudget <= 0)
        return;
      let { state: state4, viewport: { to: vpTo } } = this.view, field = state4.field(Language.state);
      if (field.tree == field.context.tree && field.context.isDone(
        vpTo + 1e5
        /* Work.MaxParseAhead */
      ))
        return;
      let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
      let viewportFirst = field.context.treeLen < vpTo && state4.doc.length > vpTo + 1e3;
      let done = field.context.work(() => {
        return isInputPending && isInputPending() || Date.now() > endTime;
      }, vpTo + (viewportFirst ? 0 : 1e5));
      this.chunkBudget -= Date.now() - now3;
      if (done || this.chunkBudget <= 0) {
        field.context.takeTree();
        this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
      }
      if (this.chunkBudget > 0 && !(done && !viewportFirst))
        this.scheduleWork();
      this.checkAsyncSchedule(field.context);
    }
    checkAsyncSchedule(cx) {
      if (cx.scheduleOn) {
        this.workScheduled++;
        cx.scheduleOn.then(() => this.scheduleWork()).catch((err) => logException(this.view.state, err)).then(() => this.workScheduled--);
        cx.scheduleOn = null;
      }
    }
    destroy() {
      if (this.working)
        this.working();
    }
    isWorking() {
      return !!(this.working || this.workScheduled > 0);
    }
  }, {
    eventHandlers: { focus() {
      this.scheduleWork();
    } }
  });
  var language = /* @__PURE__ */ Facet.define({
    combine(languages2) {
      return languages2.length ? languages2[0] : null;
    },
    enables: (language3) => [
      Language.state,
      parseWorker,
      EditorView.contentAttributes.compute([language3], (state4) => {
        let lang2 = state4.facet(language3);
        return lang2 && lang2.name ? { "data-language": lang2.name } : {};
      })
    ]
  });
  var LanguageSupport = class {
    /**
    Create a language support object.
    */
    constructor(language3, support = []) {
      this.language = language3;
      this.support = support;
      this.extension = [language3, support];
    }
  };
  var indentService = /* @__PURE__ */ Facet.define();
  var indentUnit = /* @__PURE__ */ Facet.define({
    combine: (values) => {
      if (!values.length)
        return "  ";
      let unit2 = values[0];
      if (!unit2 || /\S/.test(unit2) || Array.from(unit2).some((e2) => e2 != unit2[0]))
        throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
      return unit2;
    }
  });
  function getIndentUnit(state4) {
    let unit2 = state4.facet(indentUnit);
    return unit2.charCodeAt(0) == 9 ? state4.tabSize * unit2.length : unit2.length;
  }
  function indentString(state4, cols2) {
    let result = "", ts = state4.tabSize, ch = state4.facet(indentUnit)[0];
    if (ch == "	") {
      while (cols2 >= ts) {
        result += "	";
        cols2 -= ts;
      }
      ch = " ";
    }
    for (let i2 = 0; i2 < cols2; i2++)
      result += ch;
    return result;
  }
  function getIndentation(context3, pos) {
    if (context3 instanceof EditorState)
      context3 = new IndentContext(context3);
    for (let service of context3.state.facet(indentService)) {
      let result = service(context3, pos);
      if (result !== void 0)
        return result;
    }
    let tree = syntaxTree(context3.state);
    return tree.length >= pos ? syntaxIndentation(context3, tree, pos) : null;
  }
  var IndentContext = class {
    /**
    Create an indent context.
    */
    constructor(state4, options2 = {}) {
      this.state = state4;
      this.options = options2;
      this.unit = getIndentUnit(state4);
    }
    /**
    Get a description of the line at the given position, taking
    [simulated line
    breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
    into account. If there is such a break at `pos`, the `bias`
    argument determines whether the part of the line line before or
    after the break is used.
    */
    lineAt(pos, bias = 1) {
      let line = this.state.doc.lineAt(pos);
      let { simulateBreak, simulateDoubleBreak } = this.options;
      if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
        if (simulateDoubleBreak && simulateBreak == pos)
          return { text: "", from: pos };
        else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
          return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };
        else
          return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };
      }
      return line;
    }
    /**
    Get the text directly after `pos`, either the entire line
    or the next 100 characters, whichever is shorter.
    */
    textAfterPos(pos, bias = 1) {
      if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
        return "";
      let { text: text6, from: from3 } = this.lineAt(pos, bias);
      return text6.slice(pos - from3, Math.min(text6.length, pos + 100 - from3));
    }
    /**
    Find the column for the given position.
    */
    column(pos, bias = 1) {
      let { text: text6, from: from3 } = this.lineAt(pos, bias);
      let result = this.countColumn(text6, pos - from3);
      let override = this.options.overrideIndentation ? this.options.overrideIndentation(from3) : -1;
      if (override > -1)
        result += override - this.countColumn(text6, text6.search(/\S|$/));
      return result;
    }
    /**
    Find the column position (taking tabs into account) of the given
    position in the given string.
    */
    countColumn(line, pos = line.length) {
      return countColumn(line, this.state.tabSize, pos);
    }
    /**
    Find the indentation column of the line at the given point.
    */
    lineIndent(pos, bias = 1) {
      let { text: text6, from: from3 } = this.lineAt(pos, bias);
      let override = this.options.overrideIndentation;
      if (override) {
        let overriden = override(from3);
        if (overriden > -1)
          return overriden;
      }
      return this.countColumn(text6, text6.search(/\S|$/));
    }
    /**
    Returns the [simulated line
    break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
    for this context, if any.
    */
    get simulatedBreak() {
      return this.options.simulateBreak || null;
    }
  };
  var indentNodeProp = /* @__PURE__ */ new NodeProp();
  function syntaxIndentation(cx, ast, pos) {
    let stack = ast.resolveStack(pos);
    let inner = stack.node.enterUnfinishedNodesBefore(pos);
    if (inner != stack.node) {
      let add5 = [];
      for (let cur2 = inner; cur2 != stack.node; cur2 = cur2.parent)
        add5.push(cur2);
      for (let i2 = add5.length - 1; i2 >= 0; i2--)
        stack = { node: add5[i2], next: stack };
    }
    return indentFor(stack, cx, pos);
  }
  function indentFor(stack, cx, pos) {
    for (let cur2 = stack; cur2; cur2 = cur2.next) {
      let strategy = indentStrategy(cur2.node);
      if (strategy)
        return strategy(TreeIndentContext.create(cx, pos, cur2));
    }
    return 0;
  }
  function ignoreClosed(cx) {
    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
  }
  function indentStrategy(tree) {
    let strategy = tree.type.prop(indentNodeProp);
    if (strategy)
      return strategy;
    let first = tree.firstChild, close2;
    if (first && (close2 = first.type.prop(NodeProp.closedBy))) {
      let last4 = tree.lastChild, closed = last4 && close2.indexOf(last4.name) > -1;
      return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last4.from : void 0);
    }
    return tree.parent == null ? topIndent : null;
  }
  function topIndent() {
    return 0;
  }
  var TreeIndentContext = class _TreeIndentContext extends IndentContext {
    constructor(base2, pos, context3) {
      super(base2.state, base2.options);
      this.base = base2;
      this.pos = pos;
      this.context = context3;
    }
    /**
    The syntax tree node to which the indentation strategy
    applies.
    */
    get node() {
      return this.context.node;
    }
    /**
    @internal
    */
    static create(base2, pos, context3) {
      return new _TreeIndentContext(base2, pos, context3);
    }
    /**
    Get the text directly after `this.pos`, either the entire line
    or the next 100 characters, whichever is shorter.
    */
    get textAfter() {
      return this.textAfterPos(this.pos);
    }
    /**
    Get the indentation at the reference line for `this.node`, which
    is the line on which it starts, unless there is a node that is
    _not_ a parent of this node covering the start of that line. If
    so, the line at the start of that node is tried, again skipping
    on if it is covered by another such node.
    */
    get baseIndent() {
      return this.baseIndentFor(this.node);
    }
    /**
    Get the indentation for the reference line of the given node
    (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
    */
    baseIndentFor(node) {
      let line = this.state.doc.lineAt(node.from);
      for (; ; ) {
        let atBreak = node.resolve(line.from);
        while (atBreak.parent && atBreak.parent.from == atBreak.from)
          atBreak = atBreak.parent;
        if (isParent(atBreak, node))
          break;
        line = this.state.doc.lineAt(atBreak.from);
      }
      return this.lineIndent(line.from);
    }
    /**
    Continue looking for indentations in the node's parent nodes,
    and return the result of that.
    */
    continue() {
      return indentFor(this.context.next, this.base, this.pos);
    }
  };
  function isParent(parent2, of) {
    for (let cur2 = of; cur2; cur2 = cur2.parent)
      if (parent2 == cur2)
        return true;
    return false;
  }
  function bracketedAligned(context3) {
    let tree = context3.node;
    let openToken = tree.childAfter(tree.from), last4 = tree.lastChild;
    if (!openToken)
      return null;
    let sim = context3.options.simulateBreak;
    let openLine = context3.state.doc.lineAt(openToken.from);
    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
    for (let pos = openToken.to; ; ) {
      let next = tree.childAfter(pos);
      if (!next || next == last4)
        return null;
      if (!next.type.isSkipped) {
        if (next.from >= lineEnd)
          return null;
        let space2 = /^ */.exec(openLine.text.slice(openToken.to - openLine.from))[0].length;
        return { from: openToken.from, to: openToken.to + space2 };
      }
      pos = next.to;
    }
  }
  function delimitedIndent({ closing: closing2, align = true, units = 1 }) {
    return (context3) => delimitedStrategy(context3, align, units, closing2);
  }
  function delimitedStrategy(context3, align, units, closing2, closedAt) {
    let after = context3.textAfter, space2 = after.match(/^\s*/)[0].length;
    let closed = closing2 && after.slice(space2, space2 + closing2.length) == closing2 || closedAt == context3.pos + space2;
    let aligned = align ? bracketedAligned(context3) : null;
    if (aligned)
      return closed ? context3.column(aligned.from) : context3.column(aligned.to);
    return context3.baseIndent + (closed ? 0 : context3.unit * units);
  }
  var flatIndent = (context3) => context3.baseIndent;
  function continuedIndent({ except: except3, units = 1 } = {}) {
    return (context3) => {
      let matchExcept = except3 && except3.test(context3.textAfter);
      return context3.baseIndent + (matchExcept ? 0 : units * context3.unit);
    };
  }
  var DontIndentBeyond = 200;
  function indentOnInput() {
    return EditorState.transactionFilter.of((tr) => {
      if (!tr.docChanged || !tr.isUserEvent("input.type") && !tr.isUserEvent("input.complete"))
        return tr;
      let rules2 = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
      if (!rules2.length)
        return tr;
      let doc2 = tr.newDoc, { head: head5 } = tr.newSelection.main, line = doc2.lineAt(head5);
      if (head5 > line.from + DontIndentBeyond)
        return tr;
      let lineStart = doc2.sliceString(line.from, head5);
      if (!rules2.some((r2) => r2.test(lineStart)))
        return tr;
      let { state: state4 } = tr, last4 = -1, changes = [];
      for (let { head: head6 } of state4.selection.ranges) {
        let line2 = state4.doc.lineAt(head6);
        if (line2.from == last4)
          continue;
        last4 = line2.from;
        let indent = getIndentation(state4, line2.from);
        if (indent == null)
          continue;
        let cur2 = /^\s*/.exec(line2.text)[0];
        let norm = indentString(state4, indent);
        if (cur2 != norm)
          changes.push({ from: line2.from, to: line2.from + cur2.length, insert: norm });
      }
      return changes.length ? [tr, { changes, sequential: true }] : tr;
    });
  }
  var foldService = /* @__PURE__ */ Facet.define();
  var foldNodeProp = /* @__PURE__ */ new NodeProp();
  function foldInside(node) {
    let first = node.firstChild, last4 = node.lastChild;
    return first && first.to < last4.from ? { from: first.to, to: last4.type.isError ? node.to : last4.from } : null;
  }
  function syntaxFolding(state4, start3, end) {
    let tree = syntaxTree(state4);
    if (tree.length < end)
      return null;
    let stack = tree.resolveStack(end, 1);
    let found = null;
    for (let iter = stack; iter; iter = iter.next) {
      let cur2 = iter.node;
      if (cur2.to <= end || cur2.from > end)
        continue;
      if (found && cur2.from < start3)
        break;
      let prop = cur2.type.prop(foldNodeProp);
      if (prop && (cur2.to < tree.length - 50 || tree.length == state4.doc.length || !isUnfinished(cur2))) {
        let value12 = prop(cur2, state4);
        if (value12 && value12.from <= end && value12.from >= start3 && value12.to > end)
          found = value12;
      }
    }
    return found;
  }
  function isUnfinished(node) {
    let ch = node.lastChild;
    return ch && ch.to == node.to && ch.type.isError;
  }
  function foldable(state4, lineStart, lineEnd) {
    for (let service of state4.facet(foldService)) {
      let result = service(state4, lineStart, lineEnd);
      if (result)
        return result;
    }
    return syntaxFolding(state4, lineStart, lineEnd);
  }
  function mapRange(range3, mapping) {
    let from3 = mapping.mapPos(range3.from, 1), to3 = mapping.mapPos(range3.to, -1);
    return from3 >= to3 ? void 0 : { from: from3, to: to3 };
  }
  var foldEffect = /* @__PURE__ */ StateEffect.define({ map: mapRange });
  var unfoldEffect = /* @__PURE__ */ StateEffect.define({ map: mapRange });
  function selectedLines(view2) {
    let lines = [];
    for (let { head: head5 } of view2.state.selection.ranges) {
      if (lines.some((l2) => l2.from <= head5 && l2.to >= head5))
        continue;
      lines.push(view2.lineBlockAt(head5));
    }
    return lines;
  }
  var foldState = /* @__PURE__ */ StateField.define({
    create() {
      return Decoration.none;
    },
    update(folded, tr) {
      folded = folded.map(tr.changes);
      for (let e2 of tr.effects) {
        if (e2.is(foldEffect) && !foldExists(folded, e2.value.from, e2.value.to)) {
          let { preparePlaceholder } = tr.state.facet(foldConfig);
          let widget = !preparePlaceholder ? foldWidget : Decoration.replace({ widget: new PreparedFoldWidget(preparePlaceholder(tr.state, e2.value)) });
          folded = folded.update({ add: [widget.range(e2.value.from, e2.value.to)] });
        } else if (e2.is(unfoldEffect)) {
          folded = folded.update({
            filter: (from3, to3) => e2.value.from != from3 || e2.value.to != to3,
            filterFrom: e2.value.from,
            filterTo: e2.value.to
          });
        }
      }
      if (tr.selection) {
        let onSelection = false, { head: head5 } = tr.selection.main;
        folded.between(head5, head5, (a2, b2) => {
          if (a2 < head5 && b2 > head5)
            onSelection = true;
        });
        if (onSelection)
          folded = folded.update({
            filterFrom: head5,
            filterTo: head5,
            filter: (a2, b2) => b2 <= head5 || a2 >= head5
          });
      }
      return folded;
    },
    provide: (f2) => EditorView.decorations.from(f2),
    toJSON(folded, state4) {
      let ranges = [];
      folded.between(0, state4.doc.length, (from3, to3) => {
        ranges.push(from3, to3);
      });
      return ranges;
    },
    fromJSON(value12) {
      if (!Array.isArray(value12) || value12.length % 2)
        throw new RangeError("Invalid JSON for fold state");
      let ranges = [];
      for (let i2 = 0; i2 < value12.length; ) {
        let from3 = value12[i2++], to3 = value12[i2++];
        if (typeof from3 != "number" || typeof to3 != "number")
          throw new RangeError("Invalid JSON for fold state");
        ranges.push(foldWidget.range(from3, to3));
      }
      return Decoration.set(ranges, true);
    }
  });
  function findFold(state4, from3, to3) {
    var _a2;
    let found = null;
    (_a2 = state4.field(foldState, false)) === null || _a2 === void 0 ? void 0 : _a2.between(from3, to3, (from4, to4) => {
      if (!found || found.from > from4)
        found = { from: from4, to: to4 };
    });
    return found;
  }
  function foldExists(folded, from3, to3) {
    let found = false;
    folded.between(from3, from3, (a2, b2) => {
      if (a2 == from3 && b2 == to3)
        found = true;
    });
    return found;
  }
  function maybeEnable(state4, other) {
    return state4.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));
  }
  var foldCode = (view2) => {
    for (let line of selectedLines(view2)) {
      let range3 = foldable(view2.state, line.from, line.to);
      if (range3) {
        view2.dispatch({ effects: maybeEnable(view2.state, [foldEffect.of(range3), announceFold(view2, range3)]) });
        return true;
      }
    }
    return false;
  };
  var unfoldCode = (view2) => {
    if (!view2.state.field(foldState, false))
      return false;
    let effects = [];
    for (let line of selectedLines(view2)) {
      let folded = findFold(view2.state, line.from, line.to);
      if (folded)
        effects.push(unfoldEffect.of(folded), announceFold(view2, folded, false));
    }
    if (effects.length)
      view2.dispatch({ effects });
    return effects.length > 0;
  };
  function announceFold(view2, range3, fold3 = true) {
    let lineFrom = view2.state.doc.lineAt(range3.from).number, lineTo = view2.state.doc.lineAt(range3.to).number;
    return EditorView.announce.of(`${view2.state.phrase(fold3 ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view2.state.phrase("to")} ${lineTo}.`);
  }
  var foldAll = (view2) => {
    let { state: state4 } = view2, effects = [];
    for (let pos = 0; pos < state4.doc.length; ) {
      let line = view2.lineBlockAt(pos), range3 = foldable(state4, line.from, line.to);
      if (range3)
        effects.push(foldEffect.of(range3));
      pos = (range3 ? view2.lineBlockAt(range3.to) : line).to + 1;
    }
    if (effects.length)
      view2.dispatch({ effects: maybeEnable(view2.state, effects) });
    return !!effects.length;
  };
  var unfoldAll = (view2) => {
    let field = view2.state.field(foldState, false);
    if (!field || !field.size)
      return false;
    let effects = [];
    field.between(0, view2.state.doc.length, (from3, to3) => {
      effects.push(unfoldEffect.of({ from: from3, to: to3 }));
    });
    view2.dispatch({ effects });
    return true;
  };
  var foldKeymap = [
    { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: foldCode },
    { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: unfoldCode },
    { key: "Ctrl-Alt-[", run: foldAll },
    { key: "Ctrl-Alt-]", run: unfoldAll }
  ];
  var defaultConfig = {
    placeholderDOM: null,
    preparePlaceholder: null,
    placeholderText: "\u2026"
  };
  var foldConfig = /* @__PURE__ */ Facet.define({
    combine(values) {
      return combineConfig(values, defaultConfig);
    }
  });
  function codeFolding(config2) {
    let result = [foldState, baseTheme$12];
    if (config2)
      result.push(foldConfig.of(config2));
    return result;
  }
  function widgetToDOM(view2, prepared) {
    let { state: state4 } = view2, conf = state4.facet(foldConfig);
    let onclick = (event) => {
      let line = view2.lineBlockAt(view2.posAtDOM(event.target));
      let folded = findFold(view2.state, line.from, line.to);
      if (folded)
        view2.dispatch({ effects: unfoldEffect.of(folded) });
      event.preventDefault();
    };
    if (conf.placeholderDOM)
      return conf.placeholderDOM(view2, onclick, prepared);
    let element = document.createElement("span");
    element.textContent = conf.placeholderText;
    element.setAttribute("aria-label", state4.phrase("folded code"));
    element.title = state4.phrase("unfold");
    element.className = "cm-foldPlaceholder";
    element.onclick = onclick;
    return element;
  }
  var foldWidget = /* @__PURE__ */ Decoration.replace({ widget: /* @__PURE__ */ new class extends WidgetType {
    toDOM(view2) {
      return widgetToDOM(view2, null);
    }
  }() });
  var PreparedFoldWidget = class extends WidgetType {
    constructor(value12) {
      super();
      this.value = value12;
    }
    eq(other) {
      return this.value == other.value;
    }
    toDOM(view2) {
      return widgetToDOM(view2, this.value);
    }
  };
  var foldGutterDefaults = {
    openText: "\u2304",
    closedText: "\u203A",
    markerDOM: null,
    domEventHandlers: {},
    foldingChanged: () => false
  };
  var FoldMarker = class extends GutterMarker {
    constructor(config2, open) {
      super();
      this.config = config2;
      this.open = open;
    }
    eq(other) {
      return this.config == other.config && this.open == other.open;
    }
    toDOM(view2) {
      if (this.config.markerDOM)
        return this.config.markerDOM(this.open);
      let span4 = document.createElement("span");
      span4.textContent = this.open ? this.config.openText : this.config.closedText;
      span4.title = view2.state.phrase(this.open ? "Fold line" : "Unfold line");
      return span4;
    }
  };
  function foldGutter(config2 = {}) {
    let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config2);
    let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
    let markers = ViewPlugin.fromClass(class {
      constructor(view2) {
        this.from = view2.viewport.from;
        this.markers = this.buildMarkers(view2);
      }
      update(update3) {
        if (update3.docChanged || update3.viewportChanged || update3.startState.facet(language) != update3.state.facet(language) || update3.startState.field(foldState, false) != update3.state.field(foldState, false) || syntaxTree(update3.startState) != syntaxTree(update3.state) || fullConfig.foldingChanged(update3))
          this.markers = this.buildMarkers(update3.view);
      }
      buildMarkers(view2) {
        let builder = new RangeSetBuilder();
        for (let line of view2.viewportLineBlocks) {
          let mark = findFold(view2.state, line.from, line.to) ? canUnfold : foldable(view2.state, line.from, line.to) ? canFold : null;
          if (mark)
            builder.add(line.from, line.from, mark);
        }
        return builder.finish();
      }
    });
    let { domEventHandlers } = fullConfig;
    return [
      markers,
      gutter({
        class: "cm-foldGutter",
        markers(view2) {
          var _a2;
          return ((_a2 = view2.plugin(markers)) === null || _a2 === void 0 ? void 0 : _a2.markers) || RangeSet.empty;
        },
        initialSpacer() {
          return new FoldMarker(fullConfig, false);
        },
        domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), { click: (view2, line, event) => {
          if (domEventHandlers.click && domEventHandlers.click(view2, line, event))
            return true;
          let folded = findFold(view2.state, line.from, line.to);
          if (folded) {
            view2.dispatch({ effects: unfoldEffect.of(folded) });
            return true;
          }
          let range3 = foldable(view2.state, line.from, line.to);
          if (range3) {
            view2.dispatch({ effects: foldEffect.of(range3) });
            return true;
          }
          return false;
        } })
      }),
      codeFolding()
    ];
  }
  var baseTheme$12 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-foldPlaceholder": {
      backgroundColor: "#eee",
      border: "1px solid #ddd",
      color: "#888",
      borderRadius: ".2em",
      margin: "0 1px",
      padding: "0 1px",
      cursor: "pointer"
    },
    ".cm-foldGutter span": {
      padding: "0 1px",
      cursor: "pointer"
    }
  });
  var HighlightStyle = class _HighlightStyle {
    constructor(specs, options2) {
      this.specs = specs;
      let modSpec;
      function def(spec) {
        let cls = StyleModule.newName();
        (modSpec || (modSpec = /* @__PURE__ */ Object.create(null)))["." + cls] = spec;
        return cls;
      }
      const all4 = typeof options2.all == "string" ? options2.all : options2.all ? def(options2.all) : void 0;
      const scopeOpt = options2.scope;
      this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type) => type == scopeOpt : void 0;
      this.style = tagHighlighter(specs.map((style3) => ({
        tag: style3.tag,
        class: style3.class || def(Object.assign({}, style3, { tag: null }))
      })), {
        all: all4
      }).style;
      this.module = modSpec ? new StyleModule(modSpec) : null;
      this.themeType = options2.themeType;
    }
    /**
    Create a highlighter style that associates the given styles to
    the given tags. The specs must be objects that hold a style tag
    or array of tags in their `tag` property, and either a single
    `class` property providing a static CSS class (for highlighter
    that rely on external styling), or a
    [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
    set of CSS properties (which define the styling for those tags).
    
    The CSS rules created for a highlighter will be emitted in the
    order of the spec's properties. That means that for elements that
    have multiple tags associated with them, styles defined further
    down in the list will have a higher CSS precedence than styles
    defined earlier.
    */
    static define(specs, options2) {
      return new _HighlightStyle(specs, options2 || {});
    }
  };
  var highlighterFacet = /* @__PURE__ */ Facet.define();
  var fallbackHighlighter = /* @__PURE__ */ Facet.define({
    combine(values) {
      return values.length ? [values[0]] : null;
    }
  });
  function getHighlighters(state4) {
    let main4 = state4.facet(highlighterFacet);
    return main4.length ? main4 : state4.facet(fallbackHighlighter);
  }
  function syntaxHighlighting(highlighter, options2) {
    let ext = [treeHighlighter], themeType;
    if (highlighter instanceof HighlightStyle) {
      if (highlighter.module)
        ext.push(EditorView.styleModule.of(highlighter.module));
      themeType = highlighter.themeType;
    }
    if (options2 === null || options2 === void 0 ? void 0 : options2.fallback)
      ext.push(fallbackHighlighter.of(highlighter));
    else if (themeType)
      ext.push(highlighterFacet.computeN([EditorView.darkTheme], (state4) => {
        return state4.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
      }));
    else
      ext.push(highlighterFacet.of(highlighter));
    return ext;
  }
  var TreeHighlighter = class {
    constructor(view2) {
      this.markCache = /* @__PURE__ */ Object.create(null);
      this.tree = syntaxTree(view2.state);
      this.decorations = this.buildDeco(view2, getHighlighters(view2.state));
      this.decoratedTo = view2.viewport.to;
    }
    update(update3) {
      let tree = syntaxTree(update3.state), highlighters = getHighlighters(update3.state);
      let styleChange = highlighters != getHighlighters(update3.startState);
      let { viewport } = update3.view, decoratedToMapped = update3.changes.mapPos(this.decoratedTo, 1);
      if (tree.length < viewport.to && !styleChange && tree.type == this.tree.type && decoratedToMapped >= viewport.to) {
        this.decorations = this.decorations.map(update3.changes);
        this.decoratedTo = decoratedToMapped;
      } else if (tree != this.tree || update3.viewportChanged || styleChange) {
        this.tree = tree;
        this.decorations = this.buildDeco(update3.view, highlighters);
        this.decoratedTo = viewport.to;
      }
    }
    buildDeco(view2, highlighters) {
      if (!highlighters || !this.tree.length)
        return Decoration.none;
      let builder = new RangeSetBuilder();
      for (let { from: from3, to: to3 } of view2.visibleRanges) {
        highlightTree(this.tree, highlighters, (from4, to4, style3) => {
          builder.add(from4, to4, this.markCache[style3] || (this.markCache[style3] = Decoration.mark({ class: style3 })));
        }, from3, to3);
      }
      return builder.finish();
    }
  };
  var treeHighlighter = /* @__PURE__ */ Prec.high(/* @__PURE__ */ ViewPlugin.fromClass(TreeHighlighter, {
    decorations: (v2) => v2.decorations
  }));
  var defaultHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
    {
      tag: tags.meta,
      color: "#404740"
    },
    {
      tag: tags.link,
      textDecoration: "underline"
    },
    {
      tag: tags.heading,
      textDecoration: "underline",
      fontWeight: "bold"
    },
    {
      tag: tags.emphasis,
      fontStyle: "italic"
    },
    {
      tag: tags.strong,
      fontWeight: "bold"
    },
    {
      tag: tags.strikethrough,
      textDecoration: "line-through"
    },
    {
      tag: tags.keyword,
      color: "#708"
    },
    {
      tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
      color: "#219"
    },
    {
      tag: [tags.literal, tags.inserted],
      color: "#164"
    },
    {
      tag: [tags.string, tags.deleted],
      color: "#a11"
    },
    {
      tag: [tags.regexp, tags.escape, /* @__PURE__ */ tags.special(tags.string)],
      color: "#e40"
    },
    {
      tag: /* @__PURE__ */ tags.definition(tags.variableName),
      color: "#00f"
    },
    {
      tag: /* @__PURE__ */ tags.local(tags.variableName),
      color: "#30a"
    },
    {
      tag: [tags.typeName, tags.namespace],
      color: "#085"
    },
    {
      tag: tags.className,
      color: "#167"
    },
    {
      tag: [/* @__PURE__ */ tags.special(tags.variableName), tags.macroName],
      color: "#256"
    },
    {
      tag: /* @__PURE__ */ tags.definition(tags.propertyName),
      color: "#00c"
    },
    {
      tag: tags.comment,
      color: "#940"
    },
    {
      tag: tags.invalid,
      color: "#f00"
    }
  ]);
  var baseTheme2 = /* @__PURE__ */ EditorView.baseTheme({
    "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
    "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
  });
  var DefaultScanDist = 1e4;
  var DefaultBrackets = "()[]{}";
  var bracketMatchingConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        afterCursor: true,
        brackets: DefaultBrackets,
        maxScanDistance: DefaultScanDist,
        renderMatch: defaultRenderMatch
      });
    }
  });
  var matchingMark = /* @__PURE__ */ Decoration.mark({ class: "cm-matchingBracket" });
  var nonmatchingMark = /* @__PURE__ */ Decoration.mark({ class: "cm-nonmatchingBracket" });
  function defaultRenderMatch(match2) {
    let decorations2 = [];
    let mark = match2.matched ? matchingMark : nonmatchingMark;
    decorations2.push(mark.range(match2.start.from, match2.start.to));
    if (match2.end)
      decorations2.push(mark.range(match2.end.from, match2.end.to));
    return decorations2;
  }
  var bracketMatchingState = /* @__PURE__ */ StateField.define({
    create() {
      return Decoration.none;
    },
    update(deco, tr) {
      if (!tr.docChanged && !tr.selection)
        return deco;
      let decorations2 = [];
      let config2 = tr.state.facet(bracketMatchingConfig);
      for (let range3 of tr.state.selection.ranges) {
        if (!range3.empty)
          continue;
        let match2 = matchBrackets(tr.state, range3.head, -1, config2) || range3.head > 0 && matchBrackets(tr.state, range3.head - 1, 1, config2) || config2.afterCursor && (matchBrackets(tr.state, range3.head, 1, config2) || range3.head < tr.state.doc.length && matchBrackets(tr.state, range3.head + 1, -1, config2));
        if (match2)
          decorations2 = decorations2.concat(config2.renderMatch(match2, tr.state));
      }
      return Decoration.set(decorations2, true);
    },
    provide: (f2) => EditorView.decorations.from(f2)
  });
  var bracketMatchingUnique = [
    bracketMatchingState,
    baseTheme2
  ];
  function bracketMatching(config2 = {}) {
    return [bracketMatchingConfig.of(config2), bracketMatchingUnique];
  }
  var bracketMatchingHandle = /* @__PURE__ */ new NodeProp();
  function matchingNodes(node, dir2, brackets) {
    let byProp = node.prop(dir2 < 0 ? NodeProp.openedBy : NodeProp.closedBy);
    if (byProp)
      return byProp;
    if (node.name.length == 1) {
      let index6 = brackets.indexOf(node.name);
      if (index6 > -1 && index6 % 2 == (dir2 < 0 ? 1 : 0))
        return [brackets[index6 + dir2]];
    }
    return null;
  }
  function findHandle(node) {
    let hasHandle = node.type.prop(bracketMatchingHandle);
    return hasHandle ? hasHandle(node.node) : node;
  }
  function matchBrackets(state4, pos, dir2, config2 = {}) {
    let maxScanDistance = config2.maxScanDistance || DefaultScanDist, brackets = config2.brackets || DefaultBrackets;
    let tree = syntaxTree(state4), node = tree.resolveInner(pos, dir2);
    for (let cur2 = node; cur2; cur2 = cur2.parent) {
      let matches2 = matchingNodes(cur2.type, dir2, brackets);
      if (matches2 && cur2.from < cur2.to) {
        let handle8 = findHandle(cur2);
        if (handle8 && (dir2 > 0 ? pos >= handle8.from && pos < handle8.to : pos > handle8.from && pos <= handle8.to))
          return matchMarkedBrackets(state4, pos, dir2, cur2, handle8, matches2, brackets);
      }
    }
    return matchPlainBrackets(state4, pos, dir2, tree, node.type, maxScanDistance, brackets);
  }
  function matchMarkedBrackets(_state, _pos, dir2, token, handle8, matching, brackets) {
    let parent2 = token.parent, firstToken = { from: handle8.from, to: handle8.to };
    let depth = 0, cursor = parent2 === null || parent2 === void 0 ? void 0 : parent2.cursor();
    if (cursor && (dir2 < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))
      do {
        if (dir2 < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
          if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {
            let endHandle = findHandle(cursor);
            return { start: firstToken, end: endHandle ? { from: endHandle.from, to: endHandle.to } : void 0, matched: true };
          } else if (matchingNodes(cursor.type, dir2, brackets)) {
            depth++;
          } else if (matchingNodes(cursor.type, -dir2, brackets)) {
            if (depth == 0) {
              let endHandle = findHandle(cursor);
              return {
                start: firstToken,
                end: endHandle && endHandle.from < endHandle.to ? { from: endHandle.from, to: endHandle.to } : void 0,
                matched: false
              };
            }
            depth--;
          }
        }
      } while (dir2 < 0 ? cursor.prevSibling() : cursor.nextSibling());
    return { start: firstToken, matched: false };
  }
  function matchPlainBrackets(state4, pos, dir2, tree, tokenType, maxScanDistance, brackets) {
    let startCh = dir2 < 0 ? state4.sliceDoc(pos - 1, pos) : state4.sliceDoc(pos, pos + 1);
    let bracket2 = brackets.indexOf(startCh);
    if (bracket2 < 0 || bracket2 % 2 == 0 != dir2 > 0)
      return null;
    let startToken = { from: dir2 < 0 ? pos - 1 : pos, to: dir2 > 0 ? pos + 1 : pos };
    let iter = state4.doc.iterRange(pos, dir2 > 0 ? state4.doc.length : 0), depth = 0;
    for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
      let text6 = iter.value;
      if (dir2 < 0)
        distance += text6.length;
      let basePos = pos + distance * dir2;
      for (let pos2 = dir2 > 0 ? 0 : text6.length - 1, end = dir2 > 0 ? text6.length : -1; pos2 != end; pos2 += dir2) {
        let found = brackets.indexOf(text6[pos2]);
        if (found < 0 || tree.resolveInner(basePos + pos2, 1).type != tokenType)
          continue;
        if (found % 2 == 0 == dir2 > 0) {
          depth++;
        } else if (depth == 1) {
          return { start: startToken, end: { from: basePos + pos2, to: basePos + pos2 + 1 }, matched: found >> 1 == bracket2 >> 1 };
        } else {
          depth--;
        }
      }
      if (dir2 > 0)
        distance += text6.length;
    }
    return iter.done ? { start: startToken, matched: false } : null;
  }
  var noTokens = /* @__PURE__ */ Object.create(null);
  var typeArray = [NodeType.none];
  var warned = [];
  var byTag = /* @__PURE__ */ Object.create(null);
  var defaultTable = /* @__PURE__ */ Object.create(null);
  for (let [legacyName, name16] of [
    ["variable", "variableName"],
    ["variable-2", "variableName.special"],
    ["string-2", "string.special"],
    ["def", "variableName.definition"],
    ["tag", "tagName"],
    ["attribute", "attributeName"],
    ["type", "typeName"],
    ["builtin", "variableName.standard"],
    ["qualifier", "modifier"],
    ["error", "invalid"],
    ["header", "heading"],
    ["property", "propertyName"]
  ])
    defaultTable[legacyName] = /* @__PURE__ */ createTokenType(noTokens, name16);
  function warnForPart(part, msg) {
    if (warned.indexOf(part) > -1)
      return;
    warned.push(part);
    console.warn(msg);
  }
  function createTokenType(extra, tagStr) {
    let tags$1 = [];
    for (let name17 of tagStr.split(" ")) {
      let found = [];
      for (let part of name17.split(".")) {
        let value12 = extra[part] || tags[part];
        if (!value12) {
          warnForPart(part, `Unknown highlighting tag ${part}`);
        } else if (typeof value12 == "function") {
          if (!found.length)
            warnForPart(part, `Modifier ${part} used at start of tag`);
          else
            found = found.map(value12);
        } else {
          if (found.length)
            warnForPart(part, `Tag ${part} used as modifier`);
          else
            found = Array.isArray(value12) ? value12 : [value12];
        }
      }
      for (let tag of found)
        tags$1.push(tag);
    }
    if (!tags$1.length)
      return 0;
    let name16 = tagStr.replace(/ /g, "_"), key = name16 + " " + tags$1.map((t3) => t3.id);
    let known = byTag[key];
    if (known)
      return known.id;
    let type = byTag[key] = NodeType.define({
      id: typeArray.length,
      name: name16,
      props: [styleTags({ [name16]: tags$1 })]
    });
    typeArray.push(type);
    return type.id;
  }
  var marks = {
    rtl: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "rtl" }, bidiIsolate: Direction.RTL }),
    ltr: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "ltr" }, bidiIsolate: Direction.LTR }),
    auto: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "auto" }, bidiIsolate: null })
  };

  // node_modules/@codemirror/commands/dist/index.js
  var toggleComment = (target5) => {
    let { state: state4 } = target5, line = state4.doc.lineAt(state4.selection.main.from), config2 = getConfig(target5.state, line.from);
    return config2.line ? toggleLineComment(target5) : config2.block ? toggleBlockCommentByLine(target5) : false;
  };
  function command(f2, option) {
    return ({ state: state4, dispatch }) => {
      if (state4.readOnly)
        return false;
      let tr = f2(option, state4);
      if (!tr)
        return false;
      dispatch(state4.update(tr));
      return true;
    };
  }
  var toggleLineComment = /* @__PURE__ */ command(
    changeLineComment,
    0
    /* CommentOption.Toggle */
  );
  var toggleBlockComment = /* @__PURE__ */ command(
    changeBlockComment,
    0
    /* CommentOption.Toggle */
  );
  var toggleBlockCommentByLine = /* @__PURE__ */ command(
    (o2, s2) => changeBlockComment(o2, s2, selectedLineRanges(s2)),
    0
    /* CommentOption.Toggle */
  );
  function getConfig(state4, pos) {
    let data = state4.languageDataAt("commentTokens", pos);
    return data.length ? data[0] : {};
  }
  var SearchMargin = 50;
  function findBlockComment(state4, { open, close: close2 }, from3, to3) {
    let textBefore = state4.sliceDoc(from3 - SearchMargin, from3);
    let textAfter = state4.sliceDoc(to3, to3 + SearchMargin);
    let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
    let beforeOff = textBefore.length - spaceBefore;
    if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close2.length) == close2) {
      return {
        open: { pos: from3 - spaceBefore, margin: spaceBefore && 1 },
        close: { pos: to3 + spaceAfter, margin: spaceAfter && 1 }
      };
    }
    let startText, endText;
    if (to3 - from3 <= 2 * SearchMargin) {
      startText = endText = state4.sliceDoc(from3, to3);
    } else {
      startText = state4.sliceDoc(from3, from3 + SearchMargin);
      endText = state4.sliceDoc(to3 - SearchMargin, to3);
    }
    let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
    let endOff = endText.length - endSpace - close2.length;
    if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close2.length) == close2) {
      return {
        open: {
          pos: from3 + startSpace + open.length,
          margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
        },
        close: {
          pos: to3 - endSpace - close2.length,
          margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
        }
      };
    }
    return null;
  }
  function selectedLineRanges(state4) {
    let ranges = [];
    for (let r2 of state4.selection.ranges) {
      let fromLine = state4.doc.lineAt(r2.from);
      let toLine = r2.to <= fromLine.to ? fromLine : state4.doc.lineAt(r2.to);
      if (toLine.from > fromLine.from && toLine.from == r2.to)
        toLine = r2.to == fromLine.to + 1 ? fromLine : state4.doc.lineAt(r2.to - 1);
      let last4 = ranges.length - 1;
      if (last4 >= 0 && ranges[last4].to > fromLine.from)
        ranges[last4].to = toLine.to;
      else
        ranges.push({ from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length, to: toLine.to });
    }
    return ranges;
  }
  function changeBlockComment(option, state4, ranges = state4.selection.ranges) {
    let tokens = ranges.map((r2) => getConfig(state4, r2.from).block);
    if (!tokens.every((c2) => c2))
      return null;
    let comments = ranges.map((r2, i2) => findBlockComment(state4, tokens[i2], r2.from, r2.to));
    if (option != 2 && !comments.every((c2) => c2)) {
      return { changes: state4.changes(ranges.map((range3, i2) => {
        if (comments[i2])
          return [];
        return [{ from: range3.from, insert: tokens[i2].open + " " }, { from: range3.to, insert: " " + tokens[i2].close }];
      })) };
    } else if (option != 1 && comments.some((c2) => c2)) {
      let changes = [];
      for (let i2 = 0, comment2; i2 < comments.length; i2++)
        if (comment2 = comments[i2]) {
          let token = tokens[i2], { open, close: close2 } = comment2;
          changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close2.pos - close2.margin, to: close2.pos + token.close.length });
        }
      return { changes };
    }
    return null;
  }
  function changeLineComment(option, state4, ranges = state4.selection.ranges) {
    let lines = [];
    let prevLine = -1;
    for (let { from: from3, to: to3 } of ranges) {
      let startI = lines.length, minIndent = 1e9;
      let token = getConfig(state4, from3).line;
      if (!token)
        continue;
      for (let pos = from3; pos <= to3; ) {
        let line = state4.doc.lineAt(pos);
        if (line.from > prevLine && (from3 == to3 || to3 > line.from)) {
          prevLine = line.from;
          let indent = /^\s*/.exec(line.text)[0].length;
          let empty7 = indent == line.length;
          let comment2 = line.text.slice(indent, indent + token.length) == token ? indent : -1;
          if (indent < line.text.length && indent < minIndent)
            minIndent = indent;
          lines.push({ line, comment: comment2, token, indent, empty: empty7, single: false });
        }
        pos = line.to + 1;
      }
      if (minIndent < 1e9) {
        for (let i2 = startI; i2 < lines.length; i2++)
          if (lines[i2].indent < lines[i2].line.text.length)
            lines[i2].indent = minIndent;
      }
      if (lines.length == startI + 1)
        lines[startI].single = true;
    }
    if (option != 2 && lines.some((l2) => l2.comment < 0 && (!l2.empty || l2.single))) {
      let changes = [];
      for (let { line, token, indent, empty: empty7, single } of lines)
        if (single || !empty7)
          changes.push({ from: line.from + indent, insert: token + " " });
      let changeSet = state4.changes(changes);
      return { changes: changeSet, selection: state4.selection.map(changeSet, 1) };
    } else if (option != 1 && lines.some((l2) => l2.comment >= 0)) {
      let changes = [];
      for (let { line, comment: comment2, token } of lines)
        if (comment2 >= 0) {
          let from3 = line.from + comment2, to3 = from3 + token.length;
          if (line.text[to3 - line.from] == " ")
            to3++;
          changes.push({ from: from3, to: to3 });
        }
      return { changes };
    }
    return null;
  }
  var fromHistory = /* @__PURE__ */ Annotation.define();
  var isolateHistory = /* @__PURE__ */ Annotation.define();
  var invertedEffects = /* @__PURE__ */ Facet.define();
  var historyConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        minDepth: 100,
        newGroupDelay: 500,
        joinToEvent: (_t, isAdjacent2) => isAdjacent2
      }, {
        minDepth: Math.max,
        newGroupDelay: Math.min,
        joinToEvent: (a2, b2) => (tr, adj) => a2(tr, adj) || b2(tr, adj)
      });
    }
  });
  var historyField_ = /* @__PURE__ */ StateField.define({
    create() {
      return HistoryState.empty;
    },
    update(state4, tr) {
      let config2 = tr.state.facet(historyConfig);
      let fromHist = tr.annotation(fromHistory);
      if (fromHist) {
        let item = HistEvent.fromTransaction(tr, fromHist.selection), from3 = fromHist.side;
        let other = from3 == 0 ? state4.undone : state4.done;
        if (item)
          other = updateBranch(other, other.length, config2.minDepth, item);
        else
          other = addSelection(other, tr.startState.selection);
        return new HistoryState(from3 == 0 ? fromHist.rest : other, from3 == 0 ? other : fromHist.rest);
      }
      let isolate = tr.annotation(isolateHistory);
      if (isolate == "full" || isolate == "before")
        state4 = state4.isolate();
      if (tr.annotation(Transaction.addToHistory) === false)
        return !tr.changes.empty ? state4.addMapping(tr.changes.desc) : state4;
      let event = HistEvent.fromTransaction(tr);
      let time3 = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);
      if (event)
        state4 = state4.addChanges(event, time3, userEvent, config2, tr);
      else if (tr.selection)
        state4 = state4.addSelection(tr.startState.selection, time3, userEvent, config2.newGroupDelay);
      if (isolate == "full" || isolate == "after")
        state4 = state4.isolate();
      return state4;
    },
    toJSON(value12) {
      return { done: value12.done.map((e2) => e2.toJSON()), undone: value12.undone.map((e2) => e2.toJSON()) };
    },
    fromJSON(json) {
      return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
    }
  });
  function history(config2 = {}) {
    return [
      historyField_,
      historyConfig.of(config2),
      EditorView.domEventHandlers({
        beforeinput(e2, view2) {
          let command2 = e2.inputType == "historyUndo" ? undo : e2.inputType == "historyRedo" ? redo : null;
          if (!command2)
            return false;
          e2.preventDefault();
          return command2(view2);
        }
      })
    ];
  }
  function cmd(side, selection) {
    return function({ state: state4, dispatch }) {
      if (!selection && state4.readOnly)
        return false;
      let historyState = state4.field(historyField_, false);
      if (!historyState)
        return false;
      let tr = historyState.pop(side, state4, selection);
      if (!tr)
        return false;
      dispatch(tr);
      return true;
    };
  }
  var undo = /* @__PURE__ */ cmd(0, false);
  var redo = /* @__PURE__ */ cmd(1, false);
  var undoSelection = /* @__PURE__ */ cmd(0, true);
  var redoSelection = /* @__PURE__ */ cmd(1, true);
  var HistEvent = class _HistEvent {
    constructor(changes, effects, mapped, startSelection, selectionsAfter) {
      this.changes = changes;
      this.effects = effects;
      this.mapped = mapped;
      this.startSelection = startSelection;
      this.selectionsAfter = selectionsAfter;
    }
    setSelAfter(after) {
      return new _HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
    }
    toJSON() {
      var _a2, _b, _c;
      return {
        changes: (_a2 = this.changes) === null || _a2 === void 0 ? void 0 : _a2.toJSON(),
        mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
        startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
        selectionsAfter: this.selectionsAfter.map((s2) => s2.toJSON())
      };
    }
    static fromJSON(json) {
      return new _HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));
    }
    // This does not check `addToHistory` and such, it assumes the
    // transaction needs to be converted to an item. Returns null when
    // there are no changes or effects in the transaction.
    static fromTransaction(tr, selection) {
      let effects = none3;
      for (let invert of tr.startState.facet(invertedEffects)) {
        let result = invert(tr);
        if (result.length)
          effects = effects.concat(result);
      }
      if (!effects.length && tr.changes.empty)
        return null;
      return new _HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, selection || tr.startState.selection, none3);
    }
    static selection(selections) {
      return new _HistEvent(void 0, none3, void 0, void 0, selections);
    }
  };
  function updateBranch(branch, to3, maxLen, newEvent) {
    let start3 = to3 + 1 > maxLen + 20 ? to3 - maxLen - 1 : 0;
    let newBranch = branch.slice(start3, to3);
    newBranch.push(newEvent);
    return newBranch;
  }
  function isAdjacent(a2, b2) {
    let ranges = [], isAdjacent2 = false;
    a2.iterChangedRanges((f2, t3) => ranges.push(f2, t3));
    b2.iterChangedRanges((_f, _t, f2, t3) => {
      for (let i2 = 0; i2 < ranges.length; ) {
        let from3 = ranges[i2++], to3 = ranges[i2++];
        if (t3 >= from3 && f2 <= to3)
          isAdjacent2 = true;
      }
    });
    return isAdjacent2;
  }
  function eqSelectionShape(a2, b2) {
    return a2.ranges.length == b2.ranges.length && a2.ranges.filter((r2, i2) => r2.empty != b2.ranges[i2].empty).length === 0;
  }
  function conc(a2, b2) {
    return !a2.length ? b2 : !b2.length ? a2 : a2.concat(b2);
  }
  var none3 = [];
  var MaxSelectionsPerEvent = 200;
  function addSelection(branch, selection) {
    if (!branch.length) {
      return [HistEvent.selection([selection])];
    } else {
      let lastEvent = branch[branch.length - 1];
      let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
      if (sels.length && sels[sels.length - 1].eq(selection))
        return branch;
      sels.push(selection);
      return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
    }
  }
  function popSelection(branch) {
    let last4 = branch[branch.length - 1];
    let newBranch = branch.slice();
    newBranch[branch.length - 1] = last4.setSelAfter(last4.selectionsAfter.slice(0, last4.selectionsAfter.length - 1));
    return newBranch;
  }
  function addMappingToBranch(branch, mapping) {
    if (!branch.length)
      return branch;
    let length9 = branch.length, selections = none3;
    while (length9) {
      let event = mapEvent(branch[length9 - 1], mapping, selections);
      if (event.changes && !event.changes.empty || event.effects.length) {
        let result = branch.slice(0, length9);
        result[length9 - 1] = event;
        return result;
      } else {
        mapping = event.mapped;
        length9--;
        selections = event.selectionsAfter;
      }
    }
    return selections.length ? [HistEvent.selection(selections)] : none3;
  }
  function mapEvent(event, mapping, extraSelections) {
    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s2) => s2.map(mapping)) : none3, extraSelections);
    if (!event.changes)
      return HistEvent.selection(selections);
    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
    return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
  }
  var joinableUserEvent = /^(input\.type|delete)($|\.)/;
  var HistoryState = class _HistoryState {
    constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
      this.done = done;
      this.undone = undone;
      this.prevTime = prevTime;
      this.prevUserEvent = prevUserEvent;
    }
    isolate() {
      return this.prevTime ? new _HistoryState(this.done, this.undone) : this;
    }
    addChanges(event, time3, userEvent, config2, tr) {
      let done = this.done, lastEvent = done[done.length - 1];
      if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time3 - this.prevTime < config2.newGroupDelay && config2.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes)) || // For compose (but not compose.start) events, always join with previous event
      userEvent == "input.type.compose")) {
        done = updateBranch(done, done.length - 1, config2.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(StateEffect.mapEffects(event.effects, lastEvent.changes), lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none3));
      } else {
        done = updateBranch(done, done.length, config2.minDepth, event);
      }
      return new _HistoryState(done, none3, time3, userEvent);
    }
    addSelection(selection, time3, userEvent, newGroupDelay) {
      let last4 = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none3;
      if (last4.length > 0 && time3 - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last4[last4.length - 1], selection))
        return this;
      return new _HistoryState(addSelection(this.done, selection), this.undone, time3, userEvent);
    }
    addMapping(mapping) {
      return new _HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
    }
    pop(side, state4, onlySelection) {
      let branch = side == 0 ? this.done : this.undone;
      if (branch.length == 0)
        return null;
      let event = branch[branch.length - 1], selection = event.selectionsAfter[0] || state4.selection;
      if (onlySelection && event.selectionsAfter.length) {
        return state4.update({
          selection: event.selectionsAfter[event.selectionsAfter.length - 1],
          annotations: fromHistory.of({ side, rest: popSelection(branch), selection }),
          userEvent: side == 0 ? "select.undo" : "select.redo",
          scrollIntoView: true
        });
      } else if (!event.changes) {
        return null;
      } else {
        let rest = branch.length == 1 ? none3 : branch.slice(0, branch.length - 1);
        if (event.mapped)
          rest = addMappingToBranch(rest, event.mapped);
        return state4.update({
          changes: event.changes,
          selection: event.startSelection,
          effects: event.effects,
          annotations: fromHistory.of({ side, rest, selection }),
          filter: false,
          userEvent: side == 0 ? "undo" : "redo",
          scrollIntoView: true
        });
      }
    }
  };
  HistoryState.empty = /* @__PURE__ */ new HistoryState(none3, none3);
  var historyKeymap = [
    { key: "Mod-z", run: undo, preventDefault: true },
    { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
    { linux: "Ctrl-Shift-z", run: redo, preventDefault: true },
    { key: "Mod-u", run: undoSelection, preventDefault: true },
    { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
  ];
  function updateSel(sel, by) {
    return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
  }
  function setSel(state4, selection) {
    return state4.update({ selection, scrollIntoView: true, userEvent: "select" });
  }
  function moveSel({ state: state4, dispatch }, how) {
    let selection = updateSel(state4.selection, how);
    if (selection.eq(state4.selection, true))
      return false;
    dispatch(setSel(state4, selection));
    return true;
  }
  function rangeEnd(range3, forward2) {
    return EditorSelection.cursor(forward2 ? range3.to : range3.from);
  }
  function cursorByChar(view2, forward2) {
    return moveSel(view2, (range3) => range3.empty ? view2.moveByChar(range3, forward2) : rangeEnd(range3, forward2));
  }
  function ltrAtCursor(view2) {
    return view2.textDirectionAt(view2.state.selection.main.head) == Direction.LTR;
  }
  var cursorCharLeft = (view2) => cursorByChar(view2, !ltrAtCursor(view2));
  var cursorCharRight = (view2) => cursorByChar(view2, ltrAtCursor(view2));
  function cursorByGroup(view2, forward2) {
    return moveSel(view2, (range3) => range3.empty ? view2.moveByGroup(range3, forward2) : rangeEnd(range3, forward2));
  }
  var cursorGroupLeft = (view2) => cursorByGroup(view2, !ltrAtCursor(view2));
  var cursorGroupRight = (view2) => cursorByGroup(view2, ltrAtCursor(view2));
  var segmenter = typeof Intl != "undefined" && Intl.Segmenter ? /* @__PURE__ */ new Intl.Segmenter(void 0, { granularity: "word" }) : null;
  function interestingNode(state4, node, bracketProp) {
    if (node.type.prop(bracketProp))
      return true;
    let len = node.to - node.from;
    return len && (len > 2 || /[^\s,.;:]/.test(state4.sliceDoc(node.from, node.to))) || node.firstChild;
  }
  function moveBySyntax(state4, start3, forward2) {
    let pos = syntaxTree(state4).resolveInner(start3.head);
    let bracketProp = forward2 ? NodeProp.closedBy : NodeProp.openedBy;
    for (let at = start3.head; ; ) {
      let next = forward2 ? pos.childAfter(at) : pos.childBefore(at);
      if (!next)
        break;
      if (interestingNode(state4, next, bracketProp))
        pos = next;
      else
        at = forward2 ? next.to : next.from;
    }
    let bracket2 = pos.type.prop(bracketProp), match2, newPos;
    if (bracket2 && (match2 = forward2 ? matchBrackets(state4, pos.from, 1) : matchBrackets(state4, pos.to, -1)) && match2.matched)
      newPos = forward2 ? match2.end.to : match2.end.from;
    else
      newPos = forward2 ? pos.to : pos.from;
    return EditorSelection.cursor(newPos, forward2 ? -1 : 1);
  }
  var cursorSyntaxLeft = (view2) => moveSel(view2, (range3) => moveBySyntax(view2.state, range3, !ltrAtCursor(view2)));
  var cursorSyntaxRight = (view2) => moveSel(view2, (range3) => moveBySyntax(view2.state, range3, ltrAtCursor(view2)));
  function cursorByLine(view2, forward2) {
    return moveSel(view2, (range3) => {
      if (!range3.empty)
        return rangeEnd(range3, forward2);
      let moved = view2.moveVertically(range3, forward2);
      return moved.head != range3.head ? moved : view2.moveToLineBoundary(range3, forward2);
    });
  }
  var cursorLineUp = (view2) => cursorByLine(view2, false);
  var cursorLineDown = (view2) => cursorByLine(view2, true);
  function pageInfo(view2) {
    let selfScroll = view2.scrollDOM.clientHeight < view2.scrollDOM.scrollHeight - 2;
    let marginTop = 0, marginBottom = 0, height8;
    if (selfScroll) {
      for (let source3 of view2.state.facet(EditorView.scrollMargins)) {
        let margins = source3(view2);
        if (margins === null || margins === void 0 ? void 0 : margins.top)
          marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
        if (margins === null || margins === void 0 ? void 0 : margins.bottom)
          marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
      }
      height8 = view2.scrollDOM.clientHeight - marginTop - marginBottom;
    } else {
      height8 = (view2.dom.ownerDocument.defaultView || window).innerHeight;
    }
    return {
      marginTop,
      marginBottom,
      selfScroll,
      height: Math.max(view2.defaultLineHeight, height8 - 5)
    };
  }
  function cursorByPage(view2, forward2) {
    let page = pageInfo(view2);
    let { state: state4 } = view2, selection = updateSel(state4.selection, (range3) => {
      return range3.empty ? view2.moveVertically(range3, forward2, page.height) : rangeEnd(range3, forward2);
    });
    if (selection.eq(state4.selection))
      return false;
    let effect;
    if (page.selfScroll) {
      let startPos = view2.coordsAtPos(state4.selection.main.head);
      let scrollRect = view2.scrollDOM.getBoundingClientRect();
      let scrollTop2 = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
      if (startPos && startPos.top > scrollTop2 && startPos.bottom < scrollBottom)
        effect = EditorView.scrollIntoView(selection.main.head, { y: "start", yMargin: startPos.top - scrollTop2 });
    }
    view2.dispatch(setSel(state4, selection), { effects: effect });
    return true;
  }
  var cursorPageUp = (view2) => cursorByPage(view2, false);
  var cursorPageDown = (view2) => cursorByPage(view2, true);
  function moveByLineBoundary(view2, start3, forward2) {
    let line = view2.lineBlockAt(start3.head), moved = view2.moveToLineBoundary(start3, forward2);
    if (moved.head == start3.head && moved.head != (forward2 ? line.to : line.from))
      moved = view2.moveToLineBoundary(start3, forward2, false);
    if (!forward2 && moved.head == line.from && line.length) {
      let space2 = /^\s*/.exec(view2.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
      if (space2 && start3.head != line.from + space2)
        moved = EditorSelection.cursor(line.from + space2);
    }
    return moved;
  }
  var cursorLineBoundaryForward = (view2) => moveSel(view2, (range3) => moveByLineBoundary(view2, range3, true));
  var cursorLineBoundaryBackward = (view2) => moveSel(view2, (range3) => moveByLineBoundary(view2, range3, false));
  var cursorLineBoundaryLeft = (view2) => moveSel(view2, (range3) => moveByLineBoundary(view2, range3, !ltrAtCursor(view2)));
  var cursorLineBoundaryRight = (view2) => moveSel(view2, (range3) => moveByLineBoundary(view2, range3, ltrAtCursor(view2)));
  var cursorLineStart = (view2) => moveSel(view2, (range3) => EditorSelection.cursor(view2.lineBlockAt(range3.head).from, 1));
  var cursorLineEnd = (view2) => moveSel(view2, (range3) => EditorSelection.cursor(view2.lineBlockAt(range3.head).to, -1));
  function toMatchingBracket(state4, dispatch, extend3) {
    let found = false, selection = updateSel(state4.selection, (range3) => {
      let matching = matchBrackets(state4, range3.head, -1) || matchBrackets(state4, range3.head, 1) || range3.head > 0 && matchBrackets(state4, range3.head - 1, 1) || range3.head < state4.doc.length && matchBrackets(state4, range3.head + 1, -1);
      if (!matching || !matching.end)
        return range3;
      found = true;
      let head5 = matching.start.from == range3.head ? matching.end.to : matching.end.from;
      return extend3 ? EditorSelection.range(range3.anchor, head5) : EditorSelection.cursor(head5);
    });
    if (!found)
      return false;
    dispatch(setSel(state4, selection));
    return true;
  }
  var cursorMatchingBracket = ({ state: state4, dispatch }) => toMatchingBracket(state4, dispatch, false);
  function extendSel(target5, how) {
    let selection = updateSel(target5.state.selection, (range3) => {
      let head5 = how(range3);
      return EditorSelection.range(range3.anchor, head5.head, head5.goalColumn, head5.bidiLevel || void 0);
    });
    if (selection.eq(target5.state.selection))
      return false;
    target5.dispatch(setSel(target5.state, selection));
    return true;
  }
  function selectByChar(view2, forward2) {
    return extendSel(view2, (range3) => view2.moveByChar(range3, forward2));
  }
  var selectCharLeft = (view2) => selectByChar(view2, !ltrAtCursor(view2));
  var selectCharRight = (view2) => selectByChar(view2, ltrAtCursor(view2));
  function selectByGroup(view2, forward2) {
    return extendSel(view2, (range3) => view2.moveByGroup(range3, forward2));
  }
  var selectGroupLeft = (view2) => selectByGroup(view2, !ltrAtCursor(view2));
  var selectGroupRight = (view2) => selectByGroup(view2, ltrAtCursor(view2));
  var selectSyntaxLeft = (view2) => extendSel(view2, (range3) => moveBySyntax(view2.state, range3, !ltrAtCursor(view2)));
  var selectSyntaxRight = (view2) => extendSel(view2, (range3) => moveBySyntax(view2.state, range3, ltrAtCursor(view2)));
  function selectByLine(view2, forward2) {
    return extendSel(view2, (range3) => view2.moveVertically(range3, forward2));
  }
  var selectLineUp = (view2) => selectByLine(view2, false);
  var selectLineDown = (view2) => selectByLine(view2, true);
  function selectByPage(view2, forward2) {
    return extendSel(view2, (range3) => view2.moveVertically(range3, forward2, pageInfo(view2).height));
  }
  var selectPageUp = (view2) => selectByPage(view2, false);
  var selectPageDown = (view2) => selectByPage(view2, true);
  var selectLineBoundaryForward = (view2) => extendSel(view2, (range3) => moveByLineBoundary(view2, range3, true));
  var selectLineBoundaryBackward = (view2) => extendSel(view2, (range3) => moveByLineBoundary(view2, range3, false));
  var selectLineBoundaryLeft = (view2) => extendSel(view2, (range3) => moveByLineBoundary(view2, range3, !ltrAtCursor(view2)));
  var selectLineBoundaryRight = (view2) => extendSel(view2, (range3) => moveByLineBoundary(view2, range3, ltrAtCursor(view2)));
  var selectLineStart = (view2) => extendSel(view2, (range3) => EditorSelection.cursor(view2.lineBlockAt(range3.head).from));
  var selectLineEnd = (view2) => extendSel(view2, (range3) => EditorSelection.cursor(view2.lineBlockAt(range3.head).to));
  var cursorDocStart = ({ state: state4, dispatch }) => {
    dispatch(setSel(state4, { anchor: 0 }));
    return true;
  };
  var cursorDocEnd = ({ state: state4, dispatch }) => {
    dispatch(setSel(state4, { anchor: state4.doc.length }));
    return true;
  };
  var selectDocStart = ({ state: state4, dispatch }) => {
    dispatch(setSel(state4, { anchor: state4.selection.main.anchor, head: 0 }));
    return true;
  };
  var selectDocEnd = ({ state: state4, dispatch }) => {
    dispatch(setSel(state4, { anchor: state4.selection.main.anchor, head: state4.doc.length }));
    return true;
  };
  var selectAll = ({ state: state4, dispatch }) => {
    dispatch(state4.update({ selection: { anchor: 0, head: state4.doc.length }, userEvent: "select" }));
    return true;
  };
  var selectLine = ({ state: state4, dispatch }) => {
    let ranges = selectedLineBlocks(state4).map(({ from: from3, to: to3 }) => EditorSelection.range(from3, Math.min(to3 + 1, state4.doc.length)));
    dispatch(state4.update({ selection: EditorSelection.create(ranges), userEvent: "select" }));
    return true;
  };
  var selectParentSyntax = ({ state: state4, dispatch }) => {
    let selection = updateSel(state4.selection, (range3) => {
      let tree = syntaxTree(state4), stack = tree.resolveStack(range3.from, 1);
      if (range3.empty) {
        let stackBefore = tree.resolveStack(range3.from, -1);
        if (stackBefore.node.from >= stack.node.from && stackBefore.node.to <= stack.node.to)
          stack = stackBefore;
      }
      for (let cur2 = stack; cur2; cur2 = cur2.next) {
        let { node } = cur2;
        if ((node.from < range3.from && node.to >= range3.to || node.to > range3.to && node.from <= range3.from) && cur2.next)
          return EditorSelection.range(node.to, node.from);
      }
      return range3;
    });
    if (selection.eq(state4.selection))
      return false;
    dispatch(setSel(state4, selection));
    return true;
  };
  var simplifySelection = ({ state: state4, dispatch }) => {
    let cur2 = state4.selection, selection = null;
    if (cur2.ranges.length > 1)
      selection = EditorSelection.create([cur2.main]);
    else if (!cur2.main.empty)
      selection = EditorSelection.create([EditorSelection.cursor(cur2.main.head)]);
    if (!selection)
      return false;
    dispatch(setSel(state4, selection));
    return true;
  };
  function deleteBy2(target5, by) {
    if (target5.state.readOnly)
      return false;
    let event = "delete.selection", { state: state4 } = target5;
    let changes = state4.changeByRange((range3) => {
      let { from: from3, to: to3 } = range3;
      if (from3 == to3) {
        let towards = by(range3);
        if (towards < from3) {
          event = "delete.backward";
          towards = skipAtomic(target5, towards, false);
        } else if (towards > from3) {
          event = "delete.forward";
          towards = skipAtomic(target5, towards, true);
        }
        from3 = Math.min(from3, towards);
        to3 = Math.max(to3, towards);
      } else {
        from3 = skipAtomic(target5, from3, false);
        to3 = skipAtomic(target5, to3, true);
      }
      return from3 == to3 ? { range: range3 } : { changes: { from: from3, to: to3 }, range: EditorSelection.cursor(from3, from3 < range3.head ? -1 : 1) };
    });
    if (changes.changes.empty)
      return false;
    target5.dispatch(state4.update(changes, {
      scrollIntoView: true,
      userEvent: event,
      effects: event == "delete.selection" ? EditorView.announce.of(state4.phrase("Selection deleted")) : void 0
    }));
    return true;
  }
  function skipAtomic(target5, pos, forward2) {
    if (target5 instanceof EditorView)
      for (let ranges of target5.state.facet(EditorView.atomicRanges).map((f2) => f2(target5)))
        ranges.between(pos, pos, (from3, to3) => {
          if (from3 < pos && to3 > pos)
            pos = forward2 ? to3 : from3;
        });
    return pos;
  }
  var deleteByChar = (target5, forward2, byIndentUnit) => deleteBy2(target5, (range3) => {
    let pos = range3.from, { state: state4 } = target5, line = state4.doc.lineAt(pos), before, targetPos;
    if (byIndentUnit && !forward2 && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
      if (before[before.length - 1] == "	")
        return pos - 1;
      let col = countColumn(before, state4.tabSize), drop4 = col % getIndentUnit(state4) || getIndentUnit(state4);
      for (let i2 = 0; i2 < drop4 && before[before.length - 1 - i2] == " "; i2++)
        pos--;
      targetPos = pos;
    } else {
      targetPos = findClusterBreak(line.text, pos - line.from, forward2, forward2) + line.from;
      if (targetPos == pos && line.number != (forward2 ? state4.doc.lines : 1))
        targetPos += forward2 ? 1 : -1;
      else if (!forward2 && /[\ufe00-\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from)))
        targetPos = findClusterBreak(line.text, targetPos - line.from, false, false) + line.from;
    }
    return targetPos;
  });
  var deleteCharBackward = (view2) => deleteByChar(view2, false, true);
  var deleteCharForward = (view2) => deleteByChar(view2, true, false);
  var deleteByGroup = (target5, forward2) => deleteBy2(target5, (range3) => {
    let pos = range3.head, { state: state4 } = target5, line = state4.doc.lineAt(pos);
    let categorize = state4.charCategorizer(pos);
    for (let cat = null; ; ) {
      if (pos == (forward2 ? line.to : line.from)) {
        if (pos == range3.head && line.number != (forward2 ? state4.doc.lines : 1))
          pos += forward2 ? 1 : -1;
        break;
      }
      let next = findClusterBreak(line.text, pos - line.from, forward2) + line.from;
      let nextChar2 = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
      let nextCat = categorize(nextChar2);
      if (cat != null && nextCat != cat)
        break;
      if (nextChar2 != " " || pos != range3.head)
        cat = nextCat;
      pos = next;
    }
    return pos;
  });
  var deleteGroupBackward = (target5) => deleteByGroup(target5, false);
  var deleteGroupForward = (target5) => deleteByGroup(target5, true);
  var deleteToLineEnd = (view2) => deleteBy2(view2, (range3) => {
    let lineEnd = view2.lineBlockAt(range3.head).to;
    return range3.head < lineEnd ? lineEnd : Math.min(view2.state.doc.length, range3.head + 1);
  });
  var deleteLineBoundaryBackward = (view2) => deleteBy2(view2, (range3) => {
    let lineStart = view2.moveToLineBoundary(range3, false).head;
    return range3.head > lineStart ? lineStart : Math.max(0, range3.head - 1);
  });
  var deleteLineBoundaryForward = (view2) => deleteBy2(view2, (range3) => {
    let lineStart = view2.moveToLineBoundary(range3, true).head;
    return range3.head < lineStart ? lineStart : Math.min(view2.state.doc.length, range3.head + 1);
  });
  var splitLine = ({ state: state4, dispatch }) => {
    if (state4.readOnly)
      return false;
    let changes = state4.changeByRange((range3) => {
      return {
        changes: { from: range3.from, to: range3.to, insert: Text2.of(["", ""]) },
        range: EditorSelection.cursor(range3.from)
      };
    });
    dispatch(state4.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
  };
  var transposeChars = ({ state: state4, dispatch }) => {
    if (state4.readOnly)
      return false;
    let changes = state4.changeByRange((range3) => {
      if (!range3.empty || range3.from == 0 || range3.from == state4.doc.length)
        return { range: range3 };
      let pos = range3.from, line = state4.doc.lineAt(pos);
      let from3 = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
      let to3 = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
      return {
        changes: { from: from3, to: to3, insert: state4.doc.slice(pos, to3).append(state4.doc.slice(from3, pos)) },
        range: EditorSelection.cursor(to3)
      };
    });
    if (changes.changes.empty)
      return false;
    dispatch(state4.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
    return true;
  };
  function selectedLineBlocks(state4) {
    let blocks = [], upto = -1;
    for (let range3 of state4.selection.ranges) {
      let startLine = state4.doc.lineAt(range3.from), endLine = state4.doc.lineAt(range3.to);
      if (!range3.empty && range3.to == endLine.from)
        endLine = state4.doc.lineAt(range3.to - 1);
      if (upto >= startLine.number) {
        let prev = blocks[blocks.length - 1];
        prev.to = endLine.to;
        prev.ranges.push(range3);
      } else {
        blocks.push({ from: startLine.from, to: endLine.to, ranges: [range3] });
      }
      upto = endLine.number + 1;
    }
    return blocks;
  }
  function moveLine(state4, dispatch, forward2) {
    if (state4.readOnly)
      return false;
    let changes = [], ranges = [];
    for (let block of selectedLineBlocks(state4)) {
      if (forward2 ? block.to == state4.doc.length : block.from == 0)
        continue;
      let nextLine = state4.doc.lineAt(forward2 ? block.to + 1 : block.from - 1);
      let size5 = nextLine.length + 1;
      if (forward2) {
        changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state4.lineBreak });
        for (let r2 of block.ranges)
          ranges.push(EditorSelection.range(Math.min(state4.doc.length, r2.anchor + size5), Math.min(state4.doc.length, r2.head + size5)));
      } else {
        changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state4.lineBreak + nextLine.text });
        for (let r2 of block.ranges)
          ranges.push(EditorSelection.range(r2.anchor - size5, r2.head - size5));
      }
    }
    if (!changes.length)
      return false;
    dispatch(state4.update({
      changes,
      scrollIntoView: true,
      selection: EditorSelection.create(ranges, state4.selection.mainIndex),
      userEvent: "move.line"
    }));
    return true;
  }
  var moveLineUp = ({ state: state4, dispatch }) => moveLine(state4, dispatch, false);
  var moveLineDown = ({ state: state4, dispatch }) => moveLine(state4, dispatch, true);
  function copyLine(state4, dispatch, forward2) {
    if (state4.readOnly)
      return false;
    let changes = [];
    for (let block of selectedLineBlocks(state4)) {
      if (forward2)
        changes.push({ from: block.from, insert: state4.doc.slice(block.from, block.to) + state4.lineBreak });
      else
        changes.push({ from: block.to, insert: state4.lineBreak + state4.doc.slice(block.from, block.to) });
    }
    dispatch(state4.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
    return true;
  }
  var copyLineUp = ({ state: state4, dispatch }) => copyLine(state4, dispatch, false);
  var copyLineDown = ({ state: state4, dispatch }) => copyLine(state4, dispatch, true);
  var deleteLine = (view2) => {
    if (view2.state.readOnly)
      return false;
    let { state: state4 } = view2, changes = state4.changes(selectedLineBlocks(state4).map(({ from: from3, to: to3 }) => {
      if (from3 > 0)
        from3--;
      else if (to3 < state4.doc.length)
        to3++;
      return { from: from3, to: to3 };
    }));
    let selection = updateSel(state4.selection, (range3) => {
      let dist2 = void 0;
      if (view2.lineWrapping) {
        let block = view2.lineBlockAt(range3.head), pos = view2.coordsAtPos(range3.head, range3.assoc || 1);
        if (pos)
          dist2 = block.bottom + view2.documentTop - pos.bottom + view2.defaultLineHeight / 2;
      }
      return view2.moveVertically(range3, true, dist2);
    }).map(changes);
    view2.dispatch({ changes, selection, scrollIntoView: true, userEvent: "delete.line" });
    return true;
  };
  function isBetweenBrackets(state4, pos) {
    if (/\(\)|\[\]|\{\}/.test(state4.sliceDoc(pos - 1, pos + 1)))
      return { from: pos, to: pos };
    let context3 = syntaxTree(state4).resolveInner(pos);
    let before = context3.childBefore(pos), after = context3.childAfter(pos), closedBy;
    if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state4.doc.lineAt(before.to).from == state4.doc.lineAt(after.from).from && !/\S/.test(state4.sliceDoc(before.to, after.from)))
      return { from: before.to, to: after.from };
    return null;
  }
  var insertNewlineAndIndent = /* @__PURE__ */ newlineAndIndent(false);
  var insertBlankLine = /* @__PURE__ */ newlineAndIndent(true);
  function newlineAndIndent(atEof) {
    return ({ state: state4, dispatch }) => {
      if (state4.readOnly)
        return false;
      let changes = state4.changeByRange((range3) => {
        let { from: from3, to: to3 } = range3, line = state4.doc.lineAt(from3);
        let explode = !atEof && from3 == to3 && isBetweenBrackets(state4, from3);
        if (atEof)
          from3 = to3 = (to3 <= line.to ? line : state4.doc.lineAt(to3)).to;
        let cx = new IndentContext(state4, { simulateBreak: from3, simulateDoubleBreak: !!explode });
        let indent = getIndentation(cx, from3);
        if (indent == null)
          indent = countColumn(/^\s*/.exec(state4.doc.lineAt(from3).text)[0], state4.tabSize);
        while (to3 < line.to && /\s/.test(line.text[to3 - line.from]))
          to3++;
        if (explode)
          ({ from: from3, to: to3 } = explode);
        else if (from3 > line.from && from3 < line.from + 100 && !/\S/.test(line.text.slice(0, from3)))
          from3 = line.from;
        let insert10 = ["", indentString(state4, indent)];
        if (explode)
          insert10.push(indentString(state4, cx.lineIndent(line.from, -1)));
        return {
          changes: { from: from3, to: to3, insert: Text2.of(insert10) },
          range: EditorSelection.cursor(from3 + 1 + insert10[1].length)
        };
      });
      dispatch(state4.update(changes, { scrollIntoView: true, userEvent: "input" }));
      return true;
    };
  }
  function changeBySelectedLine(state4, f2) {
    let atLine = -1;
    return state4.changeByRange((range3) => {
      let changes = [];
      for (let pos = range3.from; pos <= range3.to; ) {
        let line = state4.doc.lineAt(pos);
        if (line.number > atLine && (range3.empty || range3.to > line.from)) {
          f2(line, changes, range3);
          atLine = line.number;
        }
        pos = line.to + 1;
      }
      let changeSet = state4.changes(changes);
      return {
        changes,
        range: EditorSelection.range(changeSet.mapPos(range3.anchor, 1), changeSet.mapPos(range3.head, 1))
      };
    });
  }
  var indentSelection = ({ state: state4, dispatch }) => {
    if (state4.readOnly)
      return false;
    let updated = /* @__PURE__ */ Object.create(null);
    let context3 = new IndentContext(state4, { overrideIndentation: (start3) => {
      let found = updated[start3];
      return found == null ? -1 : found;
    } });
    let changes = changeBySelectedLine(state4, (line, changes2, range3) => {
      let indent = getIndentation(context3, line.from);
      if (indent == null)
        return;
      if (!/\S/.test(line.text))
        indent = 0;
      let cur2 = /^\s*/.exec(line.text)[0];
      let norm = indentString(state4, indent);
      if (cur2 != norm || range3.from < line.from + cur2.length) {
        updated[line.from] = indent;
        changes2.push({ from: line.from, to: line.from + cur2.length, insert: norm });
      }
    });
    if (!changes.changes.empty)
      dispatch(state4.update(changes, { userEvent: "indent" }));
    return true;
  };
  var indentMore = ({ state: state4, dispatch }) => {
    if (state4.readOnly)
      return false;
    dispatch(state4.update(changeBySelectedLine(state4, (line, changes) => {
      changes.push({ from: line.from, insert: state4.facet(indentUnit) });
    }), { userEvent: "input.indent" }));
    return true;
  };
  var indentLess = ({ state: state4, dispatch }) => {
    if (state4.readOnly)
      return false;
    dispatch(state4.update(changeBySelectedLine(state4, (line, changes) => {
      let space2 = /^\s*/.exec(line.text)[0];
      if (!space2)
        return;
      let col = countColumn(space2, state4.tabSize), keep = 0;
      let insert10 = indentString(state4, Math.max(0, col - getIndentUnit(state4)));
      while (keep < space2.length && keep < insert10.length && space2.charCodeAt(keep) == insert10.charCodeAt(keep))
        keep++;
      changes.push({ from: line.from + keep, to: line.from + space2.length, insert: insert10.slice(keep) });
    }), { userEvent: "delete.dedent" }));
    return true;
  };
  var toggleTabFocusMode = (view2) => {
    view2.setTabFocusMode();
    return true;
  };
  var emacsStyleKeymap = [
    { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
    { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
    { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
    { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
    { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
    { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
    { key: "Ctrl-d", run: deleteCharForward },
    { key: "Ctrl-h", run: deleteCharBackward },
    { key: "Ctrl-k", run: deleteToLineEnd },
    { key: "Ctrl-Alt-h", run: deleteGroupBackward },
    { key: "Ctrl-o", run: splitLine },
    { key: "Ctrl-t", run: transposeChars },
    { key: "Ctrl-v", run: cursorPageDown }
  ];
  var standardKeymap = /* @__PURE__ */ [
    { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
    { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
    { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
    { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
    { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
    { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
    { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
    { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
    { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
    { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
    { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
    { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
    { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
    { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
    { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
    { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
    { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
    { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
    { key: "Enter", run: insertNewlineAndIndent, shift: insertNewlineAndIndent },
    { key: "Mod-a", run: selectAll },
    { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
    { key: "Delete", run: deleteCharForward },
    { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
    { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
    { mac: "Mod-Backspace", run: deleteLineBoundaryBackward },
    { mac: "Mod-Delete", run: deleteLineBoundaryForward }
  ].concat(/* @__PURE__ */ emacsStyleKeymap.map((b2) => ({ mac: b2.key, run: b2.run, shift: b2.shift })));
  var defaultKeymap = /* @__PURE__ */ [
    { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
    { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
    { key: "Alt-ArrowUp", run: moveLineUp },
    { key: "Shift-Alt-ArrowUp", run: copyLineUp },
    { key: "Alt-ArrowDown", run: moveLineDown },
    { key: "Shift-Alt-ArrowDown", run: copyLineDown },
    { key: "Escape", run: simplifySelection },
    { key: "Mod-Enter", run: insertBlankLine },
    { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
    { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
    { key: "Mod-[", run: indentLess },
    { key: "Mod-]", run: indentMore },
    { key: "Mod-Alt-\\", run: indentSelection },
    { key: "Shift-Mod-k", run: deleteLine },
    { key: "Shift-Mod-\\", run: cursorMatchingBracket },
    { key: "Mod-/", run: toggleComment },
    { key: "Alt-A", run: toggleBlockComment },
    { key: "Ctrl-m", mac: "Shift-Alt-m", run: toggleTabFocusMode }
  ].concat(standardKeymap);

  // node_modules/crelt/index.js
  function crelt() {
    var elt = arguments[0];
    if (typeof elt == "string") elt = document.createElement(elt);
    var i2 = 1, next = arguments[1];
    if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
      for (var name16 in next) if (Object.prototype.hasOwnProperty.call(next, name16)) {
        var value12 = next[name16];
        if (typeof value12 == "string") elt.setAttribute(name16, value12);
        else if (value12 != null) elt[name16] = value12;
      }
      i2++;
    }
    for (; i2 < arguments.length; i2++) add4(elt, arguments[i2]);
    return elt;
  }
  function add4(elt, child) {
    if (typeof child == "string") {
      elt.appendChild(document.createTextNode(child));
    } else if (child == null) {
    } else if (child.nodeType != null) {
      elt.appendChild(child);
    } else if (Array.isArray(child)) {
      for (var i2 = 0; i2 < child.length; i2++) add4(elt, child[i2]);
    } else {
      throw new RangeError("Unsupported child node: " + child);
    }
  }

  // node_modules/@codemirror/search/dist/index.js
  var basicNormalize = typeof String.prototype.normalize == "function" ? (x2) => x2.normalize("NFKD") : (x2) => x2;
  var SearchCursor = class {
    /**
    Create a text cursor. The query is the search string, `from` to
    `to` provides the region to search.
    
    When `normalize` is given, it will be called, on both the query
    string and the content it is matched against, before comparing.
    You can, for example, create a case-insensitive search by
    passing `s => s.toLowerCase()`.
    
    Text is always normalized with
    [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
    (when supported).
    */
    constructor(text6, query, from3 = 0, to3 = text6.length, normalize, test2) {
      this.test = test2;
      this.value = { from: 0, to: 0 };
      this.done = false;
      this.matches = [];
      this.buffer = "";
      this.bufferPos = 0;
      this.iter = text6.iterRange(from3, to3);
      this.bufferStart = from3;
      this.normalize = normalize ? (x2) => normalize(basicNormalize(x2)) : basicNormalize;
      this.query = this.normalize(query);
    }
    peek() {
      if (this.bufferPos == this.buffer.length) {
        this.bufferStart += this.buffer.length;
        this.iter.next();
        if (this.iter.done)
          return -1;
        this.bufferPos = 0;
        this.buffer = this.iter.value;
      }
      return codePointAt2(this.buffer, this.bufferPos);
    }
    /**
    Look for the next match. Updates the iterator's
    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
    at least once before using the cursor.
    */
    next() {
      while (this.matches.length)
        this.matches.pop();
      return this.nextOverlapping();
    }
    /**
    The `next` method will ignore matches that partially overlap a
    previous match. This method behaves like `next`, but includes
    such matches.
    */
    nextOverlapping() {
      for (; ; ) {
        let next = this.peek();
        if (next < 0) {
          this.done = true;
          return this;
        }
        let str = fromCodePoint(next), start3 = this.bufferStart + this.bufferPos;
        this.bufferPos += codePointSize(next);
        let norm = this.normalize(str);
        if (norm.length)
          for (let i2 = 0, pos = start3; ; i2++) {
            let code = norm.charCodeAt(i2);
            let match2 = this.match(code, pos, this.bufferPos + this.bufferStart);
            if (i2 == norm.length - 1) {
              if (match2) {
                this.value = match2;
                return this;
              }
              break;
            }
            if (pos == start3 && i2 < str.length && str.charCodeAt(i2) == code)
              pos++;
          }
      }
    }
    match(code, pos, end) {
      let match2 = null;
      for (let i2 = 0; i2 < this.matches.length; i2 += 2) {
        let index6 = this.matches[i2], keep = false;
        if (this.query.charCodeAt(index6) == code) {
          if (index6 == this.query.length - 1) {
            match2 = { from: this.matches[i2 + 1], to: end };
          } else {
            this.matches[i2]++;
            keep = true;
          }
        }
        if (!keep) {
          this.matches.splice(i2, 2);
          i2 -= 2;
        }
      }
      if (this.query.charCodeAt(0) == code) {
        if (this.query.length == 1)
          match2 = { from: pos, to: end };
        else
          this.matches.push(1, pos);
      }
      if (match2 && this.test && !this.test(match2.from, match2.to, this.buffer, this.bufferStart))
        match2 = null;
      return match2;
    }
  };
  if (typeof Symbol != "undefined")
    SearchCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  var empty6 = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") };
  var baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
  var RegExpCursor = class {
    /**
    Create a cursor that will search the given range in the given
    document. `query` should be the raw pattern (as you'd pass it to
    `new RegExp`).
    */
    constructor(text6, query, options2, from3 = 0, to3 = text6.length) {
      this.text = text6;
      this.to = to3;
      this.curLine = "";
      this.done = false;
      this.value = empty6;
      if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
        return new MultilineRegExpCursor(text6, query, options2, from3, to3);
      this.re = new RegExp(query, baseFlags + ((options2 === null || options2 === void 0 ? void 0 : options2.ignoreCase) ? "i" : ""));
      this.test = options2 === null || options2 === void 0 ? void 0 : options2.test;
      this.iter = text6.iter();
      let startLine = text6.lineAt(from3);
      this.curLineStart = startLine.from;
      this.matchPos = toCharEnd(text6, from3);
      this.getLine(this.curLineStart);
    }
    getLine(skip) {
      this.iter.next(skip);
      if (this.iter.lineBreak) {
        this.curLine = "";
      } else {
        this.curLine = this.iter.value;
        if (this.curLineStart + this.curLine.length > this.to)
          this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
        this.iter.next();
      }
    }
    nextLine() {
      this.curLineStart = this.curLineStart + this.curLine.length + 1;
      if (this.curLineStart > this.to)
        this.curLine = "";
      else
        this.getLine(0);
    }
    /**
    Move to the next match, if there is one.
    */
    next() {
      for (let off = this.matchPos - this.curLineStart; ; ) {
        this.re.lastIndex = off;
        let match2 = this.matchPos <= this.to && this.re.exec(this.curLine);
        if (match2) {
          let from3 = this.curLineStart + match2.index, to3 = from3 + match2[0].length;
          this.matchPos = toCharEnd(this.text, to3 + (from3 == to3 ? 1 : 0));
          if (from3 == this.curLineStart + this.curLine.length)
            this.nextLine();
          if ((from3 < to3 || from3 > this.value.to) && (!this.test || this.test(from3, to3, match2))) {
            this.value = { from: from3, to: to3, match: match2 };
            return this;
          }
          off = this.matchPos - this.curLineStart;
        } else if (this.curLineStart + this.curLine.length < this.to) {
          this.nextLine();
          off = 0;
        } else {
          this.done = true;
          return this;
        }
      }
    }
  };
  var flattened = /* @__PURE__ */ new WeakMap();
  var FlattenedDoc = class _FlattenedDoc {
    constructor(from3, text6) {
      this.from = from3;
      this.text = text6;
    }
    get to() {
      return this.from + this.text.length;
    }
    static get(doc2, from3, to3) {
      let cached = flattened.get(doc2);
      if (!cached || cached.from >= to3 || cached.to <= from3) {
        let flat = new _FlattenedDoc(from3, doc2.sliceString(from3, to3));
        flattened.set(doc2, flat);
        return flat;
      }
      if (cached.from == from3 && cached.to == to3)
        return cached;
      let { text: text6, from: cachedFrom } = cached;
      if (cachedFrom > from3) {
        text6 = doc2.sliceString(from3, cachedFrom) + text6;
        cachedFrom = from3;
      }
      if (cached.to < to3)
        text6 += doc2.sliceString(cached.to, to3);
      flattened.set(doc2, new _FlattenedDoc(cachedFrom, text6));
      return new _FlattenedDoc(from3, text6.slice(from3 - cachedFrom, to3 - cachedFrom));
    }
  };
  var MultilineRegExpCursor = class {
    constructor(text6, query, options2, from3, to3) {
      this.text = text6;
      this.to = to3;
      this.done = false;
      this.value = empty6;
      this.matchPos = toCharEnd(text6, from3);
      this.re = new RegExp(query, baseFlags + ((options2 === null || options2 === void 0 ? void 0 : options2.ignoreCase) ? "i" : ""));
      this.test = options2 === null || options2 === void 0 ? void 0 : options2.test;
      this.flat = FlattenedDoc.get(text6, from3, this.chunkEnd(
        from3 + 5e3
        /* Chunk.Base */
      ));
    }
    chunkEnd(pos) {
      return pos >= this.to ? this.to : this.text.lineAt(pos).to;
    }
    next() {
      for (; ; ) {
        let off = this.re.lastIndex = this.matchPos - this.flat.from;
        let match2 = this.re.exec(this.flat.text);
        if (match2 && !match2[0] && match2.index == off) {
          this.re.lastIndex = off + 1;
          match2 = this.re.exec(this.flat.text);
        }
        if (match2) {
          let from3 = this.flat.from + match2.index, to3 = from3 + match2[0].length;
          if ((this.flat.to >= this.to || match2.index + match2[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from3, to3, match2))) {
            this.value = { from: from3, to: to3, match: match2 };
            this.matchPos = toCharEnd(this.text, to3 + (from3 == to3 ? 1 : 0));
            return this;
          }
        }
        if (this.flat.to == this.to) {
          this.done = true;
          return this;
        }
        this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
      }
    }
  };
  if (typeof Symbol != "undefined") {
    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  }
  function validRegExp(source3) {
    try {
      new RegExp(source3, baseFlags);
      return true;
    } catch (_a2) {
      return false;
    }
  }
  function toCharEnd(text6, pos) {
    if (pos >= text6.length)
      return pos;
    let line = text6.lineAt(pos), next;
    while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 56320 && next < 57344)
      pos++;
    return pos;
  }
  function createLineDialog(view2) {
    let line = String(view2.state.doc.lineAt(view2.state.selection.main.head).number);
    let input = crelt("input", { class: "cm-textfield", name: "line", value: line });
    let dom = crelt("form", {
      class: "cm-gotoLine",
      onkeydown: (event) => {
        if (event.keyCode == 27) {
          event.preventDefault();
          view2.dispatch({ effects: dialogEffect.of(false) });
          view2.focus();
        } else if (event.keyCode == 13) {
          event.preventDefault();
          go2();
        }
      },
      onsubmit: (event) => {
        event.preventDefault();
        go2();
      }
    }, crelt("label", view2.state.phrase("Go to line"), ": ", input), " ", crelt("button", { class: "cm-button", type: "submit" }, view2.state.phrase("go")));
    function go2() {
      let match2 = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
      if (!match2)
        return;
      let { state: state4 } = view2, startLine = state4.doc.lineAt(state4.selection.main.head);
      let [, sign2, ln, cl, percent] = match2;
      let col = cl ? +cl.slice(1) : 0;
      let line2 = ln ? +ln : startLine.number;
      if (ln && percent) {
        let pc = line2 / 100;
        if (sign2)
          pc = pc * (sign2 == "-" ? -1 : 1) + startLine.number / state4.doc.lines;
        line2 = Math.round(state4.doc.lines * pc);
      } else if (ln && sign2) {
        line2 = line2 * (sign2 == "-" ? -1 : 1) + startLine.number;
      }
      let docLine = state4.doc.line(Math.max(1, Math.min(state4.doc.lines, line2)));
      let selection = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));
      view2.dispatch({
        effects: [dialogEffect.of(false), EditorView.scrollIntoView(selection.from, { y: "center" })],
        selection
      });
      view2.focus();
    }
    return { dom };
  }
  var dialogEffect = /* @__PURE__ */ StateEffect.define();
  var dialogField = /* @__PURE__ */ StateField.define({
    create() {
      return true;
    },
    update(value12, tr) {
      for (let e2 of tr.effects)
        if (e2.is(dialogEffect))
          value12 = e2.value;
      return value12;
    },
    provide: (f2) => showPanel.from(f2, (val) => val ? createLineDialog : null)
  });
  var gotoLine = (view2) => {
    let panel = getPanel(view2, createLineDialog);
    if (!panel) {
      let effects = [dialogEffect.of(true)];
      if (view2.state.field(dialogField, false) == null)
        effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$13]));
      view2.dispatch({ effects });
      panel = getPanel(view2, createLineDialog);
    }
    if (panel)
      panel.dom.querySelector("input").select();
    return true;
  };
  var baseTheme$13 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-panel.cm-gotoLine": {
      padding: "2px 6px 4px",
      "& label": { fontSize: "80%" }
    }
  });
  var defaultHighlightOptions = {
    highlightWordAroundCursor: false,
    minSelectionLength: 1,
    maxMatches: 100,
    wholeWords: false
  };
  var highlightConfig = /* @__PURE__ */ Facet.define({
    combine(options2) {
      return combineConfig(options2, defaultHighlightOptions, {
        highlightWordAroundCursor: (a2, b2) => a2 || b2,
        minSelectionLength: Math.min,
        maxMatches: Math.min
      });
    }
  });
  function highlightSelectionMatches(options2) {
    let ext = [defaultTheme, matchHighlighter];
    if (options2)
      ext.push(highlightConfig.of(options2));
    return ext;
  }
  var matchDeco = /* @__PURE__ */ Decoration.mark({ class: "cm-selectionMatch" });
  var mainMatchDeco = /* @__PURE__ */ Decoration.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
  function insideWordBoundaries(check, state4, from3, to3) {
    return (from3 == 0 || check(state4.sliceDoc(from3 - 1, from3)) != CharCategory.Word) && (to3 == state4.doc.length || check(state4.sliceDoc(to3, to3 + 1)) != CharCategory.Word);
  }
  function insideWord(check, state4, from3, to3) {
    return check(state4.sliceDoc(from3, from3 + 1)) == CharCategory.Word && check(state4.sliceDoc(to3 - 1, to3)) == CharCategory.Word;
  }
  var matchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view2) {
      this.decorations = this.getDeco(view2);
    }
    update(update3) {
      if (update3.selectionSet || update3.docChanged || update3.viewportChanged)
        this.decorations = this.getDeco(update3.view);
    }
    getDeco(view2) {
      let conf = view2.state.facet(highlightConfig);
      let { state: state4 } = view2, sel = state4.selection;
      if (sel.ranges.length > 1)
        return Decoration.none;
      let range3 = sel.main, query, check = null;
      if (range3.empty) {
        if (!conf.highlightWordAroundCursor)
          return Decoration.none;
        let word = state4.wordAt(range3.head);
        if (!word)
          return Decoration.none;
        check = state4.charCategorizer(range3.head);
        query = state4.sliceDoc(word.from, word.to);
      } else {
        let len = range3.to - range3.from;
        if (len < conf.minSelectionLength || len > 200)
          return Decoration.none;
        if (conf.wholeWords) {
          query = state4.sliceDoc(range3.from, range3.to);
          check = state4.charCategorizer(range3.head);
          if (!(insideWordBoundaries(check, state4, range3.from, range3.to) && insideWord(check, state4, range3.from, range3.to)))
            return Decoration.none;
        } else {
          query = state4.sliceDoc(range3.from, range3.to);
          if (!query)
            return Decoration.none;
        }
      }
      let deco = [];
      for (let part of view2.visibleRanges) {
        let cursor = new SearchCursor(state4.doc, query, part.from, part.to);
        while (!cursor.next().done) {
          let { from: from3, to: to3 } = cursor.value;
          if (!check || insideWordBoundaries(check, state4, from3, to3)) {
            if (range3.empty && from3 <= range3.from && to3 >= range3.to)
              deco.push(mainMatchDeco.range(from3, to3));
            else if (from3 >= range3.to || to3 <= range3.from)
              deco.push(matchDeco.range(from3, to3));
            if (deco.length > conf.maxMatches)
              return Decoration.none;
          }
        }
      }
      return Decoration.set(deco);
    }
  }, {
    decorations: (v2) => v2.decorations
  });
  var defaultTheme = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
    ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
  });
  var selectWord = ({ state: state4, dispatch }) => {
    let { selection } = state4;
    let newSel = EditorSelection.create(selection.ranges.map((range3) => state4.wordAt(range3.head) || EditorSelection.cursor(range3.head)), selection.mainIndex);
    if (newSel.eq(selection))
      return false;
    dispatch(state4.update({ selection: newSel }));
    return true;
  };
  function findNextOccurrence(state4, query) {
    let { main: main4, ranges } = state4.selection;
    let word = state4.wordAt(main4.head), fullWord = word && word.from == main4.from && word.to == main4.to;
    for (let cycled = false, cursor = new SearchCursor(state4.doc, query, ranges[ranges.length - 1].to); ; ) {
      cursor.next();
      if (cursor.done) {
        if (cycled)
          return null;
        cursor = new SearchCursor(state4.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
        cycled = true;
      } else {
        if (cycled && ranges.some((r2) => r2.from == cursor.value.from))
          continue;
        if (fullWord) {
          let word2 = state4.wordAt(cursor.value.from);
          if (!word2 || word2.from != cursor.value.from || word2.to != cursor.value.to)
            continue;
        }
        return cursor.value;
      }
    }
  }
  var selectNextOccurrence = ({ state: state4, dispatch }) => {
    let { ranges } = state4.selection;
    if (ranges.some((sel) => sel.from === sel.to))
      return selectWord({ state: state4, dispatch });
    let searchedText = state4.sliceDoc(ranges[0].from, ranges[0].to);
    if (state4.selection.ranges.some((r2) => state4.sliceDoc(r2.from, r2.to) != searchedText))
      return false;
    let range3 = findNextOccurrence(state4, searchedText);
    if (!range3)
      return false;
    dispatch(state4.update({
      selection: state4.selection.addRange(EditorSelection.range(range3.from, range3.to), false),
      effects: EditorView.scrollIntoView(range3.to)
    }));
    return true;
  };
  var searchConfigFacet = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        top: false,
        caseSensitive: false,
        literal: false,
        regexp: false,
        wholeWord: false,
        createPanel: (view2) => new SearchPanel(view2),
        scrollToMatch: (range3) => EditorView.scrollIntoView(range3)
      });
    }
  });
  var SearchQuery = class {
    /**
    Create a query object.
    */
    constructor(config2) {
      this.search = config2.search;
      this.caseSensitive = !!config2.caseSensitive;
      this.literal = !!config2.literal;
      this.regexp = !!config2.regexp;
      this.replace = config2.replace || "";
      this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
      this.unquoted = this.unquote(this.search);
      this.wholeWord = !!config2.wholeWord;
    }
    /**
    @internal
    */
    unquote(text6) {
      return this.literal ? text6 : text6.replace(/\\([nrt\\])/g, (_, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
    }
    /**
    Compare this query to another query.
    */
    eq(other) {
      return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;
    }
    /**
    @internal
    */
    create() {
      return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
    }
    /**
    Get a search cursor for this query, searching through the given
    range in the given state.
    */
    getCursor(state4, from3 = 0, to3) {
      let st = state4.doc ? state4 : EditorState.create({ doc: state4 });
      if (to3 == null)
        to3 = st.doc.length;
      return this.regexp ? regexpCursor(this, st, from3, to3) : stringCursor(this, st, from3, to3);
    }
  };
  var QueryType2 = class {
    constructor(spec) {
      this.spec = spec;
    }
  };
  function stringCursor(spec, state4, from3, to3) {
    return new SearchCursor(state4.doc, spec.unquoted, from3, to3, spec.caseSensitive ? void 0 : (x2) => x2.toLowerCase(), spec.wholeWord ? stringWordTest(state4.doc, state4.charCategorizer(state4.selection.main.head)) : void 0);
  }
  function stringWordTest(doc2, categorizer) {
    return (from3, to3, buf, bufPos) => {
      if (bufPos > from3 || bufPos + buf.length < to3) {
        bufPos = Math.max(0, from3 - 2);
        buf = doc2.sliceString(bufPos, Math.min(doc2.length, to3 + 2));
      }
      return (categorizer(charBefore(buf, from3 - bufPos)) != CharCategory.Word || categorizer(charAfter(buf, from3 - bufPos)) != CharCategory.Word) && (categorizer(charAfter(buf, to3 - bufPos)) != CharCategory.Word || categorizer(charBefore(buf, to3 - bufPos)) != CharCategory.Word);
    };
  }
  var StringQuery = class extends QueryType2 {
    constructor(spec) {
      super(spec);
    }
    nextMatch(state4, curFrom, curTo) {
      let cursor = stringCursor(this.spec, state4, curTo, state4.doc.length).nextOverlapping();
      if (cursor.done) {
        let end = Math.min(state4.doc.length, curFrom + this.spec.unquoted.length);
        cursor = stringCursor(this.spec, state4, 0, end).nextOverlapping();
      }
      return cursor.done || cursor.value.from == curFrom && cursor.value.to == curTo ? null : cursor.value;
    }
    // Searching in reverse is, rather than implementing an inverted search
    // cursor, done by scanning chunk after chunk forward.
    prevMatchInRange(state4, from3, to3) {
      for (let pos = to3; ; ) {
        let start3 = Math.max(from3, pos - 1e4 - this.spec.unquoted.length);
        let cursor = stringCursor(this.spec, state4, start3, pos), range3 = null;
        while (!cursor.nextOverlapping().done)
          range3 = cursor.value;
        if (range3)
          return range3;
        if (start3 == from3)
          return null;
        pos -= 1e4;
      }
    }
    prevMatch(state4, curFrom, curTo) {
      let found = this.prevMatchInRange(state4, 0, curFrom);
      if (!found)
        found = this.prevMatchInRange(state4, Math.max(0, curTo - this.spec.unquoted.length), state4.doc.length);
      return found && (found.from != curFrom || found.to != curTo) ? found : null;
    }
    getReplacement(_result) {
      return this.spec.unquote(this.spec.replace);
    }
    matchAll(state4, limit) {
      let cursor = stringCursor(this.spec, state4, 0, state4.doc.length), ranges = [];
      while (!cursor.next().done) {
        if (ranges.length >= limit)
          return null;
        ranges.push(cursor.value);
      }
      return ranges;
    }
    highlight(state4, from3, to3, add5) {
      let cursor = stringCursor(this.spec, state4, Math.max(0, from3 - this.spec.unquoted.length), Math.min(to3 + this.spec.unquoted.length, state4.doc.length));
      while (!cursor.next().done)
        add5(cursor.value.from, cursor.value.to);
    }
  };
  function regexpCursor(spec, state4, from3, to3) {
    return new RegExpCursor(state4.doc, spec.search, {
      ignoreCase: !spec.caseSensitive,
      test: spec.wholeWord ? regexpWordTest(state4.charCategorizer(state4.selection.main.head)) : void 0
    }, from3, to3);
  }
  function charBefore(str, index6) {
    return str.slice(findClusterBreak(str, index6, false), index6);
  }
  function charAfter(str, index6) {
    return str.slice(index6, findClusterBreak(str, index6));
  }
  function regexpWordTest(categorizer) {
    return (_from, _to, match2) => !match2[0].length || (categorizer(charBefore(match2.input, match2.index)) != CharCategory.Word || categorizer(charAfter(match2.input, match2.index)) != CharCategory.Word) && (categorizer(charAfter(match2.input, match2.index + match2[0].length)) != CharCategory.Word || categorizer(charBefore(match2.input, match2.index + match2[0].length)) != CharCategory.Word);
  }
  var RegExpQuery = class extends QueryType2 {
    nextMatch(state4, curFrom, curTo) {
      let cursor = regexpCursor(this.spec, state4, curTo, state4.doc.length).next();
      if (cursor.done)
        cursor = regexpCursor(this.spec, state4, 0, curFrom).next();
      return cursor.done ? null : cursor.value;
    }
    prevMatchInRange(state4, from3, to3) {
      for (let size5 = 1; ; size5++) {
        let start3 = Math.max(
          from3,
          to3 - size5 * 1e4
          /* FindPrev.ChunkSize */
        );
        let cursor = regexpCursor(this.spec, state4, start3, to3), range3 = null;
        while (!cursor.next().done)
          range3 = cursor.value;
        if (range3 && (start3 == from3 || range3.from > start3 + 10))
          return range3;
        if (start3 == from3)
          return null;
      }
    }
    prevMatch(state4, curFrom, curTo) {
      return this.prevMatchInRange(state4, 0, curFrom) || this.prevMatchInRange(state4, curTo, state4.doc.length);
    }
    getReplacement(result) {
      return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (m2, i2) => i2 == "$" ? "$" : i2 == "&" ? result.match[0] : i2 != "0" && +i2 < result.match.length ? result.match[i2] : m2);
    }
    matchAll(state4, limit) {
      let cursor = regexpCursor(this.spec, state4, 0, state4.doc.length), ranges = [];
      while (!cursor.next().done) {
        if (ranges.length >= limit)
          return null;
        ranges.push(cursor.value);
      }
      return ranges;
    }
    highlight(state4, from3, to3, add5) {
      let cursor = regexpCursor(this.spec, state4, Math.max(
        0,
        from3 - 250
        /* RegExp.HighlightMargin */
      ), Math.min(to3 + 250, state4.doc.length));
      while (!cursor.next().done)
        add5(cursor.value.from, cursor.value.to);
    }
  };
  var setSearchQuery = /* @__PURE__ */ StateEffect.define();
  var togglePanel = /* @__PURE__ */ StateEffect.define();
  var searchState = /* @__PURE__ */ StateField.define({
    create(state4) {
      return new SearchState(defaultQuery(state4).create(), null);
    },
    update(value12, tr) {
      for (let effect of tr.effects) {
        if (effect.is(setSearchQuery))
          value12 = new SearchState(effect.value.create(), value12.panel);
        else if (effect.is(togglePanel))
          value12 = new SearchState(value12.query, effect.value ? createSearchPanel : null);
      }
      return value12;
    },
    provide: (f2) => showPanel.from(f2, (val) => val.panel)
  });
  var SearchState = class {
    constructor(query, panel) {
      this.query = query;
      this.panel = panel;
    }
  };
  var matchMark = /* @__PURE__ */ Decoration.mark({ class: "cm-searchMatch" });
  var selectedMatchMark = /* @__PURE__ */ Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
  var searchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view2) {
      this.view = view2;
      this.decorations = this.highlight(view2.state.field(searchState));
    }
    update(update3) {
      let state4 = update3.state.field(searchState);
      if (state4 != update3.startState.field(searchState) || update3.docChanged || update3.selectionSet || update3.viewportChanged)
        this.decorations = this.highlight(state4);
    }
    highlight({ query, panel }) {
      if (!panel || !query.spec.valid)
        return Decoration.none;
      let { view: view2 } = this;
      let builder = new RangeSetBuilder();
      for (let i2 = 0, ranges = view2.visibleRanges, l2 = ranges.length; i2 < l2; i2++) {
        let { from: from3, to: to3 } = ranges[i2];
        while (i2 < l2 - 1 && to3 > ranges[i2 + 1].from - 2 * 250)
          to3 = ranges[++i2].to;
        query.highlight(view2.state, from3, to3, (from4, to4) => {
          let selected2 = view2.state.selection.ranges.some((r2) => r2.from == from4 && r2.to == to4);
          builder.add(from4, to4, selected2 ? selectedMatchMark : matchMark);
        });
      }
      return builder.finish();
    }
  }, {
    decorations: (v2) => v2.decorations
  });
  function searchCommand(f2) {
    return (view2) => {
      let state4 = view2.state.field(searchState, false);
      return state4 && state4.query.spec.valid ? f2(view2, state4) : openSearchPanel(view2);
    };
  }
  var findNext = /* @__PURE__ */ searchCommand((view2, { query }) => {
    let { to: to3 } = view2.state.selection.main;
    let next = query.nextMatch(view2.state, to3, to3);
    if (!next)
      return false;
    let selection = EditorSelection.single(next.from, next.to);
    let config2 = view2.state.facet(searchConfigFacet);
    view2.dispatch({
      selection,
      effects: [announceMatch(view2, next), config2.scrollToMatch(selection.main, view2)],
      userEvent: "select.search"
    });
    selectSearchInput(view2);
    return true;
  });
  var findPrevious = /* @__PURE__ */ searchCommand((view2, { query }) => {
    let { state: state4 } = view2, { from: from3 } = state4.selection.main;
    let prev = query.prevMatch(state4, from3, from3);
    if (!prev)
      return false;
    let selection = EditorSelection.single(prev.from, prev.to);
    let config2 = view2.state.facet(searchConfigFacet);
    view2.dispatch({
      selection,
      effects: [announceMatch(view2, prev), config2.scrollToMatch(selection.main, view2)],
      userEvent: "select.search"
    });
    selectSearchInput(view2);
    return true;
  });
  var selectMatches = /* @__PURE__ */ searchCommand((view2, { query }) => {
    let ranges = query.matchAll(view2.state, 1e3);
    if (!ranges || !ranges.length)
      return false;
    view2.dispatch({
      selection: EditorSelection.create(ranges.map((r2) => EditorSelection.range(r2.from, r2.to))),
      userEvent: "select.search.matches"
    });
    return true;
  });
  var selectSelectionMatches = ({ state: state4, dispatch }) => {
    let sel = state4.selection;
    if (sel.ranges.length > 1 || sel.main.empty)
      return false;
    let { from: from3, to: to3 } = sel.main;
    let ranges = [], main4 = 0;
    for (let cur2 = new SearchCursor(state4.doc, state4.sliceDoc(from3, to3)); !cur2.next().done; ) {
      if (ranges.length > 1e3)
        return false;
      if (cur2.value.from == from3)
        main4 = ranges.length;
      ranges.push(EditorSelection.range(cur2.value.from, cur2.value.to));
    }
    dispatch(state4.update({
      selection: EditorSelection.create(ranges, main4),
      userEvent: "select.search.matches"
    }));
    return true;
  };
  var replaceNext = /* @__PURE__ */ searchCommand((view2, { query }) => {
    let { state: state4 } = view2, { from: from3, to: to3 } = state4.selection.main;
    if (state4.readOnly)
      return false;
    let next = query.nextMatch(state4, from3, from3);
    if (!next)
      return false;
    let changes = [], selection, replacement;
    let effects = [];
    if (next.from == from3 && next.to == to3) {
      replacement = state4.toText(query.getReplacement(next));
      changes.push({ from: next.from, to: next.to, insert: replacement });
      next = query.nextMatch(state4, next.from, next.to);
      effects.push(EditorView.announce.of(state4.phrase("replaced match on line $", state4.doc.lineAt(from3).number) + "."));
    }
    if (next) {
      let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;
      selection = EditorSelection.single(next.from - off, next.to - off);
      effects.push(announceMatch(view2, next));
      effects.push(state4.facet(searchConfigFacet).scrollToMatch(selection.main, view2));
    }
    view2.dispatch({
      changes,
      selection,
      effects,
      userEvent: "input.replace"
    });
    return true;
  });
  var replaceAll3 = /* @__PURE__ */ searchCommand((view2, { query }) => {
    if (view2.state.readOnly)
      return false;
    let changes = query.matchAll(view2.state, 1e9).map((match2) => {
      let { from: from3, to: to3 } = match2;
      return { from: from3, to: to3, insert: query.getReplacement(match2) };
    });
    if (!changes.length)
      return false;
    let announceText = view2.state.phrase("replaced $ matches", changes.length) + ".";
    view2.dispatch({
      changes,
      effects: EditorView.announce.of(announceText),
      userEvent: "input.replace.all"
    });
    return true;
  });
  function createSearchPanel(view2) {
    return view2.state.facet(searchConfigFacet).createPanel(view2);
  }
  function defaultQuery(state4, fallback) {
    var _a2, _b, _c, _d, _e;
    let sel = state4.selection.main;
    let selText = sel.empty || sel.to > sel.from + 100 ? "" : state4.sliceDoc(sel.from, sel.to);
    if (fallback && !selText)
      return fallback;
    let config2 = state4.facet(searchConfigFacet);
    return new SearchQuery({
      search: ((_a2 = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a2 !== void 0 ? _a2 : config2.literal) ? selText : selText.replace(/\n/g, "\\n"),
      caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config2.caseSensitive,
      literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config2.literal,
      regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config2.regexp,
      wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config2.wholeWord
    });
  }
  function getSearchInput(view2) {
    let panel = getPanel(view2, createSearchPanel);
    return panel && panel.dom.querySelector("[main-field]");
  }
  function selectSearchInput(view2) {
    let input = getSearchInput(view2);
    if (input && input == view2.root.activeElement)
      input.select();
  }
  var openSearchPanel = (view2) => {
    let state4 = view2.state.field(searchState, false);
    if (state4 && state4.panel) {
      let searchInput = getSearchInput(view2);
      if (searchInput && searchInput != view2.root.activeElement) {
        let query = defaultQuery(view2.state, state4.query.spec);
        if (query.valid)
          view2.dispatch({ effects: setSearchQuery.of(query) });
        searchInput.focus();
        searchInput.select();
      }
    } else {
      view2.dispatch({ effects: [
        togglePanel.of(true),
        state4 ? setSearchQuery.of(defaultQuery(view2.state, state4.query.spec)) : StateEffect.appendConfig.of(searchExtensions)
      ] });
    }
    return true;
  };
  var closeSearchPanel = (view2) => {
    let state4 = view2.state.field(searchState, false);
    if (!state4 || !state4.panel)
      return false;
    let panel = getPanel(view2, createSearchPanel);
    if (panel && panel.dom.contains(view2.root.activeElement))
      view2.focus();
    view2.dispatch({ effects: togglePanel.of(false) });
    return true;
  };
  var searchKeymap = [
    { key: "Mod-f", run: openSearchPanel, scope: "editor search-panel" },
    { key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
    { key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
    { key: "Escape", run: closeSearchPanel, scope: "editor search-panel" },
    { key: "Mod-Shift-l", run: selectSelectionMatches },
    { key: "Mod-Alt-g", run: gotoLine },
    { key: "Mod-d", run: selectNextOccurrence, preventDefault: true }
  ];
  var SearchPanel = class {
    constructor(view2) {
      this.view = view2;
      let query = this.query = view2.state.field(searchState).query.spec;
      this.commit = this.commit.bind(this);
      this.searchField = crelt("input", {
        value: query.search,
        placeholder: phrase(view2, "Find"),
        "aria-label": phrase(view2, "Find"),
        class: "cm-textfield",
        name: "search",
        form: "",
        "main-field": "true",
        onchange: this.commit,
        onkeyup: this.commit
      });
      this.replaceField = crelt("input", {
        value: query.replace,
        placeholder: phrase(view2, "Replace"),
        "aria-label": phrase(view2, "Replace"),
        class: "cm-textfield",
        name: "replace",
        form: "",
        onchange: this.commit,
        onkeyup: this.commit
      });
      this.caseField = crelt("input", {
        type: "checkbox",
        name: "case",
        form: "",
        checked: query.caseSensitive,
        onchange: this.commit
      });
      this.reField = crelt("input", {
        type: "checkbox",
        name: "re",
        form: "",
        checked: query.regexp,
        onchange: this.commit
      });
      this.wordField = crelt("input", {
        type: "checkbox",
        name: "word",
        form: "",
        checked: query.wholeWord,
        onchange: this.commit
      });
      function button3(name16, onclick, content4) {
        return crelt("button", { class: "cm-button", name: name16, onclick, type: "button" }, content4);
      }
      this.dom = crelt("div", { onkeydown: (e2) => this.keydown(e2), class: "cm-search" }, [
        this.searchField,
        button3("next", () => findNext(view2), [phrase(view2, "next")]),
        button3("prev", () => findPrevious(view2), [phrase(view2, "previous")]),
        button3("select", () => selectMatches(view2), [phrase(view2, "all")]),
        crelt("label", null, [this.caseField, phrase(view2, "match case")]),
        crelt("label", null, [this.reField, phrase(view2, "regexp")]),
        crelt("label", null, [this.wordField, phrase(view2, "by word")]),
        ...view2.state.readOnly ? [] : [
          crelt("br"),
          this.replaceField,
          button3("replace", () => replaceNext(view2), [phrase(view2, "replace")]),
          button3("replaceAll", () => replaceAll3(view2), [phrase(view2, "replace all")])
        ],
        crelt("button", {
          name: "close",
          onclick: () => closeSearchPanel(view2),
          "aria-label": phrase(view2, "close"),
          type: "button"
        }, ["\xD7"])
      ]);
    }
    commit() {
      let query = new SearchQuery({
        search: this.searchField.value,
        caseSensitive: this.caseField.checked,
        regexp: this.reField.checked,
        wholeWord: this.wordField.checked,
        replace: this.replaceField.value
      });
      if (!query.eq(this.query)) {
        this.query = query;
        this.view.dispatch({ effects: setSearchQuery.of(query) });
      }
    }
    keydown(e2) {
      if (runScopeHandlers(this.view, e2, "search-panel")) {
        e2.preventDefault();
      } else if (e2.keyCode == 13 && e2.target == this.searchField) {
        e2.preventDefault();
        (e2.shiftKey ? findPrevious : findNext)(this.view);
      } else if (e2.keyCode == 13 && e2.target == this.replaceField) {
        e2.preventDefault();
        replaceNext(this.view);
      }
    }
    update(update3) {
      for (let tr of update3.transactions)
        for (let effect of tr.effects) {
          if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
            this.setQuery(effect.value);
        }
    }
    setQuery(query) {
      this.query = query;
      this.searchField.value = query.search;
      this.replaceField.value = query.replace;
      this.caseField.checked = query.caseSensitive;
      this.reField.checked = query.regexp;
      this.wordField.checked = query.wholeWord;
    }
    mount() {
      this.searchField.select();
    }
    get pos() {
      return 80;
    }
    get top() {
      return this.view.state.facet(searchConfigFacet).top;
    }
  };
  function phrase(view2, phrase2) {
    return view2.state.phrase(phrase2);
  }
  var AnnounceMargin = 30;
  var Break = /[\s\.,:;?!]/;
  function announceMatch(view2, { from: from3, to: to3 }) {
    let line = view2.state.doc.lineAt(from3), lineEnd = view2.state.doc.lineAt(to3).to;
    let start3 = Math.max(line.from, from3 - AnnounceMargin), end = Math.min(lineEnd, to3 + AnnounceMargin);
    let text6 = view2.state.sliceDoc(start3, end);
    if (start3 != line.from) {
      for (let i2 = 0; i2 < AnnounceMargin; i2++)
        if (!Break.test(text6[i2 + 1]) && Break.test(text6[i2])) {
          text6 = text6.slice(i2);
          break;
        }
    }
    if (end != lineEnd) {
      for (let i2 = text6.length - 1; i2 > text6.length - AnnounceMargin; i2--)
        if (!Break.test(text6[i2 - 1]) && Break.test(text6[i2])) {
          text6 = text6.slice(0, i2);
          break;
        }
    }
    return EditorView.announce.of(`${view2.state.phrase("current match")}. ${text6} ${view2.state.phrase("on line")} ${line.number}.`);
  }
  var baseTheme3 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-panel.cm-search": {
      padding: "2px 6px 4px",
      position: "relative",
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "4px",
        backgroundColor: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0
      },
      "& input, & button, & label": {
        margin: ".2em .6em .2em 0"
      },
      "& input[type=checkbox]": {
        marginRight: ".2em"
      },
      "& label": {
        fontSize: "80%",
        whiteSpace: "pre"
      }
    },
    "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
    "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
    "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
    "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
  });
  var searchExtensions = [
    searchState,
    /* @__PURE__ */ Prec.low(searchHighlighter),
    baseTheme3
  ];

  // node_modules/@codemirror/autocomplete/dist/index.js
  var CompletionContext = class {
    /**
    Create a new completion context. (Mostly useful for testing
    completion sources—in the editor, the extension will create
    these for you.)
    */
    constructor(state4, pos, explicit, view2) {
      this.state = state4;
      this.pos = pos;
      this.explicit = explicit;
      this.view = view2;
      this.abortListeners = [];
      this.abortOnDocChange = false;
    }
    /**
    Get the extent, content, and (if there is a token) type of the
    token before `this.pos`.
    */
    tokenBefore(types2) {
      let token = syntaxTree(this.state).resolveInner(this.pos, -1);
      while (token && types2.indexOf(token.name) < 0)
        token = token.parent;
      return token ? {
        from: token.from,
        to: this.pos,
        text: this.state.sliceDoc(token.from, this.pos),
        type: token.type
      } : null;
    }
    /**
    Get the match of the given expression directly before the
    cursor.
    */
    matchBefore(expr) {
      let line = this.state.doc.lineAt(this.pos);
      let start3 = Math.max(line.from, this.pos - 250);
      let str = line.text.slice(start3 - line.from, this.pos - line.from);
      let found = str.search(ensureAnchor(expr, false));
      return found < 0 ? null : { from: start3 + found, to: this.pos, text: str.slice(found) };
    }
    /**
    Yields true when the query has been aborted. Can be useful in
    asynchronous queries to avoid doing work that will be ignored.
    */
    get aborted() {
      return this.abortListeners == null;
    }
    /**
    Allows you to register abort handlers, which will be called when
    the query is
    [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
    
    By default, running queries will not be aborted for regular
    typing or backspacing, on the assumption that they are likely to
    return a result with a
    [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
    allows the result to be used after all. Passing `onDocChange:
    true` will cause this query to be aborted for any document
    change.
    */
    addEventListener(type, listener, options2) {
      if (type == "abort" && this.abortListeners) {
        this.abortListeners.push(listener);
        if (options2 && options2.onDocChange)
          this.abortOnDocChange = true;
      }
    }
  };
  function toSet(chars) {
    let flat = Object.keys(chars).join("");
    let words2 = /\w/.test(flat);
    if (words2)
      flat = flat.replace(/\w/g, "");
    return `[${words2 ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
  }
  function prefixMatch(options2) {
    let first = /* @__PURE__ */ Object.create(null), rest = /* @__PURE__ */ Object.create(null);
    for (let { label: label4 } of options2) {
      first[label4[0]] = true;
      for (let i2 = 1; i2 < label4.length; i2++)
        rest[label4[i2]] = true;
    }
    let source3 = toSet(first) + toSet(rest) + "*$";
    return [new RegExp("^" + source3), new RegExp(source3)];
  }
  function completeFromList(list) {
    let options2 = list.map((o2) => typeof o2 == "string" ? { label: o2 } : o2);
    let [validFor, match2] = options2.every((o2) => /^\w+$/.test(o2.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options2);
    return (context3) => {
      let token = context3.matchBefore(match2);
      return token || context3.explicit ? { from: token ? token.from : context3.pos, options: options2, validFor } : null;
    };
  }
  function ifNotIn(nodes, source3) {
    return (context3) => {
      for (let pos = syntaxTree(context3.state).resolveInner(context3.pos, -1); pos; pos = pos.parent) {
        if (nodes.indexOf(pos.name) > -1)
          return null;
        if (pos.type.isTop)
          break;
      }
      return source3(context3);
    };
  }
  var Option = class {
    constructor(completion, source3, match2, score2) {
      this.completion = completion;
      this.source = source3;
      this.match = match2;
      this.score = score2;
    }
  };
  function cur(state4) {
    return state4.selection.main.from;
  }
  function ensureAnchor(expr, start3) {
    var _a2;
    let { source: source3 } = expr;
    let addStart = start3 && source3[0] != "^", addEnd = source3[source3.length - 1] != "$";
    if (!addStart && !addEnd)
      return expr;
    return new RegExp(`${addStart ? "^" : ""}(?:${source3})${addEnd ? "$" : ""}`, (_a2 = expr.flags) !== null && _a2 !== void 0 ? _a2 : expr.ignoreCase ? "i" : "");
  }
  var pickedCompletion = /* @__PURE__ */ Annotation.define();
  function insertCompletionText(state4, text6, from3, to3) {
    let { main: main4 } = state4.selection, fromOff = from3 - main4.from, toOff = to3 - main4.from;
    return Object.assign(Object.assign({}, state4.changeByRange((range3) => {
      if (range3 != main4 && from3 != to3 && state4.sliceDoc(range3.from + fromOff, range3.from + toOff) != state4.sliceDoc(from3, to3))
        return { range: range3 };
      let lines = state4.toText(text6);
      return {
        changes: { from: range3.from + fromOff, to: to3 == main4.from ? range3.to : range3.from + toOff, insert: lines },
        range: EditorSelection.cursor(range3.from + fromOff + lines.length)
      };
    })), { scrollIntoView: true, userEvent: "input.complete" });
  }
  var SourceCache = /* @__PURE__ */ new WeakMap();
  function asSource(source3) {
    if (!Array.isArray(source3))
      return source3;
    let known = SourceCache.get(source3);
    if (!known)
      SourceCache.set(source3, known = completeFromList(source3));
    return known;
  }
  var startCompletionEffect = /* @__PURE__ */ StateEffect.define();
  var closeCompletionEffect = /* @__PURE__ */ StateEffect.define();
  var FuzzyMatcher = class {
    constructor(pattern2) {
      this.pattern = pattern2;
      this.chars = [];
      this.folded = [];
      this.any = [];
      this.precise = [];
      this.byWord = [];
      this.score = 0;
      this.matched = [];
      for (let p2 = 0; p2 < pattern2.length; ) {
        let char2 = codePointAt2(pattern2, p2), size5 = codePointSize(char2);
        this.chars.push(char2);
        let part = pattern2.slice(p2, p2 + size5), upper2 = part.toUpperCase();
        this.folded.push(codePointAt2(upper2 == part ? part.toLowerCase() : upper2, 0));
        p2 += size5;
      }
      this.astral = pattern2.length != this.chars.length;
    }
    ret(score2, matched) {
      this.score = score2;
      this.matched = matched;
      return this;
    }
    // Matches a given word (completion) against the pattern (input).
    // Will return a boolean indicating whether there was a match and,
    // on success, set `this.score` to the score, `this.matched` to an
    // array of `from, to` pairs indicating the matched parts of `word`.
    //
    // The score is a number that is more negative the worse the match
    // is. See `Penalty` above.
    match(word) {
      if (this.pattern.length == 0)
        return this.ret(-100, []);
      if (word.length < this.pattern.length)
        return null;
      let { chars, folded, any: any3, precise, byWord } = this;
      if (chars.length == 1) {
        let first = codePointAt2(word, 0), firstSize = codePointSize(first);
        let score2 = firstSize == word.length ? 0 : -100;
        if (first == chars[0]) ;
        else if (first == folded[0])
          score2 += -200;
        else
          return null;
        return this.ret(score2, [0, firstSize]);
      }
      let direct = word.indexOf(this.pattern);
      if (direct == 0)
        return this.ret(word.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
      let len = chars.length, anyTo = 0;
      if (direct < 0) {
        for (let i2 = 0, e2 = Math.min(word.length, 200); i2 < e2 && anyTo < len; ) {
          let next = codePointAt2(word, i2);
          if (next == chars[anyTo] || next == folded[anyTo])
            any3[anyTo++] = i2;
          i2 += codePointSize(next);
        }
        if (anyTo < len)
          return null;
      }
      let preciseTo = 0;
      let byWordTo = 0, byWordFolded = false;
      let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
      let hasLower = /[a-z]/.test(word), wordAdjacent = true;
      for (let i2 = 0, e2 = Math.min(word.length, 200), prevType = 0; i2 < e2 && byWordTo < len; ) {
        let next = codePointAt2(word, i2);
        if (direct < 0) {
          if (preciseTo < len && next == chars[preciseTo])
            precise[preciseTo++] = i2;
          if (adjacentTo < len) {
            if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
              if (adjacentTo == 0)
                adjacentStart = i2;
              adjacentEnd = i2 + 1;
              adjacentTo++;
            } else {
              adjacentTo = 0;
            }
          }
        }
        let ch, type = next < 255 ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 : next >= 65 && next <= 90 ? 1 : 0 : (ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 : ch != ch.toUpperCase() ? 2 : 0;
        if (!i2 || type == 1 && hasLower || prevType == 0 && type != 0) {
          if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true))
            byWord[byWordTo++] = i2;
          else if (byWord.length)
            wordAdjacent = false;
        }
        prevType = type;
        i2 += codePointSize(next);
      }
      if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
        return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);
      if (adjacentTo == len && adjacentStart == 0)
        return this.ret(-200 - word.length + (adjacentEnd == word.length ? 0 : -100), [0, adjacentEnd]);
      if (direct > -1)
        return this.ret(-700 - word.length, [direct, direct + this.pattern.length]);
      if (adjacentTo == len)
        return this.ret(-200 + -700 - word.length, [adjacentStart, adjacentEnd]);
      if (byWordTo == len)
        return this.result(-100 + (byWordFolded ? -200 : 0) + -700 + (wordAdjacent ? 0 : -1100), byWord, word);
      return chars.length == 2 ? null : this.result((any3[0] ? -700 : 0) + -200 + -1100, any3, word);
    }
    result(score2, positions, word) {
      let result = [], i2 = 0;
      for (let pos of positions) {
        let to3 = pos + (this.astral ? codePointSize(codePointAt2(word, pos)) : 1);
        if (i2 && result[i2 - 1] == pos)
          result[i2 - 1] = to3;
        else {
          result[i2++] = pos;
          result[i2++] = to3;
        }
      }
      return this.ret(score2 - word.length, result);
    }
  };
  var StrictMatcher = class {
    constructor(pattern2) {
      this.pattern = pattern2;
      this.matched = [];
      this.score = 0;
      this.folded = pattern2.toLowerCase();
    }
    match(word) {
      if (word.length < this.pattern.length)
        return null;
      let start3 = word.slice(0, this.pattern.length);
      let match2 = start3 == this.pattern ? 0 : start3.toLowerCase() == this.folded ? -200 : null;
      if (match2 == null)
        return null;
      this.matched = [0, start3.length];
      this.score = match2 + (word.length == this.pattern.length ? 0 : -100);
      return this;
    }
  };
  var completionConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        activateOnTyping: true,
        activateOnCompletion: () => false,
        activateOnTypingDelay: 100,
        selectOnOpen: true,
        override: null,
        closeOnBlur: true,
        maxRenderedOptions: 100,
        defaultKeymap: true,
        tooltipClass: () => "",
        optionClass: () => "",
        aboveCursor: false,
        icons: true,
        addToOptions: [],
        positionInfo: defaultPositionInfo,
        filterStrict: false,
        compareCompletions: (a2, b2) => a2.label.localeCompare(b2.label),
        interactionDelay: 75,
        updateSyncTime: 100
      }, {
        defaultKeymap: (a2, b2) => a2 && b2,
        closeOnBlur: (a2, b2) => a2 && b2,
        icons: (a2, b2) => a2 && b2,
        tooltipClass: (a2, b2) => (c2) => joinClass(a2(c2), b2(c2)),
        optionClass: (a2, b2) => (c2) => joinClass(a2(c2), b2(c2)),
        addToOptions: (a2, b2) => a2.concat(b2),
        filterStrict: (a2, b2) => a2 || b2
      });
    }
  });
  function joinClass(a2, b2) {
    return a2 ? b2 ? a2 + " " + b2 : a2 : b2;
  }
  function defaultPositionInfo(view2, list, option, info2, space2, tooltip) {
    let rtl = view2.textDirection == Direction.RTL, left = rtl, narrow = false;
    let side = "top", offset, maxWidth;
    let spaceLeft = list.left - space2.left, spaceRight = space2.right - list.right;
    let infoWidth = info2.right - info2.left, infoHeight = info2.bottom - info2.top;
    if (left && spaceLeft < Math.min(infoWidth, spaceRight))
      left = false;
    else if (!left && spaceRight < Math.min(infoWidth, spaceLeft))
      left = true;
    if (infoWidth <= (left ? spaceLeft : spaceRight)) {
      offset = Math.max(space2.top, Math.min(option.top, space2.bottom - infoHeight)) - list.top;
      maxWidth = Math.min(400, left ? spaceLeft : spaceRight);
    } else {
      narrow = true;
      maxWidth = Math.min(
        400,
        (rtl ? list.right : space2.right - list.left) - 30
        /* Info.Margin */
      );
      let spaceBelow = space2.bottom - list.bottom;
      if (spaceBelow >= infoHeight || spaceBelow > list.top) {
        offset = option.bottom - list.top;
      } else {
        side = "bottom";
        offset = list.bottom - option.top;
      }
    }
    let scaleY = (list.bottom - list.top) / tooltip.offsetHeight;
    let scaleX = (list.right - list.left) / tooltip.offsetWidth;
    return {
      style: `${side}: ${offset / scaleY}px; max-width: ${maxWidth / scaleX}px`,
      class: "cm-completionInfo-" + (narrow ? rtl ? "left-narrow" : "right-narrow" : left ? "left" : "right")
    };
  }
  function optionContent(config2) {
    let content4 = config2.addToOptions.slice();
    if (config2.icons)
      content4.push({
        render(completion) {
          let icon = document.createElement("div");
          icon.classList.add("cm-completionIcon");
          if (completion.type)
            icon.classList.add(...completion.type.split(/\s+/g).map((cls) => "cm-completionIcon-" + cls));
          icon.setAttribute("aria-hidden", "true");
          return icon;
        },
        position: 20
      });
    content4.push({
      render(completion, _s, _v, match2) {
        let labelElt = document.createElement("span");
        labelElt.className = "cm-completionLabel";
        let label4 = completion.displayLabel || completion.label, off = 0;
        for (let j2 = 0; j2 < match2.length; ) {
          let from3 = match2[j2++], to3 = match2[j2++];
          if (from3 > off)
            labelElt.appendChild(document.createTextNode(label4.slice(off, from3)));
          let span4 = labelElt.appendChild(document.createElement("span"));
          span4.appendChild(document.createTextNode(label4.slice(from3, to3)));
          span4.className = "cm-completionMatchedText";
          off = to3;
        }
        if (off < label4.length)
          labelElt.appendChild(document.createTextNode(label4.slice(off)));
        return labelElt;
      },
      position: 50
    }, {
      render(completion) {
        if (!completion.detail)
          return null;
        let detailElt = document.createElement("span");
        detailElt.className = "cm-completionDetail";
        detailElt.textContent = completion.detail;
        return detailElt;
      },
      position: 80
    });
    return content4.sort((a2, b2) => a2.position - b2.position).map((a2) => a2.render);
  }
  function rangeAroundSelected(total, selected2, max7) {
    if (total <= max7)
      return { from: 0, to: total };
    if (selected2 < 0)
      selected2 = 0;
    if (selected2 <= total >> 1) {
      let off2 = Math.floor(selected2 / max7);
      return { from: off2 * max7, to: (off2 + 1) * max7 };
    }
    let off = Math.floor((total - selected2) / max7);
    return { from: total - (off + 1) * max7, to: total - off * max7 };
  }
  var CompletionTooltip = class {
    constructor(view2, stateField, applyCompletion2) {
      this.view = view2;
      this.stateField = stateField;
      this.applyCompletion = applyCompletion2;
      this.info = null;
      this.infoDestroy = null;
      this.placeInfoReq = {
        read: () => this.measureInfo(),
        write: (pos) => this.placeInfo(pos),
        key: this
      };
      this.space = null;
      this.currentClass = "";
      let cState = view2.state.field(stateField);
      let { options: options2, selected: selected2 } = cState.open;
      let config2 = view2.state.facet(completionConfig);
      this.optionContent = optionContent(config2);
      this.optionClass = config2.optionClass;
      this.tooltipClass = config2.tooltipClass;
      this.range = rangeAroundSelected(options2.length, selected2, config2.maxRenderedOptions);
      this.dom = document.createElement("div");
      this.dom.className = "cm-tooltip-autocomplete";
      this.updateTooltipClass(view2.state);
      this.dom.addEventListener("mousedown", (e2) => {
        let { options: options3 } = view2.state.field(stateField).open;
        for (let dom = e2.target, match2; dom && dom != this.dom; dom = dom.parentNode) {
          if (dom.nodeName == "LI" && (match2 = /-(\d+)$/.exec(dom.id)) && +match2[1] < options3.length) {
            this.applyCompletion(view2, options3[+match2[1]]);
            e2.preventDefault();
            return;
          }
        }
      });
      this.dom.addEventListener("focusout", (e2) => {
        let state4 = view2.state.field(this.stateField, false);
        if (state4 && state4.tooltip && view2.state.facet(completionConfig).closeOnBlur && e2.relatedTarget != view2.contentDOM)
          view2.dispatch({ effects: closeCompletionEffect.of(null) });
      });
      this.showOptions(options2, cState.id);
    }
    mount() {
      this.updateSel();
    }
    showOptions(options2, id5) {
      if (this.list)
        this.list.remove();
      this.list = this.dom.appendChild(this.createListBox(options2, id5, this.range));
      this.list.addEventListener("scroll", () => {
        if (this.info)
          this.view.requestMeasure(this.placeInfoReq);
      });
    }
    update(update3) {
      var _a2;
      let cState = update3.state.field(this.stateField);
      let prevState = update3.startState.field(this.stateField);
      this.updateTooltipClass(update3.state);
      if (cState != prevState) {
        let { options: options2, selected: selected2, disabled: disabled10 } = cState.open;
        if (!prevState.open || prevState.open.options != options2) {
          this.range = rangeAroundSelected(options2.length, selected2, update3.state.facet(completionConfig).maxRenderedOptions);
          this.showOptions(options2, cState.id);
        }
        this.updateSel();
        if (disabled10 != ((_a2 = prevState.open) === null || _a2 === void 0 ? void 0 : _a2.disabled))
          this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!disabled10);
      }
    }
    updateTooltipClass(state4) {
      let cls = this.tooltipClass(state4);
      if (cls != this.currentClass) {
        for (let c2 of this.currentClass.split(" "))
          if (c2)
            this.dom.classList.remove(c2);
        for (let c2 of cls.split(" "))
          if (c2)
            this.dom.classList.add(c2);
        this.currentClass = cls;
      }
    }
    positioned(space2) {
      this.space = space2;
      if (this.info)
        this.view.requestMeasure(this.placeInfoReq);
    }
    updateSel() {
      let cState = this.view.state.field(this.stateField), open = cState.open;
      if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {
        this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
        this.showOptions(open.options, cState.id);
      }
      if (this.updateSelectedOption(open.selected)) {
        this.destroyInfo();
        let { completion } = open.options[open.selected];
        let { info: info2 } = completion;
        if (!info2)
          return;
        let infoResult = typeof info2 === "string" ? document.createTextNode(info2) : info2(completion);
        if (!infoResult)
          return;
        if ("then" in infoResult) {
          infoResult.then((obj) => {
            if (obj && this.view.state.field(this.stateField, false) == cState)
              this.addInfoPane(obj, completion);
          }).catch((e2) => logException(this.view.state, e2, "completion info"));
        } else {
          this.addInfoPane(infoResult, completion);
        }
      }
    }
    addInfoPane(content4, completion) {
      this.destroyInfo();
      let wrap3 = this.info = document.createElement("div");
      wrap3.className = "cm-tooltip cm-completionInfo";
      if (content4.nodeType != null) {
        wrap3.appendChild(content4);
        this.infoDestroy = null;
      } else {
        let { dom, destroy } = content4;
        wrap3.appendChild(dom);
        this.infoDestroy = destroy || null;
      }
      this.dom.appendChild(wrap3);
      this.view.requestMeasure(this.placeInfoReq);
    }
    updateSelectedOption(selected2) {
      let set = null;
      for (let opt = this.list.firstChild, i2 = this.range.from; opt; opt = opt.nextSibling, i2++) {
        if (opt.nodeName != "LI" || !opt.id) {
          i2--;
        } else if (i2 == selected2) {
          if (!opt.hasAttribute("aria-selected")) {
            opt.setAttribute("aria-selected", "true");
            set = opt;
          }
        } else {
          if (opt.hasAttribute("aria-selected"))
            opt.removeAttribute("aria-selected");
        }
      }
      if (set)
        scrollIntoView2(this.list, set);
      return set;
    }
    measureInfo() {
      let sel = this.dom.querySelector("[aria-selected]");
      if (!sel || !this.info)
        return null;
      let listRect = this.dom.getBoundingClientRect();
      let infoRect = this.info.getBoundingClientRect();
      let selRect = sel.getBoundingClientRect();
      let space2 = this.space;
      if (!space2) {
        let win = this.dom.ownerDocument.defaultView || window;
        space2 = { left: 0, top: 0, right: win.innerWidth, bottom: win.innerHeight };
      }
      if (selRect.top > Math.min(space2.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space2.top, listRect.top) + 10)
        return null;
      return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space2, this.dom);
    }
    placeInfo(pos) {
      if (this.info) {
        if (pos) {
          if (pos.style)
            this.info.style.cssText = pos.style;
          this.info.className = "cm-tooltip cm-completionInfo " + (pos.class || "");
        } else {
          this.info.style.cssText = "top: -1e6px";
        }
      }
    }
    createListBox(options2, id5, range3) {
      const ul = document.createElement("ul");
      ul.id = id5;
      ul.setAttribute("role", "listbox");
      ul.setAttribute("aria-expanded", "true");
      ul.setAttribute("aria-label", this.view.state.phrase("Completions"));
      let curSection = null;
      for (let i2 = range3.from; i2 < range3.to; i2++) {
        let { completion, match: match2 } = options2[i2], { section } = completion;
        if (section) {
          let name16 = typeof section == "string" ? section : section.name;
          if (name16 != curSection && (i2 > range3.from || range3.from == 0)) {
            curSection = name16;
            if (typeof section != "string" && section.header) {
              ul.appendChild(section.header(section));
            } else {
              let header = ul.appendChild(document.createElement("completion-section"));
              header.textContent = name16;
            }
          }
        }
        const li = ul.appendChild(document.createElement("li"));
        li.id = id5 + "-" + i2;
        li.setAttribute("role", "option");
        let cls = this.optionClass(completion);
        if (cls)
          li.className = cls;
        for (let source3 of this.optionContent) {
          let node = source3(completion, this.view.state, this.view, match2);
          if (node)
            li.appendChild(node);
        }
      }
      if (range3.from)
        ul.classList.add("cm-completionListIncompleteTop");
      if (range3.to < options2.length)
        ul.classList.add("cm-completionListIncompleteBottom");
      return ul;
    }
    destroyInfo() {
      if (this.info) {
        if (this.infoDestroy)
          this.infoDestroy();
        this.info.remove();
        this.info = null;
      }
    }
    destroy() {
      this.destroyInfo();
    }
  };
  function completionTooltip(stateField, applyCompletion2) {
    return (view2) => new CompletionTooltip(view2, stateField, applyCompletion2);
  }
  function scrollIntoView2(container, element) {
    let parent2 = container.getBoundingClientRect();
    let self2 = element.getBoundingClientRect();
    let scaleY = parent2.height / container.offsetHeight;
    if (self2.top < parent2.top)
      container.scrollTop -= (parent2.top - self2.top) / scaleY;
    else if (self2.bottom > parent2.bottom)
      container.scrollTop += (self2.bottom - parent2.bottom) / scaleY;
  }
  function score(option) {
    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
  }
  function sortOptions(active, state4) {
    let options2 = [];
    let sections = null;
    let addOption = (option) => {
      options2.push(option);
      let { section } = option.completion;
      if (section) {
        if (!sections)
          sections = [];
        let name16 = typeof section == "string" ? section : section.name;
        if (!sections.some((s2) => s2.name == name16))
          sections.push(typeof section == "string" ? { name: name16 } : section);
      }
    };
    let conf = state4.facet(completionConfig);
    for (let a2 of active)
      if (a2.hasResult()) {
        let getMatch = a2.result.getMatch;
        if (a2.result.filter === false) {
          for (let option of a2.result.options) {
            addOption(new Option(option, a2.source, getMatch ? getMatch(option) : [], 1e9 - options2.length));
          }
        } else {
          let pattern2 = state4.sliceDoc(a2.from, a2.to), match2;
          let matcher = conf.filterStrict ? new StrictMatcher(pattern2) : new FuzzyMatcher(pattern2);
          for (let option of a2.result.options)
            if (match2 = matcher.match(option.label)) {
              let matched = !option.displayLabel ? match2.matched : getMatch ? getMatch(option, match2.matched) : [];
              addOption(new Option(option, a2.source, matched, match2.score + (option.boost || 0)));
            }
        }
      }
    if (sections) {
      let sectionOrder = /* @__PURE__ */ Object.create(null), pos = 0;
      let cmp = (a2, b2) => {
        var _a2, _b;
        return ((_a2 = a2.rank) !== null && _a2 !== void 0 ? _a2 : 1e9) - ((_b = b2.rank) !== null && _b !== void 0 ? _b : 1e9) || (a2.name < b2.name ? -1 : 1);
      };
      for (let s2 of sections.sort(cmp)) {
        pos -= 1e5;
        sectionOrder[s2.name] = pos;
      }
      for (let option of options2) {
        let { section } = option.completion;
        if (section)
          option.score += sectionOrder[typeof section == "string" ? section : section.name];
      }
    }
    let result = [], prev = null;
    let compare4 = conf.compareCompletions;
    for (let opt of options2.sort((a2, b2) => b2.score - a2.score || compare4(a2.completion, b2.completion))) {
      let cur2 = opt.completion;
      if (!prev || prev.label != cur2.label || prev.detail != cur2.detail || prev.type != null && cur2.type != null && prev.type != cur2.type || prev.apply != cur2.apply || prev.boost != cur2.boost)
        result.push(opt);
      else if (score(opt.completion) > score(prev))
        result[result.length - 1] = opt;
      prev = opt.completion;
    }
    return result;
  }
  var CompletionDialog = class _CompletionDialog {
    constructor(options2, attrs, tooltip, timestamp2, selected2, disabled10) {
      this.options = options2;
      this.attrs = attrs;
      this.tooltip = tooltip;
      this.timestamp = timestamp2;
      this.selected = selected2;
      this.disabled = disabled10;
    }
    setSelected(selected2, id5) {
      return selected2 == this.selected || selected2 >= this.options.length ? this : new _CompletionDialog(this.options, makeAttrs(id5, selected2), this.tooltip, this.timestamp, selected2, this.disabled);
    }
    static build(active, state4, id5, prev, conf, didSetActive) {
      if (prev && !didSetActive && active.some(
        (s2) => s2.state == 1
        /* State.Pending */
      ))
        return prev.setDisabled();
      let options2 = sortOptions(active, state4);
      if (!options2.length)
        return prev && active.some(
          (a2) => a2.state == 1
          /* State.Pending */
        ) ? prev.setDisabled() : null;
      let selected2 = state4.facet(completionConfig).selectOnOpen ? 0 : -1;
      if (prev && prev.selected != selected2 && prev.selected != -1) {
        let selectedValue = prev.options[prev.selected].completion;
        for (let i2 = 0; i2 < options2.length; i2++)
          if (options2[i2].completion == selectedValue) {
            selected2 = i2;
            break;
          }
      }
      return new _CompletionDialog(options2, makeAttrs(id5, selected2), {
        pos: active.reduce((a2, b2) => b2.hasResult() ? Math.min(a2, b2.from) : a2, 1e8),
        create: createTooltip,
        above: conf.aboveCursor
      }, prev ? prev.timestamp : Date.now(), selected2, false);
    }
    map(changes) {
      return new _CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
    }
    setDisabled() {
      return new _CompletionDialog(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, true);
    }
  };
  var CompletionState = class _CompletionState {
    constructor(active, id5, open) {
      this.active = active;
      this.id = id5;
      this.open = open;
    }
    static start() {
      return new _CompletionState(none4, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
    }
    update(tr) {
      let { state: state4 } = tr, conf = state4.facet(completionConfig);
      let sources2 = conf.override || state4.languageDataAt("autocomplete", cur(state4)).map(asSource);
      let active = sources2.map((source3) => {
        let value12 = this.active.find((s2) => s2.source == source3) || new ActiveSource(
          source3,
          this.active.some(
            (a2) => a2.state != 0
            /* State.Inactive */
          ) ? 1 : 0
          /* State.Inactive */
        );
        return value12.update(tr, conf);
      });
      if (active.length == this.active.length && active.every((a2, i2) => a2 == this.active[i2]))
        active = this.active;
      let open = this.open, didSet = tr.effects.some((e2) => e2.is(setActiveEffect));
      if (open && tr.docChanged)
        open = open.map(tr.changes);
      if (tr.selection || active.some((a2) => a2.hasResult() && tr.changes.touchesRange(a2.from, a2.to)) || !sameResults(active, this.active) || didSet)
        open = CompletionDialog.build(active, state4, this.id, open, conf, didSet);
      else if (open && open.disabled && !active.some(
        (a2) => a2.state == 1
        /* State.Pending */
      ))
        open = null;
      if (!open && active.every(
        (a2) => a2.state != 1
        /* State.Pending */
      ) && active.some((a2) => a2.hasResult()))
        active = active.map((a2) => a2.hasResult() ? new ActiveSource(
          a2.source,
          0
          /* State.Inactive */
        ) : a2);
      for (let effect of tr.effects)
        if (effect.is(setSelectedEffect))
          open = open && open.setSelected(effect.value, this.id);
      return active == this.active && open == this.open ? this : new _CompletionState(active, this.id, open);
    }
    get tooltip() {
      return this.open ? this.open.tooltip : null;
    }
    get attrs() {
      return this.open ? this.open.attrs : this.active.length ? baseAttrs : noAttrs2;
    }
  };
  function sameResults(a2, b2) {
    if (a2 == b2)
      return true;
    for (let iA = 0, iB = 0; ; ) {
      while (iA < a2.length && !a2[iA].hasResult)
        iA++;
      while (iB < b2.length && !b2[iB].hasResult)
        iB++;
      let endA = iA == a2.length, endB = iB == b2.length;
      if (endA || endB)
        return endA == endB;
      if (a2[iA++].result != b2[iB++].result)
        return false;
    }
  }
  var baseAttrs = {
    "aria-autocomplete": "list"
  };
  var noAttrs2 = {};
  function makeAttrs(id5, selected2) {
    let result = {
      "aria-autocomplete": "list",
      "aria-haspopup": "listbox",
      "aria-controls": id5
    };
    if (selected2 > -1)
      result["aria-activedescendant"] = id5 + "-" + selected2;
    return result;
  }
  var none4 = [];
  function getUpdateType(tr, conf) {
    if (tr.isUserEvent("input.complete")) {
      let completion = tr.annotation(pickedCompletion);
      if (completion && conf.activateOnCompletion(completion))
        return 4 | 8;
    }
    let typing = tr.isUserEvent("input.type");
    return typing && conf.activateOnTyping ? 4 | 1 : typing ? 1 : tr.isUserEvent("delete.backward") ? 2 : tr.selection ? 8 : tr.docChanged ? 16 : 0;
  }
  var ActiveSource = class _ActiveSource {
    constructor(source3, state4, explicitPos = -1) {
      this.source = source3;
      this.state = state4;
      this.explicitPos = explicitPos;
    }
    hasResult() {
      return false;
    }
    update(tr, conf) {
      let type = getUpdateType(tr, conf), value12 = this;
      if (type & 8 || type & 16 && this.touches(tr))
        value12 = new _ActiveSource(
          value12.source,
          0
          /* State.Inactive */
        );
      if (type & 4 && value12.state == 0)
        value12 = new _ActiveSource(
          this.source,
          1
          /* State.Pending */
        );
      value12 = value12.updateFor(tr, type);
      for (let effect of tr.effects) {
        if (effect.is(startCompletionEffect))
          value12 = new _ActiveSource(value12.source, 1, effect.value ? cur(tr.state) : -1);
        else if (effect.is(closeCompletionEffect))
          value12 = new _ActiveSource(
            value12.source,
            0
            /* State.Inactive */
          );
        else if (effect.is(setActiveEffect)) {
          for (let active of effect.value)
            if (active.source == value12.source)
              value12 = active;
        }
      }
      return value12;
    }
    updateFor(tr, type) {
      return this.map(tr.changes);
    }
    map(changes) {
      return changes.empty || this.explicitPos < 0 ? this : new _ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));
    }
    touches(tr) {
      return tr.changes.touchesRange(cur(tr.state));
    }
  };
  var ActiveResult = class _ActiveResult extends ActiveSource {
    constructor(source3, explicitPos, result, from3, to3) {
      super(source3, 2, explicitPos);
      this.result = result;
      this.from = from3;
      this.to = to3;
    }
    hasResult() {
      return true;
    }
    updateFor(tr, type) {
      var _a2;
      if (!(type & 3))
        return this.map(tr.changes);
      let result = this.result;
      if (result.map && !tr.changes.empty)
        result = result.map(result, tr.changes);
      let from3 = tr.changes.mapPos(this.from), to3 = tr.changes.mapPos(this.to, 1);
      let pos = cur(tr.state);
      if ((this.explicitPos < 0 ? pos <= from3 : pos < this.from) || pos > to3 || !result || type & 2 && cur(tr.startState) == this.from)
        return new ActiveSource(
          this.source,
          type & 4 ? 1 : 0
          /* State.Inactive */
        );
      let explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos);
      if (checkValid2(result.validFor, tr.state, from3, to3))
        return new _ActiveResult(this.source, explicitPos, result, from3, to3);
      if (result.update && (result = result.update(result, from3, to3, new CompletionContext(tr.state, pos, explicitPos >= 0))))
        return new _ActiveResult(this.source, explicitPos, result, result.from, (_a2 = result.to) !== null && _a2 !== void 0 ? _a2 : cur(tr.state));
      return new ActiveSource(this.source, 1, explicitPos);
    }
    map(mapping) {
      if (mapping.empty)
        return this;
      let result = this.result.map ? this.result.map(this.result, mapping) : this.result;
      if (!result)
        return new ActiveSource(
          this.source,
          0
          /* State.Inactive */
        );
      return new _ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
    }
    touches(tr) {
      return tr.changes.touchesRange(this.from, this.to);
    }
  };
  function checkValid2(validFor, state4, from3, to3) {
    if (!validFor)
      return false;
    let text6 = state4.sliceDoc(from3, to3);
    return typeof validFor == "function" ? validFor(text6, from3, to3, state4) : ensureAnchor(validFor, true).test(text6);
  }
  var setActiveEffect = /* @__PURE__ */ StateEffect.define({
    map(sources2, mapping) {
      return sources2.map((s2) => s2.map(mapping));
    }
  });
  var setSelectedEffect = /* @__PURE__ */ StateEffect.define();
  var completionState = /* @__PURE__ */ StateField.define({
    create() {
      return CompletionState.start();
    },
    update(value12, tr) {
      return value12.update(tr);
    },
    provide: (f2) => [
      showTooltip.from(f2, (val) => val.tooltip),
      EditorView.contentAttributes.from(f2, (state4) => state4.attrs)
    ]
  });
  function applyCompletion(view2, option) {
    const apply5 = option.completion.apply || option.completion.label;
    let result = view2.state.field(completionState).active.find((a2) => a2.source == option.source);
    if (!(result instanceof ActiveResult))
      return false;
    if (typeof apply5 == "string")
      view2.dispatch(Object.assign(Object.assign({}, insertCompletionText(view2.state, apply5, result.from, result.to)), { annotations: pickedCompletion.of(option.completion) }));
    else
      apply5(view2, option.completion, result.from, result.to);
    return true;
  }
  var createTooltip = /* @__PURE__ */ completionTooltip(completionState, applyCompletion);
  function moveCompletionSelection(forward2, by = "option") {
    return (view2) => {
      let cState = view2.state.field(completionState, false);
      if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view2.state.facet(completionConfig).interactionDelay)
        return false;
      let step2 = 1, tooltip;
      if (by == "page" && (tooltip = getTooltip(view2, cState.open.tooltip)))
        step2 = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector("li").offsetHeight) - 1);
      let { length: length9 } = cState.open.options;
      let selected2 = cState.open.selected > -1 ? cState.open.selected + step2 * (forward2 ? 1 : -1) : forward2 ? 0 : length9 - 1;
      if (selected2 < 0)
        selected2 = by == "page" ? 0 : length9 - 1;
      else if (selected2 >= length9)
        selected2 = by == "page" ? length9 - 1 : 0;
      view2.dispatch({ effects: setSelectedEffect.of(selected2) });
      return true;
    };
  }
  var acceptCompletion = (view2) => {
    let cState = view2.state.field(completionState, false);
    if (view2.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled || Date.now() - cState.open.timestamp < view2.state.facet(completionConfig).interactionDelay)
      return false;
    return applyCompletion(view2, cState.open.options[cState.open.selected]);
  };
  var startCompletion = (view2) => {
    let cState = view2.state.field(completionState, false);
    if (!cState)
      return false;
    view2.dispatch({ effects: startCompletionEffect.of(true) });
    return true;
  };
  var closeCompletion = (view2) => {
    let cState = view2.state.field(completionState, false);
    if (!cState || !cState.active.some(
      (a2) => a2.state != 0
      /* State.Inactive */
    ))
      return false;
    view2.dispatch({ effects: closeCompletionEffect.of(null) });
    return true;
  };
  var RunningQuery = class {
    constructor(active, context3) {
      this.active = active;
      this.context = context3;
      this.time = Date.now();
      this.updates = [];
      this.done = void 0;
    }
  };
  var MaxUpdateCount = 50;
  var MinAbortTime = 1e3;
  var completionPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view2) {
      this.view = view2;
      this.debounceUpdate = -1;
      this.running = [];
      this.debounceAccept = -1;
      this.pendingStart = false;
      this.composing = 0;
      for (let active of view2.state.field(completionState).active)
        if (active.state == 1)
          this.startQuery(active);
    }
    update(update3) {
      let cState = update3.state.field(completionState);
      let conf = update3.state.facet(completionConfig);
      if (!update3.selectionSet && !update3.docChanged && update3.startState.field(completionState) == cState)
        return;
      let doesReset = update3.transactions.some((tr) => {
        let type = getUpdateType(tr, conf);
        return type & 8 || (tr.selection || tr.docChanged) && !(type & 3);
      });
      for (let i2 = 0; i2 < this.running.length; i2++) {
        let query = this.running[i2];
        if (doesReset || query.context.abortOnDocChange && update3.docChanged || query.updates.length + update3.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {
          for (let handler of query.context.abortListeners) {
            try {
              handler();
            } catch (e2) {
              logException(this.view.state, e2);
            }
          }
          query.context.abortListeners = null;
          this.running.splice(i2--, 1);
        } else {
          query.updates.push(...update3.transactions);
        }
      }
      if (this.debounceUpdate > -1)
        clearTimeout(this.debounceUpdate);
      if (update3.transactions.some((tr) => tr.effects.some((e2) => e2.is(startCompletionEffect))))
        this.pendingStart = true;
      let delay2 = this.pendingStart ? 50 : conf.activateOnTypingDelay;
      this.debounceUpdate = cState.active.some((a2) => a2.state == 1 && !this.running.some((q) => q.active.source == a2.source)) ? setTimeout(() => this.startUpdate(), delay2) : -1;
      if (this.composing != 0)
        for (let tr of update3.transactions) {
          if (tr.isUserEvent("input.type"))
            this.composing = 2;
          else if (this.composing == 2 && tr.selection)
            this.composing = 3;
        }
    }
    startUpdate() {
      this.debounceUpdate = -1;
      this.pendingStart = false;
      let { state: state4 } = this.view, cState = state4.field(completionState);
      for (let active of cState.active) {
        if (active.state == 1 && !this.running.some((r2) => r2.active.source == active.source))
          this.startQuery(active);
      }
      if (this.running.length && cState.open && cState.open.disabled)
        this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
    }
    startQuery(active) {
      let { state: state4 } = this.view, pos = cur(state4);
      let context3 = new CompletionContext(state4, pos, active.explicitPos == pos, this.view);
      let pending = new RunningQuery(active, context3);
      this.running.push(pending);
      Promise.resolve(active.source(context3)).then((result) => {
        if (!pending.context.aborted) {
          pending.done = result || null;
          this.scheduleAccept();
        }
      }, (err) => {
        this.view.dispatch({ effects: closeCompletionEffect.of(null) });
        logException(this.view.state, err);
      });
    }
    scheduleAccept() {
      if (this.running.every((q) => q.done !== void 0))
        this.accept();
      else if (this.debounceAccept < 0)
        this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
    }
    // For each finished query in this.running, try to create a result
    // or, if appropriate, restart the query.
    accept() {
      var _a2;
      if (this.debounceAccept > -1)
        clearTimeout(this.debounceAccept);
      this.debounceAccept = -1;
      let updated = [];
      let conf = this.view.state.facet(completionConfig), cState = this.view.state.field(completionState);
      for (let i2 = 0; i2 < this.running.length; i2++) {
        let query = this.running[i2];
        if (query.done === void 0)
          continue;
        this.running.splice(i2--, 1);
        if (query.done) {
          let active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a2 = query.done.to) !== null && _a2 !== void 0 ? _a2 : cur(query.updates.length ? query.updates[0].startState : this.view.state));
          for (let tr of query.updates)
            active = active.update(tr, conf);
          if (active.hasResult()) {
            updated.push(active);
            continue;
          }
        }
        let current = cState.active.find((a2) => a2.source == query.active.source);
        if (current && current.state == 1) {
          if (query.done == null) {
            let active = new ActiveSource(
              query.active.source,
              0
              /* State.Inactive */
            );
            for (let tr of query.updates)
              active = active.update(tr, conf);
            if (active.state != 1)
              updated.push(active);
          } else {
            this.startQuery(current);
          }
        }
      }
      if (updated.length || cState.open && cState.open.disabled)
        this.view.dispatch({ effects: setActiveEffect.of(updated) });
    }
  }, {
    eventHandlers: {
      blur(event) {
        let state4 = this.view.state.field(completionState, false);
        if (state4 && state4.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {
          let dialog = state4.open && getTooltip(this.view, state4.open.tooltip);
          if (!dialog || !dialog.dom.contains(event.relatedTarget))
            setTimeout(() => this.view.dispatch({ effects: closeCompletionEffect.of(null) }), 10);
        }
      },
      compositionstart() {
        this.composing = 1;
      },
      compositionend() {
        if (this.composing == 3) {
          setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);
        }
        this.composing = 0;
      }
    }
  });
  var windows = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform);
  var commitCharacters = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ EditorView.domEventHandlers({
    keydown(event, view2) {
      let field = view2.state.field(completionState, false);
      if (!field || !field.open || field.open.disabled || field.open.selected < 0 || event.key.length > 1 || event.ctrlKey && !(windows && event.altKey) || event.metaKey)
        return false;
      let option = field.open.options[field.open.selected];
      let result = field.active.find((a2) => a2.source == option.source);
      let commitChars = option.completion.commitCharacters || result.result.commitCharacters;
      if (commitChars && commitChars.indexOf(event.key) > -1)
        applyCompletion(view2, option);
      return false;
    }
  }));
  var baseTheme4 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-tooltip.cm-tooltip-autocomplete": {
      "& > ul": {
        fontFamily: "monospace",
        whiteSpace: "nowrap",
        overflow: "hidden auto",
        maxWidth_fallback: "700px",
        maxWidth: "min(700px, 95vw)",
        minWidth: "250px",
        maxHeight: "10em",
        height: "100%",
        listStyle: "none",
        margin: 0,
        padding: 0,
        "& > li, & > completion-section": {
          padding: "1px 3px",
          lineHeight: 1.2
        },
        "& > li": {
          overflowX: "hidden",
          textOverflow: "ellipsis",
          cursor: "pointer"
        },
        "& > completion-section": {
          display: "list-item",
          borderBottom: "1px solid silver",
          paddingLeft: "0.5em",
          opacity: 0.7
        }
      }
    },
    "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
      background: "#17c",
      color: "white"
    },
    "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
      background: "#777"
    },
    "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
      background: "#347",
      color: "white"
    },
    "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
      background: "#444"
    },
    ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
      content: '"\xB7\xB7\xB7"',
      opacity: 0.5,
      display: "block",
      textAlign: "center"
    },
    ".cm-tooltip.cm-completionInfo": {
      position: "absolute",
      padding: "3px 9px",
      width: "max-content",
      maxWidth: `${400}px`,
      boxSizing: "border-box",
      whiteSpace: "pre-line"
    },
    ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
    ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
    ".cm-completionInfo.cm-completionInfo-left-narrow": { right: `${30}px` },
    ".cm-completionInfo.cm-completionInfo-right-narrow": { left: `${30}px` },
    "&light .cm-snippetField": { backgroundColor: "#00000022" },
    "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
    ".cm-snippetFieldPosition": {
      verticalAlign: "text-top",
      width: 0,
      height: "1.15em",
      display: "inline-block",
      margin: "0 -0.7px -.7em",
      borderLeft: "1.4px dotted #888"
    },
    ".cm-completionMatchedText": {
      textDecoration: "underline"
    },
    ".cm-completionDetail": {
      marginLeft: "0.5em",
      fontStyle: "italic"
    },
    ".cm-completionIcon": {
      fontSize: "90%",
      width: ".8em",
      display: "inline-block",
      textAlign: "center",
      paddingRight: ".6em",
      opacity: "0.6",
      boxSizing: "content-box"
    },
    ".cm-completionIcon-function, .cm-completionIcon-method": {
      "&:after": { content: "'\u0192'" }
    },
    ".cm-completionIcon-class": {
      "&:after": { content: "'\u25CB'" }
    },
    ".cm-completionIcon-interface": {
      "&:after": { content: "'\u25CC'" }
    },
    ".cm-completionIcon-variable": {
      "&:after": { content: "'\u{1D465}'" }
    },
    ".cm-completionIcon-constant": {
      "&:after": { content: "'\u{1D436}'" }
    },
    ".cm-completionIcon-type": {
      "&:after": { content: "'\u{1D461}'" }
    },
    ".cm-completionIcon-enum": {
      "&:after": { content: "'\u222A'" }
    },
    ".cm-completionIcon-property": {
      "&:after": { content: "'\u25A1'" }
    },
    ".cm-completionIcon-keyword": {
      "&:after": { content: "'\u{1F511}\uFE0E'" }
      // Disable emoji rendering
    },
    ".cm-completionIcon-namespace": {
      "&:after": { content: "'\u25A2'" }
    },
    ".cm-completionIcon-text": {
      "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
    }
  });
  var FieldPos = class {
    constructor(field, line, from3, to3) {
      this.field = field;
      this.line = line;
      this.from = from3;
      this.to = to3;
    }
  };
  var FieldRange = class _FieldRange {
    constructor(field, from3, to3) {
      this.field = field;
      this.from = from3;
      this.to = to3;
    }
    map(changes) {
      let from3 = changes.mapPos(this.from, -1, MapMode.TrackDel);
      let to3 = changes.mapPos(this.to, 1, MapMode.TrackDel);
      return from3 == null || to3 == null ? null : new _FieldRange(this.field, from3, to3);
    }
  };
  var Snippet = class _Snippet {
    constructor(lines, fieldPositions) {
      this.lines = lines;
      this.fieldPositions = fieldPositions;
    }
    instantiate(state4, pos) {
      let text6 = [], lineStart = [pos];
      let lineObj = state4.doc.lineAt(pos), baseIndent = /^\s*/.exec(lineObj.text)[0];
      for (let line of this.lines) {
        if (text6.length) {
          let indent = baseIndent, tabs = /^\t*/.exec(line)[0].length;
          for (let i2 = 0; i2 < tabs; i2++)
            indent += state4.facet(indentUnit);
          lineStart.push(pos + indent.length - tabs);
          line = indent + line.slice(tabs);
        }
        text6.push(line);
        pos += line.length + 1;
      }
      let ranges = this.fieldPositions.map((pos2) => new FieldRange(pos2.field, lineStart[pos2.line] + pos2.from, lineStart[pos2.line] + pos2.to));
      return { text: text6, ranges };
    }
    static parse(template) {
      let fields = [];
      let lines = [], positions = [], m2;
      for (let line of template.split(/\r\n?|\n/)) {
        while (m2 = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(line)) {
          let seq = m2[1] ? +m2[1] : null, rawName = m2[2] || m2[3] || "", found = -1;
          let name16 = rawName.replace(/\\[{}]/g, (m3) => m3[1]);
          for (let i2 = 0; i2 < fields.length; i2++) {
            if (seq != null ? fields[i2].seq == seq : name16 ? fields[i2].name == name16 : false)
              found = i2;
          }
          if (found < 0) {
            let i2 = 0;
            while (i2 < fields.length && (seq == null || fields[i2].seq != null && fields[i2].seq < seq))
              i2++;
            fields.splice(i2, 0, { seq, name: name16 });
            found = i2;
            for (let pos of positions)
              if (pos.field >= found)
                pos.field++;
          }
          positions.push(new FieldPos(found, lines.length, m2.index, m2.index + name16.length));
          line = line.slice(0, m2.index) + rawName + line.slice(m2.index + m2[0].length);
        }
        line = line.replace(/\\([{}])/g, (_, brace, index6) => {
          for (let pos of positions)
            if (pos.line == lines.length && pos.from > index6) {
              pos.from--;
              pos.to--;
            }
          return brace;
        });
        lines.push(line);
      }
      return new _Snippet(lines, positions);
    }
  };
  var fieldMarker = /* @__PURE__ */ Decoration.widget({ widget: /* @__PURE__ */ new class extends WidgetType {
    toDOM() {
      let span4 = document.createElement("span");
      span4.className = "cm-snippetFieldPosition";
      return span4;
    }
    ignoreEvent() {
      return false;
    }
  }() });
  var fieldRange = /* @__PURE__ */ Decoration.mark({ class: "cm-snippetField" });
  var ActiveSnippet = class _ActiveSnippet {
    constructor(ranges, active) {
      this.ranges = ranges;
      this.active = active;
      this.deco = Decoration.set(ranges.map((r2) => (r2.from == r2.to ? fieldMarker : fieldRange).range(r2.from, r2.to)));
    }
    map(changes) {
      let ranges = [];
      for (let r2 of this.ranges) {
        let mapped = r2.map(changes);
        if (!mapped)
          return null;
        ranges.push(mapped);
      }
      return new _ActiveSnippet(ranges, this.active);
    }
    selectionInsideField(sel) {
      return sel.ranges.every((range3) => this.ranges.some((r2) => r2.field == this.active && r2.from <= range3.from && r2.to >= range3.to));
    }
  };
  var setActive = /* @__PURE__ */ StateEffect.define({
    map(value12, changes) {
      return value12 && value12.map(changes);
    }
  });
  var moveToField = /* @__PURE__ */ StateEffect.define();
  var snippetState = /* @__PURE__ */ StateField.define({
    create() {
      return null;
    },
    update(value12, tr) {
      for (let effect of tr.effects) {
        if (effect.is(setActive))
          return effect.value;
        if (effect.is(moveToField) && value12)
          return new ActiveSnippet(value12.ranges, effect.value);
      }
      if (value12 && tr.docChanged)
        value12 = value12.map(tr.changes);
      if (value12 && tr.selection && !value12.selectionInsideField(tr.selection))
        value12 = null;
      return value12;
    },
    provide: (f2) => EditorView.decorations.from(f2, (val) => val ? val.deco : Decoration.none)
  });
  function fieldSelection(ranges, field) {
    return EditorSelection.create(ranges.filter((r2) => r2.field == field).map((r2) => EditorSelection.range(r2.from, r2.to)));
  }
  function snippet(template) {
    let snippet2 = Snippet.parse(template);
    return (editor2, completion, from3, to3) => {
      let { text: text6, ranges } = snippet2.instantiate(editor2.state, from3);
      let spec = {
        changes: { from: from3, to: to3, insert: Text2.of(text6) },
        scrollIntoView: true,
        annotations: completion ? [pickedCompletion.of(completion), Transaction.userEvent.of("input.complete")] : void 0
      };
      if (ranges.length)
        spec.selection = fieldSelection(ranges, 0);
      if (ranges.some((r2) => r2.field > 0)) {
        let active = new ActiveSnippet(ranges, 0);
        let effects = spec.effects = [setActive.of(active)];
        if (editor2.state.field(snippetState, false) === void 0)
          effects.push(StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme4]));
      }
      editor2.dispatch(editor2.state.update(spec));
    };
  }
  function moveField(dir2) {
    return ({ state: state4, dispatch }) => {
      let active = state4.field(snippetState, false);
      if (!active || dir2 < 0 && active.active == 0)
        return false;
      let next = active.active + dir2, last4 = dir2 > 0 && !active.ranges.some((r2) => r2.field == next + dir2);
      dispatch(state4.update({
        selection: fieldSelection(active.ranges, next),
        effects: setActive.of(last4 ? null : new ActiveSnippet(active.ranges, next)),
        scrollIntoView: true
      }));
      return true;
    };
  }
  var clearSnippet = ({ state: state4, dispatch }) => {
    let active = state4.field(snippetState, false);
    if (!active)
      return false;
    dispatch(state4.update({ effects: setActive.of(null) }));
    return true;
  };
  var nextSnippetField = /* @__PURE__ */ moveField(1);
  var prevSnippetField = /* @__PURE__ */ moveField(-1);
  var defaultSnippetKeymap = [
    { key: "Tab", run: nextSnippetField, shift: prevSnippetField },
    { key: "Escape", run: clearSnippet }
  ];
  var snippetKeymap = /* @__PURE__ */ Facet.define({
    combine(maps) {
      return maps.length ? maps[0] : defaultSnippetKeymap;
    }
  });
  var addSnippetKeymap = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ keymap.compute([snippetKeymap], (state4) => state4.facet(snippetKeymap)));
  function snippetCompletion(template, completion) {
    return Object.assign(Object.assign({}, completion), { apply: snippet(template) });
  }
  var snippetPointerHandler = /* @__PURE__ */ EditorView.domEventHandlers({
    mousedown(event, view2) {
      let active = view2.state.field(snippetState, false), pos;
      if (!active || (pos = view2.posAtCoords({ x: event.clientX, y: event.clientY })) == null)
        return false;
      let match2 = active.ranges.find((r2) => r2.from <= pos && r2.to >= pos);
      if (!match2 || match2.field == active.active)
        return false;
      view2.dispatch({
        selection: fieldSelection(active.ranges, match2.field),
        effects: setActive.of(active.ranges.some((r2) => r2.field > match2.field) ? new ActiveSnippet(active.ranges, match2.field) : null),
        scrollIntoView: true
      });
      return true;
    }
  });
  var defaults2 = {
    brackets: ["(", "[", "{", "'", '"'],
    before: ")]}:;>",
    stringPrefixes: []
  };
  var closeBracketEffect = /* @__PURE__ */ StateEffect.define({
    map(value12, mapping) {
      let mapped = mapping.mapPos(value12, -1, MapMode.TrackAfter);
      return mapped == null ? void 0 : mapped;
    }
  });
  var closedBracket = /* @__PURE__ */ new class extends RangeValue {
  }();
  closedBracket.startSide = 1;
  closedBracket.endSide = -1;
  var bracketState = /* @__PURE__ */ StateField.define({
    create() {
      return RangeSet.empty;
    },
    update(value12, tr) {
      value12 = value12.map(tr.changes);
      if (tr.selection) {
        let line = tr.state.doc.lineAt(tr.selection.main.head);
        value12 = value12.update({ filter: (from3) => from3 >= line.from && from3 <= line.to });
      }
      for (let effect of tr.effects)
        if (effect.is(closeBracketEffect))
          value12 = value12.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });
      return value12;
    }
  });
  function closeBrackets() {
    return [inputHandler2, bracketState];
  }
  var definedClosing = "()[]{}<>";
  function closing(ch) {
    for (let i2 = 0; i2 < definedClosing.length; i2 += 2)
      if (definedClosing.charCodeAt(i2) == ch)
        return definedClosing.charAt(i2 + 1);
    return fromCodePoint(ch < 128 ? ch : ch + 1);
  }
  function config(state4, pos) {
    return state4.languageDataAt("closeBrackets", pos)[0] || defaults2;
  }
  var android = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent);
  var inputHandler2 = /* @__PURE__ */ EditorView.inputHandler.of((view2, from3, to3, insert10) => {
    if ((android ? view2.composing : view2.compositionStarted) || view2.state.readOnly)
      return false;
    let sel = view2.state.selection.main;
    if (insert10.length > 2 || insert10.length == 2 && codePointSize(codePointAt2(insert10, 0)) == 1 || from3 != sel.from || to3 != sel.to)
      return false;
    let tr = insertBracket(view2.state, insert10);
    if (!tr)
      return false;
    view2.dispatch(tr);
    return true;
  });
  var deleteBracketPair = ({ state: state4, dispatch }) => {
    if (state4.readOnly)
      return false;
    let conf = config(state4, state4.selection.main.head);
    let tokens = conf.brackets || defaults2.brackets;
    let dont = null, changes = state4.changeByRange((range3) => {
      if (range3.empty) {
        let before = prevChar(state4.doc, range3.head);
        for (let token of tokens) {
          if (token == before && nextChar(state4.doc, range3.head) == closing(codePointAt2(token, 0)))
            return {
              changes: { from: range3.head - token.length, to: range3.head + token.length },
              range: EditorSelection.cursor(range3.head - token.length)
            };
        }
      }
      return { range: dont = range3 };
    });
    if (!dont)
      dispatch(state4.update(changes, { scrollIntoView: true, userEvent: "delete.backward" }));
    return !dont;
  };
  var closeBracketsKeymap = [
    { key: "Backspace", run: deleteBracketPair }
  ];
  function insertBracket(state4, bracket2) {
    let conf = config(state4, state4.selection.main.head);
    let tokens = conf.brackets || defaults2.brackets;
    for (let tok of tokens) {
      let closed = closing(codePointAt2(tok, 0));
      if (bracket2 == tok)
        return closed == tok ? handleSame(state4, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state4, tok, closed, conf.before || defaults2.before);
      if (bracket2 == closed && closedBracketAt(state4, state4.selection.main.from))
        return handleClose(state4, tok, closed);
    }
    return null;
  }
  function closedBracketAt(state4, pos) {
    let found = false;
    state4.field(bracketState).between(0, state4.doc.length, (from3) => {
      if (from3 == pos)
        found = true;
    });
    return found;
  }
  function nextChar(doc2, pos) {
    let next = doc2.sliceString(pos, pos + 2);
    return next.slice(0, codePointSize(codePointAt2(next, 0)));
  }
  function prevChar(doc2, pos) {
    let prev = doc2.sliceString(pos - 2, pos);
    return codePointSize(codePointAt2(prev, 0)) == prev.length ? prev : prev.slice(1);
  }
  function handleOpen(state4, open, close2, closeBefore) {
    let dont = null, changes = state4.changeByRange((range3) => {
      if (!range3.empty)
        return {
          changes: [{ insert: open, from: range3.from }, { insert: close2, from: range3.to }],
          effects: closeBracketEffect.of(range3.to + open.length),
          range: EditorSelection.range(range3.anchor + open.length, range3.head + open.length)
        };
      let next = nextChar(state4.doc, range3.head);
      if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1)
        return {
          changes: { insert: open + close2, from: range3.head },
          effects: closeBracketEffect.of(range3.head + open.length),
          range: EditorSelection.cursor(range3.head + open.length)
        };
      return { range: dont = range3 };
    });
    return dont ? null : state4.update(changes, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function handleClose(state4, _open2, close2) {
    let dont = null, changes = state4.changeByRange((range3) => {
      if (range3.empty && nextChar(state4.doc, range3.head) == close2)
        return {
          changes: { from: range3.head, to: range3.head + close2.length, insert: close2 },
          range: EditorSelection.cursor(range3.head + close2.length)
        };
      return dont = { range: range3 };
    });
    return dont ? null : state4.update(changes, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function handleSame(state4, token, allowTriple, config2) {
    let stringPrefixes = config2.stringPrefixes || defaults2.stringPrefixes;
    let dont = null, changes = state4.changeByRange((range3) => {
      if (!range3.empty)
        return {
          changes: [{ insert: token, from: range3.from }, { insert: token, from: range3.to }],
          effects: closeBracketEffect.of(range3.to + token.length),
          range: EditorSelection.range(range3.anchor + token.length, range3.head + token.length)
        };
      let pos = range3.head, next = nextChar(state4.doc, pos), start3;
      if (next == token) {
        if (nodeStart(state4, pos)) {
          return {
            changes: { insert: token + token, from: pos },
            effects: closeBracketEffect.of(pos + token.length),
            range: EditorSelection.cursor(pos + token.length)
          };
        } else if (closedBracketAt(state4, pos)) {
          let isTriple = allowTriple && state4.sliceDoc(pos, pos + token.length * 3) == token + token + token;
          let content4 = isTriple ? token + token + token : token;
          return {
            changes: { from: pos, to: pos + content4.length, insert: content4 },
            range: EditorSelection.cursor(pos + content4.length)
          };
        }
      } else if (allowTriple && state4.sliceDoc(pos - 2 * token.length, pos) == token + token && (start3 = canStartStringAt(state4, pos - 2 * token.length, stringPrefixes)) > -1 && nodeStart(state4, start3)) {
        return {
          changes: { insert: token + token + token + token, from: pos },
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
      } else if (state4.charCategorizer(pos)(next) != CharCategory.Word) {
        if (canStartStringAt(state4, pos, stringPrefixes) > -1 && !probablyInString(state4, pos, token, stringPrefixes))
          return {
            changes: { insert: token + token, from: pos },
            effects: closeBracketEffect.of(pos + token.length),
            range: EditorSelection.cursor(pos + token.length)
          };
      }
      return { range: dont = range3 };
    });
    return dont ? null : state4.update(changes, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function nodeStart(state4, pos) {
    let tree = syntaxTree(state4).resolveInner(pos + 1);
    return tree.parent && tree.from == pos;
  }
  function probablyInString(state4, pos, quoteToken, prefixes) {
    let node = syntaxTree(state4).resolveInner(pos, -1);
    let maxPrefix = prefixes.reduce((m2, p2) => Math.max(m2, p2.length), 0);
    for (let i2 = 0; i2 < 5; i2++) {
      let start3 = state4.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));
      let quotePos = start3.indexOf(quoteToken);
      if (!quotePos || quotePos > -1 && prefixes.indexOf(start3.slice(0, quotePos)) > -1) {
        let first = node.firstChild;
        while (first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos) {
          if (state4.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)
            return false;
          first = first.firstChild;
        }
        return true;
      }
      let parent2 = node.to == pos && node.parent;
      if (!parent2)
        break;
      node = parent2;
    }
    return false;
  }
  function canStartStringAt(state4, pos, prefixes) {
    let charCat = state4.charCategorizer(pos);
    if (charCat(state4.sliceDoc(pos - 1, pos)) != CharCategory.Word)
      return pos;
    for (let prefix of prefixes) {
      let start3 = pos - prefix.length;
      if (state4.sliceDoc(start3, pos) == prefix && charCat(state4.sliceDoc(start3 - 1, start3)) != CharCategory.Word)
        return start3;
    }
    return -1;
  }
  function autocompletion(config2 = {}) {
    return [
      commitCharacters,
      completionState,
      completionConfig.of(config2),
      completionPlugin,
      completionKeymapExt,
      baseTheme4
    ];
  }
  var completionKeymap = [
    { key: "Ctrl-Space", run: startCompletion },
    { mac: "Alt-`", run: startCompletion },
    { key: "Escape", run: closeCompletion },
    { key: "ArrowDown", run: /* @__PURE__ */ moveCompletionSelection(true) },
    { key: "ArrowUp", run: /* @__PURE__ */ moveCompletionSelection(false) },
    { key: "PageDown", run: /* @__PURE__ */ moveCompletionSelection(true, "page") },
    { key: "PageUp", run: /* @__PURE__ */ moveCompletionSelection(false, "page") },
    { key: "Enter", run: acceptCompletion }
  ];
  var completionKeymapExt = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ keymap.computeN([completionConfig], (state4) => state4.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));

  // node_modules/@codemirror/lint/dist/index.js
  var SelectedDiagnostic = class {
    constructor(from3, to3, diagnostic) {
      this.from = from3;
      this.to = to3;
      this.diagnostic = diagnostic;
    }
  };
  var LintState = class _LintState {
    constructor(diagnostics, panel, selected2) {
      this.diagnostics = diagnostics;
      this.panel = panel;
      this.selected = selected2;
    }
    static init(diagnostics, panel, state4) {
      let markedDiagnostics = diagnostics;
      let diagnosticFilter = state4.facet(lintConfig).markerFilter;
      if (diagnosticFilter)
        markedDiagnostics = diagnosticFilter(markedDiagnostics, state4);
      let ranges = Decoration.set(markedDiagnostics.map((d2) => {
        return d2.from == d2.to || d2.from == d2.to - 1 && state4.doc.lineAt(d2.from).to == d2.from ? Decoration.widget({
          widget: new DiagnosticWidget(d2),
          diagnostic: d2
        }).range(d2.from) : Decoration.mark({
          attributes: { class: "cm-lintRange cm-lintRange-" + d2.severity + (d2.markClass ? " " + d2.markClass : "") },
          diagnostic: d2
        }).range(d2.from, d2.to);
      }), true);
      return new _LintState(ranges, panel, findDiagnostic(ranges));
    }
  };
  function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
    let found = null;
    diagnostics.between(after, 1e9, (from3, to3, { spec }) => {
      if (diagnostic && spec.diagnostic != diagnostic)
        return;
      found = new SelectedDiagnostic(from3, to3, spec.diagnostic);
      return false;
    });
    return found;
  }
  function hideTooltip(tr, tooltip) {
    let from3 = tooltip.pos, to3 = tooltip.end || from3;
    let result = tr.state.facet(lintConfig).hideOn(tr, from3, to3);
    if (result != null)
      return result;
    let line = tr.startState.doc.lineAt(tooltip.pos);
    return !!(tr.effects.some((e2) => e2.is(setDiagnosticsEffect)) || tr.changes.touchesRange(line.from, Math.max(line.to, to3)));
  }
  function maybeEnableLint(state4, effects) {
    return state4.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of(lintExtensions));
  }
  var setDiagnosticsEffect = /* @__PURE__ */ StateEffect.define();
  var togglePanel2 = /* @__PURE__ */ StateEffect.define();
  var movePanelSelection = /* @__PURE__ */ StateEffect.define();
  var lintState = /* @__PURE__ */ StateField.define({
    create() {
      return new LintState(Decoration.none, null, null);
    },
    update(value12, tr) {
      if (tr.docChanged && value12.diagnostics.size) {
        let mapped = value12.diagnostics.map(tr.changes), selected2 = null, panel = value12.panel;
        if (value12.selected) {
          let selPos = tr.changes.mapPos(value12.selected.from, 1);
          selected2 = findDiagnostic(mapped, value12.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
        }
        if (!mapped.size && panel && tr.state.facet(lintConfig).autoPanel)
          panel = null;
        value12 = new LintState(mapped, panel, selected2);
      }
      for (let effect of tr.effects) {
        if (effect.is(setDiagnosticsEffect)) {
          let panel = !tr.state.facet(lintConfig).autoPanel ? value12.panel : effect.value.length ? LintPanel.open : null;
          value12 = LintState.init(effect.value, panel, tr.state);
        } else if (effect.is(togglePanel2)) {
          value12 = new LintState(value12.diagnostics, effect.value ? LintPanel.open : null, value12.selected);
        } else if (effect.is(movePanelSelection)) {
          value12 = new LintState(value12.diagnostics, value12.panel, effect.value);
        }
      }
      return value12;
    },
    provide: (f2) => [
      showPanel.from(f2, (val) => val.panel),
      EditorView.decorations.from(f2, (s2) => s2.diagnostics)
    ]
  });
  var activeMark = /* @__PURE__ */ Decoration.mark({ class: "cm-lintRange cm-lintRange-active" });
  function lintTooltip(view2, pos, side) {
    let { diagnostics } = view2.state.field(lintState);
    let found = [], stackStart = 2e8, stackEnd = 0;
    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from3, to3, { spec }) => {
      if (pos >= from3 && pos <= to3 && (from3 == to3 || (pos > from3 || side > 0) && (pos < to3 || side < 0))) {
        found.push(spec.diagnostic);
        stackStart = Math.min(from3, stackStart);
        stackEnd = Math.max(to3, stackEnd);
      }
    });
    let diagnosticFilter = view2.state.facet(lintConfig).tooltipFilter;
    if (diagnosticFilter)
      found = diagnosticFilter(found, view2.state);
    if (!found.length)
      return null;
    return {
      pos: stackStart,
      end: stackEnd,
      above: view2.state.doc.lineAt(stackStart).to < stackEnd,
      create() {
        return { dom: diagnosticsTooltip(view2, found) };
      }
    };
  }
  function diagnosticsTooltip(view2, diagnostics) {
    return crelt("ul", { class: "cm-tooltip-lint" }, diagnostics.map((d2) => renderDiagnostic(view2, d2, false)));
  }
  var openLintPanel = (view2) => {
    let field = view2.state.field(lintState, false);
    if (!field || !field.panel)
      view2.dispatch({ effects: maybeEnableLint(view2.state, [togglePanel2.of(true)]) });
    let panel = getPanel(view2, LintPanel.open);
    if (panel)
      panel.dom.querySelector(".cm-panel-lint ul").focus();
    return true;
  };
  var closeLintPanel = (view2) => {
    let field = view2.state.field(lintState, false);
    if (!field || !field.panel)
      return false;
    view2.dispatch({ effects: togglePanel2.of(false) });
    return true;
  };
  var nextDiagnostic = (view2) => {
    let field = view2.state.field(lintState, false);
    if (!field)
      return false;
    let sel = view2.state.selection.main, next = field.diagnostics.iter(sel.to + 1);
    if (!next.value) {
      next = field.diagnostics.iter(0);
      if (!next.value || next.from == sel.from && next.to == sel.to)
        return false;
    }
    view2.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });
    return true;
  };
  var lintKeymap = [
    { key: "Mod-Shift-m", run: openLintPanel, preventDefault: true },
    { key: "F8", run: nextDiagnostic }
  ];
  var lintConfig = /* @__PURE__ */ Facet.define({
    combine(input) {
      return Object.assign({ sources: input.map((i2) => i2.source).filter((x2) => x2 != null) }, combineConfig(input.map((i2) => i2.config), {
        delay: 750,
        markerFilter: null,
        tooltipFilter: null,
        needsRefresh: null,
        hideOn: () => null
      }, {
        needsRefresh: (a2, b2) => !a2 ? b2 : !b2 ? a2 : (u2) => a2(u2) || b2(u2)
      }));
    }
  });
  function assignKeys(actions) {
    let assigned = [];
    if (actions)
      actions: for (let { name: name16 } of actions) {
        for (let i2 = 0; i2 < name16.length; i2++) {
          let ch = name16[i2];
          if (/[a-zA-Z]/.test(ch) && !assigned.some((c2) => c2.toLowerCase() == ch.toLowerCase())) {
            assigned.push(ch);
            continue actions;
          }
        }
        assigned.push("");
      }
    return assigned;
  }
  function renderDiagnostic(view2, diagnostic, inPanel) {
    var _a2;
    let keys6 = inPanel ? assignKeys(diagnostic.actions) : [];
    return crelt("li", { class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity }, crelt("span", { class: "cm-diagnosticText" }, diagnostic.renderMessage ? diagnostic.renderMessage(view2) : diagnostic.message), (_a2 = diagnostic.actions) === null || _a2 === void 0 ? void 0 : _a2.map((action2, i2) => {
      let fired = false, click2 = (e2) => {
        e2.preventDefault();
        if (fired)
          return;
        fired = true;
        let found = findDiagnostic(view2.state.field(lintState).diagnostics, diagnostic);
        if (found)
          action2.apply(view2, found.from, found.to);
      };
      let { name: name16 } = action2, keyIndex = keys6[i2] ? name16.indexOf(keys6[i2]) : -1;
      let nameElt = keyIndex < 0 ? name16 : [
        name16.slice(0, keyIndex),
        crelt("u", name16.slice(keyIndex, keyIndex + 1)),
        name16.slice(keyIndex + 1)
      ];
      return crelt("button", {
        type: "button",
        class: "cm-diagnosticAction",
        onclick: click2,
        onmousedown: click2,
        "aria-label": ` Action: ${name16}${keyIndex < 0 ? "" : ` (access key "${keys6[i2]})"`}.`
      }, nameElt);
    }), diagnostic.source && crelt("div", { class: "cm-diagnosticSource" }, diagnostic.source));
  }
  var DiagnosticWidget = class extends WidgetType {
    constructor(diagnostic) {
      super();
      this.diagnostic = diagnostic;
    }
    eq(other) {
      return other.diagnostic == this.diagnostic;
    }
    toDOM() {
      return crelt("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
    }
  };
  var PanelItem = class {
    constructor(view2, diagnostic) {
      this.diagnostic = diagnostic;
      this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16);
      this.dom = renderDiagnostic(view2, diagnostic, true);
      this.dom.id = this.id;
      this.dom.setAttribute("role", "option");
    }
  };
  var LintPanel = class _LintPanel {
    constructor(view2) {
      this.view = view2;
      this.items = [];
      let onkeydown = (event) => {
        if (event.keyCode == 27) {
          closeLintPanel(this.view);
          this.view.focus();
        } else if (event.keyCode == 38 || event.keyCode == 33) {
          this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
        } else if (event.keyCode == 40 || event.keyCode == 34) {
          this.moveSelection((this.selectedIndex + 1) % this.items.length);
        } else if (event.keyCode == 36) {
          this.moveSelection(0);
        } else if (event.keyCode == 35) {
          this.moveSelection(this.items.length - 1);
        } else if (event.keyCode == 13) {
          this.view.focus();
        } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {
          let { diagnostic } = this.items[this.selectedIndex], keys6 = assignKeys(diagnostic.actions);
          for (let i2 = 0; i2 < keys6.length; i2++)
            if (keys6[i2].toUpperCase().charCodeAt(0) == event.keyCode) {
              let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
              if (found)
                diagnostic.actions[i2].apply(view2, found.from, found.to);
            }
        } else {
          return;
        }
        event.preventDefault();
      };
      let onclick = (event) => {
        for (let i2 = 0; i2 < this.items.length; i2++) {
          if (this.items[i2].dom.contains(event.target))
            this.moveSelection(i2);
        }
      };
      this.list = crelt("ul", {
        tabIndex: 0,
        role: "listbox",
        "aria-label": this.view.state.phrase("Diagnostics"),
        onkeydown,
        onclick
      });
      this.dom = crelt("div", { class: "cm-panel-lint" }, this.list, crelt("button", {
        type: "button",
        name: "close",
        "aria-label": this.view.state.phrase("close"),
        onclick: () => closeLintPanel(this.view)
      }, "\xD7"));
      this.update();
    }
    get selectedIndex() {
      let selected2 = this.view.state.field(lintState).selected;
      if (!selected2)
        return -1;
      for (let i2 = 0; i2 < this.items.length; i2++)
        if (this.items[i2].diagnostic == selected2.diagnostic)
          return i2;
      return -1;
    }
    update() {
      let { diagnostics, selected: selected2 } = this.view.state.field(lintState);
      let i2 = 0, needsSync = false, newSelectedItem = null;
      diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {
        let found = -1, item;
        for (let j2 = i2; j2 < this.items.length; j2++)
          if (this.items[j2].diagnostic == spec.diagnostic) {
            found = j2;
            break;
          }
        if (found < 0) {
          item = new PanelItem(this.view, spec.diagnostic);
          this.items.splice(i2, 0, item);
          needsSync = true;
        } else {
          item = this.items[found];
          if (found > i2) {
            this.items.splice(i2, found - i2);
            needsSync = true;
          }
        }
        if (selected2 && item.diagnostic == selected2.diagnostic) {
          if (!item.dom.hasAttribute("aria-selected")) {
            item.dom.setAttribute("aria-selected", "true");
            newSelectedItem = item;
          }
        } else if (item.dom.hasAttribute("aria-selected")) {
          item.dom.removeAttribute("aria-selected");
        }
        i2++;
      });
      while (i2 < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
        needsSync = true;
        this.items.pop();
      }
      if (this.items.length == 0) {
        this.items.push(new PanelItem(this.view, {
          from: -1,
          to: -1,
          severity: "info",
          message: this.view.state.phrase("No diagnostics")
        }));
        needsSync = true;
      }
      if (newSelectedItem) {
        this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
        this.view.requestMeasure({
          key: this,
          read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
          write: ({ sel, panel }) => {
            let scaleY = panel.height / this.list.offsetHeight;
            if (sel.top < panel.top)
              this.list.scrollTop -= (panel.top - sel.top) / scaleY;
            else if (sel.bottom > panel.bottom)
              this.list.scrollTop += (sel.bottom - panel.bottom) / scaleY;
          }
        });
      } else if (this.selectedIndex < 0) {
        this.list.removeAttribute("aria-activedescendant");
      }
      if (needsSync)
        this.sync();
    }
    sync() {
      let domPos = this.list.firstChild;
      function rm2() {
        let prev = domPos;
        domPos = prev.nextSibling;
        prev.remove();
      }
      for (let item of this.items) {
        if (item.dom.parentNode == this.list) {
          while (domPos != item.dom)
            rm2();
          domPos = item.dom.nextSibling;
        } else {
          this.list.insertBefore(item.dom, domPos);
        }
      }
      while (domPos)
        rm2();
    }
    moveSelection(selectedIndex2) {
      if (this.selectedIndex < 0)
        return;
      let field = this.view.state.field(lintState);
      let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex2].diagnostic);
      if (!selection)
        return;
      this.view.dispatch({
        selection: { anchor: selection.from, head: selection.to },
        scrollIntoView: true,
        effects: movePanelSelection.of(selection)
      });
    }
    static open(view2) {
      return new _LintPanel(view2);
    }
  };
  function svg(content4, attrs = `viewBox="0 0 40 40"`) {
    return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content4)}</svg>')`;
  }
  function underline(color) {
    return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
  }
  var baseTheme5 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-diagnostic": {
      padding: "3px 6px 3px 8px",
      marginLeft: "-1px",
      display: "block",
      whiteSpace: "pre-wrap"
    },
    ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
    ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
    ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
    ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
    ".cm-diagnosticAction": {
      font: "inherit",
      border: "none",
      padding: "2px 4px",
      backgroundColor: "#444",
      color: "white",
      borderRadius: "3px",
      marginLeft: "8px",
      cursor: "pointer"
    },
    ".cm-diagnosticSource": {
      fontSize: "70%",
      opacity: 0.7
    },
    ".cm-lintRange": {
      backgroundPosition: "left bottom",
      backgroundRepeat: "repeat-x",
      paddingBottom: "0.7px"
    },
    ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ underline("#d11") },
    ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ underline("orange") },
    ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ underline("#999") },
    ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ underline("#66d") },
    ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
    ".cm-tooltip-lint": {
      padding: 0,
      margin: 0
    },
    ".cm-lintPoint": {
      position: "relative",
      "&:after": {
        content: '""',
        position: "absolute",
        bottom: 0,
        left: "-2px",
        borderLeft: "3px solid transparent",
        borderRight: "3px solid transparent",
        borderBottom: "4px solid #d11"
      }
    },
    ".cm-lintPoint-warning": {
      "&:after": { borderBottomColor: "orange" }
    },
    ".cm-lintPoint-info": {
      "&:after": { borderBottomColor: "#999" }
    },
    ".cm-lintPoint-hint": {
      "&:after": { borderBottomColor: "#66d" }
    },
    ".cm-panel.cm-panel-lint": {
      position: "relative",
      "& ul": {
        maxHeight: "100px",
        overflowY: "auto",
        "& [aria-selected]": {
          backgroundColor: "#ddd",
          "& u": { textDecoration: "underline" }
        },
        "&:focus [aria-selected]": {
          background_fallback: "#bdf",
          backgroundColor: "Highlight",
          color_fallback: "white",
          color: "HighlightText"
        },
        "& u": { textDecoration: "none" },
        padding: 0,
        margin: 0
      },
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "2px",
        background: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0
      }
    }
  });
  var lintExtensions = [
    lintState,
    /* @__PURE__ */ EditorView.decorations.compute([lintState], (state4) => {
      let { selected: selected2, panel } = state4.field(lintState);
      return !selected2 || !panel || selected2.from == selected2.to ? Decoration.none : Decoration.set([
        activeMark.range(selected2.from, selected2.to)
      ]);
    }),
    /* @__PURE__ */ hoverTooltip(lintTooltip, { hideOn: hideTooltip }),
    baseTheme5
  ];

  // node_modules/codemirror/dist/index.js
  var basicSetup = /* @__PURE__ */ (() => [
    lineNumbers(),
    highlightActiveLineGutter(),
    highlightSpecialChars(),
    history(),
    foldGutter(),
    drawSelection(),
    dropCursor(),
    EditorState.allowMultipleSelections.of(true),
    indentOnInput(),
    syntaxHighlighting(defaultHighlightStyle, { fallback: true }),
    bracketMatching(),
    closeBrackets(),
    autocompletion(),
    rectangularSelection(),
    crosshairCursor(),
    highlightActiveLine(),
    highlightSelectionMatches(),
    keymap.of([
      ...closeBracketsKeymap,
      ...defaultKeymap,
      ...searchKeymap,
      ...historyKeymap,
      ...foldKeymap,
      ...completionKeymap,
      ...lintKeymap
    ])
  ])();

  // node_modules/@lezer/lr/dist/index.js
  var Stack = class _Stack {
    /**
    @internal
    */
    constructor(p2, stack, state4, reducePos, pos, score2, buffer, bufferBase, curContext, lookAhead = 0, parent2) {
      this.p = p2;
      this.stack = stack;
      this.state = state4;
      this.reducePos = reducePos;
      this.pos = pos;
      this.score = score2;
      this.buffer = buffer;
      this.bufferBase = bufferBase;
      this.curContext = curContext;
      this.lookAhead = lookAhead;
      this.parent = parent2;
    }
    /**
    @internal
    */
    toString() {
      return `[${this.stack.filter((_, i2) => i2 % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
    }
    // Start an empty stack
    /**
    @internal
    */
    static start(p2, state4, pos = 0) {
      let cx = p2.parser.context;
      return new _Stack(p2, [], state4, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
    }
    /**
    The stack's current [context](#lr.ContextTracker) value, if
    any. Its type will depend on the context tracker's type
    parameter, or it will be `null` if there is no context
    tracker.
    */
    get context() {
      return this.curContext ? this.curContext.context : null;
    }
    // Push a state onto the stack, tracking its start position as well
    // as the buffer base at that point.
    /**
    @internal
    */
    pushState(state4, start3) {
      this.stack.push(this.state, start3, this.bufferBase + this.buffer.length);
      this.state = state4;
    }
    // Apply a reduce action
    /**
    @internal
    */
    reduce(action2) {
      var _a2;
      let depth = action2 >> 19, type = action2 & 65535;
      let { parser: parser2 } = this.p;
      let lookaheadRecord = this.reducePos < this.pos - 25;
      if (lookaheadRecord)
        this.setLookAhead(this.pos);
      let dPrec = parser2.dynamicPrecedence(type);
      if (dPrec)
        this.score += dPrec;
      if (depth == 0) {
        this.pushState(parser2.getGoto(this.state, type, true), this.reducePos);
        if (type < parser2.minRepeatTerm)
          this.storeNode(type, this.reducePos, this.reducePos, lookaheadRecord ? 8 : 4, true);
        this.reduceContext(type, this.reducePos);
        return;
      }
      let base2 = this.stack.length - (depth - 1) * 3 - (action2 & 262144 ? 6 : 0);
      let start3 = base2 ? this.stack[base2 - 2] : this.p.ranges[0].from, size5 = this.reducePos - start3;
      if (size5 >= 2e3 && !((_a2 = this.p.parser.nodeSet.types[type]) === null || _a2 === void 0 ? void 0 : _a2.isAnonymous)) {
        if (start3 == this.p.lastBigReductionStart) {
          this.p.bigReductionCount++;
          this.p.lastBigReductionSize = size5;
        } else if (this.p.lastBigReductionSize < size5) {
          this.p.bigReductionCount = 1;
          this.p.lastBigReductionStart = start3;
          this.p.lastBigReductionSize = size5;
        }
      }
      let bufferBase = base2 ? this.stack[base2 - 1] : 0, count2 = this.bufferBase + this.buffer.length - bufferBase;
      if (type < parser2.minRepeatTerm || action2 & 131072) {
        let pos = parser2.stateFlag(
          this.state,
          1
          /* StateFlag.Skipped */
        ) ? this.pos : this.reducePos;
        this.storeNode(type, start3, pos, count2 + 4, true);
      }
      if (action2 & 262144) {
        this.state = this.stack[base2];
      } else {
        let baseStateID = this.stack[base2 - 3];
        this.state = parser2.getGoto(baseStateID, type, true);
      }
      while (this.stack.length > base2)
        this.stack.pop();
      this.reduceContext(type, start3);
    }
    // Shift a value into the buffer
    /**
    @internal
    */
    storeNode(term, start3, end, size5 = 4, mustSink = false) {
      if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
        let cur2 = this, top4 = this.buffer.length;
        if (top4 == 0 && cur2.parent) {
          top4 = cur2.bufferBase - cur2.parent.bufferBase;
          cur2 = cur2.parent;
        }
        if (top4 > 0 && cur2.buffer[top4 - 4] == 0 && cur2.buffer[top4 - 1] > -1) {
          if (start3 == end)
            return;
          if (cur2.buffer[top4 - 2] >= start3) {
            cur2.buffer[top4 - 2] = end;
            return;
          }
        }
      }
      if (!mustSink || this.pos == end) {
        this.buffer.push(term, start3, end, size5);
      } else {
        let index6 = this.buffer.length;
        if (index6 > 0 && this.buffer[index6 - 4] != 0) {
          let mustMove = false;
          for (let scan = index6; scan > 0 && this.buffer[scan - 2] > end; scan -= 4) {
            if (this.buffer[scan - 1] >= 0) {
              mustMove = true;
              break;
            }
          }
          if (mustMove)
            while (index6 > 0 && this.buffer[index6 - 2] > end) {
              this.buffer[index6] = this.buffer[index6 - 4];
              this.buffer[index6 + 1] = this.buffer[index6 - 3];
              this.buffer[index6 + 2] = this.buffer[index6 - 2];
              this.buffer[index6 + 3] = this.buffer[index6 - 1];
              index6 -= 4;
              if (size5 > 4)
                size5 -= 4;
            }
        }
        this.buffer[index6] = term;
        this.buffer[index6 + 1] = start3;
        this.buffer[index6 + 2] = end;
        this.buffer[index6 + 3] = size5;
      }
    }
    // Apply a shift action
    /**
    @internal
    */
    shift(action2, type, start3, end) {
      if (action2 & 131072) {
        this.pushState(action2 & 65535, this.pos);
      } else if ((action2 & 262144) == 0) {
        let nextState = action2, { parser: parser2 } = this.p;
        if (end > this.pos || type <= parser2.maxNode) {
          this.pos = end;
          if (!parser2.stateFlag(
            nextState,
            1
            /* StateFlag.Skipped */
          ))
            this.reducePos = end;
        }
        this.pushState(nextState, start3);
        this.shiftContext(type, start3);
        if (type <= parser2.maxNode)
          this.buffer.push(type, start3, end, 4);
      } else {
        this.pos = end;
        this.shiftContext(type, start3);
        if (type <= this.p.parser.maxNode)
          this.buffer.push(type, start3, end, 4);
      }
    }
    // Apply an action
    /**
    @internal
    */
    apply(action2, next, nextStart, nextEnd) {
      if (action2 & 65536)
        this.reduce(action2);
      else
        this.shift(action2, next, nextStart, nextEnd);
    }
    // Add a prebuilt (reused) node into the buffer.
    /**
    @internal
    */
    useNode(value12, next) {
      let index6 = this.p.reused.length - 1;
      if (index6 < 0 || this.p.reused[index6] != value12) {
        this.p.reused.push(value12);
        index6++;
      }
      let start3 = this.pos;
      this.reducePos = this.pos = start3 + value12.length;
      this.pushState(next, start3);
      this.buffer.push(
        index6,
        start3,
        this.reducePos,
        -1
        /* size == -1 means this is a reused value */
      );
      if (this.curContext)
        this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value12, this, this.p.stream.reset(this.pos - value12.length)));
    }
    // Split the stack. Due to the buffer sharing and the fact
    // that `this.stack` tends to stay quite shallow, this isn't very
    // expensive.
    /**
    @internal
    */
    split() {
      let parent2 = this;
      let off = parent2.buffer.length;
      while (off > 0 && parent2.buffer[off - 2] > parent2.reducePos)
        off -= 4;
      let buffer = parent2.buffer.slice(off), base2 = parent2.bufferBase + off;
      while (parent2 && base2 == parent2.bufferBase)
        parent2 = parent2.parent;
      return new _Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base2, this.curContext, this.lookAhead, parent2);
    }
    // Try to recover from an error by 'deleting' (ignoring) one token.
    /**
    @internal
    */
    recoverByDelete(next, nextEnd) {
      let isNode = next <= this.p.parser.maxNode;
      if (isNode)
        this.storeNode(next, this.pos, nextEnd, 4);
      this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
      this.pos = this.reducePos = nextEnd;
      this.score -= 190;
    }
    /**
    Check if the given term would be able to be shifted (optionally
    after some reductions) on this stack. This can be useful for
    external tokenizers that want to make sure they only provide a
    given token when it applies.
    */
    canShift(term) {
      for (let sim = new SimulatedStack(this); ; ) {
        let action2 = this.p.parser.stateSlot(
          sim.state,
          4
          /* ParseState.DefaultReduce */
        ) || this.p.parser.hasAction(sim.state, term);
        if (action2 == 0)
          return false;
        if ((action2 & 65536) == 0)
          return true;
        sim.reduce(action2);
      }
    }
    // Apply up to Recover.MaxNext recovery actions that conceptually
    // inserts some missing token or rule.
    /**
    @internal
    */
    recoverByInsert(next) {
      if (this.stack.length >= 300)
        return [];
      let nextStates = this.p.parser.nextStates(this.state);
      if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
        let best = [];
        for (let i2 = 0, s2; i2 < nextStates.length; i2 += 2) {
          if ((s2 = nextStates[i2 + 1]) != this.state && this.p.parser.hasAction(s2, next))
            best.push(nextStates[i2], s2);
        }
        if (this.stack.length < 120)
          for (let i2 = 0; best.length < 4 << 1 && i2 < nextStates.length; i2 += 2) {
            let s2 = nextStates[i2 + 1];
            if (!best.some((v2, i3) => i3 & 1 && v2 == s2))
              best.push(nextStates[i2], s2);
          }
        nextStates = best;
      }
      let result = [];
      for (let i2 = 0; i2 < nextStates.length && result.length < 4; i2 += 2) {
        let s2 = nextStates[i2 + 1];
        if (s2 == this.state)
          continue;
        let stack = this.split();
        stack.pushState(s2, this.pos);
        stack.storeNode(0, stack.pos, stack.pos, 4, true);
        stack.shiftContext(nextStates[i2], this.pos);
        stack.reducePos = this.pos;
        stack.score -= 200;
        result.push(stack);
      }
      return result;
    }
    // Force a reduce, if possible. Return false if that can't
    // be done.
    /**
    @internal
    */
    forceReduce() {
      let { parser: parser2 } = this.p;
      let reduce = parser2.stateSlot(
        this.state,
        5
        /* ParseState.ForcedReduce */
      );
      if ((reduce & 65536) == 0)
        return false;
      if (!parser2.validAction(this.state, reduce)) {
        let depth = reduce >> 19, term = reduce & 65535;
        let target5 = this.stack.length - depth * 3;
        if (target5 < 0 || parser2.getGoto(this.stack[target5], term, false) < 0) {
          let backup = this.findForcedReduction();
          if (backup == null)
            return false;
          reduce = backup;
        }
        this.storeNode(0, this.pos, this.pos, 4, true);
        this.score -= 100;
      }
      this.reducePos = this.pos;
      this.reduce(reduce);
      return true;
    }
    /**
    Try to scan through the automaton to find some kind of reduction
    that can be applied. Used when the regular ForcedReduce field
    isn't a valid action. @internal
    */
    findForcedReduction() {
      let { parser: parser2 } = this.p, seen = [];
      let explore = (state4, depth) => {
        if (seen.includes(state4))
          return;
        seen.push(state4);
        return parser2.allActions(state4, (action2) => {
          if (action2 & (262144 | 131072)) ;
          else if (action2 & 65536) {
            let rDepth = (action2 >> 19) - depth;
            if (rDepth > 1) {
              let term = action2 & 65535, target5 = this.stack.length - rDepth * 3;
              if (target5 >= 0 && parser2.getGoto(this.stack[target5], term, false) >= 0)
                return rDepth << 19 | 65536 | term;
            }
          } else {
            let found = explore(action2, depth + 1);
            if (found != null)
              return found;
          }
        });
      };
      return explore(this.state, 0);
    }
    /**
    @internal
    */
    forceAll() {
      while (!this.p.parser.stateFlag(
        this.state,
        2
        /* StateFlag.Accepting */
      )) {
        if (!this.forceReduce()) {
          this.storeNode(0, this.pos, this.pos, 4, true);
          break;
        }
      }
      return this;
    }
    /**
    Check whether this state has no further actions (assumed to be a direct descendant of the
    top state, since any other states must be able to continue
    somehow). @internal
    */
    get deadEnd() {
      if (this.stack.length != 3)
        return false;
      let { parser: parser2 } = this.p;
      return parser2.data[parser2.stateSlot(
        this.state,
        1
        /* ParseState.Actions */
      )] == 65535 && !parser2.stateSlot(
        this.state,
        4
        /* ParseState.DefaultReduce */
      );
    }
    /**
    Restart the stack (put it back in its start state). Only safe
    when this.stack.length == 3 (state is directly below the top
    state). @internal
    */
    restart() {
      this.storeNode(0, this.pos, this.pos, 4, true);
      this.state = this.stack[0];
      this.stack.length = 0;
    }
    /**
    @internal
    */
    sameState(other) {
      if (this.state != other.state || this.stack.length != other.stack.length)
        return false;
      for (let i2 = 0; i2 < this.stack.length; i2 += 3)
        if (this.stack[i2] != other.stack[i2])
          return false;
      return true;
    }
    /**
    Get the parser used by this stack.
    */
    get parser() {
      return this.p.parser;
    }
    /**
    Test whether a given dialect (by numeric ID, as exported from
    the terms file) is enabled.
    */
    dialectEnabled(dialectID) {
      return this.p.parser.dialect.flags[dialectID];
    }
    shiftContext(term, start3) {
      if (this.curContext)
        this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start3)));
    }
    reduceContext(term, start3) {
      if (this.curContext)
        this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start3)));
    }
    /**
    @internal
    */
    emitContext() {
      let last4 = this.buffer.length - 1;
      if (last4 < 0 || this.buffer[last4] != -3)
        this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
    }
    /**
    @internal
    */
    emitLookAhead() {
      let last4 = this.buffer.length - 1;
      if (last4 < 0 || this.buffer[last4] != -4)
        this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
    }
    updateContext(context3) {
      if (context3 != this.curContext.context) {
        let newCx = new StackContext(this.curContext.tracker, context3);
        if (newCx.hash != this.curContext.hash)
          this.emitContext();
        this.curContext = newCx;
      }
    }
    /**
    @internal
    */
    setLookAhead(lookAhead) {
      if (lookAhead > this.lookAhead) {
        this.emitLookAhead();
        this.lookAhead = lookAhead;
      }
    }
    /**
    @internal
    */
    close() {
      if (this.curContext && this.curContext.tracker.strict)
        this.emitContext();
      if (this.lookAhead > 0)
        this.emitLookAhead();
    }
  };
  var StackContext = class {
    constructor(tracker, context3) {
      this.tracker = tracker;
      this.context = context3;
      this.hash = tracker.strict ? tracker.hash(context3) : 0;
    }
  };
  var SimulatedStack = class {
    constructor(start3) {
      this.start = start3;
      this.state = start3.state;
      this.stack = start3.stack;
      this.base = this.stack.length;
    }
    reduce(action2) {
      let term = action2 & 65535, depth = action2 >> 19;
      if (depth == 0) {
        if (this.stack == this.start.stack)
          this.stack = this.stack.slice();
        this.stack.push(this.state, 0, 0);
        this.base += 3;
      } else {
        this.base -= (depth - 1) * 3;
      }
      let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
      this.state = goto;
    }
  };
  var StackBufferCursor = class _StackBufferCursor {
    constructor(stack, pos, index6) {
      this.stack = stack;
      this.pos = pos;
      this.index = index6;
      this.buffer = stack.buffer;
      if (this.index == 0)
        this.maybeNext();
    }
    static create(stack, pos = stack.bufferBase + stack.buffer.length) {
      return new _StackBufferCursor(stack, pos, pos - stack.bufferBase);
    }
    maybeNext() {
      let next = this.stack.parent;
      if (next != null) {
        this.index = this.stack.bufferBase - next.bufferBase;
        this.stack = next;
        this.buffer = next.buffer;
      }
    }
    get id() {
      return this.buffer[this.index - 4];
    }
    get start() {
      return this.buffer[this.index - 3];
    }
    get end() {
      return this.buffer[this.index - 2];
    }
    get size() {
      return this.buffer[this.index - 1];
    }
    next() {
      this.index -= 4;
      this.pos -= 4;
      if (this.index == 0)
        this.maybeNext();
    }
    fork() {
      return new _StackBufferCursor(this.stack, this.pos, this.index);
    }
  };
  function decodeArray3(input, Type = Uint16Array) {
    if (typeof input != "string")
      return input;
    let array = null;
    for (let pos = 0, out2 = 0; pos < input.length; ) {
      let value12 = 0;
      for (; ; ) {
        let next = input.charCodeAt(pos++), stop = false;
        if (next == 126) {
          value12 = 65535;
          break;
        }
        if (next >= 92)
          next--;
        if (next >= 34)
          next--;
        let digit = next - 32;
        if (digit >= 46) {
          digit -= 46;
          stop = true;
        }
        value12 += digit;
        if (stop)
          break;
        value12 *= 46;
      }
      if (array)
        array[out2++] = value12;
      else
        array = new Type(value12);
    }
    return array;
  }
  var CachedToken = class {
    constructor() {
      this.start = -1;
      this.value = -1;
      this.end = -1;
      this.extended = -1;
      this.lookAhead = 0;
      this.mask = 0;
      this.context = 0;
    }
  };
  var nullToken = new CachedToken();
  var InputStream = class {
    /**
    @internal
    */
    constructor(input, ranges) {
      this.input = input;
      this.ranges = ranges;
      this.chunk = "";
      this.chunkOff = 0;
      this.chunk2 = "";
      this.chunk2Pos = 0;
      this.next = -1;
      this.token = nullToken;
      this.rangeIndex = 0;
      this.pos = this.chunkPos = ranges[0].from;
      this.range = ranges[0];
      this.end = ranges[ranges.length - 1].to;
      this.readNext();
    }
    /**
    @internal
    */
    resolveOffset(offset, assoc) {
      let range3 = this.range, index6 = this.rangeIndex;
      let pos = this.pos + offset;
      while (pos < range3.from) {
        if (!index6)
          return null;
        let next = this.ranges[--index6];
        pos -= range3.from - next.to;
        range3 = next;
      }
      while (assoc < 0 ? pos > range3.to : pos >= range3.to) {
        if (index6 == this.ranges.length - 1)
          return null;
        let next = this.ranges[++index6];
        pos += next.from - range3.to;
        range3 = next;
      }
      return pos;
    }
    /**
    @internal
    */
    clipPos(pos) {
      if (pos >= this.range.from && pos < this.range.to)
        return pos;
      for (let range3 of this.ranges)
        if (range3.to > pos)
          return Math.max(pos, range3.from);
      return this.end;
    }
    /**
    Look at a code unit near the stream position. `.peek(0)` equals
    `.next`, `.peek(-1)` gives you the previous character, and so
    on.
    
    Note that looking around during tokenizing creates dependencies
    on potentially far-away content, which may reduce the
    effectiveness incremental parsing—when looking forward—or even
    cause invalid reparses when looking backward more than 25 code
    units, since the library does not track lookbehind.
    */
    peek(offset) {
      let idx = this.chunkOff + offset, pos, result;
      if (idx >= 0 && idx < this.chunk.length) {
        pos = this.pos + offset;
        result = this.chunk.charCodeAt(idx);
      } else {
        let resolved = this.resolveOffset(offset, 1);
        if (resolved == null)
          return -1;
        pos = resolved;
        if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
          result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
        } else {
          let i2 = this.rangeIndex, range3 = this.range;
          while (range3.to <= pos)
            range3 = this.ranges[++i2];
          this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
          if (pos + this.chunk2.length > range3.to)
            this.chunk2 = this.chunk2.slice(0, range3.to - pos);
          result = this.chunk2.charCodeAt(0);
        }
      }
      if (pos >= this.token.lookAhead)
        this.token.lookAhead = pos + 1;
      return result;
    }
    /**
    Accept a token. By default, the end of the token is set to the
    current stream position, but you can pass an offset (relative to
    the stream position) to change that.
    */
    acceptToken(token, endOffset = 0) {
      let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
      if (end == null || end < this.token.start)
        throw new RangeError("Token end out of bounds");
      this.token.value = token;
      this.token.end = end;
    }
    /**
    Accept a token ending at a specific given position.
    */
    acceptTokenTo(token, endPos) {
      this.token.value = token;
      this.token.end = endPos;
    }
    getChunk() {
      if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
        let { chunk, chunkPos } = this;
        this.chunk = this.chunk2;
        this.chunkPos = this.chunk2Pos;
        this.chunk2 = chunk;
        this.chunk2Pos = chunkPos;
        this.chunkOff = this.pos - this.chunkPos;
      } else {
        this.chunk2 = this.chunk;
        this.chunk2Pos = this.chunkPos;
        let nextChunk = this.input.chunk(this.pos);
        let end = this.pos + nextChunk.length;
        this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
        this.chunkPos = this.pos;
        this.chunkOff = 0;
      }
    }
    readNext() {
      if (this.chunkOff >= this.chunk.length) {
        this.getChunk();
        if (this.chunkOff == this.chunk.length)
          return this.next = -1;
      }
      return this.next = this.chunk.charCodeAt(this.chunkOff);
    }
    /**
    Move the stream forward N (defaults to 1) code units. Returns
    the new value of [`next`](#lr.InputStream.next).
    */
    advance(n2 = 1) {
      this.chunkOff += n2;
      while (this.pos + n2 >= this.range.to) {
        if (this.rangeIndex == this.ranges.length - 1)
          return this.setDone();
        n2 -= this.range.to - this.pos;
        this.range = this.ranges[++this.rangeIndex];
        this.pos = this.range.from;
      }
      this.pos += n2;
      if (this.pos >= this.token.lookAhead)
        this.token.lookAhead = this.pos + 1;
      return this.readNext();
    }
    setDone() {
      this.pos = this.chunkPos = this.end;
      this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
      this.chunk = "";
      return this.next = -1;
    }
    /**
    @internal
    */
    reset(pos, token) {
      if (token) {
        this.token = token;
        token.start = pos;
        token.lookAhead = pos + 1;
        token.value = token.extended = -1;
      } else {
        this.token = nullToken;
      }
      if (this.pos != pos) {
        this.pos = pos;
        if (pos == this.end) {
          this.setDone();
          return this;
        }
        while (pos < this.range.from)
          this.range = this.ranges[--this.rangeIndex];
        while (pos >= this.range.to)
          this.range = this.ranges[++this.rangeIndex];
        if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
          this.chunkOff = pos - this.chunkPos;
        } else {
          this.chunk = "";
          this.chunkOff = 0;
        }
        this.readNext();
      }
      return this;
    }
    /**
    @internal
    */
    read(from3, to3) {
      if (from3 >= this.chunkPos && to3 <= this.chunkPos + this.chunk.length)
        return this.chunk.slice(from3 - this.chunkPos, to3 - this.chunkPos);
      if (from3 >= this.chunk2Pos && to3 <= this.chunk2Pos + this.chunk2.length)
        return this.chunk2.slice(from3 - this.chunk2Pos, to3 - this.chunk2Pos);
      if (from3 >= this.range.from && to3 <= this.range.to)
        return this.input.read(from3, to3);
      let result = "";
      for (let r2 of this.ranges) {
        if (r2.from >= to3)
          break;
        if (r2.to > from3)
          result += this.input.read(Math.max(r2.from, from3), Math.min(r2.to, to3));
      }
      return result;
    }
  };
  var TokenGroup = class {
    constructor(data, id5) {
      this.data = data;
      this.id = id5;
    }
    token(input, stack) {
      let { parser: parser2 } = stack.p;
      readToken(this.data, input, stack, this.id, parser2.data, parser2.tokenPrecTable);
    }
  };
  TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
  var LocalTokenGroup = class {
    constructor(data, precTable, elseToken) {
      this.precTable = precTable;
      this.elseToken = elseToken;
      this.data = typeof data == "string" ? decodeArray3(data) : data;
    }
    token(input, stack) {
      let start3 = input.pos, skipped = 0;
      for (; ; ) {
        let atEof = input.next < 0, nextPos = input.resolveOffset(1, 1);
        readToken(this.data, input, stack, 0, this.data, this.precTable);
        if (input.token.value > -1)
          break;
        if (this.elseToken == null)
          return;
        if (!atEof)
          skipped++;
        if (nextPos == null)
          break;
        input.reset(nextPos, input.token);
      }
      if (skipped) {
        input.reset(start3, input.token);
        input.acceptToken(this.elseToken, skipped);
      }
    }
  };
  LocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
  var ExternalTokenizer = class {
    /**
    Create a tokenizer. The first argument is the function that,
    given an input stream, scans for the types of tokens it
    recognizes at the stream's position, and calls
    [`acceptToken`](#lr.InputStream.acceptToken) when it finds
    one.
    */
    constructor(token, options2 = {}) {
      this.token = token;
      this.contextual = !!options2.contextual;
      this.fallback = !!options2.fallback;
      this.extend = !!options2.extend;
    }
  };
  function readToken(data, input, stack, group4, precTable, precOffset) {
    let state4 = 0, groupMask = 1 << group4, { dialect } = stack.p.parser;
    scan: for (; ; ) {
      if ((groupMask & data[state4]) == 0)
        break;
      let accEnd = data[state4 + 1];
      for (let i2 = state4 + 3; i2 < accEnd; i2 += 2)
        if ((data[i2 + 1] & groupMask) > 0) {
          let term = data[i2];
          if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || overrides(term, input.token.value, precTable, precOffset))) {
            input.acceptToken(term);
            break;
          }
        }
      let next = input.next, low2 = 0, high2 = data[state4 + 2];
      if (input.next < 0 && high2 > low2 && data[accEnd + high2 * 3 - 3] == 65535) {
        state4 = data[accEnd + high2 * 3 - 1];
        continue scan;
      }
      for (; low2 < high2; ) {
        let mid = low2 + high2 >> 1;
        let index6 = accEnd + mid + (mid << 1);
        let from3 = data[index6], to3 = data[index6 + 1] || 65536;
        if (next < from3)
          high2 = mid;
        else if (next >= to3)
          low2 = mid + 1;
        else {
          state4 = data[index6 + 2];
          input.advance();
          continue scan;
        }
      }
      break;
    }
  }
  function findOffset(data, start3, term) {
    for (let i2 = start3, next; (next = data[i2]) != 65535; i2++)
      if (next == term)
        return i2 - start3;
    return -1;
  }
  function overrides(token, prev, tableData, tableOffset) {
    let iPrev = findOffset(tableData, tableOffset, prev);
    return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;
  }
  var verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
  var stackIDs = null;
  function cutAt(tree, pos, side) {
    let cursor = tree.cursor(IterMode.IncludeAnonymous);
    cursor.moveTo(pos);
    for (; ; ) {
      if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
        for (; ; ) {
          if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
            return side < 0 ? Math.max(0, Math.min(
              cursor.to - 1,
              pos - 25
              /* Lookahead.Margin */
            )) : Math.min(tree.length, Math.max(
              cursor.from + 1,
              pos + 25
              /* Lookahead.Margin */
            ));
          if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
            break;
          if (!cursor.parent())
            return side < 0 ? 0 : tree.length;
        }
    }
  }
  var FragmentCursor = class {
    constructor(fragments, nodeSet) {
      this.fragments = fragments;
      this.nodeSet = nodeSet;
      this.i = 0;
      this.fragment = null;
      this.safeFrom = -1;
      this.safeTo = -1;
      this.trees = [];
      this.start = [];
      this.index = [];
      this.nextFragment();
    }
    nextFragment() {
      let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
      if (fr) {
        this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
        this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
        while (this.trees.length) {
          this.trees.pop();
          this.start.pop();
          this.index.pop();
        }
        this.trees.push(fr.tree);
        this.start.push(-fr.offset);
        this.index.push(0);
        this.nextStart = this.safeFrom;
      } else {
        this.nextStart = 1e9;
      }
    }
    // `pos` must be >= any previously given `pos` for this cursor
    nodeAt(pos) {
      if (pos < this.nextStart)
        return null;
      while (this.fragment && this.safeTo <= pos)
        this.nextFragment();
      if (!this.fragment)
        return null;
      for (; ; ) {
        let last4 = this.trees.length - 1;
        if (last4 < 0) {
          this.nextFragment();
          return null;
        }
        let top4 = this.trees[last4], index6 = this.index[last4];
        if (index6 == top4.children.length) {
          this.trees.pop();
          this.start.pop();
          this.index.pop();
          continue;
        }
        let next = top4.children[index6];
        let start3 = this.start[last4] + top4.positions[index6];
        if (start3 > pos) {
          this.nextStart = start3;
          return null;
        }
        if (next instanceof Tree) {
          if (start3 == pos) {
            if (start3 < this.safeFrom)
              return null;
            let end = start3 + next.length;
            if (end <= this.safeTo) {
              let lookAhead = next.prop(NodeProp.lookAhead);
              if (!lookAhead || end + lookAhead < this.fragment.to)
                return next;
            }
          }
          this.index[last4]++;
          if (start3 + next.length >= Math.max(this.safeFrom, pos)) {
            this.trees.push(next);
            this.start.push(start3);
            this.index.push(0);
          }
        } else {
          this.index[last4]++;
          this.nextStart = start3 + next.length;
        }
      }
    }
  };
  var TokenCache = class {
    constructor(parser2, stream) {
      this.stream = stream;
      this.tokens = [];
      this.mainToken = null;
      this.actions = [];
      this.tokens = parser2.tokenizers.map((_) => new CachedToken());
    }
    getActions(stack) {
      let actionIndex = 0;
      let main4 = null;
      let { parser: parser2 } = stack.p, { tokenizers } = parser2;
      let mask = parser2.stateSlot(
        stack.state,
        3
        /* ParseState.TokenizerMask */
      );
      let context3 = stack.curContext ? stack.curContext.hash : 0;
      let lookAhead = 0;
      for (let i2 = 0; i2 < tokenizers.length; i2++) {
        if ((1 << i2 & mask) == 0)
          continue;
        let tokenizer = tokenizers[i2], token = this.tokens[i2];
        if (main4 && !tokenizer.fallback)
          continue;
        if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context3) {
          this.updateCachedToken(token, tokenizer, stack);
          token.mask = mask;
          token.context = context3;
        }
        if (token.lookAhead > token.end + 25)
          lookAhead = Math.max(token.lookAhead, lookAhead);
        if (token.value != 0) {
          let startIndex = actionIndex;
          if (token.extended > -1)
            actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
          actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
          if (!tokenizer.extend) {
            main4 = token;
            if (actionIndex > startIndex)
              break;
          }
        }
      }
      while (this.actions.length > actionIndex)
        this.actions.pop();
      if (lookAhead)
        stack.setLookAhead(lookAhead);
      if (!main4 && stack.pos == this.stream.end) {
        main4 = new CachedToken();
        main4.value = stack.p.parser.eofTerm;
        main4.start = main4.end = stack.pos;
        actionIndex = this.addActions(stack, main4.value, main4.end, actionIndex);
      }
      this.mainToken = main4;
      return this.actions;
    }
    getMainToken(stack) {
      if (this.mainToken)
        return this.mainToken;
      let main4 = new CachedToken(), { pos, p: p2 } = stack;
      main4.start = pos;
      main4.end = Math.min(pos + 1, p2.stream.end);
      main4.value = pos == p2.stream.end ? p2.parser.eofTerm : 0;
      return main4;
    }
    updateCachedToken(token, tokenizer, stack) {
      let start3 = this.stream.clipPos(stack.pos);
      tokenizer.token(this.stream.reset(start3, token), stack);
      if (token.value > -1) {
        let { parser: parser2 } = stack.p;
        for (let i2 = 0; i2 < parser2.specialized.length; i2++)
          if (parser2.specialized[i2] == token.value) {
            let result = parser2.specializers[i2](this.stream.read(token.start, token.end), stack);
            if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
              if ((result & 1) == 0)
                token.value = result >> 1;
              else
                token.extended = result >> 1;
              break;
            }
          }
      } else {
        token.value = 0;
        token.end = this.stream.clipPos(start3 + 1);
      }
    }
    putAction(action2, token, end, index6) {
      for (let i2 = 0; i2 < index6; i2 += 3)
        if (this.actions[i2] == action2)
          return index6;
      this.actions[index6++] = action2;
      this.actions[index6++] = token;
      this.actions[index6++] = end;
      return index6;
    }
    addActions(stack, token, end, index6) {
      let { state: state4 } = stack, { parser: parser2 } = stack.p, { data } = parser2;
      for (let set = 0; set < 2; set++) {
        for (let i2 = parser2.stateSlot(
          state4,
          set ? 2 : 1
          /* ParseState.Actions */
        ); ; i2 += 3) {
          if (data[i2] == 65535) {
            if (data[i2 + 1] == 1) {
              i2 = pair(data, i2 + 2);
            } else {
              if (index6 == 0 && data[i2 + 1] == 2)
                index6 = this.putAction(pair(data, i2 + 2), token, end, index6);
              break;
            }
          }
          if (data[i2] == token)
            index6 = this.putAction(pair(data, i2 + 1), token, end, index6);
        }
      }
      return index6;
    }
  };
  var Parse = class {
    constructor(parser2, input, fragments, ranges) {
      this.parser = parser2;
      this.input = input;
      this.ranges = ranges;
      this.recovering = 0;
      this.nextStackID = 9812;
      this.minStackPos = 0;
      this.reused = [];
      this.stoppedAt = null;
      this.lastBigReductionStart = -1;
      this.lastBigReductionSize = 0;
      this.bigReductionCount = 0;
      this.stream = new InputStream(input, ranges);
      this.tokens = new TokenCache(parser2, this.stream);
      this.topTerm = parser2.top[1];
      let { from: from3 } = ranges[0];
      this.stacks = [Stack.start(this, parser2.top[0], from3)];
      this.fragments = fragments.length && this.stream.end - from3 > parser2.bufferLength * 4 ? new FragmentCursor(fragments, parser2.nodeSet) : null;
    }
    get parsedPos() {
      return this.minStackPos;
    }
    // Move the parser forward. This will process all parse stacks at
    // `this.pos` and try to advance them to a further position. If no
    // stack for such a position is found, it'll start error-recovery.
    //
    // When the parse is finished, this will return a syntax tree. When
    // not, it returns `null`.
    advance() {
      let stacks = this.stacks, pos = this.minStackPos;
      let newStacks = this.stacks = [];
      let stopped, stoppedTokens;
      if (this.bigReductionCount > 300 && stacks.length == 1) {
        let [s2] = stacks;
        while (s2.forceReduce() && s2.stack.length && s2.stack[s2.stack.length - 2] >= this.lastBigReductionStart) {
        }
        this.bigReductionCount = this.lastBigReductionSize = 0;
      }
      for (let i2 = 0; i2 < stacks.length; i2++) {
        let stack = stacks[i2];
        for (; ; ) {
          this.tokens.mainToken = null;
          if (stack.pos > pos) {
            newStacks.push(stack);
          } else if (this.advanceStack(stack, newStacks, stacks)) {
            continue;
          } else {
            if (!stopped) {
              stopped = [];
              stoppedTokens = [];
            }
            stopped.push(stack);
            let tok = this.tokens.getMainToken(stack);
            stoppedTokens.push(tok.value, tok.end);
          }
          break;
        }
      }
      if (!newStacks.length) {
        let finished = stopped && findFinished(stopped);
        if (finished) {
          if (verbose)
            console.log("Finish with " + this.stackID(finished));
          return this.stackToTree(finished);
        }
        if (this.parser.strict) {
          if (verbose && stopped)
            console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
          throw new SyntaxError("No parse at " + pos);
        }
        if (!this.recovering)
          this.recovering = 5;
      }
      if (this.recovering && stopped) {
        let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
        if (finished) {
          if (verbose)
            console.log("Force-finish " + this.stackID(finished));
          return this.stackToTree(finished.forceAll());
        }
      }
      if (this.recovering) {
        let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
        if (newStacks.length > maxRemaining) {
          newStacks.sort((a2, b2) => b2.score - a2.score);
          while (newStacks.length > maxRemaining)
            newStacks.pop();
        }
        if (newStacks.some((s2) => s2.reducePos > pos))
          this.recovering--;
      } else if (newStacks.length > 1) {
        outer: for (let i2 = 0; i2 < newStacks.length - 1; i2++) {
          let stack = newStacks[i2];
          for (let j2 = i2 + 1; j2 < newStacks.length; j2++) {
            let other = newStacks[j2];
            if (stack.sameState(other) || stack.buffer.length > 500 && other.buffer.length > 500) {
              if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
                newStacks.splice(j2--, 1);
              } else {
                newStacks.splice(i2--, 1);
                continue outer;
              }
            }
          }
        }
        if (newStacks.length > 12)
          newStacks.splice(
            12,
            newStacks.length - 12
            /* Rec.MaxStackCount */
          );
      }
      this.minStackPos = newStacks[0].pos;
      for (let i2 = 1; i2 < newStacks.length; i2++)
        if (newStacks[i2].pos < this.minStackPos)
          this.minStackPos = newStacks[i2].pos;
      return null;
    }
    stopAt(pos) {
      if (this.stoppedAt != null && this.stoppedAt < pos)
        throw new RangeError("Can't move stoppedAt forward");
      this.stoppedAt = pos;
    }
    // Returns an updated version of the given stack, or null if the
    // stack can't advance normally. When `split` and `stacks` are
    // given, stacks split off by ambiguous operations will be pushed to
    // `split`, or added to `stacks` if they move `pos` forward.
    advanceStack(stack, stacks, split3) {
      let start3 = stack.pos, { parser: parser2 } = this;
      let base2 = verbose ? this.stackID(stack) + " -> " : "";
      if (this.stoppedAt != null && start3 > this.stoppedAt)
        return stack.forceReduce() ? stack : null;
      if (this.fragments) {
        let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
        for (let cached = this.fragments.nodeAt(start3); cached; ) {
          let match2 = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser2.getGoto(stack.state, cached.type.id) : -1;
          if (match2 > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
            stack.useNode(cached, match2);
            if (verbose)
              console.log(base2 + this.stackID(stack) + ` (via reuse of ${parser2.getName(cached.type.id)})`);
            return true;
          }
          if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)
            break;
          let inner = cached.children[0];
          if (inner instanceof Tree && cached.positions[0] == 0)
            cached = inner;
          else
            break;
        }
      }
      let defaultReduce = parser2.stateSlot(
        stack.state,
        4
        /* ParseState.DefaultReduce */
      );
      if (defaultReduce > 0) {
        stack.reduce(defaultReduce);
        if (verbose)
          console.log(base2 + this.stackID(stack) + ` (via always-reduce ${parser2.getName(
            defaultReduce & 65535
            /* Action.ValueMask */
          )})`);
        return true;
      }
      if (stack.stack.length >= 8400) {
        while (stack.stack.length > 6e3 && stack.forceReduce()) {
        }
      }
      let actions = this.tokens.getActions(stack);
      for (let i2 = 0; i2 < actions.length; ) {
        let action2 = actions[i2++], term = actions[i2++], end = actions[i2++];
        let last4 = i2 == actions.length || !split3;
        let localStack = last4 ? stack : stack.split();
        let main4 = this.tokens.mainToken;
        localStack.apply(action2, term, main4 ? main4.start : localStack.pos, end);
        if (verbose)
          console.log(base2 + this.stackID(localStack) + ` (via ${(action2 & 65536) == 0 ? "shift" : `reduce of ${parser2.getName(
            action2 & 65535
            /* Action.ValueMask */
          )}`} for ${parser2.getName(term)} @ ${start3}${localStack == stack ? "" : ", split"})`);
        if (last4)
          return true;
        else if (localStack.pos > start3)
          stacks.push(localStack);
        else
          split3.push(localStack);
      }
      return false;
    }
    // Advance a given stack forward as far as it will go. Returns the
    // (possibly updated) stack if it got stuck, or null if it moved
    // forward and was given to `pushStackDedup`.
    advanceFully(stack, newStacks) {
      let pos = stack.pos;
      for (; ; ) {
        if (!this.advanceStack(stack, null, null))
          return false;
        if (stack.pos > pos) {
          pushStackDedup(stack, newStacks);
          return true;
        }
      }
    }
    runRecovery(stacks, tokens, newStacks) {
      let finished = null, restarted = false;
      for (let i2 = 0; i2 < stacks.length; i2++) {
        let stack = stacks[i2], token = tokens[i2 << 1], tokenEnd = tokens[(i2 << 1) + 1];
        let base2 = verbose ? this.stackID(stack) + " -> " : "";
        if (stack.deadEnd) {
          if (restarted)
            continue;
          restarted = true;
          stack.restart();
          if (verbose)
            console.log(base2 + this.stackID(stack) + " (restarted)");
          let done = this.advanceFully(stack, newStacks);
          if (done)
            continue;
        }
        let force2 = stack.split(), forceBase = base2;
        for (let j2 = 0; force2.forceReduce() && j2 < 10; j2++) {
          if (verbose)
            console.log(forceBase + this.stackID(force2) + " (via force-reduce)");
          let done = this.advanceFully(force2, newStacks);
          if (done)
            break;
          if (verbose)
            forceBase = this.stackID(force2) + " -> ";
        }
        for (let insert10 of stack.recoverByInsert(token)) {
          if (verbose)
            console.log(base2 + this.stackID(insert10) + " (via recover-insert)");
          this.advanceFully(insert10, newStacks);
        }
        if (this.stream.end > stack.pos) {
          if (tokenEnd == stack.pos) {
            tokenEnd++;
            token = 0;
          }
          stack.recoverByDelete(token, tokenEnd);
          if (verbose)
            console.log(base2 + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
          pushStackDedup(stack, newStacks);
        } else if (!finished || finished.score < stack.score) {
          finished = stack;
        }
      }
      return finished;
    }
    // Convert the stack's buffer to a syntax tree.
    stackToTree(stack) {
      stack.close();
      return Tree.build({
        buffer: StackBufferCursor.create(stack),
        nodeSet: this.parser.nodeSet,
        topID: this.topTerm,
        maxBufferLength: this.parser.bufferLength,
        reused: this.reused,
        start: this.ranges[0].from,
        length: stack.pos - this.ranges[0].from,
        minRepeatType: this.parser.minRepeatTerm
      });
    }
    stackID(stack) {
      let id5 = (stackIDs || (stackIDs = /* @__PURE__ */ new WeakMap())).get(stack);
      if (!id5)
        stackIDs.set(stack, id5 = String.fromCodePoint(this.nextStackID++));
      return id5 + stack;
    }
  };
  function pushStackDedup(stack, newStacks) {
    for (let i2 = 0; i2 < newStacks.length; i2++) {
      let other = newStacks[i2];
      if (other.pos == stack.pos && other.sameState(stack)) {
        if (newStacks[i2].score < stack.score)
          newStacks[i2] = stack;
        return;
      }
    }
    newStacks.push(stack);
  }
  var Dialect = class {
    constructor(source3, flags, disabled10) {
      this.source = source3;
      this.flags = flags;
      this.disabled = disabled10;
    }
    allows(term) {
      return !this.disabled || this.disabled[term] == 0;
    }
  };
  var id3 = (x2) => x2;
  var ContextTracker = class {
    /**
    Define a context tracker.
    */
    constructor(spec) {
      this.start = spec.start;
      this.shift = spec.shift || id3;
      this.reduce = spec.reduce || id3;
      this.reuse = spec.reuse || id3;
      this.hash = spec.hash || (() => 0);
      this.strict = spec.strict !== false;
    }
  };
  var LRParser = class _LRParser extends Parser {
    /**
    @internal
    */
    constructor(spec) {
      super();
      this.wrappers = [];
      if (spec.version != 14)
        throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
      let nodeNames = spec.nodeNames.split(" ");
      this.minRepeatTerm = nodeNames.length;
      for (let i2 = 0; i2 < spec.repeatNodeCount; i2++)
        nodeNames.push("");
      let topTerms = Object.keys(spec.topRules).map((r2) => spec.topRules[r2][1]);
      let nodeProps = [];
      for (let i2 = 0; i2 < nodeNames.length; i2++)
        nodeProps.push([]);
      function setProp(nodeID, prop, value12) {
        nodeProps[nodeID].push([prop, prop.deserialize(String(value12))]);
      }
      if (spec.nodeProps)
        for (let propSpec of spec.nodeProps) {
          let prop = propSpec[0];
          if (typeof prop == "string")
            prop = NodeProp[prop];
          for (let i2 = 1; i2 < propSpec.length; ) {
            let next = propSpec[i2++];
            if (next >= 0) {
              setProp(next, prop, propSpec[i2++]);
            } else {
              let value12 = propSpec[i2 + -next];
              for (let j2 = -next; j2 > 0; j2--)
                setProp(propSpec[i2++], prop, value12);
              i2++;
            }
          }
        }
      this.nodeSet = new NodeSet(nodeNames.map((name16, i2) => NodeType.define({
        name: i2 >= this.minRepeatTerm ? void 0 : name16,
        id: i2,
        props: nodeProps[i2],
        top: topTerms.indexOf(i2) > -1,
        error: i2 == 0,
        skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i2) > -1
      })));
      if (spec.propSources)
        this.nodeSet = this.nodeSet.extend(...spec.propSources);
      this.strict = false;
      this.bufferLength = DefaultBufferLength;
      let tokenArray = decodeArray3(spec.tokenData);
      this.context = spec.context;
      this.specializerSpecs = spec.specialized || [];
      this.specialized = new Uint16Array(this.specializerSpecs.length);
      for (let i2 = 0; i2 < this.specializerSpecs.length; i2++)
        this.specialized[i2] = this.specializerSpecs[i2].term;
      this.specializers = this.specializerSpecs.map(getSpecializer);
      this.states = decodeArray3(spec.states, Uint32Array);
      this.data = decodeArray3(spec.stateData);
      this.goto = decodeArray3(spec.goto);
      this.maxTerm = spec.maxTerm;
      this.tokenizers = spec.tokenizers.map((value12) => typeof value12 == "number" ? new TokenGroup(tokenArray, value12) : value12);
      this.topRules = spec.topRules;
      this.dialects = spec.dialects || {};
      this.dynamicPrecedences = spec.dynamicPrecedences || null;
      this.tokenPrecTable = spec.tokenPrec;
      this.termNames = spec.termNames || null;
      this.maxNode = this.nodeSet.types.length - 1;
      this.dialect = this.parseDialect();
      this.top = this.topRules[Object.keys(this.topRules)[0]];
    }
    createParse(input, fragments, ranges) {
      let parse9 = new Parse(this, input, fragments, ranges);
      for (let w2 of this.wrappers)
        parse9 = w2(parse9, input, fragments, ranges);
      return parse9;
    }
    /**
    Get a goto table entry @internal
    */
    getGoto(state4, term, loose = false) {
      let table = this.goto;
      if (term >= table[0])
        return -1;
      for (let pos = table[term + 1]; ; ) {
        let groupTag = table[pos++], last4 = groupTag & 1;
        let target5 = table[pos++];
        if (last4 && loose)
          return target5;
        for (let end = pos + (groupTag >> 1); pos < end; pos++)
          if (table[pos] == state4)
            return target5;
        if (last4)
          return -1;
      }
    }
    /**
    Check if this state has an action for a given terminal @internal
    */
    hasAction(state4, terminal) {
      let data = this.data;
      for (let set = 0; set < 2; set++) {
        for (let i2 = this.stateSlot(
          state4,
          set ? 2 : 1
          /* ParseState.Actions */
        ), next; ; i2 += 3) {
          if ((next = data[i2]) == 65535) {
            if (data[i2 + 1] == 1)
              next = data[i2 = pair(data, i2 + 2)];
            else if (data[i2 + 1] == 2)
              return pair(data, i2 + 2);
            else
              break;
          }
          if (next == terminal || next == 0)
            return pair(data, i2 + 1);
        }
      }
      return 0;
    }
    /**
    @internal
    */
    stateSlot(state4, slot) {
      return this.states[state4 * 6 + slot];
    }
    /**
    @internal
    */
    stateFlag(state4, flag) {
      return (this.stateSlot(
        state4,
        0
        /* ParseState.Flags */
      ) & flag) > 0;
    }
    /**
    @internal
    */
    validAction(state4, action2) {
      return !!this.allActions(state4, (a2) => a2 == action2 ? true : null);
    }
    /**
    @internal
    */
    allActions(state4, action2) {
      let deflt = this.stateSlot(
        state4,
        4
        /* ParseState.DefaultReduce */
      );
      let result = deflt ? action2(deflt) : void 0;
      for (let i2 = this.stateSlot(
        state4,
        1
        /* ParseState.Actions */
      ); result == null; i2 += 3) {
        if (this.data[i2] == 65535) {
          if (this.data[i2 + 1] == 1)
            i2 = pair(this.data, i2 + 2);
          else
            break;
        }
        result = action2(pair(this.data, i2 + 1));
      }
      return result;
    }
    /**
    Get the states that can follow this one through shift actions or
    goto jumps. @internal
    */
    nextStates(state4) {
      let result = [];
      for (let i2 = this.stateSlot(
        state4,
        1
        /* ParseState.Actions */
      ); ; i2 += 3) {
        if (this.data[i2] == 65535) {
          if (this.data[i2 + 1] == 1)
            i2 = pair(this.data, i2 + 2);
          else
            break;
        }
        if ((this.data[i2 + 2] & 65536 >> 16) == 0) {
          let value12 = this.data[i2 + 1];
          if (!result.some((v2, i3) => i3 & 1 && v2 == value12))
            result.push(this.data[i2], value12);
        }
      }
      return result;
    }
    /**
    Configure the parser. Returns a new parser instance that has the
    given settings modified. Settings not provided in `config` are
    kept from the original parser.
    */
    configure(config2) {
      let copy = Object.assign(Object.create(_LRParser.prototype), this);
      if (config2.props)
        copy.nodeSet = this.nodeSet.extend(...config2.props);
      if (config2.top) {
        let info2 = this.topRules[config2.top];
        if (!info2)
          throw new RangeError(`Invalid top rule name ${config2.top}`);
        copy.top = info2;
      }
      if (config2.tokenizers)
        copy.tokenizers = this.tokenizers.map((t3) => {
          let found = config2.tokenizers.find((r2) => r2.from == t3);
          return found ? found.to : t3;
        });
      if (config2.specializers) {
        copy.specializers = this.specializers.slice();
        copy.specializerSpecs = this.specializerSpecs.map((s2, i2) => {
          let found = config2.specializers.find((r2) => r2.from == s2.external);
          if (!found)
            return s2;
          let spec = Object.assign(Object.assign({}, s2), { external: found.to });
          copy.specializers[i2] = getSpecializer(spec);
          return spec;
        });
      }
      if (config2.contextTracker)
        copy.context = config2.contextTracker;
      if (config2.dialect)
        copy.dialect = this.parseDialect(config2.dialect);
      if (config2.strict != null)
        copy.strict = config2.strict;
      if (config2.wrap)
        copy.wrappers = copy.wrappers.concat(config2.wrap);
      if (config2.bufferLength != null)
        copy.bufferLength = config2.bufferLength;
      return copy;
    }
    /**
    Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
    are registered for this parser.
    */
    hasWrappers() {
      return this.wrappers.length > 0;
    }
    /**
    Returns the name associated with a given term. This will only
    work for all terms when the parser was generated with the
    `--names` option. By default, only the names of tagged terms are
    stored.
    */
    getName(term) {
      return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
    }
    /**
    The eof term id is always allocated directly after the node
    types. @internal
    */
    get eofTerm() {
      return this.maxNode + 1;
    }
    /**
    The type of top node produced by the parser.
    */
    get topNode() {
      return this.nodeSet.types[this.top[1]];
    }
    /**
    @internal
    */
    dynamicPrecedence(term) {
      let prec2 = this.dynamicPrecedences;
      return prec2 == null ? 0 : prec2[term] || 0;
    }
    /**
    @internal
    */
    parseDialect(dialect) {
      let values = Object.keys(this.dialects), flags = values.map(() => false);
      if (dialect)
        for (let part of dialect.split(" ")) {
          let id5 = values.indexOf(part);
          if (id5 >= 0)
            flags[id5] = true;
        }
      let disabled10 = null;
      for (let i2 = 0; i2 < values.length; i2++)
        if (!flags[i2]) {
          for (let j2 = this.dialects[values[i2]], id5; (id5 = this.data[j2++]) != 65535; )
            (disabled10 || (disabled10 = new Uint8Array(this.maxTerm + 1)))[id5] = 1;
        }
      return new Dialect(dialect, flags, disabled10);
    }
    /**
    Used by the output of the parser generator. Not available to
    user code. @hide
    */
    static deserialize(spec) {
      return new _LRParser(spec);
    }
  };
  function pair(data, off) {
    return data[off] | data[off + 1] << 16;
  }
  function findFinished(stacks) {
    let best = null;
    for (let stack of stacks) {
      let stopped = stack.p.stoppedAt;
      if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(
        stack.state,
        2
        /* StateFlag.Accepting */
      ) && (!best || best.score < stack.score))
        best = stack;
    }
    return best;
  }
  function getSpecializer(spec) {
    if (spec.external) {
      let mask = spec.extend ? 1 : 0;
      return (value12, stack) => spec.external(value12, stack) << 1 | mask;
    }
    return spec.get;
  }

  // node_modules/@lezer/javascript/dist/index.js
  var noSemi = 312;
  var noSemiType = 313;
  var incdec = 1;
  var incdecPrefix = 2;
  var questionDot = 3;
  var JSXStartTag = 4;
  var insertSemi = 314;
  var spaces = 316;
  var newline = 317;
  var LineComment = 5;
  var BlockComment = 6;
  var Dialect_jsx = 0;
  var space = [
    9,
    10,
    11,
    12,
    13,
    32,
    133,
    160,
    5760,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8199,
    8200,
    8201,
    8202,
    8232,
    8233,
    8239,
    8287,
    12288
  ];
  var braceR = 125;
  var semicolon = 59;
  var slash = 47;
  var star = 42;
  var plus = 43;
  var minus = 45;
  var lt = 60;
  var comma = 44;
  var question = 63;
  var dot = 46;
  var bracketL = 91;
  var trackNewline = new ContextTracker({
    start: false,
    shift(context3, term) {
      return term == LineComment || term == BlockComment || term == spaces ? context3 : term == newline;
    },
    strict: false
  });
  var insertSemicolon = new ExternalTokenizer((input, stack) => {
    let { next } = input;
    if (next == braceR || next == -1 || stack.context)
      input.acceptToken(insertSemi);
  }, { contextual: true, fallback: true });
  var noSemicolon = new ExternalTokenizer((input, stack) => {
    let { next } = input, after;
    if (space.indexOf(next) > -1) return;
    if (next == slash && ((after = input.peek(1)) == slash || after == star)) return;
    if (next != braceR && next != semicolon && next != -1 && !stack.context)
      input.acceptToken(noSemi);
  }, { contextual: true });
  var noSemicolonType = new ExternalTokenizer((input, stack) => {
    if (input.next == bracketL && !stack.context) input.acceptToken(noSemiType);
  }, { contextual: true });
  var operatorToken = new ExternalTokenizer((input, stack) => {
    let { next } = input;
    if (next == plus || next == minus) {
      input.advance();
      if (next == input.next) {
        input.advance();
        let mayPostfix = !stack.context && stack.canShift(incdec);
        input.acceptToken(mayPostfix ? incdec : incdecPrefix);
      }
    } else if (next == question && input.peek(1) == dot) {
      input.advance();
      input.advance();
      if (input.next < 48 || input.next > 57)
        input.acceptToken(questionDot);
    }
  }, { contextual: true });
  function identifierChar(ch, start3) {
    return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch == 95 || ch >= 192 || !start3 && ch >= 48 && ch <= 57;
  }
  var jsx = new ExternalTokenizer((input, stack) => {
    if (input.next != lt || !stack.dialectEnabled(Dialect_jsx)) return;
    input.advance();
    if (input.next == slash) return;
    let back2 = 0;
    while (space.indexOf(input.next) > -1) {
      input.advance();
      back2++;
    }
    if (identifierChar(input.next, true)) {
      input.advance();
      back2++;
      while (identifierChar(input.next, false)) {
        input.advance();
        back2++;
      }
      while (space.indexOf(input.next) > -1) {
        input.advance();
        back2++;
      }
      if (input.next == comma) return;
      for (let i2 = 0; ; i2++) {
        if (i2 == 7) {
          if (!identifierChar(input.next, true)) return;
          break;
        }
        if (input.next != "extends".charCodeAt(i2)) break;
        input.advance();
        back2++;
      }
    }
    input.acceptToken(JSXStartTag, -back2);
  });
  var jsHighlight = styleTags({
    "get set async static": tags.modifier,
    "for while do if else switch try catch finally return throw break continue default case": tags.controlKeyword,
    "in of await yield void typeof delete instanceof": tags.operatorKeyword,
    "let var const using function class extends": tags.definitionKeyword,
    "import export from": tags.moduleKeyword,
    "with debugger as new": tags.keyword,
    TemplateString: tags.special(tags.string),
    super: tags.atom,
    BooleanLiteral: tags.bool,
    this: tags.self,
    null: tags.null,
    Star: tags.modifier,
    VariableName: tags.variableName,
    "CallExpression/VariableName TaggedTemplateExpression/VariableName": tags.function(tags.variableName),
    VariableDefinition: tags.definition(tags.variableName),
    Label: tags.labelName,
    PropertyName: tags.propertyName,
    PrivatePropertyName: tags.special(tags.propertyName),
    "CallExpression/MemberExpression/PropertyName": tags.function(tags.propertyName),
    "FunctionDeclaration/VariableDefinition": tags.function(tags.definition(tags.variableName)),
    "ClassDeclaration/VariableDefinition": tags.definition(tags.className),
    PropertyDefinition: tags.definition(tags.propertyName),
    PrivatePropertyDefinition: tags.definition(tags.special(tags.propertyName)),
    UpdateOp: tags.updateOperator,
    "LineComment Hashbang": tags.lineComment,
    BlockComment: tags.blockComment,
    Number: tags.number,
    String: tags.string,
    Escape: tags.escape,
    ArithOp: tags.arithmeticOperator,
    LogicOp: tags.logicOperator,
    BitOp: tags.bitwiseOperator,
    CompareOp: tags.compareOperator,
    RegExp: tags.regexp,
    Equals: tags.definitionOperator,
    Arrow: tags.function(tags.punctuation),
    ": Spread": tags.punctuation,
    "( )": tags.paren,
    "[ ]": tags.squareBracket,
    "{ }": tags.brace,
    "InterpolationStart InterpolationEnd": tags.special(tags.brace),
    ".": tags.derefOperator,
    ", ;": tags.separator,
    "@": tags.meta,
    TypeName: tags.typeName,
    TypeDefinition: tags.definition(tags.typeName),
    "type enum interface implements namespace module declare": tags.definitionKeyword,
    "abstract global Privacy readonly override": tags.modifier,
    "is keyof unique infer": tags.operatorKeyword,
    JSXAttributeValue: tags.attributeValue,
    JSXText: tags.content,
    "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": tags.angleBracket,
    "JSXIdentifier JSXNameSpacedName": tags.tagName,
    "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": tags.attributeName,
    "JSXBuiltin/JSXIdentifier": tags.standard(tags.tagName)
  });
  var spec_identifier = { __proto__: null, export: 20, as: 25, from: 33, default: 36, async: 41, function: 42, extends: 54, this: 58, true: 66, false: 66, null: 78, void: 82, typeof: 86, super: 102, new: 136, delete: 148, yield: 157, await: 161, class: 166, public: 229, private: 229, protected: 229, readonly: 231, instanceof: 250, satisfies: 253, in: 254, const: 256, import: 290, keyof: 345, unique: 349, infer: 355, is: 391, abstract: 411, implements: 413, type: 415, let: 418, var: 420, using: 423, interface: 429, enum: 433, namespace: 439, module: 441, declare: 445, global: 449, for: 468, of: 477, while: 480, with: 484, do: 488, if: 492, else: 494, switch: 498, case: 504, try: 510, catch: 514, finally: 518, return: 522, throw: 526, break: 530, continue: 534, debugger: 538 };
  var spec_word = { __proto__: null, async: 123, get: 125, set: 127, declare: 189, public: 191, private: 191, protected: 191, static: 193, abstract: 195, override: 197, readonly: 203, accessor: 205, new: 395 };
  var spec_LessThan = { __proto__: null, "<": 187 };
  var parser = LRParser.deserialize({
    version: 14,
    states: "$CdQ%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#D^O.QQlO'#DdO.bQlO'#DoO%[QlO'#DwO0fQlO'#EPOOQ!0Lf'#EX'#EXO1PQ`O'#EUOOQO'#Em'#EmOOQO'#Ih'#IhO1XQ`O'#GpO1dQ`O'#ElO1iQ`O'#ElO3hQ!0MxO'#JnO6[Q!0MxO'#JoO6uQ`O'#F[O6zQ,UO'#FsOOQ!0Lf'#Fe'#FeO7VO7dO'#FeO7eQMhO'#FzO9RQ`O'#FyOOQ!0Lf'#Jo'#JoOOQ!0Lb'#Jn'#JnO9WQ`O'#GtOOQ['#K['#K[O9cQ`O'#IUO9hQ!0LrO'#IVOOQ['#J['#J[OOQ['#IZ'#IZQ`QlOOQ`QlOOO9pQ!L^O'#DsO9wQlO'#D{O:OQlO'#D}O9^Q`O'#GpO:VQMhO'#CoO:eQ`O'#EkO:pQ`O'#EvO:uQMhO'#FdO;dQ`O'#GpOOQO'#K]'#K]O;iQ`O'#K]O;wQ`O'#GxO;wQ`O'#GyO;wQ`O'#G{O9^Q`O'#HOO<nQ`O'#HRO>VQ`O'#CeO>gQ`O'#H_O>oQ`O'#HeO>oQ`O'#HgO`QlO'#HiO>oQ`O'#HkO>oQ`O'#HnO>tQ`O'#HtO>yQ!0LsO'#HzO%[QlO'#H|O?UQ!0LsO'#IOO?aQ!0LsO'#IQO9hQ!0LrO'#ISO?lQ!0MxO'#CiO@nQpO'#DiQOQ`OOO%[QlO'#D}OAUQ`O'#EQO:VQMhO'#EkOAaQ`O'#EkOAlQ!bO'#FdOOQ['#Cg'#CgOOQ!0Lb'#Dn'#DnOOQ!0Lb'#Jr'#JrO%[QlO'#JrOOQO'#Ju'#JuOOQO'#Id'#IdOBlQpO'#EdOOQ!0Lb'#Ec'#EcOOQ!0Lb'#Jy'#JyOChQ!0MSO'#EdOCrQpO'#ETOOQO'#Jt'#JtODWQpO'#JuOEeQpO'#ETOCrQpO'#EdPErO&2DjO'#CbPOOO)CDy)CDyOOOO'#I['#I[OE}O#tO,59UOOQ!0Lh,59U,59UOOOO'#I]'#I]OF]O&jO,59UOFkQ!L^O'#D`OOOO'#I_'#I_OFrO#@ItO,59xOOQ!0Lf,59x,59xOGQQlO'#I`OGeQ`O'#JpOIdQ!fO'#JpO+}QlO'#JpOIkQ`O,5:OOJRQ`O'#EmOJ`Q`O'#KPOJkQ`O'#KOOJkQ`O'#KOOJsQ`O,5;ZOJxQ`O'#J}OOQ!0Ln,5:Z,5:ZOKPQlO,5:ZOL}Q!0MxO,5:cOMnQ`O,5:kONXQ!0LrO'#J|ON`Q`O'#J{O9WQ`O'#J{ONtQ`O'#J{ON|Q`O,5;YO! RQ`O'#J{O!#WQ!fO'#JoOOQ!0Lh'#Ci'#CiO%[QlO'#EPO!#vQ!fO,5:pOOQS'#Jv'#JvOOQO-E<f-E<fO9^Q`O,5=[O!$^Q`O,5=[O!$cQlO,5;WO!&fQMhO'#EhO!(PQ`O,5;WO!(UQlO'#DvO!(`QpO,5;aO!(hQpO,5;aO%[QlO,5;aOOQ['#FS'#FSOOQ['#FU'#FUO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bO%[QlO,5;bOOQ['#FY'#FYO!(vQlO,5;sOOQ!0Lf,5;x,5;xOOQ!0Lf,5;y,5;yOOQ!0Lf,5;{,5;{O%[QlO'#IlO!*yQ!0LrO,5<gO%[QlO,5;bO!&fQMhO,5;bO!+hQMhO,5;bO!-YQMhO'#EZO%[QlO,5;vOOQ!0Lf,5;z,5;zO!-aQ,UO'#FiO!.^Q,UO'#KTO!-xQ,UO'#KTO!.eQ,UO'#KTOOQO'#KT'#KTO!.yQ,UO,5<ROOOW,5<_,5<_O!/[QlO'#FuOOOW'#Ik'#IkO7VO7dO,5<PO!/cQ,UO'#FwOOQ!0Lf,5<P,5<PO!0SQ$IUO'#CvOOQ!0Lh'#Cz'#CzO!0gO#@ItO'#DOO!1TQMjO,5<dO!1[Q`O,5<fO!2wQ(CWO'#GVO!3UQ`O'#GWO!3ZQ`O'#GWO!4yQ(CWO'#G[O!6OQpO'#G`OOQO'#Gk'#GkO!+oQMhO'#GjOOQO'#Gm'#GmO!+oQMhO'#GlO!6qQ$IUO'#JhOOQ!0Lh'#Jh'#JhO!6{Q`O'#JgO!7ZQ`O'#JfO!7cQ`O'#CuOOQ!0Lh'#Cx'#CxO!7kQ`O'#CzOOQ!0Lh'#DS'#DSOOQ!0Lh'#DU'#DUO1SQ`O'#DWO!+oQMhO'#F}O!+oQMhO'#GPO!7pQ`O'#GRO!7uQ`O'#GSO!3ZQ`O'#GYO!+oQMhO'#G_O!7zQ`O'#EnO!8iQ`O,5<eOOQ!0Lb'#Cr'#CrO!8qQ`O'#EoO!9kQpO'#EpOOQ!0Lb'#J}'#J}O!9rQ!0LrO'#K^O9hQ!0LrO,5=`O`QlO,5>pOOQ['#Jd'#JdOOQ[,5>q,5>qOOQ[-E<X-E<XO!;qQ!0MxO,5:_O!9fQpO,5:]O!>[Q!0MxO,5:gO%[QlO,5:gO!@rQ!0MxO,5:iOOQO,5@w,5@wO!AcQMhO,5=[O!AqQ!0LrO'#JeO9RQ`O'#JeO!BSQ!0LrO,59ZO!B_QpO,59ZO!BgQMhO,59ZO:VQMhO,59ZO!BrQ`O,5;WO!BzQ`O'#H^O!C`Q`O'#KaO%[QlO,5;|O!9fQpO,5<OO!ChQ`O,5=wO!CmQ`O,5=wO!CrQ`O,5=wO9hQ!0LrO,5=wO;wQ`O,5=gOOQO'#Cv'#CvO!DQQpO,5=dO!DYQMhO,5=eO!DeQ`O,5=gO!DjQ!bO,5=jO!DrQ`O'#K]O>tQ`O'#HTO9^Q`O'#HVO!DwQ`O'#HVO:VQMhO'#HXO!D|Q`O'#HXOOQ[,5=m,5=mO!ERQ`O'#HYO!EdQ`O'#CoO!EiQ`O,59PO!EsQ`O,59PO!GxQlO,59POOQ[,59P,59PO!HYQ!0LrO,59PO%[QlO,59PO!JeQlO'#HaOOQ['#Hb'#HbOOQ['#Hc'#HcO`QlO,5=yO!J{Q`O,5=yO`QlO,5>PO`QlO,5>RO!KQQ`O,5>TO`QlO,5>VO!KVQ`O,5>YO!K[QlO,5>`OOQ[,5>f,5>fO%[QlO,5>fO9hQ!0LrO,5>hOOQ[,5>j,5>jO# fQ`O,5>jOOQ[,5>l,5>lO# fQ`O,5>lOOQ[,5>n,5>nO#!SQpO'#D[O%[QlO'#JrO#!uQpO'#JrO##PQpO'#DjO##bQpO'#DjO#%sQlO'#DjO#%zQ`O'#JqO#&SQ`O,5:TO#&XQ`O'#EqO#&gQ`O'#KQO#&oQ`O,5;[O#&tQpO'#DjO#'RQpO'#ESOOQ!0Lf,5:l,5:lO%[QlO,5:lO#'YQ`O,5:lO>tQ`O,5;VO!B_QpO,5;VO!BgQMhO,5;VO:VQMhO,5;VO#'bQ`O,5@^O#'gQ07dO,5:pOOQO-E<b-E<bO#(mQ!0MSO,5;OOCrQpO,5:oO#(wQpO,5:oOCrQpO,5;OO!BSQ!0LrO,5:oOOQ!0Lb'#Eg'#EgOOQO,5;O,5;OO%[QlO,5;OO#)UQ!0LrO,5;OO#)aQ!0LrO,5;OO!B_QpO,5:oOOQO,5;U,5;UO#)oQ!0LrO,5;OPOOO'#IY'#IYP#*TO&2DjO,58|POOO,58|,58|OOOO-E<Y-E<YOOQ!0Lh1G.p1G.pOOOO-E<Z-E<ZOOOO,59z,59zO#*`Q!bO,59zOOOO-E<]-E<]OOQ!0Lf1G/d1G/dO#*eQ!fO,5>zO+}QlO,5>zOOQO,5?Q,5?QO#*oQlO'#I`OOQO-E<^-E<^O#*|Q`O,5@[O#+UQ!fO,5@[O#+]Q`O,5@jOOQ!0Lf1G/j1G/jO%[QlO,5@kO#+eQ`O'#IfOOQO-E<d-E<dO#+]Q`O,5@jOOQ!0Lb1G0u1G0uOOQ!0Ln1G/u1G/uOOQ!0Ln1G0V1G0VO%[QlO,5@hO#+yQ!0LrO,5@hO#,[Q!0LrO,5@hO#,cQ`O,5@gO9WQ`O,5@gO#,kQ`O,5@gO#,yQ`O'#IiO#,cQ`O,5@gOOQ!0Lb1G0t1G0tO!(`QpO,5:rO!(kQpO,5:rOOQS,5:t,5:tO#-kQdO,5:tO#-sQMhO1G2vO9^Q`O1G2vOOQ!0Lf1G0r1G0rO#.RQ!0MxO1G0rO#/WQ!0MvO,5;SOOQ!0Lh'#GU'#GUO#/tQ!0MzO'#JhO!$cQlO1G0rO#2PQ!fO'#JsO%[QlO'#JsO#2ZQ`O,5:bOOQ!0Lh'#D['#D[OOQ!0Lf1G0{1G0{O%[QlO1G0{OOQ!0Lf1G1e1G1eO#2`Q`O1G0{O#4tQ!0MxO1G0|O#4{Q!0MxO1G0|O#7cQ!0MxO1G0|O#7jQ!0MxO1G0|O#:QQ!0MxO1G0|O#<hQ!0MxO1G0|O#<oQ!0MxO1G0|O#<vQ!0MxO1G0|O#?^Q!0MxO1G0|O#?eQ!0MxO1G0|O#ArQ?MtO'#CiO#CmQ?MtO1G1_O#CtQ?MtO'#JoO#DXQ!0MxO,5?WOOQ!0Lb-E<j-E<jO#FfQ!0MxO1G0|O#GcQ!0MzO1G0|OOQ!0Lf1G0|1G0|O#HfQMjO'#JxO#HpQ`O,5:uO#HuQ!0MxO1G1bO#IiQ,UO,5<VO#IqQ,UO,5<WO#IyQ,UO'#FnO#JbQ`O'#FmOOQO'#KU'#KUOOQO'#Ij'#IjO#JgQ,UO1G1mOOQ!0Lf1G1m1G1mOOOW1G1x1G1xO#JxQ?MtO'#JnO#KSQ`O,5<aO!(vQlO,5<aOOOW-E<i-E<iOOQ!0Lf1G1k1G1kO#KXQpO'#KTOOQ!0Lf,5<c,5<cO#KaQpO,5<cO#KfQMhO'#DQOOOO'#I^'#I^O#KmO#@ItO,59jOOQ!0Lh,59j,59jO%[QlO1G2OO!7uQ`O'#InO#KxQ`O,5<xOOQ!0Lh,5<u,5<uO!+oQMhO'#IqO#LfQMjO,5=UO!+oQMhO'#IsO#MXQMjO,5=WO!&fQMhO,5=YOOQO1G2Q1G2QO#McQ!dO'#CrO#MvQ(CWO'#EoO#N{QpO'#G`O$ cQ!dO,5<qO$ jQ`O'#KXO9WQ`O'#KXO$ xQ`O,5<sO!+oQMhO,5<rO$ }Q`O'#GXO$!`Q`O,5<rO$!eQ!dO'#GUO$!rQ!dO'#KYO$!|Q`O'#KYO!&fQMhO'#KYO$#RQ`O,5<vO$#WQlO'#JrO$#bQpO'#GaO##bQpO'#GaO$#sQ`O'#GeO!3ZQ`O'#GhO$#xQ!0LrO'#IpO$$TQpO,5<zOOQ!0Lp,5<z,5<zO$$[QpO'#GaO$$iQpO'#GbO$$zQpO'#GbO$%PQMjO,5=UO$%aQMjO,5=WOOQ!0Lh,5=Z,5=ZO!+oQMhO,5@RO!+oQMhO,5@RO$%qQ`O'#IuO$%|Q`O,5@QO$&UQ`O,59aOOQ!0Lh,59f,59fO$&{Q$IYO,59rOOQ!0Lh'#Jl'#JlO$'nQMjO,5<iO$(aQMjO,5<kO@fQ`O,5<mOOQ!0Lh,5<n,5<nO$(kQ`O,5<tO$(pQMjO,5<yO$)QQ`O'#J{O!$cQlO1G2PO$)VQ`O1G2PO9WQ`O'#KOO9WQ`O'#EqO%[QlO'#EqO9WQ`O'#IwO$)[Q!0LrO,5@xOOQ[1G2z1G2zOOQ[1G4[1G4[OOQ!0Lf1G/y1G/yOOQ!0Lf1G/w1G/wO$+^Q!0MxO1G0ROOQ[1G2v1G2vO!&fQMhO1G2vO%[QlO1G2vO#-vQ`O1G2vO$-bQMhO'#EhOOQ!0Lb,5@P,5@PO$-lQ!0LrO,5@POOQ[1G.u1G.uO!BSQ!0LrO1G.uO!B_QpO1G.uO!BgQMhO1G.uO$-}Q`O1G0rO$.SQ`O'#CiO$._Q`O'#KbO$.gQ`O,5=xO$.lQ`O'#KbO$.qQ`O'#KbO$/PQ`O'#I}O$/_Q`O,5@{O$/gQ!fO1G1hOOQ!0Lf1G1j1G1jO9^Q`O1G3cO@fQ`O1G3cO$/nQ`O1G3cO$/sQ`O1G3cOOQ[1G3c1G3cO!DeQ`O1G3RO!&fQMhO1G3OO$/xQ`O1G3OOOQ[1G3P1G3PO!&fQMhO1G3PO$/}Q`O1G3PO$0VQpO'#G}OOQ[1G3R1G3RO!5yQpO'#IyO!DjQ!bO1G3UOOQ[1G3U1G3UOOQ[,5=o,5=oO$0_QMhO,5=qO9^Q`O,5=qO$#sQ`O,5=sO9RQ`O,5=sO!B_QpO,5=sO!BgQMhO,5=sO:VQMhO,5=sO$0mQ`O'#K`O$0xQ`O,5=tOOQ[1G.k1G.kO$0}Q!0LrO1G.kO@fQ`O1G.kO$1YQ`O1G.kO9hQ!0LrO1G.kO$3bQ!fO,5@}O$3oQ`O,5@}O9WQ`O,5@}O$3zQlO,5={O$4RQ`O,5={OOQ[1G3e1G3eO`QlO1G3eOOQ[1G3k1G3kOOQ[1G3m1G3mO>oQ`O1G3oO$4WQlO1G3qO$8[QlO'#HpOOQ[1G3t1G3tO$8iQ`O'#HvO>tQ`O'#HxOOQ[1G3z1G3zO$8qQlO1G3zO9hQ!0LrO1G4QOOQ[1G4S1G4SOOQ!0Lb'#G]'#G]O9hQ!0LrO1G4UO9hQ!0LrO1G4WO$<xQ`O,5@^O!(vQlO,5;]O9WQ`O,5;]O>tQ`O,5:UO!(vQlO,5:UO!B_QpO,5:UO$<}Q?MtO,5:UOOQO,5;],5;]O$=XQpO'#IaO$=oQ`O,5@]OOQ!0Lf1G/o1G/oO$=wQpO'#IgO$>RQ`O,5@lOOQ!0Lb1G0v1G0vO##bQpO,5:UOOQO'#Ic'#IcO$>ZQpO,5:nOOQ!0Ln,5:n,5:nO#']Q`O1G0WOOQ!0Lf1G0W1G0WO%[QlO1G0WOOQ!0Lf1G0q1G0qO>tQ`O1G0qO!B_QpO1G0qO!BgQMhO1G0qOOQ!0Lb1G5x1G5xO!BSQ!0LrO1G0ZOOQO1G0j1G0jO%[QlO1G0jO$>bQ!0LrO1G0jO$>mQ!0LrO1G0jO!B_QpO1G0ZOCrQpO1G0ZO$>{Q!0LrO1G0jOOQO1G0Z1G0ZO$?aQ!0MxO1G0jPOOO-E<W-E<WPOOO1G.h1G.hOOOO1G/f1G/fO$?kQ!bO,5<gO$?sQ!fO1G4fOOQO1G4l1G4lO%[QlO,5>zO$?}Q`O1G5vO$@VQ`O1G6UO$@_Q!fO1G6VO9WQ`O,5?QO$@iQ!0MxO1G6SO%[QlO1G6SO$@yQ!0LrO1G6SO$A[Q`O1G6RO$A[Q`O1G6RO9WQ`O1G6RO$AdQ`O,5?TO9WQ`O,5?TOOQO,5?T,5?TO$AxQ`O,5?TO$)QQ`O,5?TOOQO-E<g-E<gOOQS1G0^1G0^OOQS1G0`1G0`O#-nQ`O1G0`OOQ[7+(b7+(bO!&fQMhO7+(bO%[QlO7+(bO$BWQ`O7+(bO$BcQMhO7+(bO$BqQ!0MzO,5=UO$D|Q!0MzO,5=WO$GXQ!0MzO,5=UO$IjQ!0MzO,5=WO$K{Q!0MzO,59rO$NQQ!0MzO,5<iO%!]Q!0MzO,5<kO%$hQ!0MzO,5<yOOQ!0Lf7+&^7+&^O%&yQ!0MxO7+&^O%'mQlO'#IbO%'zQ`O,5@_O%(SQ!fO,5@_OOQ!0Lf1G/|1G/|O%(^Q`O7+&gOOQ!0Lf7+&g7+&gO%(cQ?MtO,5:cO%[QlO7+&yO%(mQ?MtO,5:_O%(zQ?MtO,5:gO%)UQ?MtO,5:iO%)`QMhO'#IeO%)jQ`O,5@dOOQ!0Lh1G0a1G0aOOQO1G1q1G1qOOQO1G1r1G1rO%)rQ!jO,5<YO!(vQlO,5<XOOQO-E<h-E<hOOQ!0Lf7+'X7+'XOOOW7+'d7+'dOOOW1G1{1G1{O%)}Q`O1G1{OOQ!0Lf1G1}1G1}OOOO,59l,59lO%*SQ!dO,59lOOOO-E<[-E<[OOQ!0Lh1G/U1G/UO%*ZQ!0MxO7+'jOOQ!0Lh,5?Y,5?YO%*}QMhO1G2dP%+UQ`O'#InPOQ!0Lh-E<l-E<lO%+rQMjO,5?]OOQ!0Lh-E<o-E<oO%,eQMjO,5?_OOQ!0Lh-E<q-E<qO%,oQ!dO1G2tO%,vQ!dO'#CrO%-^QMhO'#KOO$#WQlO'#JrOOQ!0Lh1G2]1G2]O%-eQ`O'#ImO%-yQ`O,5@sO%-yQ`O,5@sO%.RQ`O,5@sO%.^Q`O,5@sOOQO1G2_1G2_O%.lQMjO1G2^O!+oQMhO1G2^O%.|Q(CWO'#IoO%/ZQ`O,5@tO!&fQMhO,5@tO%/cQ!dO,5@tOOQ!0Lh1G2b1G2bO%1sQ!fO'#CiO%1}Q`O,5<}OOQ!0Lb,5<{,5<{O%2VQpO,5<{OOQ!0Lb,5<|,5<|OCcQ`O,5<{O%2bQpO,5<{OOQ!0Lb,5=P,5=PO$)QQ`O,5=SOOQO,5?[,5?[OOQO-E<n-E<nOOQ!0Lp1G2f1G2fO##bQpO,5<{O$#WQlO,5<}O%2pQ`O,5<|O%2{QpO,5<|O!+oQMhO'#IqO%3uQMjO1G2pO!+oQMhO'#IsO%4hQMjO1G2rO%4rQMjO1G5mO%4|QMjO1G5mOOQO,5?a,5?aOOQO-E<s-E<sOOQO1G.{1G.{O!9fQpO,59tO%[QlO,59tOOQ!0Lh,5<h,5<hO%5ZQ`O1G2XO!+oQMhO1G2`O%5`Q!0MxO7+'kOOQ!0Lf7+'k7+'kO!$cQlO7+'kO%6SQ`O,5;]OOQ!0Lb,5?c,5?cOOQ!0Lb-E<u-E<uO%6XQ!dO'#KZO#']Q`O7+(bO4UQ!fO7+(bO$BZQ`O7+(bO%6cQ!0MvO'#CiO%6vQ!0MvO,5=QO%7hQ`O,5=QOOQ!0Lb1G5k1G5kOOQ[7+$a7+$aO!BSQ!0LrO7+$aO!B_QpO7+$aO!$cQlO7+&^O%7mQ`O'#I|O%8UQ`O,5@|OOQO1G3d1G3dO9^Q`O,5@|O%8UQ`O,5@|O%8^Q`O,5@|OOQO,5?i,5?iOOQO-E<{-E<{OOQ!0Lf7+'S7+'SO%8cQ`O7+(}O9hQ!0LrO7+(}O9^Q`O7+(}O@fQ`O7+(}OOQ[7+(m7+(mO%8hQ!0MvO7+(jO!&fQMhO7+(jO!D`Q`O7+(kOOQ[7+(k7+(kO!&fQMhO7+(kO%8rQ`O'#K_O%8}Q`O,5=iOOQO,5?e,5?eOOQO-E<w-E<wOOQ[7+(p7+(pO%:aQpO'#HWOOQ[1G3]1G3]O!&fQMhO1G3]O%[QlO1G3]O%:hQ`O1G3]O%:sQMhO1G3]O9hQ!0LrO1G3_O$#sQ`O1G3_O9RQ`O1G3_O!B_QpO1G3_O!BgQMhO1G3_O%;RQ`O'#I{O%;gQ`O,5@zO%;oQpO,5@zOOQ!0Lb1G3`1G3`OOQ[7+$V7+$VO@fQ`O7+$VO9hQ!0LrO7+$VO%;zQ`O7+$VO%[QlO1G6iO%[QlO1G6jO%<PQ!0LrO1G6iO%<ZQlO1G3gO%<bQ`O1G3gO%<gQlO1G3gOOQ[7+)P7+)PO9hQ!0LrO7+)ZO`QlO7+)]OOQ['#Ke'#KeOOQ['#JO'#JOO%<nQlO,5>[OOQ[,5>[,5>[O%[QlO'#HqO%<{Q`O'#HsOOQ[,5>b,5>bO9WQ`O,5>bOOQ[,5>d,5>dOOQ[7+)f7+)fOOQ[7+)l7+)lOOQ[7+)p7+)pOOQ[7+)r7+)rO%=QQpO1G5xO%=lQ?MtO1G0wO%=vQ`O1G0wOOQO1G/p1G/pO%>RQ?MtO1G/pO>tQ`O1G/pO!(vQlO'#DjOOQO,5>{,5>{OOQO-E<_-E<_OOQO,5?R,5?ROOQO-E<e-E<eO!B_QpO1G/pOOQO-E<a-E<aOOQ!0Ln1G0Y1G0YOOQ!0Lf7+%r7+%rO#']Q`O7+%rOOQ!0Lf7+&]7+&]O>tQ`O7+&]O!B_QpO7+&]OOQO7+%u7+%uO$?aQ!0MxO7+&UOOQO7+&U7+&UO%[QlO7+&UO%>]Q!0LrO7+&UO!BSQ!0LrO7+%uO!B_QpO7+%uO%>hQ!0LrO7+&UO%>vQ!0MxO7++nO%[QlO7++nO%?WQ`O7++mO%?WQ`O7++mOOQO1G4o1G4oO9WQ`O1G4oO%?`Q`O1G4oOOQS7+%z7+%zO#']Q`O<<K|O4UQ!fO<<K|O%?nQ`O<<K|OOQ[<<K|<<K|O!&fQMhO<<K|O%[QlO<<K|O%?vQ`O<<K|O%@RQ!0MzO,5?]O%B^Q!0MzO,5?_O%DiQ!0MzO1G2^O%FzQ!0MzO1G2pO%IVQ!0MzO1G2rO%KbQ!fO,5>|O%[QlO,5>|OOQO-E<`-E<`O%KlQ`O1G5yOOQ!0Lf<<JR<<JRO%KtQ?MtO1G0rO%M{Q?MtO1G0|O%NSQ?MtO1G0|O&!TQ?MtO1G0|O&![Q?MtO1G0|O&$]Q?MtO1G0|O&&^Q?MtO1G0|O&&eQ?MtO1G0|O&&lQ?MtO1G0|O&(mQ?MtO1G0|O&(tQ?MtO1G0|O&({Q!0MxO<<JeO&*sQ?MtO1G0|O&+pQ?MvO1G0|O&,sQ?MvO'#JhO&.yQ?MtO1G1bO&/WQ?MtO1G0RO&/bQMjO,5?POOQO-E<c-E<cO!(vQlO'#FpOOQO'#KV'#KVOOQO1G1t1G1tO&/lQ`O1G1sO&/qQ?MtO,5?WOOOW7+'g7+'gOOOO1G/W1G/WO&/{Q!dO1G4tOOQ!0Lh7+(O7+(OP!&fQMhO,5?YO!+oQMhO7+(`O&0SQ`O,5?XO9WQ`O,5?XOOQO-E<k-E<kO&0bQ`O1G6_O&0bQ`O1G6_O&0jQ`O1G6_O&0uQMjO7+'xO&1VQ!dO,5?ZO&1aQ`O,5?ZO!&fQMhO,5?ZOOQO-E<m-E<mO&1fQ!dO1G6`O&1pQ`O1G6`O&1xQ`O1G2iO!&fQMhO1G2iOOQ!0Lb1G2g1G2gOOQ!0Lb1G2h1G2hO%2VQpO1G2gO!B_QpO1G2gOCcQ`O1G2gOOQ!0Lb1G2n1G2nO&1}QpO1G2gO&2]Q`O1G2iO$)QQ`O1G2hOCcQ`O1G2hO$#WQlO1G2iO&2eQ`O1G2hO&3XQMjO,5?]OOQ!0Lh-E<p-E<pO&3zQMjO,5?_OOQ!0Lh-E<r-E<rO!+oQMhO7++XOOQ!0Lh1G/`1G/`O&4UQ`O1G/`OOQ!0Lh7+'s7+'sO&4ZQMjO7+'zO&4kQ!0MxO<<KVOOQ!0Lf<<KV<<KVO&5_Q`O1G0wO!&fQMhO'#IvO&5dQ`O,5@uO&7fQ!fO<<K|O!&fQMhO1G2lOOQ[<<G{<<G{O!BSQ!0LrO<<G{O&7mQ!0MxO<<IxOOQ!0Lf<<Ix<<IxOOQO,5?h,5?hO&8aQ`O,5?hO&8fQ`O,5?hOOQO-E<z-E<zO&8tQ`O1G6hO&8tQ`O1G6hO9^Q`O1G6hO@fQ`O<<LiOOQ[<<Li<<LiO&8|Q`O<<LiO9hQ!0LrO<<LiOOQ[<<LU<<LUO%8hQ!0MvO<<LUOOQ[<<LV<<LVO!D`Q`O<<LVO&9RQpO'#IxO&9^Q`O,5@yO!(vQlO,5@yOOQ[1G3T1G3TOOQO'#Iz'#IzO9hQ!0LrO'#IzO&9fQpO,5=rOOQ[,5=r,5=rO&9mQpO'#EdO&9tQpO'#GcO&9yQ`O7+(wO&:OQ`O7+(wOOQ[7+(w7+(wO!&fQMhO7+(wO%[QlO7+(wO&:WQ`O7+(wOOQ[7+(y7+(yO9hQ!0LrO7+(yO$#sQ`O7+(yO9RQ`O7+(yO!B_QpO7+(yO&:cQ`O,5?gOOQO-E<y-E<yOOQO'#HZ'#HZO&:nQ`O1G6fO9hQ!0LrO<<GqOOQ[<<Gq<<GqO@fQ`O<<GqO&:vQ`O7+,TO&:{Q`O7+,UO%[QlO7+,TO%[QlO7+,UOOQ[7+)R7+)RO&;QQ`O7+)RO&;VQlO7+)RO&;^Q`O7+)ROOQ[<<Lu<<LuOOQ[<<Lw<<LwOOQ[-E<|-E<|OOQ[1G3v1G3vO&;cQ`O,5>]OOQ[,5>_,5>_O&;hQ`O1G3|O9WQ`O7+&cO!(vQlO7+&cOOQO7+%[7+%[O&;mQ?MtO1G6VO>tQ`O7+%[OOQ!0Lf<<I^<<I^OOQ!0Lf<<Iw<<IwO>tQ`O<<IwOOQO<<Ip<<IpO$?aQ!0MxO<<IpO%[QlO<<IpOOQO<<Ia<<IaO!BSQ!0LrO<<IaO&;wQ!0LrO<<IpO&<SQ!0MxO<= YO&<dQ`O<= XOOQO7+*Z7+*ZO9WQ`O7+*ZOOQ[ANAhANAhO&<lQ!fOANAhO!&fQMhOANAhO#']Q`OANAhO4UQ!fOANAhO&<sQ`OANAhO%[QlOANAhO&<{Q!0MzO7+'xO&?^Q!0MzO,5?]O&AiQ!0MzO,5?_O&CtQ!0MzO7+'zO&FVQ!fO1G4hO&FaQ?MtO7+&^O&HeQ?MvO,5=UO&JlQ?MvO,5=WO&J|Q?MvO,5=UO&K^Q?MvO,5=WO&KnQ?MvO,59rO&MtQ?MvO,5<iO' wQ?MvO,5<kO'$]Q?MvO,5<yO'&RQ?MtO7+'jO'&`Q?MtO7+'kO'&mQ`O,5<[OOQO7+'_7+'_OOQ!0Lh7+*`7+*`O'&rQMjO<<KzOOQO1G4s1G4sO'&yQ`O1G4sO''UQ`O1G4sO''dQ`O7++yO''dQ`O7++yO!&fQMhO1G4uO''lQ!dO1G4uO''vQ`O7++zO'(OQ`O7+(TO'(ZQ!dO7+(TOOQ!0Lb7+(R7+(ROOQ!0Lb7+(S7+(SO!B_QpO7+(ROCcQ`O7+(RO'(eQ`O7+(TO!&fQMhO7+(TO$)QQ`O7+(SO'(jQ`O7+(TOCcQ`O7+(SO'(rQMjO<<NsOOQ!0Lh7+$z7+$zO'(|Q!dO,5?bOOQO-E<t-E<tO')WQ!0MvO7+(WOOQ[AN=gAN=gO9^Q`O1G5SOOQO1G5S1G5SO')hQ`O1G5SO')mQ`O7+,SO')mQ`O7+,SO9hQ!0LrOANBTO@fQ`OANBTOOQ[ANBTANBTOOQ[ANApANApOOQ[ANAqANAqO')uQ`O,5?dOOQO-E<v-E<vO'*QQ?MtO1G6eOOQO,5?f,5?fOOQO-E<x-E<xOOQ[1G3^1G3^O'*[Q`O,5<}OOQ[<<Lc<<LcO!&fQMhO<<LcO&9yQ`O<<LcO'*aQ`O<<LcO%[QlO<<LcOOQ[<<Le<<LeO9hQ!0LrO<<LeO$#sQ`O<<LeO9RQ`O<<LeO'*iQpO1G5RO'*tQ`O7+,QOOQ[AN=]AN=]O9hQ!0LrOAN=]OOQ[<= o<= oOOQ[<= p<= pO'*|Q`O<= oO'+RQ`O<= pOOQ[<<Lm<<LmO'+WQ`O<<LmO'+]QlO<<LmOOQ[1G3w1G3wO>tQ`O7+)hO'+dQ`O<<I}O'+oQ?MtO<<I}OOQO<<Hv<<HvOOQ!0LfAN?cAN?cOOQOAN?[AN?[O$?aQ!0MxOAN?[OOQOAN>{AN>{O%[QlOAN?[OOQO<<Mu<<MuOOQ[G27SG27SO!&fQMhOG27SO#']Q`OG27SO'+yQ!fOG27SO4UQ!fOG27SO',QQ`OG27SO',YQ?MtO<<JeO',gQ?MvO1G2^O'.]Q?MvO,5?]O'0`Q?MvO,5?_O'2cQ?MvO1G2pO'4fQ?MvO1G2rO'6iQ?MtO<<KVO'6vQ?MtO<<IxOOQO1G1v1G1vO!+oQMhOANAfOOQO7+*_7+*_O'7TQ`O7+*_O'7`Q`O<= eO'7hQ!dO7+*aOOQ!0Lb<<Ko<<KoO$)QQ`O<<KoOCcQ`O<<KoO'7rQ`O<<KoO!&fQMhO<<KoOOQ!0Lb<<Km<<KmO!B_QpO<<KmO'7}Q!dO<<KoOOQ!0Lb<<Kn<<KnO'8XQ`O<<KoO!&fQMhO<<KoO$)QQ`O<<KnOOQO7+*n7+*nO9^Q`O7+*nO'8^Q`O<= nOOQ[G27oG27oO9hQ!0LrOG27oO!(vQlO1G5OO'8fQ`O7+,PO'8nQ`O1G2iO&9yQ`OANA}OOQ[ANA}ANA}O!&fQMhOANA}O'8sQ`OANA}OOQ[ANBPANBPO9hQ!0LrOANBPO$#sQ`OANBPOOQO'#H['#H[OOQO7+*m7+*mOOQ[G22wG22wOOQ[ANEZANEZOOQ[ANE[ANE[OOQ[ANBXANBXO'8{Q`OANBXOOQ[<<MS<<MSO!(vQlOAN?iOOQOG24vG24vO$?aQ!0MxOG24vO#']Q`OLD,nOOQ[LD,nLD,nO!&fQMhOLD,nO'9QQ!fOLD,nO'9XQ?MvO7+'xO':}Q?MvO,5?]O'=QQ?MvO,5?_O'?TQ?MvO7+'zO'@yQMjOG27QOOQO<<My<<MyOOQ!0LbANAZANAZO$)QQ`OANAZOCcQ`OANAZO'AZQ!dOANAZOOQ!0LbANAXANAXO'AbQ`OANAZO!&fQMhOANAZO'AmQ!dOANAZOOQ!0LbANAYANAYOOQO<<NY<<NYOOQ[LD-ZLD-ZO'AwQ?MtO7+*jOOQO'#Gd'#GdOOQ[G27iG27iO&9yQ`OG27iO!&fQMhOG27iOOQ[G27kG27kO9hQ!0LrOG27kOOQ[G27sG27sO'BRQ?MtOG25TOOQOLD*bLD*bOOQ[!$(!Y!$(!YO#']Q`O!$(!YO!&fQMhO!$(!YO'B]Q!0MzOG27QOOQ!0LbG26uG26uO$)QQ`OG26uO'DnQ`OG26uOCcQ`OG26uO'DyQ!dOG26uO!&fQMhOG26uOOQ[LD-TLD-TO&9yQ`OLD-TOOQ[LD-VLD-VOOQ[!)9Et!)9EtO#']Q`O!)9EtOOQ!0LbLD,aLD,aO$)QQ`OLD,aOCcQ`OLD,aO'EQQ`OLD,aO'E]Q!dOLD,aOOQ[!$(!o!$(!oOOQ[!.K;`!.K;`O'EdQ?MvOG27QOOQ!0Lb!$( {!$( {O$)QQ`O!$( {OCcQ`O!$( {O'GYQ`O!$( {OOQ!0Lb!)9Eg!)9EgO$)QQ`O!)9EgOCcQ`O!)9EgOOQ!0Lb!.K;R!.K;RO$)QQ`O!.K;ROOQ!0Lb!4/0m!4/0mO!(vQlO'#DwO1PQ`O'#EUO'GeQ!fO'#JnO'GlQ!L^O'#DsO'GsQlO'#D{O'GzQ!fO'#CiO'JbQ!fO'#CiO!(vQlO'#D}O'JrQlO,5;WO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO,5;bO!(vQlO'#IlO'LuQ`O,5<gO!(vQlO,5;bO'L}QMhO,5;bO'NhQMhO,5;bO!(vQlO,5;vO!&fQMhO'#GjO'L}QMhO'#GjO!&fQMhO'#GlO'L}QMhO'#GlO1SQ`O'#DWO1SQ`O'#DWO!&fQMhO'#F}O'L}QMhO'#F}O!&fQMhO'#GPO'L}QMhO'#GPO!&fQMhO'#G_O'L}QMhO'#G_O!(vQlO,5:gO'NoQpO'#D[O'NyQpO'#JrO!(vQlO,5@kO'JrQlO1G0rO( TQ?MtO'#CiO!(vQlO1G2OO!&fQMhO'#IqO'L}QMhO'#IqO!&fQMhO'#IsO'L}QMhO'#IsO( _Q!dO'#CrO!&fQMhO,5<rO'L}QMhO,5<rO'JrQlO1G2PO!(vQlO7+&yO!&fQMhO1G2^O'L}QMhO1G2^O!&fQMhO'#IqO'L}QMhO'#IqO!&fQMhO'#IsO'L}QMhO'#IsO!&fQMhO1G2`O'L}QMhO1G2`O'JrQlO7+'kO'JrQlO7+&^O!&fQMhOANAfO'L}QMhOANAfO( rQ`O'#ElO( wQ`O'#ElO(!PQ`O'#F[O(!UQ`O'#EvO(!ZQ`O'#KPO(!fQ`O'#J}O(!qQ`O,5;WO(!vQMjO,5<dO(!}Q`O'#GWO(#SQ`O'#GWO(#XQ`O,5<eO(#aQ`O,5;WO(#iQ?MtO1G1_O(#pQ`O,5<rO(#uQ`O,5<rO(#zQ`O,5<tO($PQ`O,5<tO($UQ`O1G2PO($ZQ`O1G0rO($`QMjO<<KzO($gQMjO<<KzO7eQMhO'#FzO9RQ`O'#FyOAaQ`O'#EkO!(vQlO,5;sO!3ZQ`O'#GWO!3ZQ`O'#GWO!3ZQ`O'#GYO!3ZQ`O'#GYO!+oQMhO7+(`O!+oQMhO7+(`O%,oQ!dO1G2tO%,oQ!dO1G2tO!&fQMhO,5=YO!&fQMhO,5=Y",
    stateData: "(%k~O'xOS'yOSTOS'zRQ~OPYOQYOSfOY!VOaqOdzOeyOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![XO!fuO!iZO!lYO!mYO!nYO!pvO!rwO!uxO!y]O#t!PO$V|O%e}O%g!QO%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO%v!UO&S!WO&Y!XO&[!YO&^!ZO&`![O&c!]O&i!^O&o!_O&q!`O&s!aO&u!bO&w!cO(PSO(RTO(UUO(]VO(k[O(ziO~OWtO~P`OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(P!dO(RTO(UUO(]VO(k[O(ziO~Oa!wOp!nO!P!oO!_!yO!`!vO!a!vO!y;kO#Q!pO#R!pO#S!xO#T!pO#U!pO#X!zO#Y!zO(Q!lO(RTO(UUO(a!mO(k!sO~O'z!{O~OP]XR]X[]Xa]Xo]X}]X!P]X!Y]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X'v]X(]]X(n]X(u]X(v]X~O!d%PX~P(qO_!}O(R#PO(S!}O(T#PO~O_#QO(T#PO(U#PO(V#QO~Ou#SO!R#TO(^#TO(_#VO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(P;oO(RTO(UUO(]VO(k[O(ziO~O!X#ZO!Y#WO!V(dP!V(rP~P+}O!Z#cO~P`OPYOQYOSfOd!jOe!iOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(RTO(UUO(]VO(k[O(ziO~Om#mO!X#iO!y]O#f#lO#g#iO(P;pO!h(oP~P.iO!i#oO(P#nO~O!u#sO!y]O%e#tO~O#h#uO~O!d#vO#h#uO~OP$[OR#zO[$cOo$aO}#yO!P#{O!Y$_O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO(]VO(n$YO(u#|O(v#}O~Oa(bX'v(bX's(bX!h(bX!V(bX![(bX%f(bX!d(bX~P1qO#P$dO#]$eO$P$eOP(cXR(cX[(cXo(cX}(cX!P(cX!Y(cX!i(cX!m(cX#O(cX#k(cX#l(cX#m(cX#n(cX#o(cX#p(cX#q(cX#r(cX#s(cX#u(cX#w(cX#y(cX#z(cX(](cX(n(cX(u(cX(v(cX![(cX%f(cX~Oa(cX'v(cX's(cX!V(cX!h(cXs(cX!d(cX~P4UO#]$eO~O$[$hO$^$gO$e$mO~OSfO![$nO$h$oO$j$qO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{%[O!P${O![$|O!f%aO!i$xO#g%bO$V%_O$r%]O$t%^O$w%`O(P$sO(RTO(UUO(]$uO(u$}O(v%POg(YP~O!i%cO~O!P%fO![%gO(P%eO~O!d%kO~Oa%lO'v%lO~O}%pO~P%[O(Q!lO~P%[O%k%tO~P%[Oh%VO!i%cO(P%eO(Q!lO~Oe%{O!i%cO(P%eO~O#s$RO~O}&QO![%}O!i&PO%g&TO(P%eO(Q!lO(RTO(UUO`)TP~O!u#sO~O%p&VO!P)PX![)PX(P)PX~O(P&WO~O!r&]O#t!PO%g!QO%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO~Od&bOe&aO!u&_O%e&`O%x&^O~P;|Od&eOeyO![&dO!r&]O!uxO!y]O#t!PO%e}O%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO%v!UO~Ob&hO#]&kO%g&fO(Q!lO~P=RO!i&lO!r&pO~O!i#oO~O![XO~Oa%lO't&xO'v%lO~Oa%lO't&{O'v%lO~Oa%lO't&}O'v%lO~O's]X!V]Xs]X!h]X&W]X![]X%f]X!d]X~P(qO!_'[O!`'TO!a'TO(Q!lO(RTO(UUO~Op'RO!P'QO!X'UO(a'PO!Z(eP!Z(tP~P@YOk'_O![']O(P%eO~Oe'dO!i%cO(P%eO~O}&QO!i&PO~Op!nO!P!oO!y;kO#Q!pO#R!pO#T!pO#U!pO(Q!lO(RTO(UUO(a!mO(k!sO~O!_'jO!`'iO!a'iO#S!pO#X'kO#Y'kO~PAtOa%lOh%VO!d#vO!i%cO'v%lO(n'mO~O!m'qO#]'oO~PCSOp!nO!P!oO(RTO(UUO(a!mO(k!sO~O![XOp(iX!P(iX!_(iX!`(iX!a(iX!y(iX#Q(iX#R(iX#S(iX#T(iX#U(iX#X(iX#Y(iX(Q(iX(R(iX(U(iX(a(iX(k(iX~O!`'iO!a'iO(Q!lO~PCrO'{'uO'|'uO'}'wO~O_!}O(R'yO(S!}O(T'yO~O_#QO(T'yO(U'yO(V#QO~Os'{O~P%[Ou#SO!R#TO(^#TO(_(OO~O!X(QO!V'SX!V'YX!Y'SX!Y'YX~P+}O!Y(SO!V(dX~OP$[OR#zO[$cOo$aO}#yO!P#{O!Y(SO!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO(]VO(n$YO(u#|O(v#}O~O!V(dX~PGmO!V(XO~O!V(qX!Y(qX!d(qX!h(qX(n(qX~O#](qX#h#aX!Z(qX~PIpO#](YO!V(sX!Y(sX~O!Y(ZO!V(rX~O!V(^O~O#]$eO~PIpO!Z(_O~P`OR#zO}#yO!P#{O!i#xO(]VOP!ka[!kao!ka!Y!ka!m!ka#O!ka#k!ka#l!ka#m!ka#n!ka#o!ka#p!ka#q!ka#r!ka#s!ka#u!ka#w!ka#y!ka#z!ka(n!ka(u!ka(v!ka~Oa!ka'v!ka's!ka!V!ka!h!kas!ka![!ka%f!ka!d!ka~PKWO!h(`O~O!d#vO#](aO(n'mO!Y(pXa(pX'v(pX~O!h(pX~PMsO!P%fO![%gO!y]O#f(fO#g(eO(P%eO~O!Y(gO!h(oX~O!h(iO~O!P%fO![%gO#g(eO(P%eO~OP(cXR(cX[(cXo(cX}(cX!P(cX!Y(cX!i(cX!m(cX#O(cX#k(cX#l(cX#m(cX#n(cX#o(cX#p(cX#q(cX#r(cX#s(cX#u(cX#w(cX#y(cX#z(cX(](cX(n(cX(u(cX(v(cX~O!d#vO!h(cX~P! aOR(kO}(jO!i#xO#P$dO!y!xa!P!xa~O!u!xa%e!xa![!xa#f!xa#g!xa(P!xa~P!#bO!u(oO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![XO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(P!dO(RTO(UUO(]VO(k[O(ziO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{<XO!P${O![$|O!f=jO!i$xO#g<_O$V%_O$r<ZO$t<]O$w%`O(P(sO(RTO(UUO(]$uO(u$}O(v%PO~O#h(uO~O!X(wO!h(gP~P%[O(a(yO(k[O~O!P({O!i#xO(a(yO(k[O~OP;jOQ;jOSfOd=fOe!iOmkOo;jOpkOqkOwkOy;jO{;jO!PWO!TkO!UkO![!eO!f;mO!iZO!l;jO!m;jO!n;jO!p;nO!r;qO!u!hO$V!kO(P)YO(RTO(UUO(]VO(k[O(z=dO~O!Y$_Oa$oa'v$oa's$oa!h$oa!V$oa![$oa%f$oa!d$oa~O#t)aO~P!&fOh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{%[O!P${O![$|O!f%aO!i$xO#g%bO$V%_O$r%]O$t%^O$w%`O(P(sO(RTO(UUO(]$uO(u$}O(v%PO~Og(lP~P!+oO})fO!d)eO![$]X$Y$]X$[$]X$^$]X$e$]X~O!d)eO![(wX$Y(wX$[(wX$^(wX$e(wX~O})fO~P!-xO})fO![(wX$Y(wX$[(wX$^(wX$e(wX~O![)hO$Y)lO$[)gO$^)gO$e)mO~O!X)pO~P!(vO$[$hO$^$gO$e)tO~Ok$xX}$xX#P$xX'u$xX(u$xX(v$xX~OgjXg$xXkjX!YjX#]jX~P!/nOu)vO(^)wO(_)yO~Ok*SO}){O'u)|O(u$}O(v%PO~Og)zO~P!0rOg*TO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{<XO!P*VO![*WO!f=jO!i$xO#g<_O$V%_O$r<ZO$t<]O$w%`O(RTO(UUO(]$uO(u$}O(v%PO~O!X*ZO(P*UO!h({P~P!1aO#h*]O~O!i*^O~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{<XO!P${O![$|O!f=jO!i$xO#g<_O$V%_O$r<ZO$t<]O$w%`O(P*`O(RTO(UUO(]$uO(u$}O(v%PO~O!X*cO!V(|P~P!3`Oo*oOp!nO!P*eO!_*mO!`*gO!a*gO!i*^O#X*nO%]*iO(Q!lO(RTO(UUO(a!mO~O!Z*lO~P!5TO#P$dOk([X}([X'u([X(u([X(v([X!Y([X#]([X~Og([X#}([X~P!6VOk*tO#]*sOg(ZX!Y(ZX~O!Y*uOg(YX~O(P&WOg(YP~Op*xO~O!i*}O~O(P(sO~Om+RO!P%fO!X#iO![%gO!y]O#f#lO#g#iO(P%eO!h(oP~O!d#vO#h+SO~O!P%fO!X+UO!Y(ZO![%gO(P%eO!V(rP~Op'XO!P+WO!X+VO(RTO(UUO(a(yO~O!Z(tP~P!9VO!Y+XOa)QX'v)QX~OP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO(]VO(n$YO(u#|O(v#}O~Oa!ga!Y!ga'v!ga's!ga!V!ga!h!gas!ga![!ga%f!ga!d!ga~P!9}OR#zO}#yO!P#{O!i#xO(]VOP!oa[!oao!oa!Y!oa!m!oa#O!oa#k!oa#l!oa#m!oa#n!oa#o!oa#p!oa#q!oa#r!oa#s!oa#u!oa#w!oa#y!oa#z!oa(n!oa(u!oa(v!oa~Oa!oa'v!oa's!oa!V!oa!h!oas!oa![!oa%f!oa!d!oa~P!<eOR#zO}#yO!P#{O!i#xO(]VOP!qa[!qao!qa!Y!qa!m!qa#O!qa#k!qa#l!qa#m!qa#n!qa#o!qa#p!qa#q!qa#r!qa#s!qa#u!qa#w!qa#y!qa#z!qa(n!qa(u!qa(v!qa~Oa!qa'v!qa's!qa!V!qa!h!qas!qa![!qa%f!qa!d!qa~P!>{Oh%VOk+bO![']O%f+aO~O!d+dOa(XX![(XX'v(XX!Y(XX~Oa%lO![XO'v%lO~Oh%VO!i%cO~Oh%VO!i%cO(P%eO~O!d#vO#h(uO~Ob+oO%g+pO(P+lO(RTO(UUO!Z)UP~O!Y+qO`)TX~O[+uO~O`+vO~O![%}O(P%eO(Q!lO`)TP~Oh%VO#]+{O~Oh%VOk,OO![$|O~O![,QO~O},SO![XO~O%k%tO~O!u,XO~Oe,^O~Ob,_O(P#nO(RTO(UUO!Z)SP~Oe%{O~O%g!QO(P&WO~P=RO[,dO`,cO~OPYOQYOSfOdzOeyOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO!fuO!iZO!lYO!mYO!nYO!pvO!uxO!y]O%e}O(RTO(UUO(]VO(k[O(ziO~O![!eO!r!gO$V!kO(P!dO~P!E{O`,cOa%lO'v%lO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!u!hO$V!kO(P!dO(RTO(UUO(]VO(k[O(ziO~Oa,iO!rwO#t!OO%i!OO%j!OO%k!OO~P!HeO!i&lO~O&Y,oO~O![,qO~O&k,sO&m,tOP&haQ&haS&haY&haa&had&hae&ham&hao&hap&haq&haw&hay&ha{&ha!P&ha!T&ha!U&ha![&ha!f&ha!i&ha!l&ha!m&ha!n&ha!p&ha!r&ha!u&ha!y&ha#t&ha$V&ha%e&ha%g&ha%i&ha%j&ha%k&ha%n&ha%p&ha%s&ha%t&ha%v&ha&S&ha&Y&ha&[&ha&^&ha&`&ha&c&ha&i&ha&o&ha&q&ha&s&ha&u&ha&w&ha's&ha(P&ha(R&ha(U&ha(]&ha(k&ha(z&ha!Z&ha&a&hab&ha&f&ha~O(P,yO~Oh!bX!Y!OX!Z!OX!d!OX!d!bX!i!bX#]!OX~O!Y!bX!Z!bX~P# kO!d-OO#],}Oh(fX!Y#eX!Z#eX!d(fX!i(fX~O!Y(fX!Z(fX~P#!^Oh%VO!d-QO!i%cO!Y!^X!Z!^X~Op!nO!P!oO(RTO(UUO(a!mO~OP;jOQ;jOSfOd=fOe!iOmkOo;jOpkOqkOwkOy;jO{;jO!PWO!TkO!UkO![!eO!f;mO!iZO!l;jO!m;jO!n;jO!p;nO!r;qO!u!hO$V!kO(RTO(UUO(]VO(k[O(z=dO~O(P<fO~P##sO!Y-UO!Z(eX~O!Z-WO~O!d-OO#],}O!Y#eX!Z#eX~O!Y-XO!Z(tX~O!Z-ZO~O!`-[O!a-[O(Q!lO~P##bO!Z-_O~P'_Ok-bO![']O~O!V-gO~Op!xa!_!xa!`!xa!a!xa#Q!xa#R!xa#S!xa#T!xa#U!xa#X!xa#Y!xa(Q!xa(R!xa(U!xa(a!xa(k!xa~P!#bO!m-lO#]-jO~PCSO!`-nO!a-nO(Q!lO~PCrOa%lO#]-jO'v%lO~Oa%lO!d#vO#]-jO'v%lO~Oa%lO!d#vO!m-lO#]-jO'v%lO(n'mO~O'{'uO'|'uO'}-sO~Os-tO~O!V'Sa!Y'Sa~P!9}O!X-xO!V'SX!Y'SX~P%[O!Y(SO!V(da~O!V(da~PGmO!Y(ZO!V(ra~O!P%fO!X-|O![%gO(P%eO!V'YX!Y'YX~O#].OO!Y(pa!h(paa(pa'v(pa~O!d#vO~P#+yO!Y(gO!h(oa~O!P%fO![%gO#g.SO(P%eO~Om.XO!P%fO!X.UO![%gO!y]O#f.WO#g.UO(P%eO!Y']X!h']X~OR.]O!i#xO~Oh%VOk.`O![']O%f._O~Oa#`i!Y#`i'v#`i's#`i!V#`i!h#`is#`i![#`i%f#`i!d#`i~P!9}Ok=pO}){O'u)|O(u$}O(v%PO~O#h#[aa#[a#]#[a'v#[a!Y#[a!h#[a![#[a!V#[a~P#.uO#h([XP([XR([X[([Xa([Xo([X!P([X!i([X!m([X#O([X#k([X#l([X#m([X#n([X#o([X#p([X#q([X#r([X#s([X#u([X#w([X#y([X#z([X'v([X(]([X(n([X!h([X!V([X's([Xs([X![([X%f([X!d([X~P!6VO!Y.mO!h(gX~P!9}O!h.pO~O!V.rO~OP$[OR#zO}#yO!P#{O!i#xO!m$[O(]VO[#jia#jio#ji!Y#ji#O#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'v#ji(n#ji(u#ji(v#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#k#ji~P#2eO#k$OO~P#2eOP$[OR#zOo$aO}#yO!P#{O!i#xO!m$[O#k$OO#l$PO#m$PO#n$PO(]VO[#jia#ji!Y#ji#O#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'v#ji(n#ji(u#ji(v#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#o#ji~P#5SO#o$QO~P#5SOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO(]VOa#ji!Y#ji#w#ji#y#ji#z#ji'v#ji(n#ji(u#ji(v#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#u#ji~P#7qOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO(]VO(v#}Oa#ji!Y#ji#y#ji#z#ji'v#ji(n#ji(u#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#w$UO~P#:XO#w#ji~P#:XO#u$SO~P#7qOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO(]VO(u#|O(v#}Oa#ji!Y#ji#z#ji'v#ji(n#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#y#ji~P#<}O#y$WO~P#<}OP]XR]X[]Xo]X}]X!P]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X(]]X(n]X(u]X(v]X!Y]X!Z]X~O#}]X~P#?lOP$[OR#zO[<ROo<PO}#yO!P#{O!i#xO!m$[O#O;vO#k;sO#l;tO#m;tO#n;tO#o;uO#p;vO#q;vO#r<QO#s;vO#u;wO#w;yO#y;{O#z;|O(]VO(n$YO(u#|O(v#}O~O#}.tO~P#AyO#P$dO#]<SO$P<SO#}(cX!Z(cX~P! aOa'`a!Y'`a'v'`a's'`a!h'`a!V'`as'`a!['`a%f'`a!d'`a~P!9}O[#jia#jio#ji!Y#ji#O#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'v#ji(n#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~OP$[OR#zO}#yO!P#{O!i#xO!m$[O#k$OO#l$PO#m$PO#n$PO(]VO(u#ji(v#ji~P#D{Ok=pO}){O'u)|O(u$}O(v%POP#jiR#ji!P#ji!i#ji!m#ji#k#ji#l#ji#m#ji#n#ji(]#ji~P#D{O!Y.xOg(lX~P!0rOg.zO~Oa$Oi!Y$Oi'v$Oi's$Oi!V$Oi!h$Ois$Oi![$Oi%f$Oi!d$Oi~P!9}O$[.{O$^.{O~O$[.|O$^.|O~O!d)eO#].}O![$bX$Y$bX$[$bX$^$bX$e$bX~O!X/OO~O![)hO$Y/QO$[)gO$^)gO$e/RO~O!Y;}O!Z(bX~P#AyO!Z/SO~O!d)eO$e(wX~O$e/UO~Os/VO~P!&fOu)vO(^)wO(_/YO~O!P/]O~O(u$}Ok%^a}%^a'u%^a(v%^a!Y%^a#]%^a~Og%^a#}%^a~P#K}O(v%POk%`a}%`a'u%`a(u%`a!Y%`a#]%`a~Og%`a#}%`a~P#LpO!YfX!dfX!hfX!h$xX(nfX~P!/nO!X/fO!Y(ZO(P/eO!V(rP!V(|P~P!1aOo*oO!_*mO!`*gO!a*gO!i*^O#X*nO%]*iO(Q!lO(RTO(UUO~Op<cO!P/gO!X+VO!Z*lO(a<bO!Z(tP~P#NZO!h/hO~P#.uO!Y/iO!d#vO(n'mO!h({X~O!h/nO~O!P%fO!X*ZO![%gO(P%eO!h({P~O#h/pO~O!V$xX!Y$xX!d%PX~P!/nO!Y/qO!V(|X~P#.uO!d/sO~O!V/uO~OmkO(P/vO~P.iOh%VOo/{O!d#vO!i%cO(n'mO~O!d+dO~Oa%lO!Y0PO'v%lO~O!Z0RO~P!5TO!`0SO!a0SO(Q!lO~P##bOp!nO!P0TO(RTO(UUO(a!mO~O#X0VO~Og%^a!Y%^a#]%^a#}%^a~P!0rOg%`a!Y%`a#]%`a#}%`a~P!0rO(P&WOg'iX!Y'iX~O!Y*uOg(Ya~Og0`O~OR0aO}0aO!P0bO#P$dOkza'uza(uza(vza!Yza#]za~Ogza#}za~P$&ZO}){O'u)|Ok$qa(u$qa(v$qa!Y$qa#]$qa~Og$qa#}$qa~P$'VO}){O'u)|Ok$sa(u$sa(v$sa!Y$sa#]$sa~Og$sa#}$sa~P$'xO#h0eO~Og%Ra!Y%Ra#]%Ra#}%Ra~P!0rO!d#vO~O#h0hO~O!Y+XOa)Qa'v)Qa~OR#zO}#yO!P#{O!i#xO(]VOP!oi[!oio!oi!Y!oi!m!oi#O!oi#k!oi#l!oi#m!oi#n!oi#o!oi#p!oi#q!oi#r!oi#s!oi#u!oi#w!oi#y!oi#z!oi(n!oi(u!oi(v!oi~Oa!oi'v!oi's!oi!V!oi!h!ois!oi![!oi%f!oi!d!oi~P$)gOh%VOo%XOp$tOq$tOw%YOy%ZO{<XO!P${O![$|O!f=jO!i$xO#g<_O$V%_O$r<ZO$t<]O$w%`O(RTO(UUO(]$uO(u$}O(v%PO~Om0qO(P0pO~P$+}O!d+dOa(Xa![(Xa'v(Xa!Y(Xa~O#h0wO~O[]X!YfX!ZfX~O!Y0xO!Z)UX~O!Z0zO~O[0{O~Ob0}O(P+lO(RTO(UUO~O![%}O(P%eO`'qX!Y'qX~O!Y+qO`)Ta~O!h1QO~P!9}O[1TO~O`1UO~O#]1XO~Ok1[O![$|O~O(a(yO!Z)RP~Oh%VOk1eO![1bO%f1dO~O[1oO!Y1mO!Z)SX~O!Z1pO~O`1rOa%lO'v%lO~O(P#nO(RTO(UUO~O#P$dO#]$eO$P$eOP(cXR(cX[(cXo(cX}(cX!P(cX!Y(cX!i(cX!m(cX#O(cX#k(cX#l(cX#m(cX#n(cX#o(cX#p(cX#q(cX#r(cX#u(cX#w(cX#y(cX#z(cX(](cX(n(cX(u(cX(v(cX~O#s1uO&W1vOa(cX~P$1eO#]$eO#s1uO&W1vO~Oa1xO~P%[Oa1zO~O&a1}OP&_iQ&_iS&_iY&_ia&_id&_ie&_im&_io&_ip&_iq&_iw&_iy&_i{&_i!P&_i!T&_i!U&_i![&_i!f&_i!i&_i!l&_i!m&_i!n&_i!p&_i!r&_i!u&_i!y&_i#t&_i$V&_i%e&_i%g&_i%i&_i%j&_i%k&_i%n&_i%p&_i%s&_i%t&_i%v&_i&S&_i&Y&_i&[&_i&^&_i&`&_i&c&_i&i&_i&o&_i&q&_i&s&_i&u&_i&w&_i's&_i(P&_i(R&_i(U&_i(]&_i(k&_i(z&_i!Z&_ib&_i&f&_i~Ob2TO!Z2RO&f2SO~P`O![XO!i2VO~O&m,tOP&hiQ&hiS&hiY&hia&hid&hie&him&hio&hip&hiq&hiw&hiy&hi{&hi!P&hi!T&hi!U&hi![&hi!f&hi!i&hi!l&hi!m&hi!n&hi!p&hi!r&hi!u&hi!y&hi#t&hi$V&hi%e&hi%g&hi%i&hi%j&hi%k&hi%n&hi%p&hi%s&hi%t&hi%v&hi&S&hi&Y&hi&[&hi&^&hi&`&hi&c&hi&i&hi&o&hi&q&hi&s&hi&u&hi&w&hi's&hi(P&hi(R&hi(U&hi(]&hi(k&hi(z&hi!Z&hi&a&hib&hi&f&hi~O!V2]O~O!Y!^a!Z!^a~P#AyOp!nO!P!oO!X2cO(a!mO!Y'TX!Z'TX~P@YO!Y-UO!Z(ea~O!Y'ZX!Z'ZX~P!9VO!Y-XO!Z(ta~O!Z2jO~P'_Oa%lO#]2sO'v%lO~Oa%lO!d#vO#]2sO'v%lO~Oa%lO!d#vO!m2wO#]2sO'v%lO(n'mO~Oa%lO'v%lO~P!9}O!Y$_Os$oa~O!V'Si!Y'Si~P!9}O!Y(SO!V(di~O!Y(ZO!V(ri~O!V(si!Y(si~P!9}O!Y(pi!h(pia(pi'v(pi~P!9}O#]2yO!Y(pi!h(pia(pi'v(pi~O!Y(gO!h(oi~O!P%fO![%gO!y]O#f3OO#g2}O(P%eO~O!P%fO![%gO#g2}O(P%eO~Ok3VO![']O%f3UO~Oh%VOk3VO![']O%f3UO~O#h%^aP%^aR%^a[%^aa%^ao%^a!P%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a'v%^a(]%^a(n%^a!h%^a!V%^a's%^as%^a![%^a%f%^a!d%^a~P#K}O#h%`aP%`aR%`a[%`aa%`ao%`a!P%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a'v%`a(]%`a(n%`a!h%`a!V%`a's%`as%`a![%`a%f%`a!d%`a~P#LpO#h%^aP%^aR%^a[%^aa%^ao%^a!P%^a!Y%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a'v%^a(]%^a(n%^a!h%^a!V%^a's%^a#]%^as%^a![%^a%f%^a!d%^a~P#.uO#h%`aP%`aR%`a[%`aa%`ao%`a!P%`a!Y%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a'v%`a(]%`a(n%`a!h%`a!V%`a's%`a#]%`as%`a![%`a%f%`a!d%`a~P#.uO#hzaPza[zaazaoza!iza!mza#Oza#kza#lza#mza#nza#oza#pza#qza#rza#sza#uza#wza#yza#zza'vza(]za(nza!hza!Vza'szasza![za%fza!dza~P$&ZO#h$qaP$qaR$qa[$qaa$qao$qa!P$qa!i$qa!m$qa#O$qa#k$qa#l$qa#m$qa#n$qa#o$qa#p$qa#q$qa#r$qa#s$qa#u$qa#w$qa#y$qa#z$qa'v$qa(]$qa(n$qa!h$qa!V$qa's$qas$qa![$qa%f$qa!d$qa~P$'VO#h$saP$saR$sa[$saa$sao$sa!P$sa!i$sa!m$sa#O$sa#k$sa#l$sa#m$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#u$sa#w$sa#y$sa#z$sa'v$sa(]$sa(n$sa!h$sa!V$sa's$sas$sa![$sa%f$sa!d$sa~P$'xO#h%RaP%RaR%Ra[%Raa%Rao%Ra!P%Ra!Y%Ra!i%Ra!m%Ra#O%Ra#k%Ra#l%Ra#m%Ra#n%Ra#o%Ra#p%Ra#q%Ra#r%Ra#s%Ra#u%Ra#w%Ra#y%Ra#z%Ra'v%Ra(]%Ra(n%Ra!h%Ra!V%Ra's%Ra#]%Ras%Ra![%Ra%f%Ra!d%Ra~P#.uOa#`q!Y#`q'v#`q's#`q!V#`q!h#`qs#`q![#`q%f#`q!d#`q~P!9}O!X3_O!Y'UX!h'UX~P%[O!Y.mO!h(ga~O!Y.mO!h(ga~P!9}O!V3bO~O#}!ka!Z!ka~PKWO#}!ga!Y!ga!Z!ga~P#AyO#}!oa!Z!oa~P!<eO#}!qa!Z!qa~P!>{Og'XX!Y'XX~P!+oO!Y.xOg(la~OSfO![3vO$c3wO~O!Z3{O~Os3|O~P#.uOa$lq!Y$lq'v$lq's$lq!V$lq!h$lqs$lq![$lq%f$lq!d$lq~P!9}O!V4OO~P!&fO!P4PO~O}){O'u)|O(v%POk'ea(u'ea!Y'ea#]'ea~Og'ea#}'ea~P%+ZO}){O'u)|Ok'ga(u'ga(v'ga!Y'ga#]'ga~Og'ga#}'ga~P%+|O(n$YO~P#.uO!VfX!V$xX!YfX!Y$xX!d%PX#]fX~P!/nO(P<lO~P!1aO!P%fO!X4SO![%gO(P%eO!Y'aX!h'aX~O!Y/iO!h({a~O!Y/iO!d#vO!h({a~O!Y/iO!d#vO(n'mO!h({a~Og$zi!Y$zi#]$zi#}$zi~P!0rO!X4[O!V'cX!Y'cX~P!3`O!Y/qO!V(|a~O!Y/qO!V(|a~P#.uOP]XR]X[]Xo]X}]X!P]X!V]X!Y]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X(]]X(n]X(u]X(v]X~O!d%WX#s%WX~P%/mO!d#vO#s4aO~Oh%VO!d#vO!i%cO~Oh%VOo4fO!i%cO(n'mO~Oo4kO!d#vO(n'mO~Op!nO!P4lO(RTO(UUO(a!mO~O(u$}Ok%^i}%^i'u%^i(v%^i!Y%^i#]%^i~Og%^i#}%^i~P%3^O(v%POk%`i}%`i'u%`i(u%`i!Y%`i#]%`i~Og%`i#}%`i~P%4POg(Zi!Y(Zi~P!0rO#]4rOg(Zi!Y(Zi~P!0rO!h4uO~Oa$mq!Y$mq'v$mq's$mq!V$mq!h$mqs$mq![$mq%f$mq!d$mq~P!9}O!V4yO~O!Y4zO![(}X~P#.uOa$xX![$xX%Z]X'v$xX!Y$xX~P!/nO%Z4}OalXklX}lX![lX'ulX'vlX(ulX(vlX!YlX~O%Z4}O~Ob5TO%g5UO(P+lO(RTO(UUO!Y'pX!Z'pX~O!Y0xO!Z)Ua~O[5YO~O`5ZO~Oa%lO'v%lO~P#.uO!Y5cO#]5eO!Z)RX~O!Z5fO~Oo5lOp!nO!P*eO!_!yO!`!vO!a!vO!y;kO#Q!pO#R!pO#S!pO#T!pO#U!pO#X5kO#Y!zO(Q!lO(RTO(UUO(a!mO(k!sO~O!Z5jO~P%9SOk5qO![1bO%f5pO~Oh%VOk5qO![1bO%f5pO~Ob5xO(P#nO(RTO(UUO!Y'oX!Z'oX~O!Y1mO!Z)Sa~O(RTO(UUO(a5zO~O`6OO~O#s6RO&W6SO~PMsO!h6TO~P%[Oa6VO~Oa6VO~P%[Ob2TO!Z6[O&f2SO~P`O!d6^O~O!d6`Oh(fi!Y(fi!Z(fi!d(fi!i(fio(fi(n(fi~O!Y#ei!Z#ei~P#AyO#]6aO!Y#ei!Z#ei~O!Y!^i!Z!^i~P#AyOa%lO#]6jO'v%lO~Oa%lO!d#vO#]6jO'v%lO~O!Y(pq!h(pqa(pq'v(pq~P!9}O!Y(gO!h(oq~O!P%fO![%gO#g6qO(P%eO~O![']O%f6tO~Ok6xO![']O%f6tO~O#h'eaP'eaR'ea['eaa'eao'ea!P'ea!i'ea!m'ea#O'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#s'ea#u'ea#w'ea#y'ea#z'ea'v'ea(]'ea(n'ea!h'ea!V'ea's'eas'ea!['ea%f'ea!d'ea~P%+ZO#h'gaP'gaR'ga['gaa'gao'ga!P'ga!i'ga!m'ga#O'ga#k'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#u'ga#w'ga#y'ga#z'ga'v'ga(]'ga(n'ga!h'ga!V'ga's'gas'ga!['ga%f'ga!d'ga~P%+|O#h$ziP$ziR$zi[$zia$zio$zi!P$zi!Y$zi!i$zi!m$zi#O$zi#k$zi#l$zi#m$zi#n$zi#o$zi#p$zi#q$zi#r$zi#s$zi#u$zi#w$zi#y$zi#z$zi'v$zi(]$zi(n$zi!h$zi!V$zi's$zi#]$zis$zi![$zi%f$zi!d$zi~P#.uO#h%^iP%^iR%^i[%^ia%^io%^i!P%^i!i%^i!m%^i#O%^i#k%^i#l%^i#m%^i#n%^i#o%^i#p%^i#q%^i#r%^i#s%^i#u%^i#w%^i#y%^i#z%^i'v%^i(]%^i(n%^i!h%^i!V%^i's%^is%^i![%^i%f%^i!d%^i~P%3^O#h%`iP%`iR%`i[%`ia%`io%`i!P%`i!i%`i!m%`i#O%`i#k%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#u%`i#w%`i#y%`i#z%`i'v%`i(]%`i(n%`i!h%`i!V%`i's%`is%`i![%`i%f%`i!d%`i~P%4PO!Y'Ua!h'Ua~P!9}O!Y.mO!h(gi~O#}#`i!Y#`i!Z#`i~P#AyOP$[OR#zO}#yO!P#{O!i#xO!m$[O(]VO[#jio#ji#O#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(n#ji(u#ji(v#ji!Y#ji!Z#ji~O#k#ji~P%LRO#k;sO~P%LROP$[OR#zOo<PO}#yO!P#{O!i#xO!m$[O#k;sO#l;tO#m;tO#n;tO(]VO[#ji#O#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(n#ji(u#ji(v#ji!Y#ji!Z#ji~O#o#ji~P%NZO#o;uO~P%NZOP$[OR#zO[<ROo<PO}#yO!P#{O!i#xO!m$[O#O;vO#k;sO#l;tO#m;tO#n;tO#o;uO#p;vO#q;vO#r<QO#s;vO(]VO#w#ji#y#ji#z#ji#}#ji(n#ji(u#ji(v#ji!Y#ji!Z#ji~O#u#ji~P&!cOP$[OR#zO[<ROo<PO}#yO!P#{O!i#xO!m$[O#O;vO#k;sO#l;tO#m;tO#n;tO#o;uO#p;vO#q;vO#r<QO#s;vO#u;wO(]VO(v#}O#y#ji#z#ji#}#ji(n#ji(u#ji!Y#ji!Z#ji~O#w;yO~P&$dO#w#ji~P&$dO#u;wO~P&!cOP$[OR#zO[<ROo<PO}#yO!P#{O!i#xO!m$[O#O;vO#k;sO#l;tO#m;tO#n;tO#o;uO#p;vO#q;vO#r<QO#s;vO#u;wO#w;yO(]VO(u#|O(v#}O#z#ji#}#ji(n#ji!Y#ji!Z#ji~O#y#ji~P&&sO#y;{O~P&&sOa#{y!Y#{y'v#{y's#{y!V#{y!h#{ys#{y![#{y%f#{y!d#{y~P!9}O[#jio#ji#O#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(n#ji!Y#ji!Z#ji~OP$[OR#zO}#yO!P#{O!i#xO!m$[O#k;sO#l;tO#m;tO#n;tO(]VO(u#ji(v#ji~P&)oOk=qO}){O'u)|O(u$}O(v%POP#jiR#ji!P#ji!i#ji!m#ji#k#ji#l#ji#m#ji#n#ji(]#ji~P&)oO#P$dOP([XR([X[([Xk([Xo([X}([X!P([X!i([X!m([X#O([X#k([X#l([X#m([X#n([X#o([X#p([X#q([X#r([X#s([X#u([X#w([X#y([X#z([X#}([X'u([X(]([X(n([X(u([X(v([X!Y([X!Z([X~O#}$Oi!Y$Oi!Z$Oi~P#AyO#}!oi!Z!oi~P$)gOg'Xa!Y'Xa~P!0rO!Z7[O~O!Y'`a!Z'`a~P#AyO!V7]O~P#.uO!d#vO(n'mO!Y'aa!h'aa~O!Y/iO!h({i~O!Y/iO!d#vO!h({i~Og$zq!Y$zq#]$zq#}$zq~P!0rO!V'ca!Y'ca~P#.uO!d7dO~O!Y/qO!V(|i~P#.uO!Y/qO!V(|i~O!V7gO~Oh%VOo7lO!i%cO(n'mO~O!d#vO#s7nO~Oo7qO!d#vO(n'mO~O}){O'u)|O(v%POk'fa(u'fa!Y'fa#]'fa~Og'fa#}'fa~P&2pO}){O'u)|Ok'ha(u'ha(v'ha!Y'ha#]'ha~Og'ha#}'ha~P&3cO!V7sO~Og$|q!Y$|q#]$|q#}$|q~P!0rOa$my!Y$my'v$my's$my!V$my!h$mys$my![$my%f$my!d$my~P!9}O!d6`O~O!Y4zO![(}a~O![']OP$SaR$Sa[$Sao$Sa}$Sa!P$Sa!Y$Sa!i$Sa!m$Sa#O$Sa#k$Sa#l$Sa#m$Sa#n$Sa#o$Sa#p$Sa#q$Sa#r$Sa#s$Sa#u$Sa#w$Sa#y$Sa#z$Sa(]$Sa(n$Sa(u$Sa(v$Sa~O%f6tO~P&5lOa#`y!Y#`y'v#`y's#`y!V#`y!h#`ys#`y![#`y%f#`y!d#`y~P!9}O[7xO~Ob7zO(P+lO(RTO(UUO~O!Y0xO!Z)Ui~O`8OO~O(a(yO!Y'lX!Z'lX~O!Y5cO!Z)Ra~O!Z8XO~P%9SO(k!sO~P$$iO#X8YO~O![1bO~O![1bO%f8[O~Ok8_O![1bO%f8[O~O[8dO!Y'oa!Z'oa~O!Y1mO!Z)Si~O!h8hO~O!h8iO~O!h8lO~O!h8lO~P%[Oa8nO~O!d8oO~O!h8pO~O!Y(si!Z(si~P#AyOa%lO#]8xO'v%lO~O!Y(py!h(pya(py'v(py~P!9}O!Y(gO!h(oy~O%f8{O~P&5lO![']O%f8{O~O#h$zqP$zqR$zq[$zqa$zqo$zq!P$zq!Y$zq!i$zq!m$zq#O$zq#k$zq#l$zq#m$zq#n$zq#o$zq#p$zq#q$zq#r$zq#s$zq#u$zq#w$zq#y$zq#z$zq'v$zq(]$zq(n$zq!h$zq!V$zq's$zq#]$zqs$zq![$zq%f$zq!d$zq~P#.uO#h'faP'faR'fa['faa'fao'fa!P'fa!i'fa!m'fa#O'fa#k'fa#l'fa#m'fa#n'fa#o'fa#p'fa#q'fa#r'fa#s'fa#u'fa#w'fa#y'fa#z'fa'v'fa(]'fa(n'fa!h'fa!V'fa's'fas'fa!['fa%f'fa!d'fa~P&2pO#h'haP'haR'ha['haa'hao'ha!P'ha!i'ha!m'ha#O'ha#k'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#u'ha#w'ha#y'ha#z'ha'v'ha(]'ha(n'ha!h'ha!V'ha's'has'ha!['ha%f'ha!d'ha~P&3cO#h$|qP$|qR$|q[$|qa$|qo$|q!P$|q!Y$|q!i$|q!m$|q#O$|q#k$|q#l$|q#m$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#u$|q#w$|q#y$|q#z$|q'v$|q(]$|q(n$|q!h$|q!V$|q's$|q#]$|qs$|q![$|q%f$|q!d$|q~P#.uO!Y'Ui!h'Ui~P!9}O#}#`q!Y#`q!Z#`q~P#AyO(u$}OP%^aR%^a[%^ao%^a!P%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a#}%^a(]%^a(n%^a!Y%^a!Z%^a~Ok%^a}%^a'u%^a(v%^a~P&FnO(v%POP%`aR%`a[%`ao%`a!P%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a#}%`a(]%`a(n%`a!Y%`a!Z%`a~Ok%`a}%`a'u%`a(u%`a~P&HuOk=qO}){O'u)|O(v%PO~P&FnOk=qO}){O'u)|O(u$}O~P&HuOR0aO}0aO!P0bO#P$dOPza[zakzaoza!iza!mza#Oza#kza#lza#mza#nza#oza#pza#qza#rza#sza#uza#wza#yza#zza#}za'uza(]za(nza(uza(vza!Yza!Zza~O}){O'u)|OP$qaR$qa[$qak$qao$qa!P$qa!i$qa!m$qa#O$qa#k$qa#l$qa#m$qa#n$qa#o$qa#p$qa#q$qa#r$qa#s$qa#u$qa#w$qa#y$qa#z$qa#}$qa(]$qa(n$qa(u$qa(v$qa!Y$qa!Z$qa~O}){O'u)|OP$saR$sa[$sak$sao$sa!P$sa!i$sa!m$sa#O$sa#k$sa#l$sa#m$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#u$sa#w$sa#y$sa#z$sa#}$sa(]$sa(n$sa(u$sa(v$sa!Y$sa!Z$sa~Ok=qO}){O'u)|O(u$}O(v%PO~OP%RaR%Ra[%Rao%Ra!P%Ra!i%Ra!m%Ra#O%Ra#k%Ra#l%Ra#m%Ra#n%Ra#o%Ra#p%Ra#q%Ra#r%Ra#s%Ra#u%Ra#w%Ra#y%Ra#z%Ra#}%Ra(]%Ra(n%Ra!Y%Ra!Z%Ra~P'#zO#}$lq!Y$lq!Z$lq~P#AyO#}$mq!Y$mq!Z$mq~P#AyO!Z9YO~O#}9ZO~P!0rO!d#vO!Y'ai!h'ai~O!d#vO(n'mO!Y'ai!h'ai~O!Y/iO!h({q~O!V'ci!Y'ci~P#.uO!Y/qO!V(|q~Oo9bO!d#vO(n'mO~O[9dO!V9cO~P#.uO!V9cO~O!d#vO#s9jO~Og(Zy!Y(Zy~P!0rO!Y'ja!['ja~P#.uOa%Yq![%Yq'v%Yq!Y%Yq~P#.uO[9mO~O!Y0xO!Z)Uq~O#]9qO!Y'la!Z'la~O!Y5cO!Z)Ri~P#AyO!P9sO~O![1bO%f9vO~O(RTO(UUO(a9{O~O!Y1mO!Z)Sq~O!h:OO~O!h:PO~O!h:QO~O!h:QO~P%[O#]:TO!Y#ey!Z#ey~O!Y#ey!Z#ey~P#AyO%f:YO~P&5lO![']O%f:YO~O#}#{y!Y#{y!Z#{y~P#AyOP$ziR$zi[$zio$zi!P$zi!i$zi!m$zi#O$zi#k$zi#l$zi#m$zi#n$zi#o$zi#p$zi#q$zi#r$zi#s$zi#u$zi#w$zi#y$zi#z$zi#}$zi(]$zi(n$zi!Y$zi!Z$zi~P'#zO}){O'u)|O(v%POP'eaR'ea['eak'eao'ea!P'ea!i'ea!m'ea#O'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#s'ea#u'ea#w'ea#y'ea#z'ea#}'ea(]'ea(n'ea(u'ea!Y'ea!Z'ea~O}){O'u)|OP'gaR'ga['gak'gao'ga!P'ga!i'ga!m'ga#O'ga#k'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#u'ga#w'ga#y'ga#z'ga#}'ga(]'ga(n'ga(u'ga(v'ga!Y'ga!Z'ga~O(u$}OP%^iR%^i[%^ik%^io%^i}%^i!P%^i!i%^i!m%^i#O%^i#k%^i#l%^i#m%^i#n%^i#o%^i#p%^i#q%^i#r%^i#s%^i#u%^i#w%^i#y%^i#z%^i#}%^i'u%^i(]%^i(n%^i(v%^i!Y%^i!Z%^i~O(v%POP%`iR%`i[%`ik%`io%`i}%`i!P%`i!i%`i!m%`i#O%`i#k%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#u%`i#w%`i#y%`i#z%`i#}%`i'u%`i(]%`i(n%`i(u%`i!Y%`i!Z%`i~O#}$my!Y$my!Z$my~P#AyO#}#`y!Y#`y!Z#`y~P#AyO!d#vO!Y'aq!h'aq~O!Y/iO!h({y~O!V'cq!Y'cq~P#.uOo:dO!d#vO(n'mO~O[:hO!V:gO~P#.uO!V:gO~O!Y0xO!Z)Uy~O!Y5cO!Z)Rq~O(P:nO~O![1bO%f:qO~O!h:tO~O%f:yO~P&5lOP$zqR$zq[$zqo$zq!P$zq!i$zq!m$zq#O$zq#k$zq#l$zq#m$zq#n$zq#o$zq#p$zq#q$zq#r$zq#s$zq#u$zq#w$zq#y$zq#z$zq#}$zq(]$zq(n$zq!Y$zq!Z$zq~P'#zO}){O'u)|O(v%POP'faR'fa['fak'fao'fa!P'fa!i'fa!m'fa#O'fa#k'fa#l'fa#m'fa#n'fa#o'fa#p'fa#q'fa#r'fa#s'fa#u'fa#w'fa#y'fa#z'fa#}'fa(]'fa(n'fa(u'fa!Y'fa!Z'fa~O}){O'u)|OP'haR'ha['hak'hao'ha!P'ha!i'ha!m'ha#O'ha#k'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#u'ha#w'ha#y'ha#z'ha#}'ha(]'ha(n'ha(u'ha(v'ha!Y'ha!Z'ha~OP$|qR$|q[$|qo$|q!P$|q!i$|q!m$|q#O$|q#k$|q#l$|q#m$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#u$|q#w$|q#y$|q#z$|q#}$|q(]$|q(n$|q!Y$|q!Z$|q~P'#zOg%b!Z!Y%b!Z#]%b!Z#}%b!Z~P!0rO!V:}O~P#.uOo;OO!d#vO(n'mO~O[;QO!V:}O~P#.uO!Y'lq!Z'lq~P#AyO!Y#e!Z!Z#e!Z~P#AyO#h%b!ZP%b!ZR%b!Z[%b!Za%b!Zo%b!Z!P%b!Z!Y%b!Z!i%b!Z!m%b!Z#O%b!Z#k%b!Z#l%b!Z#m%b!Z#n%b!Z#o%b!Z#p%b!Z#q%b!Z#r%b!Z#s%b!Z#u%b!Z#w%b!Z#y%b!Z#z%b!Z'v%b!Z(]%b!Z(n%b!Z!h%b!Z!V%b!Z's%b!Z#]%b!Zs%b!Z![%b!Z%f%b!Z!d%b!Z~P#.uOo;YO!d#vO(n'mO~O!V;ZO~P#.uOo;bO!d#vO(n'mO~O!V;cO~P#.uOP%b!ZR%b!Z[%b!Zo%b!Z!P%b!Z!i%b!Z!m%b!Z#O%b!Z#k%b!Z#l%b!Z#m%b!Z#n%b!Z#o%b!Z#p%b!Z#q%b!Z#r%b!Z#s%b!Z#u%b!Z#w%b!Z#y%b!Z#z%b!Z#}%b!Z(]%b!Z(n%b!Z!Y%b!Z!Z%b!Z~P'#zOo;fO!d#vO(n'mO~Os(bX~P1qO}%pO~P!(vO(Q!lO~P!(vO!VfX!YfX#]fX~P%/mOP]XR]X[]Xo]X}]X!P]X!Y]X!YfX!i]X!m]X#O]X#P]X#]]X#]fX#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X(]]X(n]X(u]X(v]X~O!dfX!h]X!hfX(nfX~P'HXOP;jOQ;jOSfOd=fOe!iOmkOo;jOpkOqkOwkOy;jO{;jO!PWO!TkO!UkO![XO!f;mO!iZO!l;jO!m;jO!n;jO!p;nO!r;qO!u!hO$V!kO(P)YO(RTO(UUO(]VO(k[O(z=dO~O!Y;}O!Z$oa~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{<YO!P${O![$|O!f=kO!i$xO#g<`O$V%_O$r<[O$t<^O$w%`O(P(sO(RTO(UUO(]$uO(u$}O(v%PO~O#t)aO~P'L}Oo!bX(n!bX~P# kOo(fX(n(fX~P#!^O!Z]X!ZfX~P'HXO!VfX!V$xX!YfX!Y$xX#]fX~P!/nO#h;rO~O!d#vO#h;rO~O#]<SO~O#s;vO~O#]<dO!Y(sX!Z(sX~O#]<SO!Y(qX!Z(qX~O#h<eO~Og<gO~P!0rO#h<mO~O#h<nO~O!d#vO#h<oO~O!d#vO#h<eO~O#}<pO~P#AyO#h<qO~O#h<rO~O#h<wO~O#h<xO~O#h<yO~O#h<zO~O#}<{O~P!0rO#}<|O~P!0rO#P#Q#R#T#U#X#f#g#r(z$r$t$w%Z%e%f%g%n%p%s%t%v%x~'zT#l!U'x(Q#mp#k#no}'y$['y(P$^(a~",
    goto: "$6w)YPPPPPP)ZPP)^P)oP+P/RPPPP6XPP6oPP<g@VP@jP@jPPP@jPBnP@jP@jP@jPBrPBwPCfPH`PPPHdPPPPHdKgPPPKmL_PHdPHdPPNmHdPPPHdPHdP!!tHdP!&[!'a!'jP!(^!(b!(^!+oPPPPPPP!,`!'aPP!,p!.bP!1nHdHd!1s!5P!9m!9m!=lPPP!=tHdPPPPPPPPPPP!ATP!BbPPHd!CsPHdPHdHdHdHdHdPHd!EVP!HaP!KgP!Kk!Ku!Ky!KyP!H^P!K}!K}P# TP# XHdHd# _#$dBr@jP@jP@j@jP#%q@j@j#(P@j#*s@j#,{@j@j#-k#/{#/{#0Q#0Z#/{#0fP#/{P@j#1O@j#4u@j@j6XPPP#8rPPP#9]#9]P#9]P#9s#9]PP#9yP#9pP#9p#:^#9p#:x#;O#;R)^#;U)^P#;]#;]#;]P)^P)^P)^P)^PP)^P#;c#;fP#;f)^P#;jP#;mP)^P)^P)^P)^P)^P)^)^PP#;s#;y#<U#<[#<b#<h#<n#<|#=S#=^#=d#=n#=t#>U#>[#>|#?`#?f#?l#?z#@a#BQ#B`#Bg#C}#D]#Ey#FX#F_#Fe#Fk#Fu#F{#GR#G]#Go#GuPPPPPPPPPPP#G{PPPPPPP#Hp#Kw#Ma#Mh#MpPPP$%OP$%X$(Q$.k$.n$.q$/p$/s$/z$0SP$0Y$0]P$0y$0}$1u$3T$3Y$3pPP$3u$3{$4PP$4S$4W$4[$5W$5o$6W$6[$6_$6b$6h$6k$6o$6sR!|RoqOXst!Z#d%k&o&q&r&t,l,q1}2QY!vQ']-^1b5iQ%rvQ%zyQ&R|Q&g!VS'T!e-UQ'c!iS'i!r!yU*g$|*W*kQ+j%{Q+w&TQ,]&aQ-['[Q-f'dQ-n'jQ0S*mQ1l,^R<a;n%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(Q(S(Y(a(u(w({)z*e+S+W,i,l,q-b-j-x.O.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3_4l5q6R6S6V6j8_8n8xS#q];k!r)[$Z$n'U)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gU*z%[<X<YQ+o%}Q,_&dQ,f&lQ0n+bQ0r+dQ0}+pQ1t,dQ3R.`Q5T0xQ5x1mQ6v3VQ7z5UR9O6x'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=g!S!nQ!r!v!y!z$|'T'[']'i'j'k*g*k*m*n-U-[-^-n0S0V1b5i5k%S$ti#v$b$c$d$x${%O%Q%]%^%b)v*O*Q*S*V*]*c*s*t+a+d+{,O._.x/]/f/p/q/s0W0Y0e1X1[1d3U4P4Q4[4a4r4z4}5p6t7d7n8[8{9Z9d9j9v:Y:h:q:y;Q<Q<R<T<U<V<W<Z<[<]<^<_<`<h<i<j<k<m<n<q<r<s<t<u<v<w<x<{<|=d=l=m=p=qQ&U|Q'R!eS'X%g-XQ+o%}Q,_&dQ0d*}Q0}+pQ1S+vQ1s,cQ1t,dQ5T0xQ5^1UQ5x1mQ5{1oQ5|1rQ7z5UQ7}5ZQ8g6OQ9p8OQ9|8dR<c*WrnOXst!V!Z#d%k&f&o&q&r&t,l,q1}2QR,a&h&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=f=g[#]WZ#W#Z'U(Q!b%hm#h#i#l$x%c%f(Z(e(f(g*V*Z*^+U+V+X,h-O-|.S.T.U.W/f/i2V2}3O4S6`6qQ%uxQ%yyS&O|&TQ&[!TQ'`!hQ'b!iQ(n#sS+i%z%{Q+m%}Q,W&_Q,[&aS-e'c'dQ.b(oQ0v+jQ0|+pQ1O+qQ1R+uQ1g,XS1k,],^Q2o-fQ5S0xQ5W0{Q5]1TQ5w1lQ7y5UQ7|5YQ9l7xR:k9m!O$zi$d%O%Q%]%^%b*O*Q*]*s*t.x/p0W0Y0e4Q4r9Z=d=l=m!^%wy!i!u%y%z%{'S'b'c'd'h'r*f+i+j-R-e-f-m/y/|0v2h2o2v4d4e4h7k9fQ+c%uQ+|&XQ,P&YQ,Z&aQ.a(nQ1f,WU1j,[,],^Q3W.bQ5r1gS5v1k1lQ8c5w#d=h#v$b$c$x${)v*S*V*c+a+d+{,O._/]/f/q/s1X1[1d3U4P4[4a4z4}5p6t7d7n8[8{9d9j9v:Y:h:q:y;Q<T<V<Z<]<_<h<j<m<q<s<u<w<{=p=qo=i<Q<R<U<W<[<^<`<i<k<n<r<t<v<x<|W%Ti%V*u=dS&X!Q&fQ&Y!RQ&Z!SR+z&V%T%Si#v$b$c$d$x${%O%Q%]%^%b)v*O*Q*S*V*]*c*s*t+a+d+{,O._.x/]/f/p/q/s0W0Y0e1X1[1d3U4P4Q4[4a4r4z4}5p6t7d7n8[8{9Z9d9j9v:Y:h:q:y;Q<Q<R<T<U<V<W<Z<[<]<^<_<`<h<i<j<k<m<n<q<r<s<t<u<v<w<x<{<|=d=l=m=p=qT)w$u)xV*z%[<X<YW'X!e%g*W-XS(z#y#zQ+^%pQ+t&QS.Z(j(kQ1],QQ4s0aR8S5c'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=g$i$^c#Y#e%o%q%s(P(V(q(v)O)P)Q)R)S)T)U)V)W)X)Z)])_)d)n+_+s-S-q-v-{-}.l.o.s.u.v.w/Z0f2^2a2q2x3^3c3d3e3f3g3h3i3j3k3l3m3n3o3r3s3z4w5Q6c6i6n6}7O7X7Y8U8r8v9Q9W9X:V:m:u;l=ZT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gQ'V!eR2d-U!W!nQ!e!r!v!y!z$|'T'[']'i'j'k*W*g*k*m*n-U-[-^-n0S0V1b5i5kR1_,SnqOXst!Z#d%k&o&q&r&t,l,q1}2QQ&v!^Q's!xS(p#u;rQ+g%xQ,U&[Q,V&^Q-c'aQ-p'lS.k(u<eS0g+S<oQ0t+hQ1a,TQ2U,sQ2W,tQ2`-PQ2m-dQ2p-hS4x0h<yQ5O0uS5R0w<zQ6b2bQ6f2nQ6k2uQ7w5PQ8s6dQ8t6gQ8w6lR:S8p$d$]c#Y#e%q%s(P(V(q(v)O)P)Q)R)S)T)U)V)W)X)Z)])_)d)n+_+s-S-q-v-{-}.l.o.s.v.w/Z0f2^2a2q2x3^3c3d3e3f3g3h3i3j3k3l3m3n3o3r3s3z4w5Q6c6i6n6}7O7X7Y8U8r8v9Q9W9X:V:m:u;l=ZS(l#p'fQ(|#zS+]%o.uS.[(k(mR3P.]'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gS#q];kQ&q!XQ&r!YQ&t![Q&u!]R1|,oQ'^!hQ+`%uQ-a'`S.^(n+cQ2k-`W3T.a.b0m0oQ6e2lW6r3Q3S3W4|U8z6s6u6wU:X8|8}9PS:w:W:ZQ;U:xR;^;VU!wQ']-^T5g1b5i!Q_OXZ`st!V!Z#d#h%c%k&f&h&o&q&r&t(g,l,q.T1}2Q]!pQ!r']-^1b5iT#q];k%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(Q(S(Y(a(u(w({)z*e+S+W+b,i,l,q-b-j-x.O.`.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3V3_4l5q6R6S6V6j6x8_8n8xS(z#y#zS.Z(j(k!s=Q$Z$n'U)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gU$fd)[,fS(m#p'fU*r%R(t3qU0c*y.g7TQ4|0nQ6s3RQ8}6vR:Z9Om!tQ!r!v!y!z']'i'j'k-^-n1b5i5kQ'q!uS(c#g1wS-l'h'tQ/l*YQ/y*fQ2w-oQ4W/mQ4d/{Q4e/|Q4j0UQ7`4RS7k4f4hS7o4k4mQ9]7aQ9a7gQ9f7lQ9k7qS:c9b9cS:|:d:gS;X:};OS;a;Y;ZS;e;b;cR;h;fQ#wbQ'p!uS(b#g1wS(d#m+RQ+T%dQ+e%vQ+k%|U-k'h'q'tQ.P(cQ/k*YQ/z*fQ/}*hQ0s+fQ1h,YS2t-l-oQ2|.XS4V/l/mQ4`/wS4c/y0UQ4g0OQ5t1iQ6m2wQ7_4RQ7c4WU7j4d4j4mQ7m4iQ8a5uS9[7`7aQ9`7gQ9h7oQ9i7pQ9y8bQ:a9]S:b9a9cQ:j9kQ:s9zS:{:c:gS;W:|:}S;`;X;ZS;d;a;cQ;g;eQ;i;hQ=T=OQ=`=XR=a=YV!wQ']-^%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(Q(S(Y(a(u(w({)z*e+S+W+b,i,l,q-b-j-x.O.`.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3V3_4l5q6R6S6V6j6x8_8n8xS#wz!j!r<}$Z$n'U)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gR=T=f%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(Q(S(Y(a(u(w({)z*e+S+W+b,i,l,q-b-j-x.O.`.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3V3_4l5q6R6S6V6j6x8_8n8xQ%dj!^%vy!i!u%y%z%{'S'b'c'd'h'r*f+i+j-R-e-f-m/y/|0v2h2o2v4d4e4h7k9fS%|z!jQ+f%wQ,Y&aW1i,Z,[,],^U5u1j1k1lS8b5v5wQ9z8c!r=O$Z$n'U)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gQ=X=eR=Y=f%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(S(Y(a(u(w({)z*e+S+W+b,i,l,q-b-j-x.O.`.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3V3_4l5q6R6S6V6j6x8_8n8xY#bWZ#W#Z(Q!b%hm#h#i#l$x%c%f(Z(e(f(g*V*Z*^+U+V+X,h-O-|.S.T.U.W/f/i2V2}3O4S6`6qQ,g&l!p=P$Z$n)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gR=S'UU'Y!e%g*WR2f-X%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(Q(S(Y(a(u(w({)z*e+S+W,i,l,q-b-j-x.O.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3_4l5q6R6S6V6j8_8n8x!r)[$Z$n'U)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gQ,f&lQ0n+bQ3R.`Q6v3VR9O6x!b$Tc#Y%o(P(V(q(v)W)X)])d+s-q-v-{-}.l.o/Z0f2q2x3^3n4w5Q6i6n6}8v:V;l!P;x)Z)n-S.u2^2a3c3l3m3r3z6c7O7X7Y8U8r9Q9W9X:m:u=Z!f$Vc#Y%o(P(V(q(v)T)U)W)X)])d+s-q-v-{-}.l.o/Z0f2q2x3^3n4w5Q6i6n6}8v:V;l!T;z)Z)n-S.u2^2a3c3i3j3l3m3r3z6c7O7X7Y8U8r9Q9W9X:m:u=Z!^$Zc#Y%o(P(V(q(v)])d+s-q-v-{-}.l.o/Z0f2q2x3^3n4w5Q6i6n6}8v:V;lQ4Q/dz=g)Z)n-S.u2^2a3c3r3z6c7O7X7Y8U8r9Q9W9X:m:u=ZQ=l=nR=m=o'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gS$oh$pR3w.}'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t.}/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gT$kf$qQ$ifS)g$l)kR)s$qT$jf$qT)i$l)k'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(Q(S(Y(a(u(w({)p)z*e+S+W+b,i,l,q,}-Q-b-j-x.O.`.m.t.}/O/g0T0b0h0w1e1u1v1x1z1}2Q2S2c2s2y3V3_3v4l5e5q6R6S6V6a6j6x8_8n8x9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=gT$oh$pQ$rhR)r$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(Q(S(Y(a(u(w({)z*e+S+W+b,i,l,q-b-j-x.O.`.m.t/g0T0b0h0w1e1u1v1x1z1}2Q2S2s2y3V3_4l5q6R6S6V6j6x8_8n8x!s=e$Z$n'U)p,}-Q/O2c3v5e6a9q:T;j;m;n;q;r;s;t;u;v;w;x;y;z;{;|;}<P<S<a<d<e<g<o<p<y<z=g#glOPXZst!Z!`!o#S#d#o#{$n%k&h&k&l&o&q&r&t&x'Q'_({)p*e+W+b,i,l,q-b.`/O/g0T0b1e1u1v1x1z1}2Q2S3V3v4l5q6R6S6V6x8_8n!O%Ri$d%O%Q%]%^%b*O*Q*]*s*t.x/p0W0Y0e4Q4r9Z=d=l=m#d(t#v$b$c$x${)v*S*V*c+a+d+{,O._/]/f/q/s1X1[1d3U4P4[4a4z4}5p6t7d7n8[8{9d9j9v:Y:h:q:y;Q<T<V<Z<]<_<h<j<m<q<s<u<w<{=p=qQ+O%`Q/[){o3q<Q<R<U<W<[<^<`<i<k<n<r<t<v<x<|!O$yi$d%O%Q%]%^%b*O*Q*]*s*t.x/p0W0Y0e4Q4r9Z=d=l=mQ*_$zU*h$|*W*kQ+P%aQ0O*i#d=V#v$b$c$x${)v*S*V*c+a+d+{,O._/]/f/q/s1X1[1d3U4P4[4a4z4}5p6t7d7n8[8{9d9j9v:Y:h:q:y;Q<T<V<Z<]<_<h<j<m<q<s<u<w<{=p=qn=W<Q<R<U<W<[<^<`<i<k<n<r<t<v<x<|Q=[=hQ=]=iQ=^=jR=_=k!O%Ri$d%O%Q%]%^%b*O*Q*]*s*t.x/p0W0Y0e4Q4r9Z=d=l=m#d(t#v$b$c$x${)v*S*V*c+a+d+{,O._/]/f/q/s1X1[1d3U4P4[4a4z4}5p6t7d7n8[8{9d9j9v:Y:h:q:y;Q<T<V<Z<]<_<h<j<m<q<s<u<w<{=p=qo3q<Q<R<U<W<[<^<`<i<k<n<r<t<v<x<|noOXst!Z#d%k&o&q&r&t,l,q1}2QS*b${*VQ,z&{Q,{&}R4Z/q%S%Si#v$b$c$d$x${%O%Q%]%^%b)v*O*Q*S*V*]*c*s*t+a+d+{,O._.x/]/f/p/q/s0W0Y0e1X1[1d3U4P4Q4[4a4r4z4}5p6t7d7n8[8{9Z9d9j9v:Y:h:q:y;Q<Q<R<T<U<V<W<Z<[<]<^<_<`<h<i<j<k<m<n<q<r<s<t<u<v<w<x<{<|=d=l=m=p=qQ+}&YQ1Z,PQ5a1YR8R5bV*j$|*W*kU*j$|*W*kT5h1b5iS/w*e/gQ4i0TT7p4l9sQ+e%vQ/}*hQ0s+fQ1h,YQ5t1iQ8a5uQ9y8bR:s9z!O%Oi$d%O%Q%]%^%b*O*Q*]*s*t.x/p0W0Y0e4Q4r9Z=d=l=mr*O$v)b*P*q+Q/o0[0]3t4X4v7^7r:`=U=b=cS0W*p0X#d<T#v$b$c$x${)v*S*V*c+a+d+{,O._/]/f/q/s1X1[1d3U4P4[4a4z4}5p6t7d7n8[8{9d9j9v:Y:h:q:y;Q<T<V<Z<]<_<h<j<m<q<s<u<w<{=p=qn<U<Q<R<U<W<[<^<`<i<k<n<r<t<v<x<|!b<h(r)`*X*a.c.f.j/W/d/t0l1W3Z3}4Y4^5`6y6|7e7h7t7v9_9g:e:i:z;P;[=n=o`<i3p7P7S7W9R:[:_;_S<s.e3[T<t7R9U!O%Qi$d%O%Q%]%^%b*O*Q*]*s*t.x/p0W0Y0e4Q4r9Z=d=l=mv*Q$v)b*R*p+Q/`/o0[0]3t4X4n4v7^7r:`=U=b=cS0Y*q0Z#d<V#v$b$c$x${)v*S*V*c+a+d+{,O._/]/f/q/s1X1[1d3U4P4[4a4z4}5p6t7d7n8[8{9d9j9v:Y:h:q:y;Q<T<V<Z<]<_<h<j<m<q<s<u<w<{=p=qn<W<Q<R<U<W<[<^<`<i<k<n<r<t<v<x<|!f<j(r)`*X*a.d.e.j/W/d/t0l1W3X3Z3}4Y4^5`6y6z6|7e7h7t7v9_9g:e:i:z;P;[=n=od<k3p7Q7R7W9R9S:[:]:_;_S<u.f3]T<v7S9VrnOXst!V!Z#d%k&f&o&q&r&t,l,q1}2QQ&c!UR,i&lrnOXst!V!Z#d%k&f&o&q&r&t,l,q1}2QR&c!UQ,R&ZR1V+zsnOXst!V!Z#d%k&f&o&q&r&t,l,q1}2QQ1c,WS5o1f1gU8Z5m5n5rS9u8]8^S:o9t9wQ;R:pR;];SQ&j!VR,b&fR5{1oR9|8dS&O|&TR1O+qQ&o!WR,l&pR,r&uT2O,q2QR,v&vQ,u&vR2X,vQ'v!{R-r'vSsOtQ#dXT%ns#dQ#OTR'x#OQ#RUR'z#RQ)x$uR/X)xQ#UVR'}#UQ#XWU(T#X(U-yQ(U#YR-y(VQ-V'VR2e-VQ.n(vS3`.n3aR3a.oQ-^']R2i-^Y!rQ']-^1b5iR'g!rQ.y)bR3u.yU#_W%f*VU([#_(]-zQ(]#`R-z(WQ-Y'YR2g-Yt`OXst!V!Z#d%k&f&h&o&q&r&t,l,q1}2QS#hZ%cU#r`#h.TR.T(gQ(h#jQ.Q(dW.Y(h.Q2z6oQ2z.RR6o2{Q)k$lR/P)kQ$phR)q$pQ$`cU)^$`-u<OQ-u;lR<O)nQ/j*YW4T/j4U7b9^U4U/k/l/mS7b4V4WR9^7c$])}$v(r)`)b*X*a*p*q*{*|+Q.e.f.h.i.j/W/`/b/d/o/t0[0]0l1W3X3Y3Z3p3t3}4X4Y4^4n4p4v5`6y6z6{6|7R7S7U7V7W7^7e7h7r7t7v9R9S9T9_9g:[:]:^:_:`:e:i:z;P;[;_=U=b=c=n=oQ/r*aU4]/r4_7fQ4_/tR7f4^S*k$|*WR0Q*kr*P$v)b*p*q+Q/o0[0]3t4X4v7^7r:`=U=b=c!b.c(r)`*X*a.e.f.j/W/d/t0l1W3Z3}4Y4^5`6y6|7e7h7t7v9_9g:e:i:z;P;[=n=oU/a*P.c7Pa7P3p7R7S7W9R:[:_;_Q0X*pQ3[.eU4o0X3[9UR9U7Rv*R$v)b*p*q+Q/`/o0[0]3t4X4n4v7^7r:`=U=b=c!f.d(r)`*X*a.e.f.j/W/d/t0l1W3X3Z3}4Y4^5`6y6z6|7e7h7t7v9_9g:e:i:z;P;[=n=oU/c*R.d7Qe7Q3p7R7S7W9R9S:[:]:_;_Q0Z*qQ3].fU4q0Z3]9VR9V7SQ*v%UR0_*vQ4{0lR7u4{Q+Y%iR0k+YQ5d1]S8T5d9rR9r8UQ,T&[R1`,TQ5i1bR8W5iQ1n,_S5y1n8eR8e5{Q0y+mW5V0y5X7{9nQ5X0|Q7{5WR9n7|Q+r&OR1P+rQ2Q,qR6Z2QYrOXst#dQ&s!ZQ+[%kQ,k&oQ,m&qQ,n&rQ,p&tQ1{,lS2O,q2QR6Y1}Q%mpQ&w!_Q&z!aQ&|!bQ'O!cQ'n!uQ+Z%jQ+g%xQ+y&UQ,a&jQ,x&yW-i'h'p'q'tQ-p'lQ0P*jQ0t+hS1q,b,eQ2Y,wQ2Z,zQ2[,{Q2p-hW2r-k-l-o-qQ5O0uQ5[1SQ5_1WQ5s1hQ5}1sQ6X1|U6h2q2t2wQ6k2uQ7w5PQ8P5^Q8Q5`Q8V5hQ8`5tQ8f5|S8u6i6mQ8w6lQ9o7}Q9x8aQ9}8gQ:U8vQ:l9pQ:r9yQ:v:VR;T:sQ%xyQ'a!iQ'l!uU+h%y%z%{Q-P'SU-d'b'c'dS-h'h'rQ/x*fS0u+i+jQ2b-RS2n-e-fQ2u-mS4b/y/|Q5P0vQ6d2hQ6g2oQ6l2vU7i4d4e4hQ9e7kR:f9fS$wi=dR*w%VU%Ui%V=dR0^*uQ$viS(r#v+dS)`$b$cQ)b$dQ*X$xS*a${*VQ*p%OQ*q%QQ*{%]Q*|%^Q+Q%bQ.e<TQ.f<VQ.h<ZQ.i<]Q.j<_Q/W)vQ/`*OQ/b*QQ/d*SQ/o*]S/t*c/fQ0[*sQ0]*tl0l+a,O._1[1d3U5p6t8[8{9v:Y:q:yQ1W+{Q3X<hQ3Y<jQ3Z<mS3p<Q<RQ3t.xS3}/]4PQ4X/pQ4Y/qQ4^/sQ4n0WQ4p0YQ4v0eQ5`1XQ6y<qQ6z<sQ6{<uQ6|<wQ7R<UQ7S<WQ7U<[Q7V<^Q7W<`Q7^4QQ7e4[Q7h4aQ7r4rQ7t4zQ7v4}Q9R<nQ9S<iQ9T<kQ9_7dQ9g7nQ:[<rQ:]<tQ:^<vQ:_<xQ:`9ZQ:e9dQ:i9jQ:z<{Q;P:hQ;[;QQ;_<|Q=U=dQ=b=lQ=c=mQ=n=pR=o=qQ*y%[Q.g<XR7T<YnpOXst!Z#d%k&o&q&r&t,l,q1}2QQ!fPS#fZ#oQ&y!`W'e!o*e0T4lQ'|#SQ(}#{Q)o$nS,e&h&kQ,j&lQ,w&xS,|'Q/gQ-`'_Q.q({Q/T)pQ0i+WQ0o+bQ1y,iQ2l-bQ3S.`Q3y/OQ4t0bQ5n1eQ6P1uQ6Q1vQ6U1xQ6W1zQ6]2SQ6w3VQ7Z3vQ8^5qQ8j6RQ8k6SQ8m6VQ9P6xQ9w8_R:R8n#[cOPXZst!Z!`!o#d#o#{%k&h&k&l&o&q&r&t&x'Q'_({*e+W+b,i,l,q-b.`/g0T0b1e1u1v1x1z1}2Q2S3V4l5q6R6S6V6x8_8nQ#YWQ#eYQ%ouQ%qvS%sw!gS(P#W(SQ(V#ZQ(q#uQ(v#xQ)O$OQ)P$PQ)Q$QQ)R$RQ)S$SQ)T$TQ)U$UQ)V$VQ)W$WQ)X$XQ)Z$ZQ)]$_Q)_$aQ)d$eW)n$n)p/O3vQ+_%rQ+s&PS-S'U2cQ-q'oS-v(Q-xQ-{(YQ-}(aQ.l(uQ.o(wQ.s;jQ.u;mQ.v;nQ.w;qQ/Z)zQ0f+SQ2^,}Q2a-QQ2q-jQ2x.OQ3^.mQ3c;rQ3d;sQ3e;tQ3f;uQ3g;vQ3h;wQ3i;xQ3j;yQ3k;zQ3l;{Q3m;|Q3n.tQ3o<PQ3r<SQ3s<aQ3z;}Q4w0hQ5Q0wQ6c<dQ6i2sQ6n2yQ6}3_Q7O<eQ7X<gQ7Y<oQ8U5eQ8r6aQ8v6jQ9Q<pQ9W<yQ9X<zQ:V8xQ:m9qQ:u:TQ;l#SR=Z=gR#[WR'W!el!tQ!r!v!y!z']'i'j'k-^-n1b5i5kS'S!e-UU*f$|*W*kS-R'T'[S/|*g*mQ0U*nQ2h-[Q4h0SR4m0VR(x#xQ!fQT-]']-^]!qQ!r']-^1b5iQ#p]R'f;kR)c$dY!uQ']-^1b5iQ'h!rS'r!v!yS't!z5kS-m'i'jQ-o'kR2v-nT#kZ%cS#jZ%cS%im,hU(d#h#i#lS.R(e(fQ.V(gQ0j+XQ2{.SU2|.T.U.WS6p2}3OR8y6qd#^W#W#Z%f(Q(Z*V+U-|/fr#gZm#h#i#l%c(e(f(g+X.S.T.U.W2}3O6qS*Y$x*^Q/m*ZQ1w,hQ2_-OQ4R/iQ6_2VQ7a4SQ8q6`T=R'U+VV#aW%f*VU#`W%f*VS(R#W(ZU(W#Z+U/fS-T'U+VT-w(Q-|V'Z!e%g*WQ$lfR)u$qT)j$l)kR3x.}T*[$x*^T*d${*VQ0m+aQ1Y,OQ3Q._Q5b1[Q5m1dQ6u3UQ8]5pQ8|6tQ9t8[Q:W8{Q:p9vQ:x:YQ;S:qR;V:ynqOXst!Z#d%k&o&q&r&t,l,q1}2QQ&i!VR,a&ftmOXst!U!V!Z#d%k&f&o&q&r&t,l,q1}2QR,h&lT%jm,hR1^,QR,`&dQ&S|R+x&TR+n%}T&m!W&pT&n!W&pT2P,q2Q",
    nodeNames: "\u26A0 ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
    maxTerm: 377,
    context: trackNewline,
    nodeProps: [
      ["isolate", -8, 5, 6, 14, 34, 36, 48, 50, 52, ""],
      ["group", -26, 9, 17, 19, 65, 204, 208, 212, 213, 215, 218, 221, 231, 233, 239, 241, 243, 245, 248, 254, 260, 262, 264, 266, 268, 270, 271, "Statement", -34, 13, 14, 29, 32, 33, 39, 48, 51, 52, 54, 59, 67, 69, 73, 77, 79, 81, 82, 107, 108, 117, 118, 135, 138, 140, 141, 142, 143, 144, 146, 147, 166, 167, 169, "Expression", -23, 28, 30, 34, 38, 40, 42, 171, 173, 175, 176, 178, 179, 180, 182, 183, 184, 186, 187, 188, 198, 200, 202, 203, "Type", -3, 85, 100, 106, "ClassItem"],
      ["openedBy", 23, "<", 35, "InterpolationStart", 53, "[", 57, "{", 70, "(", 159, "JSXStartCloseTag"],
      ["closedBy", 24, ">", 37, "InterpolationEnd", 47, "]", 58, "}", 71, ")", 164, "JSXEndTag"]
    ],
    propSources: [jsHighlight],
    skippedNodes: [0, 5, 6, 274],
    repeatNodeCount: 37,
    tokenData: "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$h&j(V!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(V!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$h&j(SpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(SpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Sp(V!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$h&j(Sp(V!b'x0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(T#S$h&j'y0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$h&j(Sp(V!b'y0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$h&j!m),Q(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#u(Ch$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#u(Ch$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(R':f$h&j(V!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$h&j(V!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$h&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$c`$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$c``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$c`$h&j(V!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(V!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$c`(V!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$h&j(Sp(V!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$h&j(Sp(V!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$h&j(V!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$h&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(V!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$h&j(SpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(SpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Sp(V!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$h&j(k%1l(Sp(V!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$h&j(Sp(V!b$[#t(P,2j(a$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$h&j(Sp(V!b$[#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$h&j(Sp(V!b#m(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$h&j$P(Ch(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(v+JY$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$h&j#y(Ch(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(U';W$h&j(SpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$h&j(SpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$h&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$c`$h&j(SpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(SpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$c`(SpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!i/.^$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!h!Lf$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$h&j(Sp(V!b(Q%&f#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$h&j(Sp(V!b#k(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$h&j(Sp(V!bo+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!Y+Jf$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$h&j(Sp(V!b}.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_!X!L^$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$h&j(Sp(V!b#l(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$h&j(Sp(V!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$h&j(V!b!U7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$h&j!U7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$h&j!U7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!U7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!U7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$h&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$h&j(V!b!U7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(V!b!U7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(V!b!U7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(V!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$h&j(V!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$h&j(Sp!U7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$h&j(Sp!U7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Sp!U7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Sp!U7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(SpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$h&j(SpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$h&j(Sp(V!b!U7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Sp(V!b!U7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Sp(V!b!U7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Sp(V!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$h&j(Sp(V!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$h&j(Sp(V!b'z0/l!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$h&j(Sp(V!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$h&j(V!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$h&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(V!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$h&j(SpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(SpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Sp(V!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$h&j$P(Ch(Sp(V!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Y#t$h&j(Sp(V!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$h&j(Sp(V!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!d$b$h&j#})Lv(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#O-<U(Sp(V!b(z7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$j&j(Sp(V!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#o(Ch(Sp(V!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$P(Ch(Sp(V!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#p(Ch(Sp(V!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#]*!Y$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#h(Cl$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#p(Ch$e#|$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#p(Ch$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#o(Ch$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#o(Ch$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(n(Ct$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$h&j#z(Ch(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!y$Ip$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!P0,v$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$h&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$h&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$h&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$h&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$h&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!V#)l$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#w(Ch$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$h&j(Sp(V!b(]+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$h&j(Sp(V!b(P,2j$^#t(a$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$h&j(Sp(V!b$^#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X![#Hb(Sp(V!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(u+JY$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_!Z(CdsBr$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!n7`$h&j(Sp(V!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$h&j(Sp(V!b'x0/l$[#t(P,2j(a$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$h&j(Sp(V!b'y0/l$[#t(P,2j(a$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
    tokenizers: [noSemicolon, noSemicolonType, operatorToken, jsx, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, insertSemicolon, new LocalTokenGroup("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOu~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!R~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(_~~", 141, 336), new LocalTokenGroup("j~RQYZXz{^~^O'|~~aP!P!Qd~iO'}~~", 25, 319)],
    topRules: { "Script": [0, 7], "SingleExpression": [1, 272], "SingleClassItem": [2, 273] },
    dialects: { jsx: 0, ts: 14980 },
    dynamicPrecedences: { "77": 1, "79": 1, "91": 1, "167": 1, "196": 1 },
    specialized: [{ term: 323, get: (value12) => spec_identifier[value12] || -1 }, { term: 339, get: (value12) => spec_word[value12] || -1 }, { term: 92, get: (value12) => spec_LessThan[value12] || -1 }],
    tokenPrec: 15004
  });

  // node_modules/@codemirror/lang-javascript/dist/index.js
  var snippets = [
    /* @__PURE__ */ snippetCompletion("function ${name}(${params}) {\n	${}\n}", {
      label: "function",
      detail: "definition",
      type: "keyword"
    }),
    /* @__PURE__ */ snippetCompletion("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
      label: "for",
      detail: "loop",
      type: "keyword"
    }),
    /* @__PURE__ */ snippetCompletion("for (let ${name} of ${collection}) {\n	${}\n}", {
      label: "for",
      detail: "of loop",
      type: "keyword"
    }),
    /* @__PURE__ */ snippetCompletion("do {\n	${}\n} while (${})", {
      label: "do",
      detail: "loop",
      type: "keyword"
    }),
    /* @__PURE__ */ snippetCompletion("while (${}) {\n	${}\n}", {
      label: "while",
      detail: "loop",
      type: "keyword"
    }),
    /* @__PURE__ */ snippetCompletion("try {\n	${}\n} catch (${error}) {\n	${}\n}", {
      label: "try",
      detail: "/ catch block",
      type: "keyword"
    }),
    /* @__PURE__ */ snippetCompletion("if (${}) {\n	${}\n}", {
      label: "if",
      detail: "block",
      type: "keyword"
    }),
    /* @__PURE__ */ snippetCompletion("if (${}) {\n	${}\n} else {\n	${}\n}", {
      label: "if",
      detail: "/ else block",
      type: "keyword"
    }),
    /* @__PURE__ */ snippetCompletion("class ${name} {\n	constructor(${params}) {\n		${}\n	}\n}", {
      label: "class",
      detail: "definition",
      type: "keyword"
    }),
    /* @__PURE__ */ snippetCompletion('import {${names}} from "${module}"\n${}', {
      label: "import",
      detail: "named",
      type: "keyword"
    }),
    /* @__PURE__ */ snippetCompletion('import ${name} from "${module}"\n${}', {
      label: "import",
      detail: "default",
      type: "keyword"
    })
  ];
  var typescriptSnippets = /* @__PURE__ */ snippets.concat([
    /* @__PURE__ */ snippetCompletion("interface ${name} {\n	${}\n}", {
      label: "interface",
      detail: "definition",
      type: "keyword"
    }),
    /* @__PURE__ */ snippetCompletion("type ${name} = ${type}", {
      label: "type",
      detail: "definition",
      type: "keyword"
    }),
    /* @__PURE__ */ snippetCompletion("enum ${name} {\n	${}\n}", {
      label: "enum",
      detail: "definition",
      type: "keyword"
    })
  ]);
  var cache = /* @__PURE__ */ new NodeWeakMap();
  var ScopeNodes = /* @__PURE__ */ new Set([
    "Script",
    "Block",
    "FunctionExpression",
    "FunctionDeclaration",
    "ArrowFunction",
    "MethodDeclaration",
    "ForStatement"
  ]);
  function defID(type) {
    return (node, def) => {
      let id5 = node.node.getChild("VariableDefinition");
      if (id5)
        def(id5, type);
      return true;
    };
  }
  var functionContext = ["FunctionDeclaration"];
  var gatherCompletions = {
    FunctionDeclaration: /* @__PURE__ */ defID("function"),
    ClassDeclaration: /* @__PURE__ */ defID("class"),
    ClassExpression: () => true,
    EnumDeclaration: /* @__PURE__ */ defID("constant"),
    TypeAliasDeclaration: /* @__PURE__ */ defID("type"),
    NamespaceDeclaration: /* @__PURE__ */ defID("namespace"),
    VariableDefinition(node, def) {
      if (!node.matchContext(functionContext))
        def(node, "variable");
    },
    TypeDefinition(node, def) {
      def(node, "type");
    },
    __proto__: null
  };
  function getScope(doc2, node) {
    let cached = cache.get(node);
    if (cached)
      return cached;
    let completions = [], top4 = true;
    function def(node2, type) {
      let name16 = doc2.sliceString(node2.from, node2.to);
      completions.push({ label: name16, type });
    }
    node.cursor(IterMode.IncludeAnonymous).iterate((node2) => {
      if (top4) {
        top4 = false;
      } else if (node2.name) {
        let gather = gatherCompletions[node2.name];
        if (gather && gather(node2, def) || ScopeNodes.has(node2.name))
          return false;
      } else if (node2.to - node2.from > 8192) {
        for (let c2 of getScope(doc2, node2.node))
          completions.push(c2);
        return false;
      }
    });
    cache.set(node, completions);
    return completions;
  }
  var Identifier = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/;
  var dontComplete = [
    "TemplateString",
    "String",
    "RegExp",
    "LineComment",
    "BlockComment",
    "VariableDefinition",
    "TypeDefinition",
    "Label",
    "PropertyDefinition",
    "PropertyName",
    "PrivatePropertyDefinition",
    "PrivatePropertyName",
    ".",
    "?."
  ];
  function localCompletionSource(context3) {
    let inner = syntaxTree(context3.state).resolveInner(context3.pos, -1);
    if (dontComplete.indexOf(inner.name) > -1)
      return null;
    let isWord = inner.name == "VariableName" || inner.to - inner.from < 20 && Identifier.test(context3.state.sliceDoc(inner.from, inner.to));
    if (!isWord && !context3.explicit)
      return null;
    let options2 = [];
    for (let pos = inner; pos; pos = pos.parent) {
      if (ScopeNodes.has(pos.name))
        options2 = options2.concat(getScope(context3.state.doc, pos));
    }
    return {
      options: options2,
      from: isWord ? inner.from : context3.pos,
      validFor: Identifier
    };
  }
  var javascriptLanguage = /* @__PURE__ */ LRLanguage.define({
    name: "javascript",
    parser: /* @__PURE__ */ parser.configure({
      props: [
        /* @__PURE__ */ indentNodeProp.add({
          IfStatement: /* @__PURE__ */ continuedIndent({ except: /^\s*({|else\b)/ }),
          TryStatement: /* @__PURE__ */ continuedIndent({ except: /^\s*({|catch\b|finally\b)/ }),
          LabeledStatement: flatIndent,
          SwitchBody: (context3) => {
            let after = context3.textAfter, closed = /^\s*\}/.test(after), isCase = /^\s*(case|default)\b/.test(after);
            return context3.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context3.unit;
          },
          Block: /* @__PURE__ */ delimitedIndent({ closing: "}" }),
          ArrowFunction: (cx) => cx.baseIndent + cx.unit,
          "TemplateString BlockComment": () => null,
          "Statement Property": /* @__PURE__ */ continuedIndent({ except: /^{/ }),
          JSXElement(context3) {
            let closed = /^\s*<\//.test(context3.textAfter);
            return context3.lineIndent(context3.node.from) + (closed ? 0 : context3.unit);
          },
          JSXEscape(context3) {
            let closed = /\s*\}/.test(context3.textAfter);
            return context3.lineIndent(context3.node.from) + (closed ? 0 : context3.unit);
          },
          "JSXOpenTag JSXSelfClosingTag"(context3) {
            return context3.column(context3.node.from) + context3.unit;
          }
        }),
        /* @__PURE__ */ foldNodeProp.add({
          "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": foldInside,
          BlockComment(tree) {
            return { from: tree.from + 2, to: tree.to - 2 };
          }
        })
      ]
    }),
    languageData: {
      closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
      commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
      indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
      wordChars: "$"
    }
  });
  var jsxSublanguage = {
    test: (node) => /^JSX/.test(node.name),
    facet: /* @__PURE__ */ defineLanguageFacet({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
  };
  var typescriptLanguage = /* @__PURE__ */ javascriptLanguage.configure({ dialect: "ts" }, "typescript");
  var jsxLanguage = /* @__PURE__ */ javascriptLanguage.configure({
    dialect: "jsx",
    props: [/* @__PURE__ */ sublanguageProp.add((n2) => n2.isTop ? [jsxSublanguage] : void 0)]
  });
  var tsxLanguage = /* @__PURE__ */ javascriptLanguage.configure({
    dialect: "jsx ts",
    props: [/* @__PURE__ */ sublanguageProp.add((n2) => n2.isTop ? [jsxSublanguage] : void 0)]
  }, "typescript");
  var kwCompletion = (name16) => ({ label: name16, type: "keyword" });
  var keywords = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(kwCompletion);
  var typescriptKeywords = /* @__PURE__ */ keywords.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(kwCompletion));
  function javascript(config2 = {}) {
    let lang2 = config2.jsx ? config2.typescript ? tsxLanguage : jsxLanguage : config2.typescript ? typescriptLanguage : javascriptLanguage;
    let completions = config2.typescript ? typescriptSnippets.concat(typescriptKeywords) : snippets.concat(keywords);
    return new LanguageSupport(lang2, [
      javascriptLanguage.data.of({
        autocomplete: ifNotIn(dontComplete, completeFromList(completions))
      }),
      javascriptLanguage.data.of({
        autocomplete: localCompletionSource
      }),
      config2.jsx ? autoCloseTags : []
    ]);
  }
  function findOpenTag(node) {
    for (; ; ) {
      if (node.name == "JSXOpenTag" || node.name == "JSXSelfClosingTag" || node.name == "JSXFragmentTag")
        return node;
      if (node.name == "JSXEscape" || !node.parent)
        return null;
      node = node.parent;
    }
  }
  function elementName(doc2, tree, max7 = doc2.length) {
    for (let ch = tree === null || tree === void 0 ? void 0 : tree.firstChild; ch; ch = ch.nextSibling) {
      if (ch.name == "JSXIdentifier" || ch.name == "JSXBuiltin" || ch.name == "JSXNamespacedName" || ch.name == "JSXMemberExpression")
        return doc2.sliceString(ch.from, Math.min(ch.to, max7));
    }
    return "";
  }
  var android2 = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent);
  var autoCloseTags = /* @__PURE__ */ EditorView.inputHandler.of((view2, from3, to3, text6, defaultInsert) => {
    if ((android2 ? view2.composing : view2.compositionStarted) || view2.state.readOnly || from3 != to3 || text6 != ">" && text6 != "/" || !javascriptLanguage.isActiveAt(view2.state, from3, -1))
      return false;
    let base2 = defaultInsert(), { state: state4 } = base2;
    let closeTags = state4.changeByRange((range3) => {
      var _a2;
      let { head: head5 } = range3, around = syntaxTree(state4).resolveInner(head5 - 1, -1), name16;
      if (around.name == "JSXStartTag")
        around = around.parent;
      if (state4.doc.sliceString(head5 - 1, head5) != text6 || around.name == "JSXAttributeValue" && around.to > head5) ;
      else if (text6 == ">" && around.name == "JSXFragmentTag") {
        return { range: range3, changes: { from: head5, insert: `</>` } };
      } else if (text6 == "/" && around.name == "JSXStartCloseTag") {
        let empty7 = around.parent, base3 = empty7.parent;
        if (base3 && empty7.from == head5 - 2 && ((name16 = elementName(state4.doc, base3.firstChild, head5)) || ((_a2 = base3.firstChild) === null || _a2 === void 0 ? void 0 : _a2.name) == "JSXFragmentTag")) {
          let insert10 = `${name16}>`;
          return { range: EditorSelection.cursor(head5 + insert10.length, -1), changes: { from: head5, insert: insert10 } };
        }
      } else if (text6 == ">") {
        let openTag = findOpenTag(around);
        if (openTag && openTag.name == "JSXOpenTag" && !/^\/?>|^<\//.test(state4.doc.sliceString(head5, head5 + 2)) && (name16 = elementName(state4.doc, openTag, head5)))
          return { range: range3, changes: { from: head5, insert: `</${name16}>` } };
      }
      return { range: range3 };
    });
    if (closeTags.changes.empty)
      return false;
    view2.dispatch([
      base2,
      state4.update(closeTags, { userEvent: "input.complete", scrollIntoView: true })
    ]);
    return true;
  });

  // output/Scriptzzz.Editor/foreign.js
  function createEditorImpl(parentElement) {
    return (contentsChangeCallback) => {
      return (initialDocumentText) => {
        return () => {
          const language3 = new Compartment();
          const tabSize = new Compartment();
          const updateListener2 = EditorView.updateListener.of((update3) => {
            if (update3.docChanged) {
              contentsChangeCallback(update3.state.doc.toString())();
            }
          });
          new EditorView({
            doc: initialDocumentText,
            extensions: [
              basicSetup,
              language3.of(javascript()),
              tabSize.of(EditorState.tabSize.of(4)),
              updateListener2
            ],
            parent: parentElement
          });
        };
      };
    };
  }

  // output/Web.DOM.Document/foreign.js
  var getEffProp = function(name16) {
    return function(doc2) {
      return function() {
        return doc2[name16];
      };
    };
  };
  var url = getEffProp("URL");
  var documentURI = getEffProp("documentURI");
  var origin2 = getEffProp("origin");
  var compatMode = getEffProp("compatMode");
  var characterSet = getEffProp("characterSet");
  var contentType = getEffProp("contentType");
  var _documentElement = getEffProp("documentElement");
  function createElement2(localName2) {
    return function(doc2) {
      return function() {
        return doc2.createElement(localName2);
      };
    };
  }

  // output/Web.DOM.Element/foreign.js
  var getProp = function(name16) {
    return function(doctype) {
      return doctype[name16];
    };
  };
  var _namespaceURI = getProp("namespaceURI");
  var _prefix = getProp("prefix");
  var localName = getProp("localName");
  var tagName = getProp("tagName");
  function setId(id5) {
    return function(node) {
      return function() {
        node.id = id5;
      };
    };
  }

  // output/Web.DOM.ParentNode/foreign.js
  var getEffProp2 = function(name16) {
    return function(node) {
      return function() {
        return node[name16];
      };
    };
  };
  var children = getEffProp2("children");
  var _firstElementChild = getEffProp2("firstElementChild");
  var _lastElementChild = getEffProp2("lastElementChild");
  var childElementCount = getEffProp2("childElementCount");

  // output/Web.DOM.Element/index.js
  var toNode2 = unsafeCoerce;

  // output/Web.HTML/foreign.js
  var windowImpl = function() {
    return window;
  };

  // output/Web.HTML.HTMLDocument/index.js
  var toDocument = unsafeCoerce;

  // output/Web.HTML.Window/foreign.js
  function document2(window2) {
    return function() {
      return window2.document;
    };
  }
  function requestAnimationFrame2(fn) {
    return function(window2) {
      return function() {
        return window2.requestAnimationFrame(fn);
      };
    };
  }

  // output/Scriptzzz.Editor/index.js
  var bindFlipped5 = /* @__PURE__ */ bindFlipped(bindEffect);
  var createEditor = function(parentElementId) {
    return function(contentsChangeCallback) {
      return function(initialDocumentText) {
        return function __do() {
          var document3 = bindFlipped5(document2)(windowImpl)();
          var parentElement = createElement2("div")(toDocument(document3))();
          setId(toString(parentElementId))(parentElement)();
          createEditorImpl(parentElement)(contentsChangeCallback)(initialDocumentText)();
          return toNode2(parentElement);
        };
      };
    };
  };

  // output/Flame.Subscription/index.js
  var send = function(dictShow) {
    var show11 = show(dictShow);
    return function(v2) {
      return function(message2) {
        return dispatchCustomEvent(show11(v2))(message2);
      };
    };
  };

  // output/Scriptzzz.Global/index.js
  var Scriptzzz = /* @__PURE__ */ function() {
    function Scriptzzz2() {
    }
    ;
    Scriptzzz2.value = new Scriptzzz2();
    return Scriptzzz2;
  }();
  var showScriptzzz = {
    show: function(v2) {
      return "scriptzzz";
    }
  };
  var send2 = /* @__PURE__ */ send(showScriptzzz);
  var appId = function(dictPos) {
    return function(dictPos1) {
      return Scriptzzz.value;
    };
  };
  var sendMessage = function(dictPos) {
    var appId1 = appId(dictPos);
    return function(dictPos1) {
      return send2(appId1(dictPos1));
    };
  };

  // output/Scriptzzz.App.View.Element/index.js
  var nes2 = /* @__PURE__ */ nes(/* @__PURE__ */ nonEmptyNonEmpty({
    reflectSymbol: function() {
      return "editor";
    }
  }));
  var pure16 = /* @__PURE__ */ pure(applicativeEffect);
  var managed2 = /* @__PURE__ */ managed(/* @__PURE__ */ toNodeArray(toNodeNodeDataNodeData));
  var style2 = /* @__PURE__ */ style(/* @__PURE__ */ toStyleListRecord());
  var editor = function(dictPos) {
    var createWithTimestamp2 = createWithTimestamp(dictPos);
    var sendMessage2 = sendMessage(dictPos);
    return function(dictPos1) {
      var createWithTimestamp1 = createWithTimestamp2(dictPos1);
      var sendMessage1 = sendMessage2(dictPos1);
      return function(isVisible) {
        var createUpdateMessage = function($29) {
          return createWithTimestamp1(EditorUpdated.create(makeScript($29)));
        };
        var nodeRenderer = function() {
          var contentsUpdateCallback = function(updatedContents) {
            return function __do() {
              var message2 = createUpdateMessage(updatedContents)();
              return sendMessage1(message2)();
            };
          };
          return {
            createNode: $$const(createEditor(nes2($$Proxy.value))(contentsUpdateCallback)("")),
            updateNode: function(n2) {
              return function(v2) {
                return function(v1) {
                  return pure16(n2);
                };
              };
            }
          };
        }();
        return managed2(nodeRenderer)([style2({
          display: function() {
            if (isVisible) {
              return "block";
            }
            ;
            return "none";
          }()
        })])(unit);
      };
    };
  };
  var canvas = function(dictPos) {
    var createWithTimestamp2 = createWithTimestamp(dictPos);
    var sendMessage2 = sendMessage(dictPos);
    return function(dictPos1) {
      var createWithTimestamp1 = createWithTimestamp2(dictPos1);
      var createCanvas2 = createCanvas(dictPos1)(dictPos);
      var sendMessage1 = sendMessage2(dictPos1);
      return function(obstacleMatrix) {
        var createCanvasInitializedMessage = createWithTimestamp1(new CanvasInitialized(unit));
        var nodeRenderer = {
          createNode: $$const(createCanvas2(obstacleMatrix)(function __do() {
            var message2 = createCanvasInitializedMessage();
            return sendMessage1(message2)();
          })),
          updateNode: function(n2) {
            return function(v2) {
              return function(v1) {
                return pure16(n2);
              };
            };
          }
        };
        return managed_(nodeRenderer)(unit);
      };
    };
  };

  // output/Scriptzzz.App.View/index.js
  var bind7 = /* @__PURE__ */ bind(bindFn);
  var ask4 = /* @__PURE__ */ ask(monadAskFun);
  var pure17 = /* @__PURE__ */ pure(applicativeFn);
  var showRecord7 = /* @__PURE__ */ showRecord()();
  var show10 = /* @__PURE__ */ show(/* @__PURE__ */ showMaybe(/* @__PURE__ */ showRecord7(/* @__PURE__ */ showRecordFieldsCons({
    reflectSymbol: function() {
      return "finishTime";
    }
  })(/* @__PURE__ */ showRecordFieldsCons({
    reflectSymbol: function() {
      return "result";
    }
  })(/* @__PURE__ */ showRecordFieldsConsNil({
    reflectSymbol: function() {
      return "startTime";
    }
  })(showTimestamp))(/* @__PURE__ */ showExecutionResult(/* @__PURE__ */ showRecord7(/* @__PURE__ */ showRecordFieldsConsNil({
    reflectSymbol: function() {
      return "workers";
    }
  })(/* @__PURE__ */ showRecord7(/* @__PURE__ */ showRecordFieldsConsNil({
    reflectSymbol: function() {
      return "moveTo";
    }
  })(/* @__PURE__ */ showUnitCommands(/* @__PURE__ */ showRecord7(/* @__PURE__ */ showRecordFieldsConsNil({
    reflectSymbol: function() {
      return "position";
    }
  })(showPosition))))))))))(showTimestamp))));
  var toNodeArray2 = /* @__PURE__ */ toNodeArray(toNodeNodeDataNodeData);
  var div$prime2 = /* @__PURE__ */ div$prime(toNodeArray2);
  var class$prime2 = /* @__PURE__ */ class$prime(toClassListString);
  var show16 = /* @__PURE__ */ show(showState);
  var show24 = /* @__PURE__ */ show(/* @__PURE__ */ showArray(showUpdateError));
  var toNodeArray1 = /* @__PURE__ */ toNodeArray(toNodeHtmlHtml);
  var button2 = /* @__PURE__ */ button(toNodeArray2)(toNodeArray1);
  var section_2 = /* @__PURE__ */ section_(toNodeArray1);
  var main2 = /* @__PURE__ */ main(toNodeStringNodeData)(toNodeArray1);
  var div4 = /* @__PURE__ */ div3(toNodeArray2)(toNodeArray1);
  var map25 = /* @__PURE__ */ map(functorArray);
  var viewEditorColumnContents = function(dictPos) {
    var editor2 = editor(dictPos);
    return function(dictPos1) {
      var editor1 = editor2(dictPos1);
      return bind7(ask4)(function(model) {
        return pure17(function() {
          if (model instanceof Editing) {
            return [editor1(true), text(show10(model.value0.lastScriptExecution))];
          }
          ;
          if (model instanceof Simulating) {
            return [editor1(false), text(show10(model.value0.editor.lastScriptExecution))];
          }
          ;
          return [editor1(false), div$prime2([class$prime2("is-skeleton")])];
        }());
      });
    };
  };
  var viewDebugColumnContents = function(dictPos) {
    return function(dictPos1) {
      return bind7(ask4)(function(model) {
        return pure17(function() {
          if (model instanceof Simulating) {
            return [text(show16(model.value0.gameState)), text(show24(model.value0.gameLogs))];
          }
          ;
          return [div$prime2([class$prime2("is-skeleton")])];
        }());
      });
    };
  };
  var viewCanvasColumnContents = function(dictPos) {
    var canvas2 = canvas(dictPos);
    var createWithoutTimestamp2 = createWithoutTimestamp(dictPos);
    return function(dictPos1) {
      var canvas1 = canvas2(dictPos1);
      var createWithoutTimestamp1 = createWithoutTimestamp2(dictPos1);
      return bind7(ask4)(function(model) {
        return pure17(function() {
          if (model instanceof CanvasInitializing) {
            return [canvas1(model.value0.obstacleMatrix)];
          }
          ;
          if (model instanceof Editing) {
            return [canvas1(model.value0.gameSettings.environment.obstacleMatrix), button2([onClick(createWithoutTimestamp1(new SimulationStartRequested(unit)))])([text("Start")])];
          }
          ;
          if (model instanceof Simulating) {
            return [canvas1(model.value0.editor.gameSettings.environment.obstacleMatrix), button2([onClick(createWithoutTimestamp1(new SimulationStopRequested(unit)))])([text("Stop")])];
          }
          ;
          throw new Error("Failed pattern match at Scriptzzz.App.View (line 34, column 8 - line 57, column 8): " + [model.constructor.name]);
        }());
      });
    };
  };
  var view = function(dictPos) {
    var viewCanvasColumnContents1 = viewCanvasColumnContents(dictPos);
    var viewEditorColumnContents1 = viewEditorColumnContents(dictPos);
    var viewDebugColumnContents1 = viewDebugColumnContents(dictPos);
    return function(dictPos1) {
      var viewEditorColumnContents2 = viewEditorColumnContents1(dictPos1);
      var viewDebugColumnContents2 = viewDebugColumnContents1(dictPos1);
      return bind7(viewCanvasColumnContents1(dictPos1))(function(canvasColumnContents) {
        return bind7(viewEditorColumnContents2)(function(editorColumnContents) {
          return bind7(viewDebugColumnContents2)(function(debugColumnContents) {
            return pure17(section_2([main2("main")([div4([class$prime2("columns")])(map25(div4([class$prime2("column")]))([editorColumnContents, canvasColumnContents, debugColumnContents]))])]));
          });
        });
      });
    };
  };

  // output/Scriptzzz.App/index.js
  var subscribe = function(dictPos) {
    return function(dictPos1) {
      return [];
    };
  };
  var makeApplication = function(dictPos) {
    var init6 = init4(dictPos);
    var emptyObstacleMatrix2 = emptyObstacleMatrix(dictPos);
    var subscribe1 = subscribe(dictPos);
    var update3 = update2(dictPos);
    var view2 = view(dictPos);
    return function(dictPos1) {
      var init1 = init6(dictPos1);
      var emptyObstacleMatrix1 = emptyObstacleMatrix2(dictPos1);
      var subscribe2 = subscribe1(dictPos1);
      var update1 = update3(dictPos1);
      var view1 = view2(dictPos1);
      return function(commandExecutors2) {
        return function(debugLevel) {
          return {
            init: init1(emptyObstacleMatrix1),
            subscribe: subscribe2,
            update: update1(commandExecutors2)(debugLevel),
            view: view1
          };
        };
      };
    };
  };

  // output/Scriptzzz.Main/index.js
  var runProgram2 = /* @__PURE__ */ runProgram(durationMilliseconds)(manageWebWorkerSandboxM)(monadEffectSandboxM);
  var readForeignRecord2 = /* @__PURE__ */ readForeignRecord();
  var readForeignFieldsCons2 = /* @__PURE__ */ readForeignFieldsCons({
    reflectSymbol: function() {
      return "workers";
    }
  });
  var readForeignFieldsCons1 = /* @__PURE__ */ readForeignFieldsCons({
    reflectSymbol: function() {
      return "moveTo";
    }
  });
  var readForeignFieldsCons22 = /* @__PURE__ */ readForeignFieldsCons({
    reflectSymbol: function() {
      return "position";
    }
  });
  var debug3 = /* @__PURE__ */ debug2(monadEffectAff);
  var error4 = /* @__PURE__ */ error3(monadEffectAff);
  var discard4 = /* @__PURE__ */ discard(discardUnit);
  var discard12 = /* @__PURE__ */ discard4(bindAff);
  var parTraverse_2 = /* @__PURE__ */ parTraverse_(parallelAff)(applicativeParAff)(foldableArray);
  var pure18 = /* @__PURE__ */ pure(applicativeAff);
  var $$void4 = /* @__PURE__ */ $$void(functorEffect);
  var map26 = /* @__PURE__ */ map(functorEffect);
  var posPosD62 = /* @__PURE__ */ posPosD6(posD1);
  var showSimplifiedModel = function(dictPos) {
    return function(dictPos1) {
      return function(v2) {
        if (v2 instanceof CanvasInitializing) {
          return "canvas initializing...";
        }
        ;
        if (v2 instanceof Editing) {
          return "editing mode";
        }
        ;
        if (v2 instanceof Simulating) {
          return "simulating mode";
        }
        ;
        throw new Error("Failed pattern match at Scriptzzz.Main (line 82, column 23 - line 88, column 22): " + [v2.constructor.name]);
      };
    };
  };
  var commandExecutors = function(dictPos) {
    var readForeignPosition2 = readForeignPosition(dictPos);
    var createEntity2 = createEntity(dictPos);
    return function(dictPos1) {
      var createEntity1 = createEntity2(dictPos1);
      return {
        executeScript: runProgram2(readForeignRecord2(readForeignFieldsCons2(readForeignRecord2(readForeignFieldsCons1(readForeignUnitCommands(readForeignRecord2(readForeignFieldsCons22(readForeignPosition2(dictPos1))(readForeignFieldsNilRowRo)()())))(readForeignFieldsNilRowRo)()()))(readForeignFieldsNilRowRo)()()))(runSandboxM("./sandbox.js"))(500),
        logDebug: debug3,
        logError: error4,
        updateAnimation: function(v2) {
          return discard12(parTraverse_2(function(v1) {
            return createEntity1(v1.id)(v1.entityType)(v1.position);
          })(v2.animation.createEntity))(function() {
            return discard12(parTraverse_2(function(v1) {
              return updateEntityPosition(v1.id)(v1.targetPosition);
            })(v2.animation.updateEntity))(function() {
              return discard12(parTraverse_2(function(v1) {
                return destroyEntity(v1.id);
              })(v2.animation.destroyEntity))(function() {
                return pure18({
                  errors: []
                });
              });
            });
          });
        }
      };
    };
  };
  var initialize = function(dictPos) {
    var createWithTimestamp2 = createWithTimestamp(dictPos)(dictPos);
    var sendMessage2 = sendMessage(dictPos)(dictPos);
    var timeUpdateProducer = function(window2) {
      return $$void4(requestAnimationFrame2(function __do() {
        var time3 = map26(timestamp)(now)();
        var v2 = createWithTimestamp2(new TimeUpdated(time3))();
        sendMessage2(v2)();
        return timeUpdateProducer(window2)();
      })(window2));
    };
    var application = makeApplication(dictPos)(dictPos)(commandExecutors(dictPos)(dictPos))(new Full(showSimplifiedModel(dictPos)(dictPos)));
    return new Tuple(application, timeUpdateProducer);
  };
  var main3 = /* @__PURE__ */ function() {
    var v2 = initialize(posPosD62);
    return mount(showScriptzzz)("body")(appId(posPosD62)(posPosD62))(v2.value0);
  }();

  // index.js
  main3();
})();
